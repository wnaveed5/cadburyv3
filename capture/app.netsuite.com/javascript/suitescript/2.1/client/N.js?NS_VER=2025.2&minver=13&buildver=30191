/**
 * SuiteScript module
 *
 * @private
 * @module N/nsobject
 * @NApiVersion 2.x
 */
define('N/nsobject',[], function (){
		/* NetSuite Javascript Object Marker */
		function NetSuiteObject() {}
		Object.freeze(NetSuiteObject);

		return {
			getNewInstance: function() { return new NetSuiteObject(); },
			isInstanceOfNSObject: function(obj) { return obj instanceof NetSuiteObject; }
		};
	}
);
/**
 * SuiteScript global context switching module
 *
 * @private
 * @module N/contextSwitch
 * @suiteScriptVersion 2.x
 *
 */
define('N/contextSwitch',[], function () {
	function safeHasOwnProperty(obj, name) {
		try {
			return Object.prototype.hasOwnProperty.call(obj, name);
		} catch (e) {
			return false;
		}
	}

	function renameTo(name, func) {
		if (typeof func === 'function') {
			try {
				Object.defineProperty(func, 'name', {value: name, configurable: true});
			} catch (e) {}
		}
		return func;
	}

	function isCrossOrigin(obj) {
		if (obj !== undefined && obj !== null) {
			try {
				void obj.propertyAccessWhichMightThrowPermissionError;
			} catch (e) {
				return true;
			}
		}
		return false;
	}

	var Context = (function () {
		var topLevelContext, currentContext;

		var Context = function Context(options) {
			var recordSysId = options.recordSysId;
			var scriptInfo = options.scriptInfo;
			var nlrumArgs = options.nlrumArgs;
			var awaitCall = options.awaitCall;

			this.recordSysId = recordSysId;
			this.scriptInfo = scriptInfo;
			this.nlrumArgs = nlrumArgs;
			this.awaitCall = awaitCall;
			this.id = String([recordSysId, scriptInfo.scriptId]);
		};

		Context.prototype.apply = function apply(func, thisArg, argsArray) {
			applyMonkeyPatch();
			var previousContext = currentContext;
			currentContext = this;
			try {
				return func.apply(thisArg, argsArray);
			} finally {
				currentContext = previousContext;
				unApplyMonkeyPatch();
			}
		};

		Context.prototype.applyPermanently = function apply(func, thisArg, argsArray) {
			applyMonkeyPatch();
			currentContext = this;
			return func.apply(thisArg, argsArray);
		};

		function applyMonkeyPatch() {
			if (monkeyPatchBuiltins !== undefined) {
				monkeyPatchBuiltins();
			}
		}

		function unApplyMonkeyPatch() {
			if (monkeyUnpatchBuiltins !== undefined) {
				monkeyUnpatchBuiltins();
			}
		}

		var unwrapKey = '_contextSwitch_unwrap';

		function isWrapped(func) {
			return typeof func === 'function' && Object.prototype.hasOwnProperty.call(func, unwrapKey);
		}

		Context.prototype.wrap = function wrap(func, options) {
			if (isCrossOrigin(func) || isWrapped(func)) {
				return func;
			}

			if (options) {
				var coerce = options.coerce;
				var enableCallbacks = options.enableCallbacks;
				var identical = options.identical;
				if (enableCallbacks) {
					var postCallback = options.postCallback;
					var nlrumArgs = this.nlrumArgs;
				}
			}

			if (this.id === topLevelContext.id && nlrumArgs === undefined && postCallback === undefined) {
				return func;
			}
			if (typeof func !== 'function' && coerce !== undefined) {
				func = coerce(func);
			}
			if (typeof func !== 'function') {
				return func;
			}

			var suffix = '[SuiteScript:' + (nlrumArgs === undefined ? this.id : [this.id, nlrumArgs[0], nlrumArgs[2]]) + ']';

			var wrapKey = '_contextSwitch_wrap' + suffix;
			if (identical && Object.prototype.hasOwnProperty.call(func, wrapKey)) {
				return func[wrapKey];
			}

			var context = this;
			var wrappedFunc = renameTo((func.name || '(anonymous)') + suffix, function () {
				try {
					if (nlrumArgs !== undefined) {
						NLRUM.clientScriptAsyncCallbackBegin.apply(NLRUM, nlrumArgs);
					}
					try {
						return context.apply(func, this, arguments);
					} catch (e) {
						nlrumArgs = undefined;
						throw e;
					} finally {
						if (nlrumArgs !== undefined) {
							NLRUM.clientScriptAsyncCallbackEnd.apply(NLRUM, nlrumArgs);
						}
					}
				} finally {
					if (postCallback !== undefined) {
						postCallback();
					}
				}
			});

			if (identical) {
				func[wrapKey] = wrappedFunc;
			}
			wrappedFunc[unwrapKey] = func;

			return wrappedFunc;
		};

		topLevelContext = new Context({scriptInfo: {}});
		currentContext = topLevelContext;

		Context.wrap = function wrap(func, options) {
			return currentContext.wrap(func, options);
		};

		Context.unwrap = function unwrap(func) {
			return isWrapped(func) ? func[unwrapKey] : func;
		};

		Context.awaitCall = function awaitCall() {
			if (currentContext.awaitCall) {
				return currentContext.awaitCall();
			}
		};

		Context.getRecordSysId = function getRecordSysId() {
			return currentContext.recordSysId;
		};

		Context.getScript = function getScript() {
			return currentContext.scriptInfo;
		};

		return Context;
	})();

	var monkeyPatchBuiltins, monkeyUnpatchBuiltins;

	(function () {
		if (typeof window === 'undefined' || typeof document === 'undefined' || typeof globalTestExposures !== 'undefined') {
			// not browser
			return;
		}

		var global = window;
		var wrap = Context.wrap;
		var unwrap = Context.unwrap;
		var awaitCall = Context.awaitCall;

		var monkeyPatch, monkeyPatchProperty;

		(function () {
			var patches = [];

			monkeyPatchProperty = function monkeyPatchProperty(obj, name, patch) {
				for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
					if (safeHasOwnProperty(obj, name)) {
						var desc = patch(Object.getOwnPropertyDescriptor(obj, name));
						try {
							Object.defineProperty(obj, name, desc);
						} catch (e) {}
						break;
					}
				}
			};

			monkeyPatch = function monkeyPatch(obj, name, patch, immediate) {
				for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
					if (safeHasOwnProperty(obj, name)) {
						var original = obj[name];
						var patched = renameTo((original.name || '(anonymous)') + '[SuiteScript]', patch(original));
						if (immediate) {
							try {
								obj[name] = patched;
							} catch (e) {}
						} else {
							patches.push({obj: obj, name: name, original: original, patched: patched});
						}
						break;
					}
				}
			};

			var depth = 0;

			monkeyPatchBuiltins = function monkeyPatchBuiltins() {
				if (depth === 0) {
					for (var i = 0; i < patches.length; i++) {
						try {
							patches[i].obj[patches[i].name] = patches[i].patched;
						} catch (e) {}
					}
				}
				depth++;
			};

			monkeyUnpatchBuiltins = function monkeyUnpatchBuiltins() {
				depth--;
				if (depth === 0) {
					for (var i = 0; i < patches.length; i++) {
						try {
							patches[i].obj[patches[i].name] = patches[i].original;
						} catch (e) {}
					}
				}
			};
		}());

		(function monkeyPatchTimers() {
			function coerceCode(code) {
				return eval.bind(this, code);
			}

			var timers = {};

			function addTimer(timerId) {
				var settleCall = awaitCall();
				if (settleCall) {
					timers[timerId] = settleCall;
				}
			}

			function removeTimer(timerId) {
				if (timerId in timers) {
					timers[timerId]();
					delete timers[timerId];
				}
			}

			monkeyPatch(global, 'setTimeout', function (origSetTimeout) {
				return function patchedSetTimeout(func) {
					var removeSelf = function () { removeTimer(timeoutId); };
					var wrappedFunc = wrap(func, {coerce: coerceCode, enableCallbacks: true, postCallback: removeSelf});
					var timeoutId = origSetTimeout.apply(this, [wrappedFunc].concat(Array.prototype.slice.call(arguments, 1)));
					addTimer(timeoutId);
					return timeoutId;
				};
			});
			monkeyPatch(global, 'setInterval', function (origSetInterval) {
				return function patchedSetInterval(func) {
					var wrappedFunc = wrap(func, {coerce: coerceCode, enableCallbacks: true});
					var intervalId = origSetInterval.apply(this, [wrappedFunc].concat(Array.prototype.slice.call(arguments, 1)));
					addTimer(intervalId);
					return intervalId;
				};
			});
			monkeyPatch(global, 'clearTimeout', function (origClearTimeout) {
				return function patchedClearTimeout(timeoutId) {
					removeTimer(timeoutId);
					return origClearTimeout(timeoutId);
				}
			});
			monkeyPatch(global, 'clearInterval', function (origClearInterval) {
				return function patchedClearInterval(intervalId) {
					removeTimer(intervalId);
					return origClearInterval(intervalId);
				}
			});
		}());

		(function monkeyPatchPromise() {
			if (typeof Promise === 'undefined') {
				return;
			}

			function identity(value) {
				return value;
			}

			function thrower(exc) {
				throw exc;
			}

			function coerceIdentity() {
				return identity;
			}

			function coerceThrower() {
				return thrower;
			}

			var origThen = Promise.prototype.then;

			monkeyPatch(Promise.prototype, 'then', function () {
				return function patchedThen(onFulfilled, onRejected) {
					var settleCall = awaitCall();
					var wrappedOnFulfilled = wrap(onFulfilled, {
						coerce: coerceIdentity,
						enableCallbacks: true,
						postCallback: settleCall
					});
					var wrappedOnRejected = wrap(onRejected, {
						coerce: coerceThrower,
						enableCallbacks: true,
						postCallback: settleCall
					});
					return origThen.call(this, wrappedOnFulfilled, wrappedOnRejected);
				};
			});
			monkeyPatch(Promise.prototype, 'catch', function () {
				return function patchedCatch(onRejected) {
					var settleCall = awaitCall();
					var wrappedOnFulfilled = wrap(undefined, {
						coerce: coerceIdentity,
						enableCallbacks: true,
						postCallback: settleCall
					});
					var wrappedOnRejected = wrap(onRejected, {
						coerce: coerceThrower,
						enableCallbacks: true,
						postCallback: settleCall
					});
					return origThen.call(this, wrappedOnFulfilled, wrappedOnRejected);
				};
			});
			monkeyPatch(Promise.prototype, 'finally', function (origFinally) {
				return function patchedFinally(onFinally) {
					var settleCall = awaitCall();
					return origFinally.call(this, wrap(onFinally, {enableCallbacks: true, postCallback: settleCall}));
				};
			});
		}());

		(function monkeyPatchEventTarget() {
			var coerceEventListenerKey = '_contextSwitch_coerceEventListener';

			function coerceEventListener(listener) {
				if (typeof listener === 'object' && listener !== null && typeof listener.handleEvent === 'function') {
					if (safeHasOwnProperty(listener, coerceEventListenerKey)) {
						return listener[coerceEventListenerKey];
					} else {
						var coercedListener = listener.handleEvent.bind(listener);
						Object.defineProperty(listener, coerceEventListenerKey, {value: coercedListener});
						return coercedListener;
					}
				}
				return listener;
			}

			function patchAddEventListener(origAddEventListener) {
				return function patchedAddEventListener(type, listener) {
					listener = wrap(listener, {coerce: coerceEventListener, identical: true});
					return origAddEventListener.apply(this, [type, listener].concat(Array.prototype.slice.call(arguments, 2)));
				};
			}

			function patchRemoveEventListener(origRemoveEventListener) {
				return function patchedRemoveEventListener(type, listener) {
					listener = wrap(listener, {coerce: coerceEventListener, identical: true});
					return origRemoveEventListener.apply(this, [type, listener].concat(Array.prototype.slice.call(arguments, 2)));
				}
			}

			var seenGlobalNames = ['Ext'];
			var seenObjs = [];
			var isEventTarget = typeof EventTarget === 'function'
				? function isEventTarget(obj) {
					return obj === EventTarget.prototype || obj instanceof EventTarget;
				}
				: function isEventTarget(obj) {
					return obj !== undefined
						&& obj !== null
						&& typeof obj.addEventListener === 'function'
						&& typeof obj.removeEventListener === 'function'
						&& typeof obj.dispatchEvent === 'function';
				};

			for (var globalObj = global; globalObj !== null; globalObj = Object.getPrototypeOf(globalObj)) {
				var globalNames = Object.getOwnPropertyNames(globalObj);
				for (var i = 0; i < globalNames.length; i++) {
					var globalName = globalNames[i];
					if (seenGlobalNames.indexOf(globalName) !== -1) {
						continue;
					}
					seenGlobalNames.push(globalName);

					var obj;
					try {
						obj = globalObj[globalName];
					} catch (e) {
						continue;
					}
					if (isCrossOrigin(obj)) {
						continue;
					}
					if (typeof obj === 'function' && obj.prototype !== undefined) {
						obj = obj.prototype;
					}
					if (!isEventTarget(obj)) {
						continue;
					}

					var seenNames = [];

					for (; obj !== null; obj = Object.getPrototypeOf(obj)) {
						if (seenObjs.indexOf(obj) !== -1 || obj === Object.prototype) {
							break;
						}
						seenObjs.push(obj);

						if (safeHasOwnProperty(obj, 'addEventListener')) {
							monkeyPatch(obj, 'addEventListener', patchAddEventListener, true);
						}
						if (safeHasOwnProperty(obj, 'removeEventListener')) {
							monkeyPatch(obj, 'removeEventListener', patchRemoveEventListener, true);
						}
						if (safeHasOwnProperty(obj, 'attachEvent')) {
							monkeyPatch(obj, 'attachEvent', patchAddEventListener, true);
						}
						if (safeHasOwnProperty(obj, 'detachEvent')) {
							monkeyPatch(obj, 'detachEvent', patchRemoveEventListener, true);
						}

						var names = Object.getOwnPropertyNames(obj);
						for (var j = 0; j < names.length; j++) {
							var name = names[j];
							if (seenNames.indexOf(name) !== -1 || name.indexOf('on') !== 0) {
								continue;
							}
							seenNames.push(name);

							monkeyPatchProperty(obj, name, function (desc) {
								if (desc.set !== undefined) {
									monkeyPatch(desc, 'set', function (origSet) {
										return function patchedSet(newValue) {
											origSet.call(this, wrap(newValue));
										};
									}, true);
									monkeyPatch(desc, 'get', function (origGet) {
										return function patchedGet() {
											return unwrap(origGet.call(this));
										};
									}, true);
								}
								return desc;
							});
						}
					}
				}
			}
		}());
	}());

	function createContext(options) {
		return new Context({
			recordSysId: options.record !== undefined ? options.record.getSystemId() : Context.getRecordSysId(),
			scriptInfo: options.scriptInfo !== undefined ? options.scriptInfo : Context.getScript(),
			nlrumArgs: typeof NLRUM !== 'undefined' ? options.nlrumArgs : undefined,
			awaitCall: createAwaitCall(options.settleCallback)
		});
	}

	function createAwaitCall(settleCallback) {
		if (settleCallback === undefined) {
			return;
		}

		var wrappedSettleCallback = Context.wrap(settleCallback);
		var numPendingCalls = 0;

		function settleCall() {
			numPendingCalls--;
			if (numPendingCalls === 0) {
				setTimeout(wrappedSettleCallback);
			}
		}

		function awaitCall() {
			numPendingCalls++;
			return settleCall;
		}

		return awaitCall;
	}

	var execute = (function () {
		function execute(options, callback) {
			var context = createContext(options);

			return context.apply(function () {
				var settleCall = Context.awaitCall();
				try {
					return callback();
				} finally {
					if (settleCall !== undefined) {
						settleCall();
					}
				}
			}, undefined, []);
		}

		return execute;
	})();

	var executeInFixedContext = (function () {
		function execute(options, callback) {
			var context = createContext(options);

			return context.applyPermanently(function () {
				var settleCall = Context.awaitCall();
				try {
					return callback();
				} finally {
					if (settleCall !== undefined) {
						settleCall();
					}
				}
			}, undefined, []);
		}

		return execute;
	})();

	return Object.freeze({
		execute: execute,
		executeInFixedContext: executeInFixedContext,
		getRecordSysId: Context.getRecordSysId,
		getScript: Context.getScript
	});
});

/**
 * @private
 * @module N/currentRecordService
 * @suiteScriptVersion 2.x
 */
define('N/currentRecordService',['N/contextSwitch'], function (contextSwitch) {
	var currentRecords = {};
	var defaultCurrentRecord;

	function get() {
		var systemId = contextSwitch.getRecordSysId();
		return systemId ? currentRecords[systemId] : defaultCurrentRecord;
	}

	function set(record) {
		currentRecords[record.getSystemId()] = record;
		if (!defaultCurrentRecord) {
			defaultCurrentRecord = record;
		}
	}

	return Object.freeze({
		get: get,
		set: set
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/dynamicData
 * @NApiVersion 2.x
 */
define('N/dynamicData',['N/currentRecordService'], function(currentRecordService) {
	var dynamicData = {};

	function init(data)
	{
		if (data)
		{
			if (util.isString(data))
				data = JSON.parse(data);
			Object.getOwnPropertyNames(data).forEach(function (key) {
				if (util.isObject(dynamicData[key]))
					util.extend(dynamicData[key], data[key]);
				else
					dynamicData[key] = data[key];
			});
		}
	}

	function getRecordData(type)
	{
		var data = {};
		var rawCurrentRecord = currentRecordService.get();

		if (rawCurrentRecord)
		{
			data = rawCurrentRecord.getDynamicData();
		}
		return data ? data[type] : undefined;
	}

	function get(type)
	{
		return dynamicData[type];
	}

	return Object.freeze({
		init: init,
		getRecordData : getRecordData,
		get: get
	})
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/internal/serverCommunicationProxy
 * @NApiVersion 2.x
 */
define('N/internal/serverCommunicationProxy',[], function () {
	var nlRequestId = 0;
	var legacyCallURL = '/app/common/scripting/nlapijsonhandler.nl';
	var callURL = '/app/common/scripting/ClientScriptHandler.nl';
	var ajaxHelpers;
	function checkResponseForError(responseCode, responseText) {
		if (!responseText) {
			throw Error("empty response");
		}

		requireAjaxHelper();
		ajaxHelpers.handleServerCallError(responseCode, responseText);

		if (!ajaxHelpers.isJson(responseText)) {
			throw Error("invalid response");
		}
	}

	function requireAjaxHelper(){
		if(!!ajaxHelpers)
			return;

		// ajaxHelpers creates a cyclic dependency, so we load it dynamically.
		//  via N/ajaxHelpers -> N/bridge-> N/reflet -> N/utilityFunctions -> N/serverCommunicationProxy
		ajaxHelpers = require("N/internal/ajaxHelpers");
	}

	function makeServerCall(options) {
		var url = options.url,
			method = options.method || 'POST',
			remoteMethodName = options.remoteMethodName,
			args = options.args,
			async = options.async,
			callback = options.callback;

		var useRemoteMethod = url === callURL || url === legacyCallURL || !!remoteMethodName && Array.isArray(args);

		function processResponse(responseText, responseCode, resultOnly) {
			var result;

			checkResponseForError(responseCode, responseText);

			result = JSON.parse(responseText);

			if (useRemoteMethod) {
				var responseObj = result || {
					result: {}
				};

				if (responseObj.hasOwnProperty("nlError") && responseObj.nlError) {
					var error = Error(responseObj.details);
					error.name = responseObj.code;
					error.userFacing = true;
					error.id = responseObj.id || null;
					throw error;
				}

				result = resultOnly ? responseObj.result : responseObj;
			}

			return result;
		}

		url = url || callURL;

		var params;
		if (useRemoteMethod) {
			args = args || [];
			params = 'jrid=' + encodeURIComponent(nlRequestId++);
			if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null) {
				params += "&c=" + nsDefaultContextObj.company;
				params += "&isExternal=T";
			}
			params += '&jrmethod=' + encodeURIComponent('remoteObject.' + remoteMethodName) +
				'&jrparams=' + encodeURIComponent(JSON.stringify(args));
		} else {
			args = args || {};
			params = Object.keys(args)
				.map(function (v, i, a) {return encodeURIComponent(v) + '=' + encodeURIComponent(args[v]);})
				.join('&');
		}

		var xhr = new XMLHttpRequest();
		if (method !== 'GET' && typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null) {
			url = (!!url && url.length > 0 && url.substr(url.length - 1) === '?' ? url.substr(0, url.length - 1) : url);

			var appendC = (url.indexOf("?") >= 0) ? '&c=' : '?c=';
			url = url + appendC + nsDefaultContextObj.company;
		}
		xhr.open(method, method === 'GET' ? url + '?' + params : url, async);
		if (async) {
			xhr.onload = function () {
				var response;

				if (this.readyState === 4) {
					try {
						response = processResponse(this.responseText, this.status);
					} catch (e) {
						response = e;
					}
					callback(response);
				}
			};
			xhr.onerror = function () {
				callback({nlError: true, code: "NETWORK_ERROR", details: "Request failed"});
			}
		}
		xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		xhr.setRequestHeader("NSXMLHttpRequest", "NSXMLHttpRequest");
		xhr.send(params);
		if (!async) {
			return processResponse(xhr.responseText, xhr.status, true);
		}
	}

	function serverCallSync(url, remoteMethodName, args) {
		var useRemoteMethod = url === callURL || url === legacyCallURL || !!remoteMethodName && Array.isArray(args);

		return makeServerCall({
			url: url,
			method: useRemoteMethod ? 'POST' : 'GET',
			remoteMethodName: remoteMethodName,
			args: args,
			async: false
		});
	}

	function serverCallAsync(url, remoteMethodName, args, callback) {
		var useRemoteMethod = url === callURL || url === legacyCallURL || !!remoteMethodName && Array.isArray(args);

		makeServerCall({
			url: url,
			method: useRemoteMethod ? 'POST' : 'GET',
			remoteMethodName: remoteMethodName,
			args: args,
			async: true,
			callback: callback
		});
	}

	return Object.freeze({
		serverCallSync: serverCallSync,
		serverCallAsync: serverCallAsync
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctionsImpl
 * @NApiVersion 2.x
 */
define('N/utilityFunctionsImpl',["N/internal/serverCommunicationProxy"],
    function (serverCommunicationProxy)
    {
	    function getGlobalScope()
	    {
		    return (function () {return this;}());
	    }

	    var serverCallSyncImpl = null;
        var serverCallAsyncImpl = null;

        // When client script modules are imported on the server side during script analysis, serverCallSync will not exist as a global variable.
        if (typeof serverCallSync !== 'undefined') {
            // serverCallSync is defined in client bootstrap.js, we should remove it from global space.
            serverCallSyncImpl = serverCallSync;
        }
        else {
            var global = getGlobalScope();
            serverCallSyncImpl = global.serverCallSync
	            // In Redwood mode, global.serverCallAsync won't exist as client bootstrap.js is not executed. We delegate on a new module
	            // that exports exactly same functions. Long term idea is to deprecate completely client bootstrap.js in favor on modularized
	            // and reusable logic. For now this will be behind hidden feature.
	            || serverCommunicationProxy.serverCallSync;
        }

        // When client script modules are imported on the server side during script analysis, serverCallAsyncImpl will not exist as a global variable.
        if (typeof serverCallAsync !== 'undefined') {
            // serverCallAsyncImpl is defined in client bootstrap.js, we should remove it from global space.
            serverCallAsyncImpl = serverCallAsync;
        }
        else {
            var global = getGlobalScope();
            serverCallAsyncImpl = global.serverCallAsync
	            // In Redwood mode, global.serverCallAsync won't exist as client bootstrap.js is not executed. We delegate on a new module
	            // that exports exactly same functions. Long term idea is to deprecate completely client bootstrap.js in favor on modularized
	            // and reusable logic. For now this will be behind hidden feature.
	            || serverCommunicationProxy.serverCallAsync;
        }

        return {
            serverCall: serverCallSyncImpl,
            serverCallAsync: serverCallAsyncImpl
        };
    });

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */

/**
 * SuiteScript module
 *
 * @private
 * @module N/reflet
 * @NApiVersion 2.x
 */
define('N/internal/reflet',['N/contextSwitch', 'N/dynamicData', 'N/utilityFunctionsImpl', 'N/currentRecordService'],
	function (contextSwitch, dynamicData, utilityFunctionsImpl, currentRecordService)
	{
		var chargeMap = {};
		var usageCostMap = null;
		var recordTypes = null;
		var totalBundleUsage = {};
		var nsJSONProxyURL = '/app/common/scripting/nlapijsonhandler.nl';
		var warningMessages = [];
		var scriptTypesWithoutGovernance = ["spaserverscript"];

		function getDynamicData(key)
		{
			var data = dynamicData.get("reflet");
			if (!data)
				return undefined;
			return data[key];
		}

		function getRecordDynamicData(key)
		{
			var data = dynamicData.getRecordData("reflet");
			if (!data)
				return undefined;
			return data[key];
		}

		function getDynamicDataWithFallback(key, fallback)
		{
			return getDynamicData(key) || utilityFunctionsImpl.serverCall(nsJSONProxyURL, fallback, []);
		}

		function alert(msg) {
			if (msg && typeof console !== 'undefined' && console.log) {
				console.log('>>ALERT:' + msg);
			}
			warningMessages.push(msg);
		}

		function confirm(msg) {
			if (msg && typeof console !== 'undefined' && console.log) {
				console.log('>>CONFIRM:' + msg);
			}
			return true; // autoconfirm
		}

		function checkWarningMessageInSession() {
			var count = warningMessages.length;
			if (count > 0) {
				var lastMsg = warningMessages.pop();
				var warningMsg = lastMsg;
				if (count > 1) {
					warningMsg = "Multiple Error Detected" + "\n" + lastMsg + "\n";
					for (var msgIndex in warningMessages) {
						var msg = warningMessages[msgIndex];
						warningMsg = warningMsg + msg + "\n";
					}
				}
				var error = new Error(warningMsg);
				error.name = "USER_ERROR";
				throw error;
			}
		}

		function getCharges()
		{
			return chargeMap[getScript().scriptId] || 0;
		}

		function setupScript(thisObject)
		{
			chargeMap[thisObject.scriptId] = 0;
		}

		var getScript = contextSwitch.getScript;

		function chargeUsage(method, type, args, governanceOverride) {
			var script = getScript().scriptId;
			if (script === "internal" || scriptHasNoGovernance(getScript().scriptType))
				return;
			if (usageCostMap === null)
				usageCostMap = getDynamicDataWithFallback("usageCostMap", "getUsageUnits");
			var cost = 0;
			if (util.isNumber(governanceOverride))
				cost = governanceOverride;
			else
			{
				if (method === 'nlapiSendEmail' && args[8] /*notifySenderOnBounce*/)
					cost = usageCostMap[method + '_trackBouncesUpcharge'] || 0;
				/* TODO: Figure out a better way to deal with bulk action */
				else if (method === 'executeAction' && args[0] === 'timesheet')
					cost = usageCostMap[method + 'Bulk'] || 0;
				else
					cost = usageCostMap[method] || 0;
				if (type != null) {
					if (recordTypes === null)
						recordTypes = getDynamicDataWithFallback("recordTypes", "getRecordTypes");
					var recType = recordTypes && recordTypes[type.toLowerCase()] && recordTypes[type.toLowerCase()].type;
					cost /= (recType === "RECORD") ? 5 : ( (recType === "BODY" ? 1 : 2) );
					if (method === 'nlapiLookupFields_v1')
						cost--; // compensate for v2 nlapiLookupFields being already charged
				}
			}
			var thisKey = getScript().scriptId;
			chargeMap[thisKey] = (chargeMap[thisKey] || 0) + cost;
			//console.log("=======" + thisKey + "will be charged " + cost
			//            + " for using " + method + " (type = " + type + "). FYI, Total Charge is " + chargeMap[thisKey]);
			if (calculateRemainingUsage() < 0)
			{
				var error = new Error(getErrorMsg("SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED"));
				error.name = "SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED";
				throw error;
			}
		}

		function scriptHasNoGovernance(scriptType) {
			return (typeof scriptType === "string") && (scriptTypesWithoutGovernance.indexOf(scriptType.toLowerCase()) != -1);
		}

		function createError(myCode, myDetails, suppressNotification)
		{
			var error = Error(myDetails);
			error.name = myCode;
			try
			{
				throw error;
			}
			catch (e)
			{
				error = e;
			}

			return {
				getId: function () { return null },
				getCode: function () { return error.name },
				getDetails: function () { return error.message },
				getStackTrace: function () { return error.stack.split("\n"); }
			};
		}

		function getTotalUsage()
		{
			var bundle = -1;
			var script = getScript().scriptId;
			if (script != null && script != "global" && script != "internal")
			{
				bundle = getScript().bundleId;
				if (bundle == null || bundle == '')  bundle = -1;
			}
			if (totalBundleUsage[bundle] == null)
			{
				totalBundleUsage[bundle] = getDynamicBundleUsage(bundle) || utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getTotalScriptGovernance", [bundle] );
			}
			return totalBundleUsage[bundle];
		}

		function getDynamicBundleUsage(bundle)
		{
			var bundleGovernances = getDynamicData("bundleGovernance");
			if (!bundleGovernances)
				return undefined;
			var bundleList = String(bundle).split(",");
			var governance = 1000; //default for client script
			for (var i = 0; i < bundleList.length; i++)
			{
				var bundleGovernance = bundleGovernances[parseInt(bundleList[i], 10)];
				if (bundleGovernance > governance)
					governance = bundleGovernance;
			}
			return governance;
		}

		function getErrorMsg(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
		{
			return utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getErrorMessage", [errorCode, errorVal1, errorVal2, errorVal3, errorVal4]);
		}

		function calculateRemainingUsage()
		{
			return getTotalUsage() - parseInt(getCharges(), 10);
		}

		var theContext = null;

		function getContext()
		{
			function getTheContext() {
				try
				{
					if (theContext === null)
					{
						if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
							theContext = nsDefaultContextObj;
						else
						{
							theContext = getDynamicData("context") || utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getContext");
							theContext.internal = true;
							if (theContext.contexttypes)
								theContext.contexttypes = JSON.parse(theContext.contexttypes);
						}
					}
					return theContext;
				}
				catch (e)
				{
					throw Error(e);
				}
			}


			function getRecordType()
			{
				return (currentRecordService.get() || {}).type || null;
			}

			function getPrefInner(name)
			{
				//Verify that the preferences global object has been already loaded
				if(typeof preferencesCache === "undefined" || !preferencesCache ||typeof preferencesCache[name] === "undefined")
				{
					preferencesCache = getDynamicData("preferences");
					if (!preferencesCache)
					{
						//cache miss or empty cache, load all preferences from the server into the global variable that's acting as
						// a cache.
						utilityFunctionsImpl.serverCallAsync(nsJSONProxyURL, 'getPreferences', [], function (data) {
							if (data != null || data)
							{
								preferencesCache = data.result == null ? data : data.result
							}
						})
						// Cache loading has been triggered, now return the single result required using the old way.
						return utilityFunctionsImpl.serverCall(nsJSONProxyURL, 'getPref', [name])
					}
				}

				// return preference value from cached object, after handling  T/F -> true/false conversion if needed.
				return preferencesCache[name];
			}

			function getPref(name)
			{
				if (name.toLowerCase().indexOf('custscript') === 0)
				{
					if (getTheContext().scriptprefs == null)
					{
						getTheContext().scriptprefs = getRecordDynamicData("scriptPrefs") || utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getScriptPrefs", [getRecordType()]);
					}
					return getTheContext().scriptprefs[name];
				}

				name = name.toUpperCase();
				var prefValue = getPrefInner(name);
				var prefType = getPrefType(name);
				if (('T' === prefValue || 'F' === prefValue) && ('boolean' === prefType))
					return 'T' === prefValue;
				else
					return prefValue;
			}

			function getPrefType(name)
			{
				if (name.toLowerCase().indexOf('custscript') == 0)
				{
					if (getTheContext().scriptpreftypes == null)
					{
						theContext.scriptpreftypes = getRecordDynamicData("scriptPrefTypes") || utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getScriptPrefTypes", [getRecordType()]);
					}
					return theContext.scriptpreftypes[name];
				}
				name = name.toUpperCase();

                if (typeof preferencesTypesCache === 'undefined' || !preferencesTypesCache || typeof preferencesTypesCache[name] === 'undefined')
				{
					if (!(preferencesTypesCache = getDynamicData("preferenceTypes"))) {
						//cache miss or empty cache.
                        utilityFunctionsImpl.serverCallAsync(nsJSONProxyURL, 'getAllPreferencesTypes', [], function (data) {
							if (data != null || data)
							{
                                preferencesTypesCache = data.result == null ? data : data.result
							}
                        })
                        return utilityFunctionsImpl.serverCall(nsJSONProxyURL, 'getPrefType', [name])
					}
				}

				// return preference value from cached object.
				return preferencesTypesCache[name];
			}

			return {
				//Script
				getLogLevel: function () { return undefined;}, // not supported for client scripts
				getScriptId: function () { return !!getScript() ? getScript().scriptId : undefined},
				getPercentComplete: function () { return undefined;}, // not supported for client scripts
				setPercentComplete: function () { return undefined;}, // not supported for client scripts
				getDeploymentId: function () { return !!getScript() ? getScript().deployId : undefined },
				getBundleId: function () { return !!getScript() ? getScript().bundleId : undefined },
				getBundleIds: function ()
				{
					var rc = !!getScript() && getScript().hasOwnProperty('bundleId') ? getScript().bundleId.split(',') : undefined;
					if (Array.isArray(rc) && rc.length === 1 && rc[0] === '')
						return [];
					return rc;
				},
				getRemainingUsage: function () { return calculateRemainingUsage();},
				getPreferenceObject: function (name) { return getPref(name);},
				getPreference: function (name) { return getPref(name);},
				getPreferenceType: function (name) { return getPrefType(name);},
				//Session
				getSessionObject: function (name) { return utilityFunctionsImpl.serverCall(nsJSONProxyURL, "getSessionObject", [name]);},
				getSessionObjectAsync: function (name, callback) { utilityFunctionsImpl.serverCallAsync(nsJSONProxyURL, "getSessionObject", [name], callback);},
				setSessionObject: function () { return undefined;}, // not supported for client scripts
				//User
				getEmail: function () { return getTheContext().email;},
				getName: function () { return getTheContext().name;},
				getLocation: function () { return parseInt(getTheContext().location, 10);},
				getDepartment: function () { return parseInt(getTheContext().department, 10);},
				getRole: function () { return parseInt(getTheContext().role, 10);},
				getRoleCenter: function () { return getTheContext().rolecenter;},
				getRoleId: function () { return getTheContext().roleid;},
				getUser: function () { return parseInt(getTheContext().user, 10);},
				getContact: function () { return parseInt(getTheContext().contact, 10);},
				getSubsidiary: function () { return parseInt(getTheContext().subsidiary, 10);},
                getPermission: function (name) {
                    name = name.toUpperCase()
                    if (typeof permissionsCache === 'undefined' || !permissionsCache || typeof permissionsCache[name] === 'undefined')
					{
						if (!(permissionsCache = getDynamicData("permissions"))) {
							//cache miss or empty cache.
                            utilityFunctionsImpl.serverCallAsync(nsJSONProxyURL, 'getPermissions', [], function (data) {
								if (data != null || data)
								{
                                    permissionsCache = data.result == null ? data : data.result
								}
                            })
                            return utilityFunctionsImpl.serverCall(nsJSONProxyURL, 'getPerm', [name])
						}
					}

					// return preference value from cached object.
                    return permissionsCache[name]
				},
				//Base
				getFeature: function (name)
				{
					name = name.toUpperCase();
					//Verify that the features global object has been already loaded
                    if (typeof featuresCache === 'undefined' || !featuresCache || typeof featuresCache.set === 'undefined')
					{
						if (!(featuresCache = getDynamicData("features")))
						{
                            //cache miss or empty cache, load all features from the server into the global variable that's acting
                            // as a cache.
                            utilityFunctionsImpl.serverCallAsync(nsJSONProxyURL, 'getFeatures', [], function (data) {
								if (data != null || data)
								{
                                    featuresCache = data.result == null ? data : data.result
								}
                            })
                            return utilityFunctionsImpl.serverCall(nsJSONProxyURL, 'getFeature', [name])
						}
					}

	                    return featuresCache.set == null ? featuresCache.hasOwnProperty(name) : featuresCache.set.hasOwnProperty(name);
                    },
                    getQueueCount: function () { return undefined;}, // not supported for client scripts
	                getProcessorCount: function () { return undefined;}, // not supported for client scripts
                    getVersion: function () { return getTheContext().version;},
                    getCompany: function () { return getTheContext().company;},
				getCountry: function () { return getTheContext().country; },
				getCompanyLongName: function () { return getTheContext().companyLongName; },
                    getEnvironment: function () { return getTheContext().environment;},
                    getExecutionContext: function () { return getTheContext().context;},
                    getExecutionContextTypes: function(){ return getTheContext().contexttypes;},
                    //Client Script Only
                    isInternal: function () { return getTheContext().internal; },
                    getScriptType: function () { return "CLIENT"; }
                }
            }

		function XMLtoString(xml)
		{
			if (!xml)
			{
				var error = new Error(getErrorMsg("SSS_MISSING_REQD_ARGUMENT"));
				error.name = "SSS_MISSING_REQD_ARGUMENT";
				throw error;
			}

			try
			{
				if (xml.nodeType === 2)    /* Special Handling for Attribute Node. XMLSerializer supports Nodes only */
					return xml.name + '=' + xml.value;
				else if (window.XMLSerializer && window.XPathEvaluator)
					return new XMLSerializer().serializeToString(xml);
				else
					return xml.xml
			}
			catch (e)
			{
				throw e;
			}
		}

		function wrap(node)
		{
			if (!node)
			{
				return node
			}

			switch (node.nodeType)
			{
				case 1:
					return wrapElement(node);
				case 2:
					return wrapAttr(node);
				case 9:
					return wrapDocument(node);
				default:
					return wrapNode(node);
			}
		}

		function wrapAttr(attr)
		{
			var wrappedAttr = {};
			wrappedAttr.getName = function () { return attr.name; };
			wrappedAttr.getOwnerElement = function () { return wrap(attr.ownerElement); };
			wrappedAttr.getSpecified = function () { return attr.specified; };
			wrappedAttr.getValue = function () { return attr.value; };
			wrappedAttr.setValue = function (val) { attr.value = val; };
			return wrappedAttr;
		}

		function wrapDocument(doc)
		{
			var wrappedDoc = wrapNode(doc);
			wrappedDoc.hasAttributes = undefined;
			wrappedDoc.adoptNode = function (source) { return wrap(doc.adoptNode(source)) };
			wrappedDoc.createAttribute = function (name) { return wrapAttr(doc.createAttribute(name)) };
			wrappedDoc.createAttributeNS = function (qualifiedName) { return wrapAttr(doc.createAttributeNS(qualifiedName)) };
			wrappedDoc.createCDATASection = function (data) { return wrapNode(doc.createCDATASection(data)) };
			wrappedDoc.createComment = function (data) { return wrapNode(doc.createComment(data)) };
			wrappedDoc.createDocumentFragment = function () { return wrapNode(doc.createDocumentFragment()) };
			wrappedDoc.createElement = function (tagName) { return wrapElement(doc.createElement(tagName)) };
			wrappedDoc.createElementNS = function (namespaceURI, qualifiedName) { return wrapElement(doc.createElementNS(namespaceURI, qualifiedName)) };
			wrappedDoc.createProcessingInstruction = function (target, data) { return wrapNode(doc.createProcessingInstruction(target, data)) };
			wrappedDoc.createTextNode = function (data) { return wrapNode(doc.createTextNode(data)) };
			wrappedDoc.getElementById = function (elementId) { return wrapElement(doc.getElementById(elementId)) };
			wrappedDoc.getElementsByTagName = function (tagName) { return wrapElement(doc.getElementsByTagName(tagName)) };
			wrappedDoc.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(doc.getElementsByTagNameNS(namespaceURI, localName)) };
			wrappedDoc.importNode = function (importedNode, deep) { return wrap(doc.importNode(importedNode, deep)) };
			wrappedDoc.normalizeDocument = function () { return doc.normalize(); };
			wrappedDoc.getDoctype = function () { return wrapNode(doc.doctype) };
			wrappedDoc.getDocumentElement = function () { return wrapElement(doc.documentElement) };
			wrappedDoc.getDocumentURI = function () { return doc.documentURI };
			wrappedDoc.setDocumentURI = function (val) { doc.documentURI = val};
			wrappedDoc.getInputEncoding = function () { return doc.inputEncoding };
			wrappedDoc.getXmlEncoding = function () { return doc.xmlEncoding };
			wrappedDoc.getXmlStandalone = function () { return doc.xmlStandalone };
			wrappedDoc.setXmlStandalone = function (val) { doc.xmlStandalone = val };
			wrappedDoc.getXmlVersion = function () { return doc.xmlVersion };
			wrappedDoc.setXmlVersion = function (val) { doc.xmlVersion = val };
			return wrappedDoc;
		}

		function wrapElement(element)
		{
			var wrappedElem = wrapNode(element)
			wrappedElem.getAttribute = function (name) { return element.getAttribute(name); };
			wrappedElem.getAttributeNode = function (name) { return wrap(element.getAttributeNode(name)); };
			wrappedElem.getAttributeNodeNS = function (namespaceURI, localName) { return wrap(element.getAttributeNodeNS(namespaceURI, localName)); };
			wrappedElem.getAttributeNS = function (namespaceURI, localName) { return element.getAttributeNS(namespaceURI, localName); };
			wrappedElem.getElementsByTagName = function (tagName) { return wrapElement(element.getElementsByTagName(tagName)); };
			wrappedElem.getElementsByTagNameNS = function (namespaceURI, localName) { return wrapElement(element.getElementsByTagNameNS(namespaceURI, localName)); };
			wrappedElem.hasAttribute = function (name) { return element.hasAttribute(name); };
			wrappedElem.hasAttributeNS = function (namespaceURI, localName) { return element.hasAttributeNS(namespaceURI, localName); };
			wrappedElem.removeAttribute = function (name) { return element.removeAttribute(name); };
			wrappedElem.removeAttributeNode = function (oldAttr) { return wrap(element.removeAttributeNode(oldAttr)); };
			wrappedElem.removeAttributeNS = function (namespaceURI, localName) { return element.removeAttributeNS(namespaceURI, localName); };
			wrappedElem.setAttribute = function (name, value) { return element.setAttribute(name, value); };
			wrappedElem.setAttributeNode = function (newAttr) { return element.setAttributeNode(newAttr); };
			wrappedElem.setAttributeNodeNS = function (newAttr) { return element.setAttributeNodeNS(newAttr); };
			wrappedElem.setAttributeNS = function (namespaceURI, qualifiedName, value) { return element.setAttributeNS(namespaceURI, qualifiedName, value); };
			wrappedElem.getTagName = function () { return element.getTagName(); };
			return wrappedElem;
		}

		function wrapNode(node)
		{
			return {
				appendChild: function (newChild) { return wrap(node.appendChild(newChild)); },
				cloneNode: function (deep) { return wrap(node.cloneNode(deep)); },
				compareDocumentPosition: function (other) { return node.compareDocumentPosition(other); },
				hasAttributes: function () { return node.hasAttributes(); },
				hasChildNodes: function () { return node.hasChildNodes(); },
				insertBefore: function (newChild, refChild) { return wrap(node.insertBefore(newChild, refChild)); },
				isDefaultNamespace: function (namespaceURI) { return node.isDefaultNamespace(namespaceURI); },
				isEqualNode: function (other) { return node.isEqualNode(other); },
				isSameNode: function (other) { return node.isSameNode(other); },
				lookupNamespaceURI: function (prefix) { return node.lookupNamespaceURI(prefix); },
				lookupPrefix: function (namespaceURI) { return node.lookupPrefix(namespaceURI); },
				normalize: function () { return node.normalize(); },
				removeChild: function (oldChild) { return wrap(node.removeChild(oldChild)); },
				replaceChild: function (newChild, oldChild) { return wrap(node.replaceChild(newChild, oldChild)); },

				getAttributes: function () { return node.attributes; },
				getBaseURI: function () { return null; },
				getFirstChild: function () { return wrap(node.firstChild); },
				getLastChild: function () { return wrap(node.lastChild); },
				getLocalName: function () { return node.localName; },
				getNamespaceURI: function () { return node.namespaceURI; },
				getNextSibling: function () { return wrap(node.nextSibling); },
				getNodeName: function () { return node.nodeName; },
				getNodeType: function () { return node.nodeType; },
				getNodeValue: function () { return node.nodeValue; },
				setNodeValue: function (val) { return node.nodeValue = val; },
				getOwnerDocument: function () { return wrap(node.ownerDocument); },
				getParentNode: function () { return wrap(node.parentNode); },
				getPrefix: function () { return node.prefix; },
				setPrefix: function (val) { return node.prefix = val; },
				getPreviousSibling: function () { return wrap(node.previousSibling); },
				getTextContent: function () { return node.textContent; },
				setTextContent: function (val) { return node.textContent = val; },
				_gd: function () { return node; }
			}
		}

		function createIEDoc()   //NLAppUtil:nsCreateDocument
		{
			var doc = null;
			if (document.implementation && document.implementation.createDocument && !(window.ActiveXObject !== undefined))
				doc = document.implementation.createDocument("", "", null);
			else
			{
				try
				{
					doc = new ActiveXObject("Msxml2.DOMDocument.6.0");
				}
				catch (e)
				{
					try
					{
						doc = new ActiveXObject("Msxml2.DOMDocument.3.0");
					}
					catch (e)
					{
						doc = new ActiveXObject("Msxml2.DOMDocument.4.0");
					}
				}
				if (doc != null)
				{
					doc.async = false;
					doc.resolveExternals = false;
				}
			}
			return doc;
		}

		function stringToXML(text, dontThrow)
		{
			var nsDocument = null;
			if (window.DOMParser && window.XPathEvaluator)
			{
				nsDocument = new DOMParser().parseFromString(text, 'text/xml')
				if (!dontThrow)
				{
					var parserErrors = nsDocument.getElementsByTagName("parsererror")
					if (parserErrors.length > 0)
					{
						var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' + parserErrors[0].innerHTML) ;
						error.name = "SSS_XML_DOM_EXCEPTION";
						throw error;
					}
				}
			}
			else if (!window.XPathEvaluator)
			{
				nsDocument = createIEDoc();
				nsDocument.loadXML(text);
				if (!dontThrow)
				{
					if (nsDocument.parseError && nsDocument.parseError.errorCode !== 0)
					{
						var error = new Error(getErrorMsg("SSS_XML_DOM_EXCEPTION") + ' ' +nsDocument.parseError.reason) ;
						error.name = "SSS_XML_DOM_EXCEPTION";
						throw error;
					}
				}
			}
			else
			{
				return null;
			}


			return nsDocument;
		}

		function selectNodes(node, expr)
		{
			if (!node || !node.hasChildNodes())
				return [];

			var nodes = null;
			var owner = node.ownerDocument != null ? node.ownerDocument : node;
			if (window.XPathEvaluator)
			{
				var xpe = new XPathEvaluator();
				/* manually resolve default namespace URI in Firefox/Safari (if needed) */
				var resolver = function (prefix)
				{
					return thisNameSpace[prefix];
				}
				var thisNameSpace = {};
				if (XMLtoString(node).indexOf('xmlns') != -1)
				{
					var nodelist = owner.getElementsByTagName("*")
					for (var j = 0; j < nodelist.length; j++)
					{
						var attributes = nodelist[j].attributes;
						for (var i = 0; attributes != null && i < attributes.length; i++)
						{
							if (attributes[i].name == 'xmlns')
								thisNameSpace["nlapi"] = attributes[i].nodeValue;
							else if (attributes[i].name.indexOf('xmlns:') == 0)
								thisNameSpace[attributes[i].name.substring(6)] = attributes[i].nodeValue;
						}
					}
				}
				var results = xpe.evaluate(expr, node, resolver, XPathResult.ANY_TYPE, null)
				if (results != null)
				{
					nodes = new Array();
					var result;
					while (result = results.iterateNext())
						nodes[nodes.length] = result;
				}
			}
			else
			{
				/* manually resolve name spaces in IE (if needed) */
				if (XMLtoString(node).indexOf('xmlns') != -1)
				{
					var namespaces = null;
					owner.setProperty("SelectionLanguage", "XPath");
					var nodelist = owner.getElementsByTagName("*")
					for (var j = 0; j < nodelist.length; j++)
					{
						var attributes = nodelist[j].attributes;
						for (var i = 0; attributes != null && i < attributes.length; i++)
						{
							if (attributes[i].name.indexOf('xmlns:') == 0)
								namespaces = (namespaces != null ? namespaces + " " : "") + attributes[i].xml;
							else if (attributes[i].name == 'xmlns')
								namespaces = (namespaces != null ? namespaces + " " : "") + "xmlns:nlapi=\"" + attributes[i].nodeValue + "\"";
						}
					}
					if (namespaces != null)
						owner.setProperty("SelectionNamespaces", namespaces)
				}
				nodes = node.selectNodes(expr);
			}
			return nodes;
		}

		function throwNotSupported()
		{
			var e = new Error(getErrorMsg("SSS_NOT_YET_SUPPORTED"))
			e.name = "SSS_NOT_YET_SUPPORTED";
			throw e;
		}

		return Object.freeze({
			nlapiCreateError: createError,
			getErrorMessage: getErrorMsg,
			transform: function (record) { return record },
			nlapiGetContext: function () { return getContext(); },
			nlapiXMLToString: function (xml) { return XMLtoString(xml); },
			nlapiStringToXML: function (text, dontThrow) { return stringToXML(text, dontThrow); },
			nlapiSelectNodes: selectNodes,
			nlapiValidateXML: function () { throwNotSupported(); },
			nsObjectToMap: function (obj) { return obj; },
			setupScript: setupScript,
			getScript: getScript,
			chargeUsage: chargeUsage,
			alert: alert,
			confirm: confirm,
			checkWarningMessageInSession: checkWarningMessageInSession
		});
	}
);
/**
 * @private
 */
define('N/restricted/xmlApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * @private
 */
define('N/restricted/errorApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * @private
 */
define('N/restricted/remoteApiBridge',['N/internal/reflet'], function(reflet){ return reflet; });
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */

/**
 * IMPORTANT! Beware of introducing circular dependencies, almost every single module depends on the [error] and [invoker] modules.
 * Only simple dependencies such as Java api bridges (although client side bridges could be an issue) are safe here.
 * Also note that it is intentional that [error] module does not use invoker for that reason, which means that any intercepting
 * logic there will not be called.
 */
/**
 * SuiteScript error module
 *
 * @module N/error
 * @suiteScriptVersion 2.x
 *
 */
define('N/error',['N/restricted/xmlApi', 'N/restricted/errorApi', 'N/restricted/remoteApiBridge', 'N/nsobject'],
        function (xmlApi, errorApi, remoteUtil, nsobject)
        {
        	/* For proper loading of (localized) alert/error messages, this MUST BE
        	 * SYNCHRONIZED with the enums in DynamicEnumsApiImpl on the backend.
        	 *
        	 * Please keep alphabetical order.
        	 */
	        var ERROR_TYPES = {
		        ARRAY_1_CANNOT_BE_EMPTY: "",
		        AT_LEAST_ONE_EXPRESSION_IS_NEEDED: "",
		        A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD: "",
		        BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE: "",
		        CANNOT_CREATE_RECORD_DRAFT_OF_EXISTING_RECORD: "",
		        CANNOT_CREATE_RECORD_INSTANCE: "",
		        CANNOT_DETERMINE_TYPE_FOR_ALIAS: "",
		        CANNOT_DETERMINE_VALUE_FOR_ALIAS: "",
		        CANNOT_RESUBMIT_SUBMITTED_ASYNC_DOCUMENT_CAPTURE_TASK: "",
		        CANNOT_RESUBMIT_SUBMITTED_ASYNC_PIVOT_TASK: "",
		        CANNOT_RESUBMIT_SUBMITTED_ASYNC_QUERY_TASK: "",
		        CANNOT_RESUBMIT_SUBMITTED_ASYNC_SEARCH_TASK: "",
		        CANNOT_RESUBMIT_SUBMITTED_ASYNC_SUITEQL_TASK: "",
		        CAN_EMBED_1_INPUTS_AT_MAXIMUM: "",
		        CAN_REFERENCE_ONLY_PERSISTED_DATASET: "",
		        CAN_SELECT_ONLY_ONE_DEFAULT_CHOICE: "",
		        COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED: "",
		        CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS: "",
		        CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY: "",
		        CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS: "",
		        DATASET_NAME_IS_MISSING: "",
		        DEFAULT_CHOICE_IS_MISSING: "",
		        DOCUMENT_CANNOT_BE_EMPTY: "",
		        DOCUMENT_IDS_MUST_BE_UNIQUE: "",
		        DOCUMENT_TOO_LARGE: "",
		        DUPLICATE_PARAMETER_NAME: "",
		        DUPLICATE_TOOL_NAME: "",
		        DUPLICATE_TOOL_RESULT: "",
		        EACH_VIEW_MUST_HAVE_AN_ID: "",
		        EACH_VIEW_MUST_HAVE_A_NAME: "",
		        EMPTY_KEY_NOT_ALLOWED_FOR_1: "",
		        EXPRESSION_CANNOT_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION: "",
		        EXPRESSION_MUST_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION: "",
		        EXPRESSIONS_CANNOT_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION: "",
		        EXPRESSIONS_MUST_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION: "",
		        FAILED_AN_UNEXPECTED_ERROR_OCCURRED: "",
		        FEATURE_1_DOES_NOT_SUPPORT_LANGUAGE_2: "",
		        FEATURES_CANNOT_BE_EMPTY: "",
		        FIELD_1_ALREADY_CONTAINS_A_SUBRECORD_YOU_CANNOT_CALL_CREATESUBRECORD: "",
		        FIELD_1_CANNOT_BE_EMPTY: "",
		        FIELD_1_IS_NOT_A_SUBRECORD_FIELD: "",
		        FIELD_MUST_CONTAIN_A_VALUE: "",
		        FILE_CANNOT_BE_EMPTY:"",
		        FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD: "",
		        FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD: "",
		        FREQUENCY_PENALTY_PARAMETER_NOT_AVAILABLE: "",
		        HISTORY_IS_ONLY_AVAILABLE_FOR_THE_LAST_30_DAYS: "",
		        IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES: "",
		        ID_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: "",
		        INCOMPATIBLE_DOCUMENT_TYPE_FOR_FEATURE_1: "",
		        INPUT_TOO_LARGE: "",
		        INVALID_AGGREGATE_TYPE: "",
		        INVALID_AGGREGATION: "",
		        INVALID_ALGORITHM: "",
		        INVALID_ALPHA_VALUE: "",
		        INVALID_ASPECT_TYPE: "",
		        INVALID_CERTIFICATE_TYPE: "",
		        INVALID_CHART_TYPE: "",
		        INVALID_CHAT_ROLE: "",
		        INVALID_COLOR_VALUE: "",
		        INVALID_COLUMN_ALIAS: "",
		        INVALID_COLUMN_FOR_SORTING: "",
		        INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_FOR_1: "",
		        INVALID_CONFIGURATION_UNABLE_TO_CHANGE_REQUIRE_CONFIGURATION_WITHOUT_A_CONTEXT: "",
		        INVALID_CONFLICT_RESOLUTION_1: "",
				INVALID_CURRENCY: "",
		        INVALID_CUSTOM_VIEW_VALUE: "",
		        INVALID_DATASET_ID: "",
		        INVALID_DATE_ID: "",
		        INVALID_DATE_OBJECT: "",
		        INVALID_DATE_VALUE_MUST_BE_1: "",
		        INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE: "",
		        INVALID_DIRECTION_FOR_SORTING: "",
		        INVALID_DOCUMENT_TYPE: "",
		        INVALID_DOCUMENT_CAPTURE_RESULT: "",
		        INVALID_EMAILS_FOUND: "",
		        INVALID_EMBED_MODEL_FAMILY_VALUE: "",
		        INVALID_EXPRESSION: "",
		        INVALID_EXPRESSION_1_EXPECTED_PARAMETER_TYPE_2_GOT_3: "",
		        INVALID_EXPRESSION_NOT_COMPARABLE: "",
		        INVALID_FIELD_CONTEXT: "",
		        INVALID_FIELD_ID: "",
		        INVALID_FIELD_INDEX: "",
		        INVALID_FIELD_VALUE: "",
		        INVALID_FIELD_VALUE_WITH_REASON: "",
		        INVALID_FILTER_FIELD_FOR_CURRENT_VIEW: "",
		        INVALID_FLD_VALUE: "",
		        INVALID_FONT_SIZE: "",
		        INVALID_FONT_STYLE: "",
		        INVALID_FONT_WEIGHT: "",
		        INVALID_FORMULA_TYPE: "",
		        INVALID_FREQUENCY_PENALTY_VALUE: "",
		        INVALID_HTTP_METHOD: "",
		        INVALID_ID_PREFIX: "",
		        INVALID_IMAGE: "",
		        INVALID_KEY_TYPE: "",
		        INVALID_LANGUAGE: "",
		        INVALID_LOCALE: "",
		        INVALID_MAX_TOKENS_VALUE: "",
		        INVALID_MODEL_FAMILY_VALUE: "",
		        INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2: "",
		        INVALID_NUMBER_MUST_BE_GREATER_THAN_1: "",
		        INVALID_NUMBER_MUST_BE_LOWER_THAN_1: "",
		        INVALID_NUMBER_OR_PERCENTAGE: "",
		        INVALID_OPERATION: "",
		        INVALID_OPERATOR: "",
		        INVALID_OR_UNSUPPORTED_RECORD_TYPE_1: "",
		        INVALID_OWNER_CATEGORY: "",
		        INVALID_PAGE_INDEX: "",
		        INVALID_PAGE_RANGE: "",
		        INVALID_PERIOD_ADJUSTMENT: "",
		        INVALID_PERIOD_CODE: "",
		        INVALID_PERIOD_TYPE: "",
		        INVALID_POSITION: "",
		        INVALID_PRESENCE_PENALTY_VALUE: "",
		        INVALID_RETURN_TYPE_EXPECTED_1: "",
		        INVALID_SAFETY_MODE: "",
		        INVALID_SEARCH_OPERATOR: "",
		        INVALID_SEARCH_TYPE: "",
		        INVALID_SIGNATURE: "",
		        INVALID_SIGNATURE_TAG: "",
		        INVALID_SORT: "",
		        INVALID_SORT_LOCALE: "",
		        INVALID_STACKING_TYPE: "",
		        INVALID_SUBRECORD_MERGE: "",
		        INVALID_SUITEAPP_APPLICATION_ID: "",
		        INVALID_TASK_TYPE: "",
		        INVALID_TEMPERATURE_VALUE: "",
		        INVALID_TEMPORAL_UNIT: "",
		        INVALID_TEXT_ALIGN: "",
		        INVALID_TEXT_DECORATION_LINE: "",
		        INVALID_TEXT_DECORATION_STYLE: "",
		        INVALID_TOOL_PARAMETER_TYPE: "",
		        INVALID_TOP_K_VALUE: "",
		        INVALID_TOP_P_VALUE: "",
		        INVALID_TOTAL_LINE: "",
		        INVALID_TRUNCATION_METHOD: "",
		        INVALID_TYPE_1_USE_2: "",
		        INVALID_UNIT: "",
		        INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL: "",
		        INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE: "",
		        INVALID_WORKBOOK_ID: "",
		        MISSING_MANDATORY_FIELDS: "",
		        MODEL_1_DOES_NOT_ACCEPT_DOCUMENTS: "",
		        MODEL_1_DOES_NOT_ACCEPT_IMAGE: "",
		        MODEL_1_DOES_NOT_ACCEPT_PREAMBLE: "",
		        MODEL_1_DOES_NOT_ACCEPT_RESPONSE_FORMAT: "",
		        MODEL_1_DOES_NOT_ACCEPT_SAFETY_MODE: "",
		        MUTUALLY_EXCLUSIVE_ARGUMENTS: "",
		        NAME_CANNOT_BE_EMPTY: "",
		        NAME_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: "",
		        NEITHER_ARGUMENT_DEFINED: "",
		        NEW_TYPES_NOT_DEFINED: "",
		        NON_KATAKANA_DATA_FOUND: "",
		        NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT: "",
		        NOT_SUPPORTED_ON_CURRENT_SUBRECORD: "",
		        NO_ASPECTS_DEFINED: "",
		        NO_CHILDREN_DEFINED: "",
		        NO_COLUMN_DEFINED: "",
				NO_DATASET_DEFINED: "",
		        NO_DIMENSION_ITEM_DEFINED: "",
		        NO_ELEMENTS_DEFINED: "",
		        NO_INPUTS_TO_EMBED: "",
		        NO_MEASURES_DEFINED: "",
		        NO_RULE_DEFINED: "",
		        NO_SELECTORS_DEFINED: "",
		        NO_SORT_BY_DEFINED: "",
		        NO_VALID_TOOL_AVAILABLE: "",
		        NOTHING_TO_TRANSLATE: "",
		        ONLY_API_SECRET_IS_ACCEPTED: "",
		        OPERATION_IS_NOT_ALLOWED: "",
		        OPERATOR_ARITY_MISMATCH: "",
		        PASSWORD_CANNOT_HAVE_MORE_THAN_N_CHARACTERS: "",
		        PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE: "",
		        PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT: "",
		        PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT: "",
		        PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER: "",
		        PRESENCE_PENALTY_PARAMETER_NOT_AVAILABLE: "",
		        PROPERTY_VALUE_CONFLICT: "",
		        READ_ONLY_PROPERTY: "",
		        RELATIONSHIP_ALREADY_USED: "",
		        SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED: "",
		        SELECT_OPTION_ALREADY_PRESENT: "",
		        SELECT_OPTION_NOT_FOUND: "",
		        SERVER_SIDE_VALIDATION_FAILED: "",
		        SIGNATURE_VERIFICATION_FAILED: "",
		        SSS_ARGUMENT_DISCREPANCY: "",
		        SSS_DUPLICATE_ALIAS: "",
		        SSS_INVALID_ACTION_ID: "",
		        SSS_INVALID_API_USAGE: "",
		        SSS_INVALID_COUNTRY_ID: "",
		        SSS_INVALID_CURRENCY_ID: "",
		        SSS_INVALID_FORMAT_TYPE: "",
		        SSS_INVALID_GETSELECTOPTION_FILTER_OPERATOR: "",
		        SSS_INVALID_MACRO_ID: "",
		        SSS_INVALID_READ_SIZE: "",
		        SSS_INVALID_REDIRECT_OPERATION_ID: "",
		        SSS_INVALID_SEARCH_RESULT_INDEX: "",
		        SSS_INVALID_SEGMENT_SEPARATOR: "",
		        SSS_INVALID_SRCH_OPERATOR: "",
		        SSS_INVALID_SUBLIST: "",
		        SSS_INVALID_SUBLIST_OPERATION: "",
		        SSS_INVALID_TYPE_ARG: "",
		        SSS_INVALID_UI_OBJECT_TYPE: "",
		        SSS_INVALID_URL: "",
		        SSS_INVALID_VALUE_WITH_REASON: "",
		        SSS_METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD: "",
		        SSS_METHOD_IS_ONLY_ALLOWED_FOR_MULTISELECT_FIELD: "",
		        SSS_METHOD_IS_ONLY_ALLOWED_FOR_SELECT_FIELD: "",
		        SSS_MISSING_ALIAS: "",
		        SSS_MISSING_REQD_ARGUMENT: "",
		        SSS_NOT_YET_SUPPORTED: "",
		        SSS_REASON_EXPECTED_TYPE: "",
		        SSS_RECORD_DOES_NOT_SATISFY_CONDITION: "",
		        SSS_RECORD_TYPE_MISMATCH: "",
		        SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED: "",
		        SSS_SEARCH_RESULT_LIMIT_EXCEEDED: "",
		        SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES: "",
		        SSS_TAG_CANNOT_BE_EMPTY: "",
		        SSS_UNSUPPORTED_METHOD: "",
		        TABLE_DOES_NOT_EXIST: "",
		        TEMPERATURE_PARAMETER_NOT_AVAILABLE: "",
		        TOP_K_PARAMETER_NOT_AVAILABLE: "",
		        TOP_P_PARAMETER_NOT_AVAILABLE: "",
		        UNSUPPORTED_FILE_TYPE: "",
				PIVOT_DOES_NOT_EXIST: "",
		        THAT_RECORD_IS_NOT_EDITABLE: "",
		        THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED: "",
		        THE_OPTIONS_ARE_MUTUALLY_EXCLUSIVE_1_2_ARG2_: "",
		        TOO_MANY_RESULTS: "",
		        TOP_K_VALUE_INVALID: "",
		        TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE: "",
		        UNHANDLED_ERRORS_ON_RESTORE: "",
		        UNKNOWN_CONTEXT_TYPE: "",
		        UNKNOWN_PARAM: "",
		        UNRECOGNIZED_MODEL_PARAMETERS: "",
		        UNRECOGNIZED_OCI_CONFIG_PARAMETERS: "",
		        UNSUPPORTED_COLOR: "",
		        UNSUPPORTED_FILE_TYPE_1_USE_2:"",
		        UNSUPPORTED_NUMBER_OF_TOKENS: "",
		        VALUE_1_OUTSIDE_OF_VALID_MINMAX_RANGE_FOR_FIELD_2: "",
		        WORKBOOK_NAME_IS_MISSING: "",
		        WRONG_PARAMETER_TYPE: "",
		        WS_INVALID_REFERENCE_KEY_1: "",
		        WS_NO_PERMISSIONS_TO_SET_VALUE: "",
		        YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION: "",
	        };

	        (function()
	        {
		        /* TODO Get rid of aliases and unused error types
				 */
		        var ALIASES = {
			        EMPTY_KEY_NOT_ALLOWED: "EMPTY_KEY_NOT_ALLOWED_FOR_1",
			        INVALID_GETSELECTOPTION_FILTER_OPERATOR: "SSS_INVALID_GETSELECTOPTION_FILTER_OPERATOR",
			        INVALID_KEY_OR_REF: "WS_INVALID_REFERENCE_KEY_1",
			        INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD: "A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD",
			        INVALID_SUBLIST_OPERATION: "SSS_INVALID_SUBLIST_OPERATION",
			        INVALID_UI_OBJECT_TYPE: "SSS_INVALID_UI_OBJECT_TYPE",
			        METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD: "SSS_METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD",
			        MISSING_REQD_ARGUMENT: "SSS_MISSING_REQD_ARGUMENT"
		        };
		        /* These error types do not exist on backend
		         * and possibly are no longer being used.
		         */
		        var ERROR_TYPES_LIKELY_NOT_USED = {
			        INVALID_RCRD_TYPE: "",  // Mentioned and possibly used, but never through `error.Type`
			        SSS_TAX_REGISTRATION_REQUIRED: ""  // Mentioned in some JSON file
		        };
		        util.each(ALIASES, function (val, key)
		        {
			        ERROR_TYPES[key] = val;
		        });
		        util.each(ERROR_TYPES_LIKELY_NOT_USED, function (val, key)
		        {
			        ERROR_TYPES[key] = val;
		        });
		        util.each(ERROR_TYPES, function (val, key)
		        {
			        if (val === "")
				        ERROR_TYPES[key] = key;
		        });
	        })();

	        var isVersionTwoOne = xmlApi !== errorApi; // TODO: (P2) REMOVE THIS HACK! Inject apiVersion module that uses SuiteScriptRuntimeVersion

            /**
             *
             * @protected
             * @class SuiteScriptError
             * @classdesc Base class of SuiteScript errors
             * @constructor
             *
             * @since 2015.2
             */
            function SuiteScriptError(delegate)
            {
                var TYPE = 'error.SuiteScriptError';

                /**
                 * @name SuiteScriptError#type
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'type', {
                    get: function ()
                    {
                        return TYPE;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'type'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error ID that is automatically generated when a new error is created
                 * @name SuiteScriptError#id
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return delegate.getId();
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'id'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * User-defined error code
                 * @name SuiteScriptError#name
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return delegate.name || (delegate.getCode) ? delegate.getCode() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'name'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error message text displayed in the Details column of the Execution Log.
                 * @name SuiteScriptError#message
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'message', {
                    get: function ()
                    {
                        return delegate.message || (delegate.getDetails) ? delegate.getDetails() : '';
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'message'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * List of method calls that the script is executing when the error is thrown. The most recently executed method is
                 * listed at the top or the list.
                 * @name SuiteScriptError#stack
                 * @type {Array<string>}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'stack', {
                    get: function ()
                    {
                        return util.isFunction(delegate.getStackTrace) ? delegate.getStackTrace().slice(0) : '';
                    },
                    //'stack' must be settable in order to wrap a JS error with a SuiteScript error
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Cause of the SuiteScript error. It either returns the error itself, or another error, which caused this new
                 * error to happen.
                 * @name SuiteScriptError#cause
                 * @type {SuiteScriptError}
                 * @readonly
                 *
                 * @since 2016.1
                 */
                Object.defineProperty(this, 'cause', {
                    get: function ()
                    {
                        return delegate.cause || this;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'cause'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Error email supression indicator
                 * @name SuiteScriptError#notifyOff
                 * @type {boolean}
                 * @readonly
                 *
                 * @since 2016.2
                 */
                Object.defineProperty(this, 'notifyOff', {
                    get: function ()
                    {
                        return delegate.notifyOff;
                    },
                    set: function (val)
                    {
                        throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY,'notifyOff'),false));
                    },
                    enumerable: true,
                    configurable: false
                });

                this.userFacing = true;

                // Functions for debugger

	            /**
				 * get JSON format of the object
				 * @governance none
				 * @return {Object}
				 *
				 * @since 2015.2
				 */
                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    var cause = this;
                    if (delegateType === "function" || delegateType === "object" && !!delegate)
                    {
                    	if (!!delegate.cause && !!delegate.cause.getStackTrace && !!delegate.cause.getMessage)
	                    {
	                    	cause = {
	                    		message: delegate.cause.getMessage(),
			                    stack: delegate.cause.getStackTrace()
		                    };
	                    }
	                    else
	                    {
		                    cause = delegate.cause || delegate;
	                    }
                    }
                    return {
                        type: TYPE,
                        name: this.name,
                        message: this.message,
	                    id: this.id,
                        stack: this.stack,
                        cause: cause,
                        notifyOff: this.notifyOff,
	                    data: this.data,
	                    userFacing : this.userFacing
                    };
                };

	            /**
				 * Returns stringified representation of this SuiteScriptError
				 * @governance none
				 * @return {string}
				 *
				 * @since 2015.2
				 */
                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };
            }

            //inheritance TODO this is not working for Error, SuiteScriptError is not an instanceof Error
            var debuggable = nsobject.getNewInstance();
            var err = Object.create(Error.prototype);
            debuggable.prototype = err;
            SuiteScriptError.prototype = debuggable;
            SuiteScriptError.prototype.constructor = SuiteScriptError;

            /**
             *
             * @protected
             * @class UserEventError
             * @classdesc SuiteScript error class for user events
             * @constructor
             *
             * @since 2015.2
             */
            function UserEventError(delegate)
            {
                var TYPE = 'error.UserEventError';

                /**
                 * Internal ID of the submitted record that triggered the script. This property only holds a value when the error
                 * is thrown by an afterSubmit user event.
                 * @name UserEventError#recordId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'recordId', {
                    get: function ()
                    {
                        return delegate.getInternalId();
                    },

                    enumerable: true,
                    configurable: false
                });

                /**
                 * @name UserEventError#eventType
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'eventType', {
                    get: function ()
                    {
                        return delegate.getUserEvent();
                    },

                    enumerable: true,
                    configurable: false
                });

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    var delegateType = typeof(delegate);
                    return {
                        type: TYPE,
                        name: delegate.getCode(),
                        message: delegate.getDetails(),
                        stack: this.stack,
                        eventType: delegate.getUserEvent(),
                        recordId: delegate.getInternalId(),
                        cause: delegateType === "function" || delegateType === "object" && !!delegate ? delegate.cause || delegate : this,
                        id: this.id
                    };
                };

	            /**
	             * Returns stringified representation of this error
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return JSON.stringify(this);
                };

            }

            UserEventError.prototype = new SuiteScriptError();

            function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
            {
                return remoteUtil.getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4);
            }

			function prepareDelegate(apiError)
			{
				var stackTrace = isVersionTwoOne ? Error().stack.split("\n\t") : apiError.getStackTrace();
				var code = apiError.getCode();
				var details = apiError.getDetails();
				var id = apiError.getId();
				var userEvent = apiError.getUserEvent();
                var notifyOff = apiError.isSuppressNotification()||false;
				var delegate = {
					getStackTrace: function() { return stackTrace; },
					getDetails: function() { return details; },
					getCode: function() { return code; },
					getId: function() { return id; }
				};
                delegate.notifyOff = notifyOff;
				delegate.cause = {
					id: id,
					code: code,
					details: details,
					userEvent: userEvent,
					stackTrace: stackTrace.slice(0),
					toString: function() { return JSON.stringify(this); },
					toJSON: function()
					{
						return {
							type: "internal error",
							code: code,
							details: details,
							userEvent: userEvent,
							stackTrace: stackTrace.slice(0),
                            notifyOff: notifyOff
						};
					}
				};
				return delegate;
			}

	        function javaArrayToJsArray(javaArray)
	        {
		        var toRet = [];
		        for(var i = 0; javaArray && i < javaArray.length; i++)
			        toRet[i] = javaArray[i];

		        return toRet;
	        }

			// The result of this method will pass a potential call to JSON.stringify(), etc.
			function getSafeCause(errorObj)
			{
				var cause = errorObj.cause || errorObj;
				if (cause instanceof Error)
				{
					var safeCopy = {};
					Object.getOwnPropertyNames(cause).forEach(function (prop) {
						safeCopy[prop] = (prop === "stack" || prop === "rhinoException") ? cause[prop].toString() : cause[prop];
					});
					cause = safeCopy;
				}
				return cause;
			}

			function addCustomDataToError(suiteScriptError, data)
			{
				Object.defineProperty(suiteScriptError, 'data', {
					get: function ()
					{
						return data;
					},
					set: function (val)
					{
						throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.READ_ONLY_PROPERTY, getErrorMessage(ERROR_TYPES.READ_ONLY_PROPERTY, 'data'),false));
					},
					enumerable: true,
					configurable: false
				});
			}

            function createError(options)
            {
	            var currentStackTrace = null;
	            if (isVersionTwoOne)
		            currentStackTrace = Error().stack.split("\n");

                if (!options)
                    throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.MISSING_REQD_ARGUMENT, getErrorMessage(ERROR_TYPES.MISSING_REQD_ARGUMENT, 'error.create', 'options'), false));
	            if (!!options['hasOwnProperty'] && options.hasOwnProperty('notifyOff') && !util.isBoolean(options.notifyOff))
		            throw new SuiteScriptError(errorApi.nlapiCreateError(ERROR_TYPES.WRONG_PARAMETER_TYPE, getErrorMessage(ERROR_TYPES.WRONG_PARAMETER_TYPE, 'options.notifyOff', 'boolean'), false));

                var toRet = null;
                // Wrap internal Java exception
                if (options instanceof Object && options.constructor && options.constructor.name === 'JavaException')
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (!!options.javaException && util.isFunction(options.javaException.getData))
		                addCustomDataToError(toRet, JSON.parse(options.javaException.getData()));
	                toRet.userFacing = false;
                }
                //TODO clean up this mess - class objects should not be exposed to scripts, left over from Nashorn - Graal checks are all duck-typing, however, need to evaluate if deterministic
                else if (
	                //TODO improve duck-typing if it must be the impl (make very specific)
                    !!options.getCode && !!options.getMessage)
                {
	                toRet = new SuiteScriptError(prepareDelegate(errorApi.nlapiCreateError(options, null, false)));
	                if (options.getClass().getName().endsWith('SuiteScriptError'))
		                addCustomDataToError(toRet, JSON.parse(options.getData()));
                }
                // [Rhino Only] Wrap nlobjError delegate
                else if (options instanceof Object && options.constructor.name === 'nlobjError')
                {
                    toRet = new SuiteScriptError(prepareDelegate(options));
                    toRet.userFacing = false;
                }
                // JS error is the "cause"
	            else if (util.isError(options) || options instanceof SuiteScriptError)
	            {
		            var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return options.message; },
			            getCode: function() { return options.name; },
			            getId: function() { return options.id; }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }
                // Standard case, options are args to create SuiteScriptError, duck type the arg
                else if(options.hasOwnProperty // extends Object.prototype
	                && (options.hasOwnProperty('name') || options.hasOwnProperty('message') || options.hasOwnProperty('notifyOff')))
                {
	                var apiError = errorApi.nlapiCreateError(options.name, options.message, options.notifyOff || false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return apiError.getDetails(); },
		                getCode: function() { return apiError.getCode(); },
		                getId: function() { return apiError.getId() || options.id || null; }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
                else if(typeof options !== 'object') //convenience method. If string is passed in, set it to details.
                {
	                var apiError = errorApi.nlapiCreateError(options, null, false);
	                var delegate = {
		                getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
		                getDetails: function() { return options; },
		                getCode: function() { return ""; },
		                getId: function() { return apiError.getId(); }
	                };
	                delegate.cause = getSafeCause(options);
	                delegate.notifyOff = options.notifyOff || false;
	                toRet = new SuiteScriptError(delegate);
                }
	            else // nlobjError ctor logic tries to handle other cases (options is a java object)
	            {
		            var apiError = errorApi.nlapiCreateError(options, null, false);
		            var delegate = {
			            getStackTrace: function() { return isVersionTwoOne ? currentStackTrace : apiError.getStackTrace(); },
			            getDetails: function() { return apiError.getDetails(); },
			            getCode: function() { return apiError.getCode(); },
			            getId: function() { return apiError.getId(); }
		            };
		            delegate.cause = getSafeCause(options);
		            delegate.notifyOff = options.notifyOff || false;
		            toRet = new SuiteScriptError(delegate);
	            }
	            if (options.userFacing !== undefined && options.userFacing !== null ) {
                	toRet.userFacing = options.userFacing;
	            }
                return toRet;
            }

            return Object.freeze({
                /**
                 * Create a new custom SuiteScript Error object
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name A user-defined error code. Sets the value for the SuiteSriptError.name property.
                 * @param {string} options.message The error message displayed in the Execution Log Details column. The default
                 *     value is null. Sets the value for the SuiteScriptError.message property.
                 * @param {boolean} [options.notifyOff=false] Sets whether email notification is suppressed. If set to false, the system
                 *     emails the users identified on the applicable script record's Unhandled Errors subtab (when the error is
                 *     thrown). If set to true, users will not be notified. The default value is false.
                 * @return {SuiteScriptError}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some mandatory argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument has incorrect type
                 *
                 * @since 2015.2
                 */
                create: createError,
	            /**
	             * @enum {string}
	             * @readonly
	             */
	            Type: Object.freeze(ERROR_TYPES)
            });

        });

/**
 * SuiteScript module
 *
 * @private
 * @module N/util
 * @NApiVersion 2.x
 *
 */
define('N/util',[], function () {
    return util;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/log
 * @NApiVersion 2.x
 *
 */
define('N/log',[], function () {
    return log;
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/internal/invoker
 * @NApiVersion 2.x
 */
define('N/internal/invoker',['N/error', 'N/utilityFunctionsImpl'],
        function (error, utilityFunctionsImpl) {

            var callURL = '/app/common/scripting/ClientScriptHandler.nl?';
            var platformRequestURL = '/app/common/scripting/PlatformClientScriptHandler.nl?';

            var needsFirstArg = ['nlapiLoadRecord', 'loadRecord', 'nlapiCreateRecord', 'createRecord', 'nlapiCopyRecord', 'copyRecord', 'nlapiTransformRecord', 'transformRecord', 'nlapiSubmitField', 'nlapiDeleteRecord', 'nlapiSearchRecord', 'executeAction'];

            function checkForCharge(target, method, args, governanceOverride)
            {
                if (!!target && target.hasOwnProperty("chargeUsage"))
                {
                    var type;
                    if (method === "nlapiSubmitRecord")
                        type = args[0].getRecordType()
                    else if (!!args && needsFirstArg.indexOf(method) != -1)
                        type = args[0];
                    else
                        type = null;
                    target["chargeUsage"].apply(this, [method, type, args, governanceOverride]);
                }
            }

            function tryParsing(data)
            {
                var parsedData = {};
                try
                {
	                parsedData = util.isString(data) ? JSON.parse(data) : data;
                }
                catch (e)
                {
                    return data;
                }

                return parsedData;
            }

            function contextUrl(scriptInfo, url)
            {
            	var script = scriptInfo.scriptId || "";
            	var deploy = scriptInfo.deployId || "";
            	return url + "script=" + script + "&deploy=" + deploy;
            }

            var invoker = function invokeOn(target, method, args, callback, parseResult)
            {
                var result;
	            var governanceOverride;

                parseResult = parseResult === undefined || !!parseResult;

                if (!!target && (typeof target[method] !== "undefined"))
                {
                    try
                    {
                        result = target[method].apply(target, args);
                    }
                    catch (e)
                    {
                    	var exception = error.create(e);
                        if (!util.isFunction(callback))
		                    throw exception;
                        else
                        	return callback(undefined, exception);
                    }

                    if (!util.isFunction(callback))
                    	return result;
                    else
                        return callback(result);
                }
                else
                {
                    try
                    {
	                    var bridge = !!target ? target.bridge : null;
	                    var targetURL = !!bridge ? platformRequestURL : callURL;
	                    if (args === undefined || args === null)
	                    	args = [];
                        if (!util.isFunction(callback))
                        {
	                        if (!!bridge)
	                        {
		                        result = utilityFunctionsImpl.serverCall(contextUrl(target.getScript(), targetURL), "bridgeCall", [bridge, method].concat(JSON.stringify(args)));
		                        governanceOverride = result.governance;
		                        result = result.result;
	                        }
                            else
                            	result = utilityFunctionsImpl.serverCall(contextUrl(target.getScript(), targetURL), method, args);

                            if (parseResult)
                            {
                                result = tryParsing(result);
                            }
                            checkForCharge(target, method, args, governanceOverride);
                        }
                        else
                        {
                            var myCallback = function (response)
                            {
                                var result, exception;
                                //noinspection JSUnresolvedVariable
	                            if (response instanceof Error)
	                            {
	                            	exception = error.create(response);
	                            }
                                else
                                {
                                    if (response.hasOwnProperty("nlError") && response.nlError)
                                    {
                                    	exception = error.create({ name: response.code, message: response.details, id: response.id });
                                    }
                                    else
                                    {
                                        result = response.result;

	                                    if (!!bridge)
	                                    {
		                                    governanceOverride = result.governance;
		                                    result = result.result;
	                                    }
                                        if (parseResult)
                                        {
                                            result = tryParsing(result);
                                        }
                                        try {
	                                        checkForCharge(target, method, args, governanceOverride);
                                        } catch (e) {
                                        	result = undefined;
                                        	exception = e;
                                        }
                                    }
                                }
                                return callback(result, exception);
                            };
                            if (!!bridge)
                              utilityFunctionsImpl.serverCallAsync(contextUrl(target.getScript(), targetURL), "bridgeCall", [bridge, method].concat(JSON.stringify(args)), myCallback);
	                        else
	                            utilityFunctionsImpl.serverCallAsync(contextUrl(target.getScript(), targetURL), method, args, myCallback);
                        }
                    }
                    catch (e)
                    {
                        var exception = error.create(e);
                        if (!util.isFunction(callback))
                        	throw exception;
                        else
                        	return callback(undefined, exception);
                    }
                }
                return result;
            };

            invoker.promise = function invokeOn_promise(target, method, args, callback, parseResult)
            {
                if (!!target && (typeof target[method] !== "undefined") && (typeof target[method].promise !== "undefined"))
                {
                	return target[method].promise.apply(target, args)['catch'](function (e)
	                {
	                	throw error.create(e);
	                });
                }
                else
                {
	                return new Promise(function (resolve, reject)
		            {
		                invoker(target, method, args, function (result, exception)
			            {
			                if (exception === undefined)
				            {
				                resolve(result);
				            }
			                else
				            {
				                reject(exception);
				            }
			            }, parseResult);
		            });
                }
            };

            return invoker;
        }
);

/**
 * SuiteScript result object module.
 *
 * @private
 * @module N/resultObject
 * @NApiVersion 2.x
 */
define('N/resultObject',[], function () {
	function isThenable(arg) {
		return arg === Object(arg) && 'then' in arg && util.isFunction(arg.then);
	}

	var Result = function Result(executor) {
		var result = undefined;

		function resolve(valueOrThenable) {
			if (result === undefined) {
				result = Result.resolve(valueOrThenable);
			}
		}

		function reject(reason) {
			if (result === undefined) {
				result = Result.reject(reason);
			}
		}

		try {
			executor(resolve, reject);
		} catch (reason) {
			reject(reason);
		}

		if (result === undefined) {
			throw new TypeError("Result not resolved");
		}

		return result;
	};

	Result.resolve = function resolve(valueOrThenable) {
		return isThenable(valueOrThenable) ? valueOrThenable : Object.create(Result.prototype, {
			unwrap: { value: function unwrap() { return valueOrThenable; } }
		});
	};

	Result.reject = function reject(reason) {
		return Object.create(Result.prototype, {
			unwrap: { value: function unwrap() { throw reason; } }
		});
	};

	Result.create = function create(callback) {
		try {
			var value = callback();
			return Result.resolve(value);
		} catch (reason) {
			return Result.reject(reason);
		}
	};

	Result.prototype.toString = function toString() {
		try {
			var value = this.unwrap();
			return "Result {<fulfilled>: " + value + "}";
		} catch (reason) {
			return "Result {<rejected>: " + reason + "}";
		}
	};

	Result.prototype.then = function then(onFulfilled, onRejected) {
		try {
			var value = this.unwrap();
			if (util.isFunction(onFulfilled)) {
				try {
					var newValue = onFulfilled(value);
					if (newValue !== value) {
						return Result.resolve(newValue);
					}
				} catch (newReason) {
					return Result.reject(newReason);
				}
			}
			if (isThenable(value)) {
				return value;
			}
		} catch (reason) {
			if (util.isFunction(onRejected)) {
				try {
					var newValue = onRejected(reason);
					return Result.resolve(newValue);
				} catch (newReason) {
					if (newReason !== reason) {
						return Result.reject(newReason);
					}
				}
			}
		}
		return this;
	};

	Result.prototype['catch'] = function catch_(onRejected) {
		try {
			var value = this.unwrap();
			if (isThenable(value)) {
				return value;
			}
		} catch (reason) {
			if (util.isFunction(onRejected)) {
				try {
					var newValue = onRejected(reason);
					return Result.resolve(newValue);
				} catch (newReason) {
					if (newReason !== reason) {
						return Result.reject(newReason);
					}
				}
			}
		}
		return this;
	};

	Result.prototype['finally'] = function finally_(onFinally) {
		try {
			var value = this.unwrap();
			if (util.isFunction(onFinally)) {
				try {
					onFinally();
				} catch (newReason) {
					return Result.reject(newReason);
				}
			}
			if (isThenable(value)) {
				return value;
			}
		} catch (reason) {
			if (util.isFunction(onFinally)) {
				try {
					onFinally();
				} catch (newReason) {
					if (newReason !== reason) {
						return Result.reject(newReason);
					}
				}
			}
		}
		return this;
	};

	return Object.freeze(Result);
});

/**
 * @private
 */
define(
	'N/restricted/dynamicEnumsApi',['N/internal/reflet'],
	function (reflet)
	{
		return util.extend({bridge: 'dynamicEnumsApi'}, reflet);
	}
);

/**
 * @private
 */
define('N/restricted/environmentApiBridge',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'environmentApiBridge'}, reflet); });
/**
 * SuiteScript module
 *
 * @private
 * @module N/environment
 * @NApiVersion 2.x
 */
define('N/environment',['N/dynamicData', 'N/internal/invoker', 'N/restricted/environmentApiBridge'], function(dynamicData, invoker, bridge){

	function get(type)
	{
		var data = dynamicData.get("environment");
		if (!data)
			return type == "debug" ? invoker(bridge, "isDebug", []) : type == "searchCanary" ? invoker(bridge, "isSearchCanaryOn") : type == "runtimeCanary" ? invoker(bridge, "isRuntimeCanaryOn") : false;
		return data[type];
	}

	function isNewUI()
	{
		return get("newUI");
	}

	function isDebug()
	{
		return get("debug");
	}

	function isSearchCanaryOn()
	{
		return get("searchCanary");
	}

	function isRuntimeCanaryOn()
	{
		return get("runtimeCanary");
	}
	
	function isClientSide()
	{
		return true;
	}

	return Object.freeze({
		isNewUI: isNewUI,
		isDebug: isDebug,
		isSearchCanaryOn: isSearchCanaryOn,
		isRuntimeCanaryOn: isRuntimeCanaryOn,
		isClientSide: isClientSide
	})
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/dynamicEnums
 * @NApiVersion 2.x
 */
define(
	'N/dynamicEnums',[
		'N/internal/invoker',
		'N/restricted/dynamicEnumsApi',
		'N/dynamicData',
		'N/environment',
	], function(
		invoker,
		bridge,
		dynamicData,
		environment
	) {
		var cache = {};

		function isDebug()
		{
			try {
				return environment.isDebug();
			} catch (e) {
				// Likely inside client side emulated script.
				return false;
			}
		}

		function getDynamic(key)
		{
			if (cache.hasOwnProperty(key))
				return cache[key];

			var data = dynamicData.get("dynamicEnumsData");
			var out = data && data[key];

			if (out === undefined) {
				if (isDebug()) {
					console.warn("Fallback to synchronous HTTP call for `" + key + "`!");
				}
				var getterName = "get" + key[0].toUpperCase() + key.slice(1);
				out = invoker(bridge, getterName, []);
			}

			cache[key] = out;
			return out;
		}

		/*
		 * Keep in sync with serverDynamicEnums.js!
		 */
		return Object.freeze({
			get querySortLocales() { return getDynamic("querySortLocales") },
			get querySearchTypes() { return getDynamic("querySearchTypes") },
			get searchTypes() { return getDynamic("searchTypes") },
			get recordTypes() { return getDynamic("recordTypes") },
			get runtimeContextTypes() { return getDynamic("runtimeContextTypes") },
			get transactionTypes() { return getDynamic("transactionTypes") },
			get translationLocales() { return getDynamic("translationLocales") },
			get errorMessages() { return getDynamic("errorMessages") },
			get currencies() { return getDynamic("currencies") },
			get errorTypesJSCode() { return getDynamic("errorTypesJSCode") }
		});
	}
);

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */

/**
 * SuiteScript module
 *
 * @private
 * @module N/utilityFunctions
 * @NApiVersion 2.x
 */
define(
	'N/utilityFunctions',['N/utilityFunctionsImpl', 'N/error', 'N/internal/invoker', 'N/restricted/remoteApiBridge', 'N/resultObject', 'N/dynamicEnums', 'N/internal/reflet'],
	function (utilImpl, error, invoker, remoteApi, resultObject, dynamicEnums, reflet)
	{
		function getGlobalScope()
		{
			return (function () {return this;}());
		}

		function isObject(obj)
		{
			return obj === Object(obj);
		}

		/**
		 * check if the value is empty
		 * @param {String} val being tested for whether it is empty (null or "")
		 * @originalFrom NLRecordUtil.js
		 */
		function isValEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return (val.length === 0) || !/\S/.test(val);
		}

		function isEmpty(val)
		{
			if (val === null || val === undefined)
				return true;

			val = String(val);
			return val.length === 0;
		}

		function isValFinite(value)
		{
			return isFinite(parseFloat(value));
		}

		function isSignedXml(object)
		{
			if (object && util.isFunction(object.toString))
			{
				return (object.toString() === "certificate.SignedXml");
			}
			return false;
		}

		function isFile(object)
		{
			if (object && util.isFunction(object.toString))
			{
				return (object.toString() === "file.File");
			}
			return false;
		}

		function isInternalErrorCode(errorCode)
		{
			for (var code in error.Type)
			{
				if (error.Type[code] === errorCode)
					return true;
			}

			return false;
		}

		/**
		 * >>> getErrorMessage(error.Type.INVALID_TYPE_1_USE_2, "String", "Number")
		 * 'Invalid type String, use Number'
		 *
		 * >>> getErrorMessage("UNRECOGNIZED_ERROR", 123, "abc")
		 * 'UNRECOGNIZED_ERROR(123, "abc")'
		 *
		 * >>> getErrorMessage(error.Type.UNRECOGNIZED_ERROR, 123, "abc")
		 * 'undefined(123, "abc")'
		 */
		function getErrorMessage(errorCode, errorVal1, errorVal2, errorVal3, errorVal4)
		{
			var vals = [
				errorVal1,
				errorVal2,
				errorVal3,
				errorVal4,
				undefined
			];
			var message = dynamicEnums.errorMessages[errorCode];
			if (message === undefined) {
				/*
				 * It would be good to log an unrecognized error code here
				 * but it would be `undefined` in most cases.
				 */
				vals = vals.slice(0, vals.indexOf(undefined))
					.map(JSON.stringify);

				var placeholders = [];
				for (var i = 1; i <= vals.length; i++)
					placeholders.push("{" + i + "}");

				message = errorCode + "(" + placeholders.join(", ") + ")";
			}
			return fillInMessageTemplate(message, vals);
		}

		function fillInMessageTemplate(message, vals)
		{
			vals = vals || [];
			return message.replace(
				/{([1-4])[^}]*}/g,
				function (match, i)
				{
					var val = vals[parseInt(i) - 1];
					if (val === undefined)
						val = null;
					return String(val);
				}
			);
		}

		function throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			throw createSuiteScriptError.apply(null, arguments);
		}

		/**
		 * @return {SuiteScriptError}
		 */
		function createSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var message = getErrorMessage(
				internalErrorMessageCode || errorCode,
				errorMessageVal1,
				errorMessageVal2,
				errorMessageVal3,
				errorMessageVal4
			);
			return error.create({name: errorCode, message: message});
		}

		function logSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2, errorMessageVal3, errorMessageVal4, internalErrorMessageCode)
		{
			var errorObj = createSuiteScriptError.apply(null, arguments);
			log.error({
				title: errorObj.name,
				details:  errorObj.message
			});
		}

		function getConstructorNameSafe(val)
		{
			if (val === null)
				return "Null";
			else if (val === undefined)
				return "Undefined";
			else if (isNaN(val))
				return "NaN";

			try {
				return val.constructor.name;
			} catch (e) {
				return "???";
			}
		}

		// must not be falsy (0 is allowed; null & false is not allowed)
		function checkArgs(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		// must not be undefined or null
		function checkArgsPresent(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (funcArgs[i] == null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		// must not be undefined
		function checkArgsDefined(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (funcArgs[i] === undefined)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		// must not be falsy (0 & null is allowed; false is not allowed)
		function checkArgsAllowNull(funcArgs, funcArgNames, funcName)
		{
			for (var i = 0; i < funcArgs.length; i++)
			{
				if (!funcArgs[i] && funcArgs[i] !== 0 && funcArgs[i] !== null)
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', funcArgNames[i]);
			}
		}

		// to check whether positional argument option is correct = non-falsy JS Object
		function checkOptionsObject(optionsArg, funcName)
		{
			if (optionsArg != null) {
				throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', "options");
			}
			if (!isObject(optionsArg)) {
				throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, funcName ? funcName : '', "options");
			}
		}

		function assertTrue(expression, errorCode, errorMessageVal1, errorMessageVal2)
		{
			if (!expression)
				throwSuiteScriptError(errorCode, errorMessageVal1, errorMessageVal2);
		}

		function checkMutuallyExclusiveArguments(arg1, arg2, arg1Name, arg2Name)
		{
			if (arg1 != undefined && arg2 != undefined)
				throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, arg1Name, arg2Name);
		}

		function checkAtLeastOneArgumentIsDefined(args, argNames, funcName)
		{
			for (var i = 0; i < args.length; i++){
				if (args[i] != null)
					return;
			}
			throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName ? funcName : '', argNames[0]);
		}

		function ensureInteger(val, paramName)
		{
			if (isNaN(val = val != null ? parseInt(val, 10) : null))
				throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, paramName, 'integer');
			return val;
		}

		function freezeObjectIfPossible(obj)
		{
			return (Object.freeze && (obj || obj === "" || obj === 0)) ? Object.freeze(obj) : obj;
		}

		function wrapDelegates(array, type)
		{
			return (array && array.map)
				? array.map(function (el, idx, arr)
				{
					return new type(el);
				})
				: null;
		}

		function arrayIndexOf(array, val, ignoreCase)
		{
			for (var i = 0; array && i < array.length; i++)
			{
				if (val === array[i] || (ignoreCase && val && array[i] && val.toLowerCase() === array[i].toLowerCase()))
					return i;
			}
			return -1;
		}

		function assignDefaultOrCurrentValue(arg, defaultVal)
		{
			return arg || arg === 0 || arg === false ? arg : defaultVal;
		}

		function checkArgTypes(checkArgObjectArray)
		{
			for (var i = 0; i < checkArgObjectArray.length; i++)
			{
				var current = checkArgObjectArray[i];
				if ((current.value || current.value === 0 || current.value === false) &&
					((util.isNumber(current.value) && isNaN(current.value)) || !current.verifyFunction(current.value)))
				{
					throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, current.name);
				}
			}
		}

		function checkArgObject(value, name, verifyFunction)
		{
			return {
				value: value,
				name: name,
				verifyFunction: verifyFunction
			};
		}

		var serverCall = function (url, methodName, args)
		{
			return utilImpl.serverCall(url, methodName, args);
		};

		serverCall.promise = function (url, methodName, args)
		{
			var myPromise = new Promise(function (resolve, reject)
			{
				try
				{
					utilImpl.serverCallAsync(url, methodName, args, function (response)
					{
						(response instanceof Error) ? reject(response) : resolve(response);
					});
				}
				catch (e)
				{
					reject(e);
				}
			});
			return myPromise;
		};

		/**
		 * Search Util
		 */
		function unmarshalArray(payloadMap, prefix, unmarshalFunction)
		{
			var array = [];
			var count = payloadMap[prefix + 'count']; // TODO : investigate if count is used elsewhere
			for (var i = 0; i < count; ++i)
			{
				var attributeMap = payloadMap[prefix + i];
				var obj = unmarshalFunction(attributeMap);
				array.push(obj);
			}
			return array;
		}

		function arrayToMap(array, func)
		{
			var result = [];
			for (var i = 0; i < array.length; ++i)
			{
				result.push(func(array[i]));
			}
			return result;
		}

		function assertArrayElementsOfSameType(array, type, argName, errorCode)
		{
			if (!util.isArray(array))
				return;
			for (var i = 0; i < array.length; i++)
			{
				assertTrue(isElementSameType(array[i], type), errorCode || 'SSS_INVALID_ARRAY_ARGUMENT', argName + '[' + i + ']');
			}

		}

		function isElementSameType(element, type)
		{
			return (element || element === 0) &&
				((type === Object(type) && element instanceof type) ||
					typeof element === type ||
					(element.constructor && element.constructor.name && element.constructor.name === type));
		}

		function normalizeArrayOrSingularObjectArg(arg)
		{
			return util.isArray(arg) ? arg : arg != undefined ? [arg] : null;
		}

		function arrayContains(array, val)
		{
			return arrayIndexOf(array, val) >= 0;
		}

		function arrayAdd(array, val)
		{
			if (!arrayContains(array, val))
				array.push(val);
		}

		function addParameterToMap(map, params)
		{
			if (!map)
				map = {};

			for (var key in params)
			{
				if (params.hasOwnProperty(key))
					map[key] = params[key];
			}

			return map;
		}

		/*
		 * Supply additional information to the arguments being passed in,
		 * with care to possibility that the inputted args are flattened or in an object
		 */
		function augmentArguments(args, keyName, keyIndex, keyValue)
		{
			var returnMe = args;
			if (!!returnMe)
			{
				if (returnMe.length > 1 || !util.isObject(returnMe[0]))
				{
					if (keyIndex >= returnMe.length)
					{
						returnMe.length = keyIndex + 1;
					}
					returnMe[keyIndex] = keyValue;
				}
				else if (util.isObject(returnMe[0]))
				{
					returnMe[0] = util.extend({}, returnMe[0]);
					returnMe[0][keyName] = keyValue;
				}
			}
			return returnMe;
		}

		function returnEmptyIfNull(str)
		{
			return str != null ? str : "";
		}

		function getAsArray(arg)
		{
			return arg != null ? (util.isArray(arg) ? arg : [arg]) : null;
		}

		function unwrapArray(arg)
		{
			return arg != null ? ((util.isArray(arg) || arg instanceof Array) ? arg : arg.list) : null;
		}

		function addReadOnlyProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: getter,
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: true,
				configurable: false
			});
		}

		function addReadOnlyNonEnumerableProperty(target, propertyName, getter)
		{
			Object.defineProperty(target, propertyName, {
				get: getter,
				set: function ()
				{
					throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName);
				},
				enumerable: false,
				configurable: false
			});
		}

		function promiseTo(fn, params, postProcess, errorPostProcess)
		{
			return new Promise(function (resolve, reject)
			{
				var callback = function(result, exception)
				{
					if (exception)
					{
						try
						{
							reject(util.isFunction(errorPostProcess) ? errorPostProcess({result: exception, data: this}) : exception);
						}
						catch (e)
						{
							reject(e);
						}
						return;
					}
					try
					{
						resolve(util.isFunction(postProcess) ? postProcess({result: result, data: this}) : result);
					}
					catch (e)
					{
						reject(e);
					}
				};

				callback.promiseCallback = true;

				try
				{
					fn.apply(callback, Array.prototype.slice.call(params));
				}
				catch (e)
				{
					reject(e);
				}
			});
		}

		function isPromiseCallback(options)
		{
			return util.isFunction(options) && options.promiseCallback;
		}

		function deepFreeze(obj)
		{
			if (util.isObject(obj))
			{
				Object.freeze(obj);
				for (var p in obj)
				{
					if (obj.hasOwnProperty(p))
						deepFreeze(obj[p]);
				}
			}
			return obj;
		}

		function getFcFileContent(filePathOrId)
		{
			if (util.isNumber(filePathOrId))
				filePathOrId = String(filePathOrId);
			return invoker(remoteApi, 'nlapiLoadFileAsString', [filePathOrId]);
		}

		function unescape(obj)
		{
			if (typeof(obj) === 'string') {
				obj = obj.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&").replace(/<br>/g, '\n');
			}
			return obj;
		}

		function getConstructorName (obj) {
			if (obj.constructor.name !== undefined) return obj.constructor.name;
			// Property "name" is not supported in IE. It is non-standard until ECMAScript 6
			return obj.constructor.toString().trim().replace(/^\S+\s+(\w+)[\S\s]+$/, '$1');
		}

		function checkObjectType(obj, type)
		{
			return objectType(type)(obj);
		}

		function objectType(type)
		{
			return function (obj)
			{
				if (obj)
				{
					if (!isObject(obj) || !util.isFunction(obj.toString) || obj.toString() != type)
						return false;
				}
				else
					return false;
				return true;
			}
		}

		function checkArrayType(array, callback)
		{
			for (var i = 0; i < array.length; i++)
			{
				if (!callback(array[i]))
					return false;
			}
			return true;
		}

		function checkMapType(map, callback)
		{
			for (var i in map)
			{
				if (!callback(i, map[i]))
					return false;
			}
			return true;
		}

		function isNull(x)
		{
			return x === null;
		}

		function isAny(x)
		{
			return true;
		}

		function isInt(x)
		{
			return typeof x === 'number' &&
				isFinite(x) &&
				Math.floor(x) === x;
		}

		function isInEnum()
		{
			var allowedValues;

			if (arguments.length === 1 && (util.isArray(arguments[0]) || util.isObject(arguments[0]))) {
				allowedValues = arguments[0];
			} else {
				// convert arguments object to array
				allowedValues = Array.prototype.slice.call(arguments);
			}

			if (util.isObject(allowedValues)) {
				return function (x)
				{
					return x in allowedValues;
				};
			} else {
				return function (x)
				{
					return allowedValues.indexOf(x) >= 0;
				};
			}
		}

		function isOneOf()
		{
			var verifyFuncs = arguments;

			return function(x)
			{
				for (var i = 0; i < verifyFuncs.length; i++)
					if (verifyFuncs[i](x))
						return true;

				return false;
			}
		}

		function isArrayOf(verifyFunc, mustBeNonEmpty)
		{
			return function (x)
			{
				if (!util.isArray(x))
					return false;

				for (var i = 0; i < x.length; i++)
					if (!verifyFunc(x[i]))
						return false;

				if (mustBeNonEmpty && x.length === 0)
					return false

				return true;
			}
		}

		function isInstanceOf(cls)
		{
			return function (x)
			{
				return x instanceof cls;
			}
		}

		function _arrayIntersection(a1, a2)
		{
			return a1.filter(function (x) {return a2.indexOf(x) >= 0;});
		}

		/**
		 * @param {Object}     key2schema
		 * @param {Object=}    key2schema.key
		 * @param {number=}    key2schema.key.inp input (convenience) arg index
		 * @param {number=}    key2schema.key.out output array index
		 * @param {Function}   key2schema.key.verify
		 * @param {*=}         key2schema.key.defaultValue
		 * @param {Function=}  key2schema.key.defaultFactory
		 * @return {Array<string>}  found errors
		 */
		// to be run during developement of key2schemas
		function _processAndCheckArgs_inputTest(key2schema)
		{
			var i;
			var result = [];

			var convenienceIdxs = [];
			var convenienceIdxMax = -1;
			var outputIdxs = [];
			var outputIdxMax = -1;
			for (var key in key2schema) {
				if (key2schema.hasOwnProperty(key))	{
					var val;
					val = key2schema[key].inp;
					if (val !== undefined) {
						convenienceIdxs[val] = true;
						convenienceIdxMax = Math.max(convenienceIdxMax, val);
					}
					val = key2schema[key].out
					if (val !== undefined) {
						outputIdxs[val] = true;
						outputIdxMax = Math.max(outputIdxMax, val);
					}
				}
			}
			for (i = 0; i < convenienceIdxMax; i++) {
				if (convenienceIdxs[i] !== true) {
					result.push(
						"convenience argument position " + i +
						"is not assigned to any key in key2schema, while max assigned position is " + convenienceIdxMax);
				}
			}

			for (i = 0; i < outputIdxMax; i++) {
				if (outputIdxs[i] !== true) {
					result.push(
						"output array position " + i +
						"is not assigned to any key in key2schema, while max assigned position is " + outputIdxMax);
				}
			}

			return result;
		}

		/**
		 * @typedef {Object} ArgsValidationSchema
		 * @property {Function}   verify
		 * @property {*|undefined}         defaultValue
		 * @property {Function|undefined}  defaultFactory
		 */

		/**
		 * @typedef {ArgsValidationSchema} ArgsValidationSchemaWithInp
		 * @property {number|undefined}    inp input (convenience) arg index
		 */

		/**
		 * @typedef {ArgsValidationSchemaWithInp} ArgsValidationSchemaWithInpOut
		 * @property {number|undefined}    out output array index
		 */

		/**
		 * Simplifies the problem of verification of options object combined with convenience arguments.
		 * key2schema defines the verification conditions and default values.
		 * The first convenience parameter (defined by having .inp = 0) must NOT BE an OBJECT! Object at callArgs[0] will always be
		 * interpreted as Options!
		 * Value is considered to be PRESENT when value !== undefined, in accordance with ES6 (implies callArgs[0].someKey exists
		 * when parsing an Options object). PRESENT value is considered VALID when the associated .verify function returns true (be
		 * sure to make the verfication fail properly (return false) on unwanted null/empty-string/other special cases, which are
		 * NOT handled by the PRESENCE check).
		 * @param {string}                              funcName
		 * @param {IArguments}                          callArgs pass here the implicit arguments from function scope.
		 *                                                  If callArgs[0] is Object, ignores the rest!
		 * @param {Object<ArgsValidationSchemaWithInp>} keyToSchema
		 * @param {boolean=}                            throwOnExtraArgs
		 * @return {Object} returns options object; throws exception if validation failed
		 */
		function processAndCheckArgsToObject(funcName, callArgs, keyToSchema, throwOnExtraArgs)
		{
			var i;

			// fake args[] for processOptions() call
			var forProcessing;

			if (callArgs.length === 0) {
				// when there are no arguments, we will try to assume defaults for all parameters
				forProcessing = [];
			} else if (isObject(callArgs[0])) {
				// when the first arg is "any object" (not only "plain object"), we assume it is options object and do not process further args
				forProcessing = [callArgs[0]];
			} else {
				// when the first arg is not "any object", ...
				// create ordered list of the conveniently parsable args
				var convenienceArgsNames = [];
				for (var key in keyToSchema) {
					if (keyToSchema.hasOwnProperty(key)) {
						if (keyToSchema[key].inp !== undefined) {
							convenienceArgsNames[keyToSchema[key].inp] = key;
						}
					}
				}
				if (callArgs.length <= convenienceArgsNames.length) {
					// .. and if the number of passed args <= expected parsable convenience args,
					// then map the positional args into Object according the convenienceArgsNames
					var options = {};
					forProcessing = [options]
					for (i = 0; i < callArgs.length; i++) {
						options[convenienceArgsNames[i]] = callArgs[i];
					}
				} else {
					// else we fail as if we were only accepting options and nothing else
					throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName, 'options');
				}
			}

			return processOptions(funcName, forProcessing, keyToSchema, !!throwOnExtraArgs);
		}

		/**
		 * Simplifies the problem of verification of options object combined with convenience arguments.
		 * key2schema defines the verification conditions and default values.
		 * The first convenience parameter (defined by having .inp = 0) must NOT BE an OBJECT! Object at callArgs[0] will always be
		 * interpreted as Options!
		 * Value is considered to be PRESENT when value !== undefined, in accordance with ES6 (implies callArgs[0].someKey exists
		 * when parsing an Options object). PRESENT value is considered VALID when the associated .verify function returns true (be
		 * sure to make the verfication fail properly (return false) on unwanted null/empty-string/other special cases, which are
		 * NOT handled by the PRESENCE check).
		 * @param {string}                                  funcName
		 * @param {IArguments}                              callArgs pass here the implicit arguments from function scope
		 * @param {Object<ArgsValidationSchemaWithInpOut>}  keyToSchema
		 * @param {boolean=}                                throwOnExtraArgs
		 * @return {Array} returns array of option-values specifed by outNames; throws exception if validation failed
		 */
		function processAndCheckArgsToArray(funcName, callArgs, keyToSchema, throwOnExtraArgs)
		{
			var i;

			var outObj = processAndCheckArgsToObject(funcName, callArgs, keyToSchema, throwOnExtraArgs)

			var outNames = [];
			for (var key in keyToSchema) {
				if (keyToSchema.hasOwnProperty(key)) {
					if (keyToSchema[key].out !== undefined) {
						outNames[keyToSchema[key].out] = key;
					}
				}
			}

			var outArr = [];
			for (i = 0; i < outNames.length; i++) {
				outArr[i] = outObj[outNames[i]];
			}
			return outArr;
		}

		/**
		 * Reduces the problem of positional argument verification
		 * to the verification of single options object.
		 * @param {string}                          funcName
		 * @param {IArguments}                      callArgs pass here the implicit arguments from function scope
		 * @param {Array<string>}                   argNames
		 * @param {Object<ArgsValidationSchema>}    keyToSchema
		 */
		function processArguments(funcName, callArgs, argNames, keyToSchema)
		{
			var i;
			var options = {};
			var upTo = Math.min(argNames.length, callArgs.length);
			for (i = 0; i < upTo; i++)
				options[argNames[i]] = callArgs[i];

			var outObj = processOptions(funcName, [options], keyToSchema, false);
			var out = [];
			for (i = 0; i < argNames.length; i++)
				out[i] = outObj[argNames[i]];

			return out;
		}

		/**
		 * @param {string}                          funcName
		 * @param {IArguments}                      callArgs pass here the implicit arguments from function scope
		 * @param {Object<ArgsValidationSchema>}    keyToSchema
		 * @param {boolean=}                        isOptContext
		 */
		function processOptions(funcName, callArgs, keyToSchema, isOptContext)
		{
			if (isOptContext === undefined)
				isOptContext = true;

			var options = callArgs.length === 0 ? {} : callArgs[0];

			if (!util.isObject(options))
				throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options');

			var out = {};
			var numParamsRecognized = 0;

			for (var key in keyToSchema) {
				if (keyToSchema.hasOwnProperty(key))
				{
					var schema = keyToSchema[key];

					if (options.hasOwnProperty(key)) {
						/*
						 * Property provided --> verify its type.
						 */
						var val = options[key];
						var verify = schema.verify;
						if (!util.isFunction(verify)) {
							throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'schema.' + key);
						}
						if (!schema.verify(val)) {
							throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.' + key);
						}
						out[key] = val;
						numParamsRecognized++;
					} else if (schema.hasOwnProperty("defaultValue")) {
						/*
						 * Property not provided, but we have a default value.
						 */
						out[key] = schema.defaultValue;
					} else if (schema.hasOwnProperty("defaultFactory")) {
						/*
						 * Property not provided, but we have a default factory.
						 */
						out[key] = schema.defaultFactory();
					} else {
						/*
						 * Property not provided, but it is required.
						 */
						if (callArgs.length === 0) {
							throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName, 'options');
						} else {
							throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, funcName, 'options.' + key);
						}
					}
				}
			}
			if (isOptContext) {
				/*
				 * Check if there are unrecognized parameters.
				 */
				var paramsProvided = Object.keys(options);
				if (numParamsRecognized < paramsProvided.length) {
					var paramsSupported = Object.keys(keyToSchema);
					var paramsUnrecognized = _arrayIntersection(paramsProvided, paramsSupported);
					throwSuiteScriptError(
						error.Type.UNKNOWN_PARAM,
						paramsUnrecognized.join(", ")
					);
				}
			}

			return out;
		}

		/**
		 * Calls a single-argument function or a zero-argument method
		 * iff the argument or the context are not null respectively.
		 * Otherwise returns null.
		 *
		 * 2 arguments --> zero-argument method call
		 *
		 *      nullAwareCall(Date.prototype.toISOString, new Date())
		 *
		 * 3 arguments --> single-argument function call
		 *
		 *      nullAwareCall(JSON.stringify, null, [1, 2, 3])
		 *
		 * The purpose of this function is to reduce code repetevity.
		 */
		function nullAwareCall(func, context, argument)
		{
			if (arguments.length === 2)
				return context === null ? null : func.call(context);
			else
				return argument === null ? null : func.call(context, argument);
		}

		/**
		 * Edits the given mapping to make it more enum-like.
		 *
		 * @param {Object.<string, string>} obj
		 * @return {Object.<string, string>}
		 *
		 * It fills-in the blanks to reduce verbosity:
		 *
		 *      >>> enumify({
		 *      ...     RED: "",
		 *      ...     GREEN: "",
		 *      ...     BLUE: "",
		 *      ...     SKY_LIKE: "BLUE",  // use aliases like this
		 *      ... })
		 *      {
		 *          RED: "RED",
		 *          GREEN: "GREEN",
		 *          BLUE: "BLUE",
		 *          SKY_LIKE: "BLUE",
		 *      }
		 *
		 * The updated object is frozen and returned back as output.
		 *
		 * TODO Make the object throw an error when accessing a non-existing property
		 *      instead of stupidly returning undefined.
		 *      Graal and most browsers now support ES6'S proxies that allow this:
		 *          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
		 *      Even in Rhino, it should be theoretically possible with JavaAdapter.
		 *          https://gist.github.com/oberhamsi/4031545
		 *      Though SS seems to forbid that feature.
		 */
		function enumify(obj)
		{
			for (var key in obj)
				if (obj[key] === "")
					obj[key] = key;

			Object.freeze(obj);
			return obj;
		}

		/**
		 * Convert unix timestamps to Date objects in the given object(s).
		 *
		 * @param {Array<string>} keys
		 * @param {Object | Array<Object>} obj
		 */
		function timestampToDate(keys, obj)
		{
			if (util.isArray(obj)) {
				for (var i = 0; i < obj.length; i++) {
					_timestampToDate(keys, obj[i]);
				}
			} else {
				_timestampToDate(keys, obj);
			}
		}

		function _timestampToDate(keys, obj)
		{
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var val = obj[key];
				if (val !== null && val !== undefined) {
					obj[key] = new Date(val);
				}
			}
		}

		function wraps(fn, wrapperFn, nameRepl) {
			Object.defineProperty(wrapperFn, 'name', {
				value: nameRepl !== undefined ? (fn.name || '(anonymous)').replace(/(\(anonymous\)|(.*))/, nameRepl): fn.name,
				configurable: true
			});
			try {
				Object.defineProperty(wrapperFn, 'length', {
					value: fn.length,
					configurable: true
				});
			} catch(e) { /* do nothing, this is here because of IE incompatibility */ }
			if ('isAsyncArgIndex' in fn) {
				wrapperFn.isAsyncArgIndex = fn.isAsyncArgIndex;
			}
			if ('proxyOptionsArgIndex' in fn) {
				wrapperFn.proxyOptionsArgIndex = fn.proxyOptionsArgIndex;
			}
			return wrapperFn;
		}

		function isThenable(arg)
		{
			return isObject(arg) && 'then' in arg && util.isFunction(arg.then);
		}

		function thenableFunction(origFn, properties)
		{
			if (properties) {
				util.extend(origFn, properties);
			}

			var isAsyncArg = 'isAsyncArgIndex' in origFn ? origFn.isAsyncArgIndex : -1;

			var fn = wraps(origFn, function ()
			{
				if (isAsyncArg !== -1)
				{
					if (isAsyncArg >= arguments.length)
					{
						arguments.length = isAsyncArg + 1;
					}
					arguments[isAsyncArg] = false;
				}
				var result = origFn.apply(this, arguments);
				var resultThenable = resultObject.resolve(result);
				if (!resultThenable.unwrap)
				{
					throw new TypeError("expected " + origFn.name + (isAsyncArg === -1 ? "()" : "(isAsync = false)") + " not to return a promise: " + origFn);
				}
				return resultThenable.unwrap();
			}, 'thenableFunction($2)');

			fn.promise = wraps(origFn, function ()
			{
				if (isAsyncArg !== -1)
				{
					if (isAsyncArg >= arguments.length)
					{
						arguments.length = isAsyncArg + 1;
					}
					arguments[isAsyncArg] = true;
				}
				try
				{
					var result = origFn.apply(this, arguments);
					return Promise.resolve(result);
				}
				catch (e)
				{
					return Promise.reject(e);
				}
			}, 'thenableFunction($2).promise');

			Object.defineProperty(fn, 'thenable', {value: wraps(origFn, function ()
			{
				try
				{
					var result = origFn.apply(this, arguments);
					return resultObject.resolve(result);
				}
				catch (e)
				{
					return resultObject.reject(e);
				}
			}, 'thenableFunction($2).thenable')});

			return fn;
		}

		function forEachThenable(array, callback)
		{
			return array.reduce(function (accumulator, value, index, array)
			{
				return accumulator.then(function ()
				{
					return callback(value, index, array);
				});
			}, resultObject.resolve());
		}

		return Object.freeze({
			getFcFileContent: getFcFileContent,
			getGlobalScope: getGlobalScope,
			isObject: isObject,
			isValEmpty: isValEmpty,
			isEmpty: isEmpty,
			isFinite: isValFinite,
			isNull: isNull,
			isAny: isAny,
			isInt: isInt,
			isInEnum: isInEnum,
			isOneOf: isOneOf,
			isArrayOf: isArrayOf,
			isInstanceOf: isInstanceOf,
			processAndCheckArgsToObject: processAndCheckArgsToObject,
			processAndCheckArgsToArray: processAndCheckArgsToArray,
			processArguments: processArguments,
			processOptions: processOptions,
			nullAwareCall: nullAwareCall,
			enumify: enumify,
			assignDefaultOrCurrentValue: assignDefaultOrCurrentValue,
			checkArgTypes: checkArgTypes,
			checkArgObject: checkArgObject,
			wrapDelegates: wrapDelegates,
			freezeObjectIfPossible: freezeObjectIfPossible,
			isInternalErrorCode: isInternalErrorCode,
			getErrorMessage: getErrorMessage,
			fillInMessageTemplate: fillInMessageTemplate,
			throwSuiteScriptError: throwSuiteScriptError,
			createSuiteScriptError: createSuiteScriptError,
			logSuiteScriptError: logSuiteScriptError,
			getConstructorNameSafe: getConstructorNameSafe,
			arrayIndexOf: arrayIndexOf,
			arrayContains: arrayContains,
			arrayAdd: arrayAdd,
			checkArgs: checkArgs,
			checkArgsPresent: checkArgsPresent,
			checkArgsDefined: checkArgsDefined,
			checkArgsAllowNull: checkArgsAllowNull,
			checkOptionsObject: checkOptionsObject,
			assertTrue: assertTrue,
			checkMutuallyExclusiveArguments: checkMutuallyExclusiveArguments,
			checkAtLeastOneArgumentIsDefined: checkAtLeastOneArgumentIsDefined,
			ensureInteger: ensureInteger,
			serverCall: serverCall,
			unmarshalArray: unmarshalArray,
			arrayToMap: arrayToMap,
			assertArrayElementsOfSameType: assertArrayElementsOfSameType,
			normalizeArrayOrSingularObjectArg: normalizeArrayOrSingularObjectArg,
			addParameterToMap: addParameterToMap,
			augmentArguments: augmentArguments,
			returnEmptyIfNull: returnEmptyIfNull,
			getAsArray: getAsArray,
			addReadOnlyProperty: addReadOnlyProperty,
			addReadOnlyNonEnumerableProperty: addReadOnlyNonEnumerableProperty,
			promiseTo: promiseTo,
			isPromiseCallback: isPromiseCallback,
			deepFreeze: deepFreeze,
			isFile: isFile,
			isSignedXml: isSignedXml,
			unwrapArray: unwrapArray,
			unescape: unescape,
			getConstructorName: getConstructorName,
			checkObjectType: checkObjectType,
			objectType: objectType,
			checkArrayType: checkArrayType,
			checkMapType: checkMapType,
			timestampToDate: timestampToDate,
			wraps: wraps,
			isThenable: isThenable,
			thenableFunction: thenableFunction,
			forEachThenable: forEachThenable
		});
	}
);

/**
 * SuiteScript xml module
 *
 * @module N/xml
 * @NApiVersion 2.x
 *
 */
define('N/xml',['N/error', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/restricted/xmlApi'],
        function (error, nsobject, invoker, utilityFunctions, xmlApi)
        {
            var NODE_TYPES = Object.freeze([
                'ELEMENT_NODE',
                'ATTRIBUTE_NODE',
                'TEXT_NODE',
                'CDATA_SECTION_NODE',
                'ENTITY_REFERENCE_NODE',
                'ENTITY_NODE',
                'PROCESSING_INSTRUCTION_NODE',
                'COMMENT_NODE',
                'DOCUMENT_NODE',
                'DOCUMENT_TYPE_NODE',
                'DOCUMENT_FRAGMENT_NODE',
                'NOTATION_NODE'
            ]);

			// Unfortunately need to duplicate this const since stub generation static analysis requires object literal enum.
			// Can't derive array from object since iteration may be unordered.
            var NODE_TYPES_ENUM = Object.freeze({
                ELEMENT_NODE: 'ELEMENT_NODE',
                ATTRIBUTE_NODE: 'ATTRIBUTE_NODE',
                TEXT_NODE: 'TEXT_NODE',
                CDATA_SECTION_NODE: 'CDATA_SECTION_NODE',
                ENTITY_REFERENCE_NODE: 'ENTITY_REFERENCE_NODE',
                ENTITY_NODE: 'ENTITY_NODE',
                PROCESSING_INSTRUCTION_NODE: 'PROCESSING_INSTRUCTION_NODE',
                COMMENT_NODE: 'COMMENT_NODE',
                DOCUMENT_NODE: 'DOCUMENT_NODE',
                DOCUMENT_TYPE_NODE: 'DOCUMENT_TYPE_NODE',
                DOCUMENT_FRAGMENT_NODE: 'DOCUMENT_FRAGMENT_NODE',
                NOTATION_NODE: 'NOTATION_NODE'
            });

            var IE_CONVERSIONS = Object.freeze({
                getTextContent: 'text',
                getLocalName: 'baseName'
            });

            var CLIENT_SIDE_ATTR = Object.freeze({
                getName: 'name',
                getOwnerElement: 'ownerElement',
                getSpecified: 'specified',
                getValue: 'value',
                setValue: 'value',
                getDoctype: 'doctype',
                getDocumentElement: 'documentElement',
                getDocumentURI: 'documentURI',
                setDocumentURI: 'documentURI',
                getInputEncoding: 'inputEncoding',
                getXmlEncoding: 'xmlEncoding',
                getXmlStandalone: 'xmlStandalone',
                setXmlStandalone: 'xmlStandalone',
                getXmlVersion: 'xmlVersion',
                setXmlVersion: 'xmlVersion',
                getAttributes: 'attributes',
                getBaseURI: 'baseURI',
                getFirstChild: 'firstChild',
                getLastChild: 'lastChild',
                getLocalName: 'localName',
                getNamespaceURI: 'namespaceURI',
                getNextSibling: 'nextSibling',
                getNodeName: 'nodeName',
                getNodeType: 'nodeType',
                getNodeValue: 'nodeValue',
                setNodeValue: 'nodeValue',
                getOwnerDocument: 'ownerDocument',
                getParentNode: 'parentNode',
                getPrefix: 'prefix',
                setPrefix: 'prefix',
                getPreviousSibling: 'previousSibling',
                getTextContent: 'textContent',
                setTextContent: 'textContent'
            });

            function checkThenInvoke(target, method, args)
            {
                if (method === "getBaseURI" || method === "getDocumentURI")
                    return null;

                var targetMethodType = typeof target[method];

                if (targetMethodType === "undefined")
                {
                    if (typeof window !== "undefined" && !window.XPathEvaluator && IE_CONVERSIONS.hasOwnProperty(method))
                        return target[IE_CONVERSIONS[method]];
                    if (CLIENT_SIDE_ATTR.hasOwnProperty(method))
                    {
                        if (method.indexOf("set") === 0)
                            return target[CLIENT_SIDE_ATTR[method]] = args[0];
                        else
                            return target[CLIENT_SIDE_ATTR[method]];
                    }
                    else
                    {
                        return undefined;
                    }
                }

                // IE is unable to handle generic calls on the XML object.
                if (typeof window !== "undefined" && !window.XPathEvaluator)
                {
                    switch (args.length)
                    {
                        case 0:
                            return target[method]();
                        case 1:
                            return target[method](args[0]);
                        case 2:
                            return target[method](args[0], args[1]);
                        case 3:
                            return target[method](args[0], args[1], args[2]);
                        case 4:
                            return target[method](args[0], args[1], args[2], args[3]);
                        default:
                            return target[method](args[0], args[1], args[2], args[3], args[4]);
                    }
                }
                else
                {
                    try
                    {
                        return invoker(target, method, args)
                    }
                    catch (e)
                    {
                        if (e.name === "NotFoundError")
                        {
                            e = Error(e.message);
                            e.name = "SSS_XML_DOM_EXCEPTION";
                        }
                        throw e;
                    }
                }
            }

	        /**
	         * @class Parser
	         * @classDescription XML Parser Object
	         * @constructor
	         * @protected
	         *
	         * @since 2015.2
	         */
            function Parser()
            {
                /**
                 * Generate XML Document object from a string.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.text XML text
                 * @return {Document}
                 *
                 * @since 2015.2
                 */
                this.fromString = function fromString(options)
                {
                    var text = (options && options.hasOwnProperty('text')) ? options.text : options;
                    checkArgs([text], ['text'], 'Parser.fromString');
                    assertString(text, 'text');

                    var document = invoker(xmlApi, 'nlapiStringToXML', [text]);
                    return new Document(document);
                };

                /**
                 * Generate a String from an XML Document object.
                 * @governance none
                 * @param {Object} options
                 * @param {Document} options.document XML Document object
                 * @return {string}
                 *
                 * @since 2015.2
                 */
                this.toString = function toString(options)
                {
                    var document = (options && options.hasOwnProperty('document')) ? options.document : options;
                    checkArgs([document], ['document'], 'Parser.toString');
                    if(!(document instanceof Document) )
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'document','xml.Document' );

                    return document._asString();
                };
            }

	        /**
	         * @class XPath
	         * @classDescription XPath Query Object
	         * @constructor
	         * @protected
	         *
	         * @since 2015.2
	         */
            function XPath()
            {
                /**
                 * Returns an Array of Nodes matching the provided XPath expression.
                 * @param {Object} options
                 * @param {string} options.xpath an XPath expression
                 * @param {Node} options.node XML node being queried
                 * @return {Array<Node>} nodes associated with the current result
                 *
                 * @since 2015.2
                 */
                this.select = function select(options)
                {
                    var node = null, xpath = null;

                    if (options && (options.hasOwnProperty('node') || options.hasOwnProperty('xpath')))
                    {
                        node = options.node;
                        xpath = options.xpath;
                    }
                    else
                    {
                        node = options;
                        xpath = arguments[1];
                    }
                    checkArgs([node, xpath], ['node', 'xpath'], 'XPath.select');
                    assertNode(node, 'node');
                    assertString(xpath, 'xpath');

                    var nodes = invoker(xmlApi, 'nlapiSelectNodes', [node._gd(), xpath]);
                    var result = [];
                    for (var i = 0; i < nodes.length; i++)
                    {
                        result.push(wrap(nodes[i]));
                    }
                    return result;
                };
            }

            /**
             * Return a new instance of XML Node.
             * @class Node
             * @classDescription Encapsulation of W3C DOM Node
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Node(xmlnode)
            {
                var TYPE = 'xml.Node';
                checkArgs([xmlnode], ['xmlnode'], 'xml.Node');

                var _deleg = xmlnode;

                // Node members

                /**
                 * Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.newChild the node to add
                 * @return {Node} the node added
                 * @throws {SuiteScriptError} SSS_DOM_EXCEPTION if node cannot be appended for some reason
                 *
                 * @since 2015.2
                 */
                this.appendChild = function appendChild(options)
                {
                    var newChild = (options && options.hasOwnProperty('newChild')) ? options.newChild : options;
                    checkArgs([newChild], ['newChild'], 'Node.appendChild');
                    assertNode(newChild, 'newChild');

                    var result = checkThenInvoke(_deleg, 'appendChild', [newChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent.
                 * @governance none
                 * @param {Object} options
                 * @param {boolean} options.deep if true, recursively clone the subtree under the specified node; if false, clone only the node itself (and its attributes, if it is an Element)
                 * @return {Node} the duplicate node
                 *
                 * @since 2015.2
                 */
                this.cloneNode = function cloneNode(options)
                {
                    var deep = (options && options.hasOwnProperty('deep')) ? options.deep : options;
                    checkArgs([deep], ['deep'], 'Node.cloneNode');

                    var result = checkThenInvoke(_deleg, 'cloneNode', [deep == true]);
                    return wrap(result);
                };

                /**
                 * Compares the reference node, i.e. the node on which this method is being called, with a node, i.e. the one passed as a parameter,
                 * with regard to their position in the document and according to the document order.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.other the node to compare against the reference node
                 * @return {int} how the node is positioned relatively to the reference node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION when the nodes cannot be compared
                 */
                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.compareDocumentPosition');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'compareDocumentPosition', [other._gd()]);
                };

                /**
                 * Returns whether this node (if it is an Element) has any attributes.
                 * @governance none
                 * @return {boolean} true if this node has any attributes, false otherwise
                 *
                 * @since 2015.2
                 */
                this.hasAttributes = function hasAttributes()
                {
                    return checkThenInvoke(_deleg, 'hasAttributes', []);
                };

                /**
                 * Returns whether this node has any children.
                 * @governance none
                 * @return {boolean} true if this node has any children, false otherwise
                 *
                 * @since 2015.2
                 */
                this.hasChildNodes = function hasChildNodes()
                {
                    return checkThenInvoke(_deleg, 'hasChildNodes', []);
                };

                /**
                 * Inserts the node newChild before the existing child node refChild. If refChild is null, insert newChild at the end of the list of children.
                 * If the newChild is already in the tree, it is first removed.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.newChild the node to insert
                 * @param {Node} options.refChild the reference node, i.e., the node before which the new node will be inserted
                 * @return {Node} the node being inserted
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be inserted for some reason
                 *
                 * @since 2015.2
                 */
                this.insertBefore = function insertBefore(options)
                {
                    var newChild = null, refChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('refChild')))
                    {
                        newChild = options.newChild;
                        refChild = options.refChild;
                    }
                    else
                    {
                        newChild = options;
                        refChild = arguments[1];
                    }
                    checkArgs([newChild], ['newChild'], 'Node.insertBefore');
                    assertNode(newChild, 'newChild');
                    assertNodeNullable(refChild, 'refChild');

                    var result = checkThenInvoke(_deleg, 'insertBefore', [newChild._gd(), refChild == null ? null : refChild._gd()]);
                    return wrap(result);
                };

                /**
                 * This method checks if the specified namespaceURI is the default namespace or not.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @return {boolean} true if the specified namespaceURI is the default namespace, false otherwise
                 *
                 * @since 2015.2
                 */
                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.isDefaultNamespace');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'isDefaultNamespace', [namespaceURI]);
                };

                /**
                 * Tests whether two nodes are equal.
                 * This method tests for equality of nodes, not sameness (i.e., whether the two nodes are references to the same object) which can be tested
                 * with Node.isSameNode(). All nodes that are the same will also be equal, though the reverse may not be true.
                 * Two nodes are equal if and only if the following conditions are satisfied:
                 * - The two nodes are of the same type.
                 * - The following string attributes are equal: nodeName, localName, namespaceURI, prefix, nodeValue
                 * - The attributes maps are equal
                 * - The childNodes lists are equal
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.other the node to compare equality with
                 * @return {boolean} true if the nodes are equal, false otherwise
                 *
                 * @since 2015.2
                 */
                this.isEqualNode = function isEqualNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isEqualNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isEqualNode', [other._gd()]);
                };

                /**
                 * Returns whether this node is the same node as the given one.
                 * This method provides a way to determine whether two Node references returned by the implementation reference the same object.
                 * When two Node references are references to the same object, even if through a proxy, the references may be used completely interchangeably,
                 * such that all attributes have the same values and calling the same DOM method on either reference always has exactly the same effect.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.other the node to test against
                 * @return {boolean} true if the nodes are the same, false otherwise
                 *
                 * @since 2015.2
                 */
                this.isSameNode = function isSameNode(options)
                {
                    var other = (options && options.hasOwnProperty('other')) ? options.other : options;
                    checkArgs([other], ['other'], 'Node.isSameNode');
                    assertNode(other, 'other');

                    return checkThenInvoke(_deleg, 'isSameNode', [other._gd()]);
                };

                /**
                 * Look up the namespace URI associated to the given prefix, starting from this node.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.prefix the prefix to look for; if this parameter is null, the method will return the default namespace URI if any
                 * @return {string} the associated namespace URI or null if none is found
                 *
                 * @since 2015.2
                 */
                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    var prefix = (options && options.hasOwnProperty('prefix')) ? options.prefix : options;
                    assertStringNullable(prefix, 'prefix');

                    return checkThenInvoke(_deleg, 'lookupNamespaceURI', [prefix == null ? null : prefix]);
                };

                /**
                 * Look up the prefix associated to the given namespace URI, starting from this node. The default namespace declarations are ignored by this method.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI to look for
                 * @return {string} an associated namespace prefix if found or null if none is found; if more than one prefix are associated to the namespace prefix, the returned namespace prefix is implementation dependent
                 *
                 * @since 2015.2
                 */
                this.lookupPrefix = function lookupPrefix(options)
                {
                    var namespaceURI = (options && options.hasOwnProperty('namespaceURI')) ? options.namespaceURI : options;
                    checkArgs([namespaceURI], ['namespaceURI'], 'Node.lookupPrefix');
                    assertString(namespaceURI, 'namespaceURI');

                    return checkThenInvoke(_deleg, 'lookupPrefix', [namespaceURI]);
                };

                /**
                 * Puts all Text nodes in the full depth of the sub-tree underneath this Node, including attribute nodes, into a "normal" form
                 * where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates
                 * Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes.
                 * @governance none
                 * @return {void}
                 *
                 * @since 2015.2
                 */
                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalize', []);
                };

                /**
                 * Removes the child node indicated by oldChild from the list of children, and returns it.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.oldChild the node being removed
                 * @return {Node} the node removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be removed for some reason
                 *
                 * @since 2015.2
                 */
                this.removeChild = function removeChild(options)
                {
                    var oldChild = (options && options.hasOwnProperty('oldChild')) ? options.oldChild : options;
                    checkArgs([oldChild], ['oldChild'], 'Node.removeChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'removeChild', [oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node.
                 * If the newChild is already in the tree, it is first removed.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.newChild the new node to put in the child list
                 * @param {Node} options.oldChild the node being replaced in the list
                 * @return {Node} the node replaced
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if node cannot be replaced for some reason
                 *
                 * @since 2015.2
                 */
                this.replaceChild = function replaceChild(options)
                {
                    var newChild = null, oldChild = null;

                    if (options && (options.hasOwnProperty('newChild') || options.hasOwnProperty('oldChild')))
                    {
                        newChild = options.newChild;
                        oldChild = options.oldChild;
                    }
                    else
                    {
                        newChild = options;
                        oldChild = arguments[1];
                    }
                    checkArgs([newChild, oldChild], ['newChild', 'oldChild'], 'Node.replaceChild');
                    assertNode(newChild, 'newChild');
                    assertNode(oldChild, 'oldChild');

                    var result = checkThenInvoke(_deleg, 'replaceChild', [newChild._gd(), oldChild._gd()]);
                    return wrap(result);
                };

                /**
                 * A map of key/value (string->Attr) pairs containing the attributes of this node (if it is an Element) or null otherwise.
                 * @name Node#attributes
                 * @type {Object}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        var attrs = checkThenInvoke(_deleg, 'getAttributes', []);
                        if (!attrs)
                            return null;
                        var attrsLength = attrs.length || checkThenInvoke(attrs, 'getLength', []);
                        var result = {};
                        for (i = 0; i < attrsLength; i++)
                        {
                            var item = checkThenInvoke(attrs, 'item', [i]);
                            var node = new Attr(item);
                            result[node.name.replace(':', '_')] = node;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The absolute base URI of this node or null if the implementation wasn't able to obtain an absolute URI.
                 * @name Node#baseURI
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getBaseURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An array of all children of this node. If there are no children, this is an empty array.
                 * @name Node#childNodes
                 * @type {Array<Node>}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        var result = [];
                        var child = this.firstChild;

                        while (child !== null)
                        {
                            result.push(child);
                            child = child.nextSibling;
                        }
                        return result;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The first child of this node or null if there is no such node.
                 * @name Node#firstChild
                 * @type {Node}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getFirstChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The last child of this node or null if there is no such node.
                 * @name Node#lastChild
                 * @type {Node}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getLastChild', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The local part of the qualified name of this node.
                 * @name Node#localName
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getLocalName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace URI of this node, or null if it is unspecified.
                 * @name Node#namespaceURI
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNamespaceURI', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The node immediately following this node or null if there is no such node.
                 * @name Node#nextSibling
                 * @type {Node}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNextSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The name of this node, depending on its type.
                 * @name Node#nodeName
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The type of the underlying object.
                 * @name Node#nodeType
                 * @type {NodeType}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getNodeType', []);
                        return NODE_TYPES[result - 1];
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The value of this node, depending on its type. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#nodeValue
                 * @type {string}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getNodeValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setNodeValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The Document object associated with this node. This is also the Document object used to create new nodes.
                 * @name Node#ownerDocument
                 * @type {Document}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerDocument', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The parent of this node. All nodes, except Attr, Document, DocumentFragment, Entity, and Notation may have a parent.
                 * @name Node#parentNode
                 * @type {Node}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getParentNode', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The namespace prefix of this node, or null if it is unspecified. When it is defined to be null, setting it has no effect, including if the node is read-only.
                 * @name Node#prefix
                 * @type {string}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to set the property value
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getPrefix', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setPrefix', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * The node immediately preceding this node or null if there is no such node.
                 * @name Node#previousSibling
                 * @type {Node}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getPreviousSibling', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This attribute returns the text content of this node and its descendants. When it is defined to be null, setting it has no effect.
                 * @name Node#textContent
                 * @type {string}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if it's not possible to get or set the property value
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTextContent', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setTextContent', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

	            /**
	             * Returns the object type name (xml.Node)
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return TYPE;
                };

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.nodeName,
                        type: this.nodeType,
                        value: this.nodeValue,
                        textContent: this.textContent
                    };
                };
            }

            Node.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Document.
             * @class Document
             * @classDescription Encapsulation of W3C DOM Document
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Document(xmldoc)
            {
                var TYPE = 'xml.Document';

                checkArgs([xmldoc], ['xmldoc'], 'xml.Document');

                var _deleg = xmldoc;
                var _node = new Node(xmldoc);

                // Document members

                /**
                 * Attempts to adopt a node from another document to this document. If supported, it changes the ownerDocument
                 * of the source node, its children, as well as the attached attribute nodes if there are any. If the source
                 * node has a parent it is first removed from the child list of its parent.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.source the node to move into this document
                 * @return {Node} the adopted node, or null if this operation fails, such as when the source node comes from a different implementation
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be adopted for some reason
                 *
                 * @since 2015.2
                 */
                this.adoptNode = function adoptNode(options)
                {
                    var source = (options && options.hasOwnProperty('source')) ? options.source : options;
                    checkArgs([source], ['source'], 'Document.adoptNode');
                    assertNode(source, 'source');

                    var result = checkThenInvoke(_deleg, 'adoptNode', [source._gd()]);
                    return wrap(result);
                };

                /**
                 * Creates an attribute node of the given name.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @return {Attr} new attribute node object with name and attribute value set as expected and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 */
                this.createAttribute = function createAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name], ['name'], 'Node.createAttribute');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'createAttribute', [name]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates an attribute of the given qualified name and namespace URI.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to instantiate
                 * @param {string} options.value (optional) the value of the attribute; if omitted, the value of the attribute will be empty string
                 * @return {Attr} new attribute node object with name, attribute value, namespaceURI, prefix and localName set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be created
                 *
                 * @since 2015.2
                 */
                this.createAttributeNS = function createAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    result = new Attr(result);
                    if (value)
                    {
                        assertString(value, 'value');
                        result.value = value;
                    }
                    return result;
                };

                /**
                 * Creates a CDATASection node whose value is the specified string.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.data the data for the CDATASection contents
                 * @return {Node} the new CDATASection node
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the CDATASection node cannot be created
                 * 
                 * @since 2015.2
                 */
                this.createCDATASection = function createCDATASection(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createCDATASection');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createCDATASection', [data]);
                    return new Node(result);
                };

                /**
                 * Creates a Comment node given the specified string.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.data the data for the node
                 * @return {Node} the new Comment node
                 * 
                 * @since 2015.2
                 */
                this.createComment = function createComment(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createComment');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createComment', [data]);
                    return new Node(result);
                };

                /**
                 * Creates an empty DocumentFragment object.
                 * @governance none
                 * @return {Node} a new DocumentFragment
                 * 
                 * @since 2015.2
                 */
                this.createDocumentFragment = function createDocumentFragment()
                {
                    var result = checkThenInvoke(_deleg, 'createDocumentFragment', []);
                    return new Node(result);
                };

                /**
                 * Creates an element of the type specified.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.tagName the name of the element type to instantiate; for XML, this is case-sensitive
                 * @return {Element} a new Element object with the nodeName attribute set to tagName, and localName, prefix, and namespaceURI set to null
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 * 
                 * @since 2015.2
                 */
                this.createElement = function createElement(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.createElement');
                    assertString(tagName, 'tagName');

                    var result = checkThenInvoke(_deleg, 'createElement', [tagName]);
                    return new Element(result);
                };

                /**
                 * Creates an element of the given qualified name and namespace URI.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the element to create; can be null
                 * @param {string} options.qualifiedName the qualified name of the element type to instantiate
                 * @return {Element} a new Element object with the nodeName, localName, prefix, and namespaceURI set accordingly
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the Element node cannot be created
                 * 
                 * @since 2015.2
                 */
                this.createElementNS = function createElementNS(options)
                {
                    var namespaceURI = null, qualifiedName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                    }
                    checkArgs([qualifiedName], ['qualifiedName'], 'Document.createElementNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');

                    var result = checkThenInvoke(_deleg, 'createElementNS', [namespaceURI == null ? null : namespaceURI, qualifiedName]);
                    return new Element(result);
                };

                /**
                 * Creates a ProcessingInstruction node given the specified name and data strings.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.target the target part of the processing instruction
                 * @param {string} options.data the data for the node
                 * @return {Node} the new ProcessingInstruction object
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the ProcessingInstruction node cannot be created
                 *
                 * @since 2015.2
                 */
                this.createProcessingInstruction = function createProcessingInstruction(options)
                {
                    var target = null, data = null;

                    if (options && (options.hasOwnProperty('target') || options.hasOwnProperty('data')))
                    {
                        target = options.target;
                        data = options.data;
                    }
                    else
                    {
                        target = options;
                        data = arguments[1];
                    }
                    checkArgs([target, data], ['target', 'data'], 'Document.createProcessingInstruction');
                    assertString(target, 'target');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createProcessingInstruction', [target, data]);
                    return new Node(result);
                };

                /**
                 * Creates a Text node given the specified string.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.data the data for the node
                 * @return {Node} the new Text node
                 *
                 * @since 2015.2
                 */
                this.createTextNode = function createTextNode(options)
                {
                    var data = (options && options.hasOwnProperty('data')) ? options.data : options;
                    checkArgs([data], ['data'], 'Document.createTextNode');
                    assertString(data, 'data');

                    var result = checkThenInvoke(_deleg, 'createTextNode', [data]);
                    return new Node(result);
                };

                /**
                 * Returns the Element that has an ID attribute with the given value. If no such element exists, this returns null.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.elementId the unique id value for an element
                 * @return {Element} the matching Element or null if there is none
                 *
                 * @since 2015.2
                 */
                this.getElementById = function getElementById(options)
                {
                    var elementId = (options && options.hasOwnProperty('elementId')) ? options.elementId : options;
                    checkArgs([elementId], ['elementId'], 'Document.getElementById');
                    assertString(elementId, 'elementId');

                    var result = checkThenInvoke(_deleg, 'getElementById', [elementId]);
                    return new Element(result);
                };

                /**
                 * Returns an array of all the Elements with a given tag name in document order.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @return {Array<Element>} an array containing all the matched Elements
                 *
                 * @since 2015.2
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Document.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
                    for (var i = 0; i < elemsLength; i++)
                    {
                        result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns an array of all the Elements with a given local name and namespace URI in document order.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @return {Array<Element>} an array containing all the matched Elements
                 *
                 * @since 2015.2
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Document.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
                    var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
                    for (var i = 0; i < elemsLength; i++)
                    {
                        result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Imports a node from another document to this document, without altering or removing the source node from the original document;
                 * this method creates a new copy of the source node.
                 * @governance none
                 * @param {Object} options
                 * @param {Node} options.importedNode the node to import
                 * @param {boolean} options.deep if true, recursively import the subtree under the specified node; if false, import only the node itself, as explained above
                 * @return {Node} the imported node that belongs to this Document
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the node cannot be imported for some reason
                 *
                 * @since 2015.2
                 */
                this.importNode = function importNode(options)
                {
                    var importedNode = null, deep = null;

                    if (options && (options.hasOwnProperty('importedNode') || options.hasOwnProperty('deep')))
                    {
                        importedNode = options.importedNode;
                        deep = options.deep;
                    }
                    else
                    {
                        importedNode = options;
                        deep = arguments[1];
                    }
                    checkArgs([importedNode, deep], ['importedNode', 'deep'], 'Document.importNode');
                    assertNode(importedNode, 'importedNode');

                    var result = checkThenInvoke(_deleg, 'importNode', [importedNode._gd(), deep == true]);
                    return wrap(result);
                };

                /**
                 * The Document Type Declaration associated with this document.
                 * @name Document#doctype
                 * @type {Object}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'doctype', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDoctype', []);
                        if (result === null || result === undefined)
                            return null;
                        return new Node(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'doctype' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * This is a convenience attribute that allows direct access to the child node that is the document element of the document.
                 * @name Document#documentElement
                 * @type {Element}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'documentElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getDocumentElement', []);
                        return new Element(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'documentElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The location of the document or null if undefined.
                 * @name Document#documentURI
                 * @type {string}
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'documentURI', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getDocumentURI', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setDocumentURI', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying the encoding used for this document at the time of the parsing.
                 * @name Document#inputEncoding
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'inputEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getInputEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'inputEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the encoding of this document.
                 * @name Document#xmlEncoding
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'xmlEncoding', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlEncoding', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'xmlEncoding' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * An attribute specifying, as part of the XML declaration, whether this document is standalone. This is false when unspecified.
                 * @name Document#xmlStandalone
                 * @type {boolean}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'xmlStandalone', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlStandalone', []);
                    },
                    set: function (val)
                    {
                        checkThenInvoke(_deleg, 'setXmlStandalone', [val == true]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                /**
                 * An attribute specifying, as part of the XML declaration, the version number of this document.
                 * @name Document#xmlVersion
                 * @type {string}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the property cannot be set
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'xmlVersion', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getXmlVersion', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setXmlVersion', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    checkThenInvoke(_deleg, 'normalizeDocument', []);
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._asString = function _asString()
                {
                    return invoker(xmlApi, 'nlapiXMLToString', [_deleg]);
                };

                this._gd = function _gd()
                {
                    return _deleg;
                };

	            /**
	             * Returns the object type name (xml.Document)
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return TYPE;
                };

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Document.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Element.
             * @class Element
             * @classDescription Encapsulation of W3C DOM Element
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Element(xmlelem)
            {
                var TYPE = 'xml.Element';

                checkArgs([xmlelem], ['xmlelem'], 'xml.Element');

                var _deleg = xmlelem;
                var _node = new Node(xmlelem);

                // Element members

                /**
                 * Retrieves an attribute value by name.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute to retrieve
                 * @return {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 *
                 * @since 2015.2
                 */
                this.getAttribute = function getAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'getAttribute', [name]);
                };

                /**
                 * Retrieves an attribute node by name.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute to retrieve
                 * @return {Attr} the Attr node with the specified name or null if there is no such attribute
                 *
                 * @since 2015.2
                 */
                this.getAttributeNode = function getAttributeNode(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.getAttributeNode');
                    assertString(name, 'name');

                    var result = checkThenInvoke(_deleg, 'getAttributeNode', [name]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute node by local name and namespace URI.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @return {Attr} the Attr node with the specified attribute local name and namespace URI or null if there is no such attribute
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 *
                 * @since 2015.2
                 */
                this.getAttributeNodeNS = function getAttributeNodeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNodeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var result = checkThenInvoke(_deleg, 'getAttributeNodeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                    return wrap(result);
                };

                /**
                 * Retrieves an attribute value by local name and namespace URI.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to retrieve; can be null
                 * @param {string} options.localName the local name of the attribute to retrieve
                 * @return {string} the Attr value as a string, or the empty string if that attribute does not have a specified or default value
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be retrieved for some reason
                 *
                 * @since 2015.2
                 */
                this.getAttributeNS = function getAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.getAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'getAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Returns an array of all descendant Elements with a given tag name, in document order.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.tagName the name of the tag to match on; the special value "*" matches all tags; for XML, the tagName parameter is case-sensitive
                 * @return {Array<Element>} an array of matching Element nodes
                 *
                 * @since 2015.2
                 */
                this.getElementsByTagName = function getElementsByTagName(options)
                {
                    var tagName = (options && options.hasOwnProperty('tagName')) ? options.tagName : options;
                    checkArgs([tagName], ['tagName'], 'Element.getElementsByTagName');
                    assertString(tagName, 'tagName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagName', [tagName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
	                for (var i = 0; i < elemsLength; i++)
                    {
		                result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns an array of all descendant Elements with a given local name and namespace URI in document order.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the elements to match on; the special value "*" matches all namespaces
                 * @param {string} options.localName the local name of the elements to match on; the special value "*" matches all local names
                 * @return {Array<Element>} an array of matching Element nodes
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the elements cannot be retrieved for some reason
                 *
                 * @since 2015.2
                 */
                this.getElementsByTagNameNS = function getElementsByTagNameNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([namespaceURI, localName], ['namespaceURI', 'localName'], 'Element.getElementsByTagNameNS');
                    assertString(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    var elems = checkThenInvoke(_deleg, 'getElementsByTagNameNS', [namespaceURI, localName]);
	                var elemsLength = elems.length || checkThenInvoke(elems, 'getLength', []);
                    var result = [];
	                for (var i = 0; i < elemsLength; i++)
                    {
		                result.push(new Element(checkThenInvoke(elems, 'item', [i])));
                    }
                    return result;
                };

                /**
                 * Returns true when an attribute with a given name is specified on this element or has a default value, false otherwise.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute to look for
                 * @return {boolean} true if an attribute with the given name is specified on this element or has a default value, false otherwise
                 *
                 * @since 2015.2
                 */
                this.hasAttribute = function hasAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.hasAttribute');
                    assertString(name, 'name');

                    return checkThenInvoke(_deleg, 'hasAttribute', [name]);
                };

                /**
                 * Returns true when an attribute with a given local name and namespace URI is specified on this element or has a default value, false otherwise.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to look for; can be null
                 * @param {string} options.localName the local name of the attribute to look for
                 * @return {boolean} true if an attribute with the given local name and namespace URI is specified or has a default value on this element, false otherwise
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the command cannot be performed for some reason
                 *
                 * @since 2015.2
                 */
                this.hasAttributeNS = function hasAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.hasAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    return checkThenInvoke(_deleg, 'hasAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Removes an attribute by name.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute to remove
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 *
                 * @since 2015.2
                 */
                this.removeAttribute = function removeAttribute(options)
                {
                    var name = (options && options.hasOwnProperty('name')) ? options.name : options;
                    checkArgs([name], ['name'], 'Element.removeAttribute');
                    assertString(name, 'name');

                    checkThenInvoke(_deleg, 'removeAttribute', [name]);
                };

                /**
                 * Removes the specified attribute node.
                 * @governance none
                 * @param {Object} options
                 * @param {Attr} options.oldAttr the Attr node to remove from the attribute list
                 * @return {Attr} the Attr node that was removed
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 *
                 * @since 2015.2
                 */
                this.removeAttributeNode = function removeAttributeNode(options)
                {
                    var oldAttr = (options && options.hasOwnProperty('oldAttr')) ? options.oldAttr : options;
                    checkArgs([oldAttr], ['oldAttr'], 'Element.removeAttributeNode');
                    assertNode(oldAttr, 'oldAttr');

                    var result = checkThenInvoke(_deleg, 'removeAttributeNode', [oldAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Removes an attribute by local name and namespace URI.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to remove; can be null
                 * @param {string} options.localName the local name of the attribute to remove
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be removed for some reason
                 *
                 * @since 2015.2
                 */
                this.removeAttributeNS = function removeAttributeNS(options)
                {
                    var namespaceURI = null, localName = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('localName')))
                    {
                        namespaceURI = options.namespaceURI;
                        localName = options.localName;
                    }
                    else
                    {
                        namespaceURI = options;
                        localName = arguments[1];
                    }
                    checkArgs([localName], ['localName'], 'Element.removeAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(localName, 'localName');

                    checkThenInvoke(_deleg, 'removeAttributeNS', [namespaceURI == null ? null : namespaceURI, localName]);
                };

                /**
                 * Adds a new attribute. If an attribute with that name is already present in the element, its value is changed to be that of the value parameter.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name the name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 *
                 * @since 2015.2
                 */
                this.setAttribute = function setAttribute(options)
                {
                    var name = null, value = null;

                    if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
                    {
                        name = options.name;
                        value = options.value;
                    }
                    else
                    {
                        name = options;
                        value = arguments[1];
                    }
                    checkArgs([name, value], ['name', 'value'], 'Element.setAttribute');
                    assertString(name, 'name');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttribute', [name, value]);
                };

                /**
                 * Adds a new attribute node. If an attribute with that name is already present in the element, it is replaced by the new one.
                 * @governance none
                 * @param {Object} options
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @return {Attr} if the newAttr attribute replaces an existing attribute, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 *
                 * @since 2015.2
                 */
                this.setAttributeNode = function setAttributeNode(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNode');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNode', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute node. If an attribute with that local name and that namespace URI is already present in the element, it is replaced by the new one.
                 * @governance none
                 * @param {Object} options
                 * @param {Attr} options.newAttr the Attr node to add to the attribute list
                 * @return {Attr} if the newAttr attribute replaces an existing attribute with the same local name and namespace URI, the replaced Attr node is returned, otherwise null is returned
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 *
                 * @since 2015.2
                 */
                this.setAttributeNodeNS = function setAttributeNodeNS(options)
                {
                    var newAttr = (options && options.hasOwnProperty('newAttr')) ? options.newAttr : options;
                    checkArgs([newAttr], ['newAttr'], 'Element.setAttributeNodeNS');
                    assertNode(newAttr, 'newAttr');

                    var result = checkThenInvoke(_deleg, 'setAttributeNodeNS', [newAttr._gd()]);
                    return wrap(result);
                };

                /**
                 * Adds a new attribute. If an attribute with the same local name and namespace URI is already present on the element, its prefix is changed
                 * to be the prefix part of the qualifiedName, and its value is changed to be the value parameter.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.namespaceURI the namespace URI of the attribute to create or alter; can be null
                 * @param {string} options.qualifiedName the qualified name of the attribute to create or alter
                 * @param {string} options.value value to set in string form
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the attribute cannot be added for some reason
                 *
                 * @since 2015.2
                 */
                this.setAttributeNS = function setAttributeNS(options)
                {
                    var namespaceURI = null, qualifiedName = null, value = null;

                    if (options && (options.hasOwnProperty('namespaceURI') || options.hasOwnProperty('qualifiedName') || options.hasOwnProperty('value')))
                    {
                        namespaceURI = options.namespaceURI;
                        qualifiedName = options.qualifiedName;
                        value = options.value;
                    }
                    else
                    {
                        namespaceURI = options;
                        qualifiedName = arguments[1];
                        value = arguments[2];
                    }
                    checkArgs([qualifiedName, value], ['qualifiedName', 'value'], 'Element.setAttributeNS');
                    assertStringNullable(namespaceURI, 'namespaceURI');
                    assertString(qualifiedName, 'qualifiedName');
                    assertString(value, 'value');

                    return checkThenInvoke(_deleg, 'setAttributeNS', [namespaceURI == null ? null : namespaceURI, qualifiedName, value]);
                };

                /**
                 * The name of the element.
                 * @name Element#tagName
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'tagName', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getTagName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'tagName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Members inherited from Node

                this.appendChild = function appendChild(options)
                {
                    return _node.appendChild(options);
                };

                this.cloneNode = function cloneNode(options)
                {
                    return _node.cloneNode(options);
                };

                this.compareDocumentPosition = function compareDocumentPosition(options)
                {
                    return _node.compareDocumentPosition(options);
                };

                this.hasAttributes = function hasAttributes()
                {
                    return _node.hasAttributes();
                };

                this.hasChildNodes = function hasChildNodes()
                {
                    return _node.hasChildNodes();
                };

                this.insertBefore = function insertBefore()
                {
                    return _node.insertBefore.apply(_node, arguments);
                };

                this.isDefaultNamespace = function isDefaultNamespace(options)
                {
                    return _node.isDefaultNamespace(options);
                };

                this.isEqualNode = function isEqualNode(options)
                {
                    return _node.isEqualNode(options);
                };

                this.isSameNode = function isSameNode(options)
                {
                    return _node.isSameNode(options);
                };

                this.lookupNamespaceURI = function lookupNamespaceURI(options)
                {
                    return _node.lookupNamespaceURI(options);
                };

                this.lookupPrefix = function lookupPrefix(options)
                {
                    return _node.lookupPrefix(options);
                };

                this.normalize = function normalize()
                {
                    _node.normalize();
                };

                this.removeChild = function removeChild(options)
                {
                    return _node.removeChild(options);
                };

                this.replaceChild = function replaceChild()
                {
                    return _node.replaceChild.apply(_node, arguments);
                };

                Object.defineProperty(this, 'attributes', {
                    get: function ()
                    {
                        return _node.attributes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'attributes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'baseURI', {
                    get: function ()
                    {
                        return _node.baseURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'baseURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'childNodes', {
                    get: function ()
                    {
                        return _node.childNodes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'childNodes' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'firstChild', {
                    get: function ()
                    {
                        return _node.firstChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'firstChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'lastChild', {
                    get: function ()
                    {
                        return _node.lastChild;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'lastChild' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'localName', {
                    get: function ()
                    {
                        return _node.localName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'localName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'namespaceURI', {
                    get: function ()
                    {
                        return _node.namespaceURI;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'namespaceURI' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nextSibling', {
                    get: function ()
                    {
                        return _node.nextSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nextSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeName', {
                    get: function ()
                    {
                        return _node.nodeName;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeName' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeType', {
                    get: function ()
                    {
                        return _node.nodeType;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nodeType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'nodeValue', {
                    get: function ()
                    {
                        return _node.nodeValue;
                    },
                    set: function (val)
                    {
                        _node.nodeValue = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'ownerDocument', {
                    get: function ()
                    {
                        return _node.ownerDocument;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerDocument' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'parentNode', {
                    get: function ()
                    {
                        return _node.parentNode;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parentNode' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'prefix', {
                    get: function ()
                    {
                        return _node.prefix;
                    },
                    set: function (val)
                    {
                        _node.prefix = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                Object.defineProperty(this, 'previousSibling', {
                    get: function ()
                    {
                        return _node.previousSibling;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'previousSibling' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                Object.defineProperty(this, 'textContent', {
                    get: function ()
                    {
                        return _node.textContent;
                    },
                    set: function (val)
                    {
                        _node.textContent = val;
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

	            /**
	             * Returns the object type name (xml.Element)
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return TYPE;
                };

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return _node.toJSON();
                };
            }

            Element.prototype = nsobject.getNewInstance();

            /**
             * Return a new instance of XML Attr.
             * @class Attr
             * @classDescription Encapsulation of W3C DOM Attr
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Attr(xmlattr)
            {
                var TYPE = 'xml.Attr';

                checkArgs([xmlattr], ['xmlattr'], 'xml.Attr');

                var _deleg = xmlattr;

                // Attr members

                /**
                 * Returns the name of this attribute. If Node.localName is different from null, this property is a qualified name.
                 * @name Attr#name
                 * @type {string}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getName', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The Element node this attribute is attached to or null if this attribute is not in use.
                 * @name Attr#ownerElement
                 * @type {Element}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'ownerElement', {
                    get: function ()
                    {
                        var result = checkThenInvoke(_deleg, 'getOwnerElement', []);
                        return wrap(result);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ownerElement' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * True if this attribute was explicitly given a value in the instance document, false otherwise.
                 * @name Attr#specified
                 * @type {boolean}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'specified', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getSpecified', []);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'specified' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The attribute value. On retrieval, the value of the attribute is returned as a string. Character and general entity
                 * references are replaced with their values. On setting, this creates a Text node with the unparsed contents of the string,
                 * i.e. any characters that an XML processor would recognize as markup are instead treated as literal text.
                 * @name Attr#value
                 * @type {string}
                 * @throws {SuiteScriptError} SSS_XML_DOM_EXCEPTION if the value cannot be set for some reason
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'value', {
                    get: function ()
                    {
                        return checkThenInvoke(_deleg, 'getValue', []);
                    },
                    set: function (val)
                    {
                        assertString(val, 'value');
                        checkThenInvoke(_deleg, 'setValue', [val]);
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: true
                });

                // Other members

                this._gd = function _gd()
                {
                    return _deleg;
                };

	            /**
	             * Returns the object type name (xml.Attr)
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return TYPE;
                };

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        name: this.name,
                        ownerElement: this.ownerElement,
                        specified: this.specified,
                        value: this.value
                    };
                };
            }

            Attr.prototype = nsobject.getNewInstance();

            //====== Utility functions (to be replaced by util module when available) ====

            function assertString(arg, argName)
            {
                if (!isString(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'string' );
            }

            function assertStringNullable(arg, argName)
            {
                if (arg != null)
                    assertString(arg, argName);
            }

            function assertNode(arg, argName)
            {
                if (!isNode(arg))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, argName,'xml.Node or subclass' );
            }

            function assertNodeNullable(arg, argName)
            {
                if (arg != null)
                    assertNode(arg, argName);
            }

            function isString(obj)
            {
                return Object.prototype.toString.call(obj) === '[object String]';
            }

            function isNode(obj)
            {
                return obj instanceof Node || obj instanceof Element || obj instanceof Attr || obj instanceof Document;
            }

            function checkArgs(funcArgs, funcArgNames, funcName)
            {
                for (var i = 0; i < funcArgs.length; i++)
                    if (funcArgs[i] == null) // also catches 'undefined'
                        utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, (funcName ? funcName + ': ' : ''),funcArgNames[i] );
            }

            function wrap(node)
            {
                if (!node)
                    return node; // do nothing

                switch (node.nodeType || checkThenInvoke(node, 'getNodeType', []))
                {
                    case 1:
                        return new Element(node);
                    case 2:
                        return new Attr(node);
                    case 9:
                        return new Document(node);
                    default:
                        return new Node(node);
                }
            }

            //========================================================================

            function escape(options)
            {
                var xmlText = (options && options.hasOwnProperty('xmlText')) ? options.xmlText : options;
                checkArgs([xmlText], ['xmlText'], 'escape');
                assertString(xmlText, 'xmlText');

                return xmlText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&apos;').replace(/"/g, '&quot;');
            }

            function validate(options)
            {
                var xml = null, xsdFilePathOrId = null, importFolderPathOrId = null;

                if (options && (options.hasOwnProperty('xml') || options.hasOwnProperty('xsdFilePathOrId') || options.hasOwnProperty('importFolderPathOrId')))
                {
                    xml = options.xml;
                    xsdFilePathOrId = options.xsdFilePathOrId;
                    importFolderPathOrId = options.importFolderPathOrId;
                }
                else
                {
                    xml = options;
                    xsdFilePathOrId = arguments[1];
                    importFolderPathOrId = arguments[2];
                }
                checkArgs([xml, xsdFilePathOrId], ['xml', 'xsdFilePathOrId'], 'validate');
                assertNode(xml, 'xml');

                var schema = utilityFunctions.getFcFileContent(xsdFilePathOrId);
                var schemaDoc = this.Parser.fromString(schema);

                invoker(xmlApi, 'nlapiValidateXML', [xml._gd(), schemaDoc._gd(), importFolderPathOrId != null ? importFolderPathOrId : null]);
            }

            //========================================================================

            return Object.freeze({
                /**
                 * Prepares a String for use in XML by escaping XML markup (for example, angle brackets, quotation marks, and ampersands).
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.xmlText the XML text to be escaped
                 * @return {string} the escaped XML
                 *
                 * @since 2015.2
                 */
                escape: escape,

                /**
                 * Validates a supplied XML document against a supplied XML Schema (XSD Document).
                 * @governance none
                 * @param {Object} options
                 * @param {Document} options.xml the XML document object
                 * @param {number|string} options.xsdFilePathOrId ID or path to the XSD file to validate the XML object against
                 * @param {number|string} options.importFolderPathOrId (optional) ID or path to a folder in the file cabinet containing additional XSD schemas which are imported by the parent XSD provided via "xsdFilePathOrId"
                 * @throws {SuiteScriptError} SSS_XML_DOES_NOT_CONFORM_TO_SCHEMA if XML provided is invalid with respect to the provided schema
                 * @throws {SuiteScriptError} SSS_INVALID_XML_SCHEMA_OR_DEPENDENCY if schema is an incorrectly structured XSD, or a dependent schema could not be found
                 * @return {void}
                 *
                 * @since 2015.2
                 */
                validate: validate,

                /**
                 * XML Parser Object
                 *
                 * @type {Parser}
                 */
                Parser: new Parser(),

                /**
                 * XPath Query Object
                 *
                 * @type {XPath}
                 */
                XPath: new XPath(),

                /**
                 * @enum {string}
                 * @readonly
                 */
                NodeType: NODE_TYPES_ENUM
            });
        });

/**
 * This file is an alias for SystemScripts - NLCommonScripts.getCurrencyFunctions(null)
 *
 * @private
 * @module N/util/currencyUtility
 */
define('N/util/currencyUtility',['N/utilityFunctions'],
	function(utilityFunctions){
		/* imports */
	   /**
		* @alias CURRENCY2_AND_RATE_PRECISION (NLCurrencyUtil.java)
		*/
		var CURRENCY2_AND_RATE_PRECISION = 8;

		/**
		 * @alias getDefaultCurrencyPrecision (NLCurrencyUtil.java)
		 */
		function getDefaultCurrencyPrecision()
		{
			return 2;
		}

		/**
		 * @alias dollars_string (NLAppUtil.jsp)
		 *
		 */
		function dollars_string(amount)
		{
			var temp = amount;
			var DigitStrings = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
			var TeenStrings = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eightteen', 'nineteen'];
			var DecadeStrings = ['zero', 'ten', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
			var result = '';
			if (temp >= 1000)
			{
				result = result + dollars_string(Math.floor(temp/1000)) + 'thousand ';
				temp = temp % 1000;
			}
			if (temp >= 100)
			{
				result = result + DigitStrings[Math.floor(temp/100)] + ' hundred ';
				temp = temp % 100;
			}
			if (temp >= 20)
			{
				result = result + DecadeStrings[Math.floor(temp/10)] + ' ';
				temp = temp % 10;
			}
			if (temp >= 10)
			{
				result = result + TeenStrings[Math.floor(temp-10)] + ' ';
			}
			else if ((amount == 0) || (temp > 0))
			{
				result = result + DigitStrings[Math.floor(temp)] + ' ';
			}
			return result;
		}

		function amount_string(amount)
		{
			var cents = Math.floor((amount-Math.floor(amount))*100+0.5);
			var centstring = (cents < 10) ? '0'+cents.toString() : cents.toString();
			var dollarstring = dollars_string(Math.floor(amount));
			return dollarstring.charAt(0).toUpperCase() + dollarstring.substr(1) + 'and ' + centstring + '/100';
		}


		function format_rate(a,p, recordContext)
		{
			var s;
			var cs;
			var n;
			var returnMe;
			if (isNaN(parseFloat(a)))
			{
				returnMe= '';
			}
			else
			{
				var precision = get_precision(recordContext);

				if (precision>1 || p) /*precision is 2 or its a % */
				{
					s=(a<0);
					if (s) a=-a;
					var d=Math.floor(a);
					var c=Math.floor((a-d)*(p?10:100)+0.5);

					if (a == d+c/(p?10:100))
					{
						if (c==(p?10:100))
						{
							d++;
							c=0;
						}
						cs=p?c.toString():((c < 10)?'0'+c.toString():c.toString());
						returnMe = (s?'-':'')+d.toString()+'.'+cs+(p?'%':'');
					}
					else
						returnMe = (s?'-':'')+a+(p?'%':'');
				}
				else if (precision === 1)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==-1) cs = cs.toString() + '.0';
					else if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.toString() + '0' ;
					returnMe = (s?'-':'') + cs ;
				}
				else if (precision === 0)
				{
					s=(a<0);
					if (s) a=-a;
					cs = a.toString();
					n = cs.indexOf('.');
					if (n==0) cs = '0.' + cs.toString() ;
					else if (n==cs.length-1) cs = cs.substring(0, cs.length-2);
					returnMe = (s?'-':'') + cs ;
				}
			}
			return returnMe;
		}

		// Cannot assume that nlapiGetFieldValue is accessible to all.
		// Protect from JS errors, and assume the USD default (2 decimal places) if no value is specified
		function getCurrencyPrecisionFieldValue(recordContext)
		{
			var precision = 2;
			if (!!recordContext)
			{
				precision = recordContext.getFieldValue('currencyprecision');
			}
			else if (typeof nlapiGetFieldValue === "function")
			{
				precision = nlapiGetFieldValue('currencyprecision');
			}

			return precision;
		}

		/*
		The 38 bit oracle representation for floating point numbers does things differently than
		the IEEE754 Spec that is used for floating point math in Java/JavaScript.  In Java/Javascript

		233 * .075 = 17.474999999999998

		In Oracle

		233 * .075 = 17.475

		To fix this so that both values will be the same, we first round to 5 decimal places
		(agreed upon) internal representation.  And then round to the two decimal places that
		we present to the user.

		Extending the above to round to either 0,1 or 2 places of decimal
		WARNING !!! This works for rounding to 0, 1, 2 places of decimal only
		 */
		function get_precision(recordContext)
		{
			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var precision = getDefaultCurrencyPrecision();
			if (cp != null)
			{
				var tprecision = parseFloat(cp.value);
				if (!isNaN(tprecision))
				{
					precision=tprecision;
				}
			}
			return precision;
		}

		function round_currency(amount, numofdecimals, method, recordContext)
		{
			var precision = numofdecimals;
			// Try reloading the precision if it wasnt passed in
			if ( precision == null )
				precision = get_precision(recordContext);
			var amountStr = amount + '';
			if ( amount > 1E10 && amountStr.indexOf('.') >= 0 && (amountStr.length - amountStr.indexOf('.') - 1 <= precision) ) //if it's already rounded, just return, don't go through the IEEE754 business
				return amount;
			var b = Math.abs(amount);// Take the abs, sign will be restored afterwards, this makes the rounding independant of sign

			// Round to five places (this is for the IEEE754 business described above)
			// Note we use Math.floor instead of Math.round to avoid problems switching from int to float.
			// This caused problems in the Safari browser, but didn't seem to affect IE.
			// See Bugs 65624 and 66338 - RGrisso, 4/1/04
			b = Math.floor((b * 100000.0)+0.5) / 100000.0 + 0.000001;

			// the + 0.000001 rounds up anything that's significant enough to affect the next rounding pass e.g. ####.459999999 (in binary)
			// e.g. a = 139.825

			// And now Round to the correct places
			var factor = Math.pow(10,precision);
			if (!method || method =='OFF') b = Math.floor((b * factor)+0.5) / factor;
			else if (method == 'UP')   b = Math.round(Math.ceil(Math.abs(amount) * factor)) / factor;
			else if (method == 'DOWN') b = Math.round(Math.floor(Math.abs(amount) * factor)) / factor;
			// return the sign
			b = b * (amount >= 0.0 ? 1.0 : -1.0);
			if( b === 0.0 )
				return 0.0;
			return b;
		}

		// Round to 8 decimal places
		function round_float(a)
		{
			return round_float_to_n_places(a,8);
		}

		// Round to n decimal places
		function round_float_to_n_places(a,n)
		{  // Take the abs, sign will be restored afterwards, this makes the rounding independant of sign
			var str = a + '';
			if(str.indexOf('.') < 0) // if it's an integer, just return
				return a;
			if(str.length-str.indexOf('.')-1 <= n) // if the decimal digits length after decimal point is less than the targeted precistion, just return
				return a;
			var b = Math.abs(a);
			b = b + 0.00000000000001; //SMALLER_NUMBER See NLRounding.round();
			var factor = Math.pow(10,n);
			b = Math.floor((b * factor)+0.5) / factor;
			// return the sign
			b = b * (a >= 0.0 ? 1.0 : -1.0);
			if( b == 0.0 )
				return 0.0;
			return b;
		}

		function pad_to_atleast_two_decimal_places(a)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if(n === -1)
				{
					s = s + '.00';
				}
				else if(n === s.length-1)
				{
					s = s + '00';
				}
				else if(n === s.length-2)
				{
					s = s + '0';
				}
				if (n === 0)
				{
					s = '0' + s;
				}
			}
			return s;
		}

		function pad_decimal_places(a, noOfDecimalPlaces)
		{
			var s;
			if(a == null)
			{
				s = '';
			}
			else
			{
				s = a.toString();
				var n = s.indexOf('.');
				if (noOfDecimalPlaces === 0)
				{
					if(a == 0.0)
					{
						s = '0';
					}
					else if(n > -1)
					{
						s = s.substring(0, n) ;
					}
				}
				else if (noOfDecimalPlaces ===1)
				{
					if(n == -1)
					{
						s = s + '.0';
					}
					else if(n == s.length-1)
					{
						s = s + '0';
					}
					else if (n == 0)
					{
						s = '0' + s;
					}
				}
				else
				{
					if(n == -1)
					{
						s = s + '.00';
					}
					else if(n == s.length-1)
					{
						s = s + '00';
					}
					else if(n == s.length-2)
					{
						s = s + '0';
					}
					if (n == 0)
					{
						s = '0' + s;
					}
				}
			}
			return s;
		}

		/**
		 *
		 * algorithm used should yield the same result as NLCurrency.Round...
		 * we should keep them consistent. There is now an additional param
		 * which will not attempt to round to 2 sig figures. All it does is
		 * to just add zeros at the end if it needs it. This is used for
		 * billing rates such as $0.4565 per gallon of paint and such.

		 * This method should optionally round the number passed in and then
		 * truncate it two digits past the decimal
		 */
		function format_currency(a, bDoNotRound, recordContext)
		{
			if(isNaN(a))
				return '';

			var cp = getCurrencyPrecisionFieldValue(recordContext);
			var noOfDecimalPlaces = getDefaultCurrencyPrecision();
			if (cp !== null)
			{
				noOfDecimalPlaces = parseFloat(cp);
				if (isNaN(noOfDecimalPlaces))
				{
					noOfDecimalPlaces = getDefaultCurrencyPrecision();
				}
			}
			var returnMe;
			if( !(bDoNotRound == true))   //This mess is necessary so that when do not round is not set it evaluates correctly
			{
				returnMe = round_currency(a, noOfDecimalPlaces);
			}
			else
			{
				returnMe = a;
			}
			returnMe = pad_decimal_places(returnMe, noOfDecimalPlaces);
			return returnMe;
		}

		//Use this for rounding Currency2
		function format_currency2(n, recordContext)
		{
			if(isNaN(n))
			{
				return '';
			}
			var returnMe;
			if( (n+'').indexOf('.') < 0 ) // if it's an integer, don't even try to do the rounding
				returnMe = n;
			else
				returnMe = round_float_to_n_places(n,CURRENCY2_AND_RATE_PRECISION);
			var precision = get_precision(recordContext);
			if (precision === 2) { //We pad zeros only if the precision on the currency is 2 (standard). For everything else, we show howsoevermany places you entered.
				returnMe = pad_to_atleast_two_decimal_places(returnMe);
			}

			return returnMe;
		}

		function format_percent(p) {
			if(typeof p == 'string')
				p = parseFloat(p);
			return p + ( p === Math.floor(p) ? '.0%' : '%');
		}

		function process_currency_field_value(value, fieldType, recordContext) {
			if (!fieldType || fieldType.indexOf('currency') == -1)
				return value;
			if (utilityFunctions.isValEmpty(value) || ('' + value).indexOf('.') != -1 || isNaN(parseFloat(value)))
				return value;
			var precision = fieldType.indexOf('currency2') >= 0 ? 2 : get_precision(recordContext);
			return pad_decimal_places('' + value, precision);
		}

		/* assign util.currency package */
		return Object.freeze({
			amount_string: amount_string,
			format_percent: format_percent,
			format_rate: format_rate,
			format_currency: format_currency,
			format_currency2: format_currency2,
			get_precision: get_precision,
			pad_decimal_places: pad_decimal_places,
			pad_to_atleast_two_decimal_places: pad_to_atleast_two_decimal_places,
			process_currency_field_value: process_currency_field_value,
			round_currency: round_currency,
			round_float: round_float,
			round_float_to_n_places: round_float_to_n_places
		});
	}
);

/**
 * @private
 */
define('N/restricted/fieldValidationHelperApi',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'fieldValidationHelperApi'}, reflet); });
/**
 * SuiteScript module
 *
 * @private
 * @module N/FieldValidationHelper
 * @NApiVersion 2.x
 */
define('N/FieldValidationHelper',['N/internal/invoker', 'N/restricted/fieldValidationHelperApi', 'N/dynamicData'], function(invoker, bridge, dynamicData){

	var weekStart = null;
	var dateFormat = null;
	var userfacingDateFormat = null;
	var longDateFormat = null;
	var timeFormat = null;
	var timeformatWithSeconds = null;
	var decimalSeparator = null;
	var groupSeparator = null;
	var negativePrefix = null;
	var negativeSuffix = null;
	var numberBlacklistRegex = null;
	var datetimeAmString = null;
	var datetimePmString = null;
	var datetimeShortMonths = null;
	var dateTimeMonths = null;
	var phoneFormat = null;

	function getDynamic(type)
	{
		var data = dynamicData.get("fieldValidationHelper");
		return data && data[type];
	}

	return Object.freeze({
		get weekstart()
		{
			if (weekStart === null)
			{
				weekStart = getDynamic("weekstart") || invoker(bridge, 'getWeekStart', []);
			}
			return weekStart;
		},
		get dateformat()
		{
			if (dateFormat === null)
			{
				dateFormat = getDynamic("dateformat") || invoker(bridge, 'getDateFormat', []);
			}
			return dateFormat;
		},
		get userfacing_dateformat()
		{
			if (userfacingDateFormat === null)
			{
				userfacingDateFormat = getDynamic("userfacing_dateformat") || invoker(bridge, 'getUserFacingDateFormat', []);
			}
			return userfacingDateFormat;
		},
		get longdateformat()
		{
			if (longDateFormat === null)
			{
				longDateFormat = getDynamic("longdateformat") || invoker(bridge, 'getLongDateFormat', []);
			}
			return longDateFormat;
		},
		get timeformat()
		{
			if (timeFormat === null)
			{
				timeFormat = getDynamic("timeformat") || invoker(bridge, 'getTimeFormat', []);
			}
			return timeFormat;
		},
		get timeformatwithseconds()
		{
			if (timeformatWithSeconds === null)
			{
				timeformatWithSeconds = getDynamic("timeformatwithseconds") || invoker(bridge, 'getTimeFormatWithSeconds', []);
			}
			return timeformatWithSeconds;
		},
		get decimalseparator()
		{
			if (decimalSeparator === null)
			{
				decimalSeparator = getDynamic("decimalseparator") || invoker(bridge, 'getDecimalSeparator', []);
			}
			return decimalSeparator;
		},
		get groupseparator()
		{
			if (groupSeparator === null)
			{
				groupSeparator = getDynamic("groupseparator") || invoker(bridge, 'getGroupSeparator', []);
			}
			return groupSeparator;
		},
		get negativeprefix()
		{
			if (negativePrefix === null)
			{
				negativePrefix = getDynamic("negativeprefix") || invoker(bridge, 'getNegativePrefix', []);
			}
			return negativePrefix;
		},
		get negativesuffix()
		{
			if (negativeSuffix === null)
			{
				negativeSuffix = getDynamic("negativesuffix") || invoker(bridge, 'getNegativeSuffix', []);
			}
			return negativeSuffix;
		},
		get number_blacklist_regex()
		{
			if (numberBlacklistRegex === null)
			{
				numberBlacklistRegex = new RegExp('[^' + (getDynamic("number_blacklist_regex") || invoker(bridge, 'getNumberBlacklistRegex', [])) + ']','g');
			}
			return numberBlacklistRegex;
		},
		get datetime_am_string()
		{
			if (datetimeAmString === null)
			{
				datetimeAmString = getDynamic("datetime_am_string") || invoker(bridge, 'getDateTimeAmString', []);
			}
			return datetimeAmString;
		},
		get datetime_pm_string()
		{
			if (datetimePmString === null)
			{
				datetimePmString = getDynamic("datetime_pm_string") || invoker(bridge, 'getDateTimePmString', []);
			}
			return datetimePmString;

		},
		get datetime_short_months()
		{
			if (datetimeShortMonths === null)
			{
				datetimeShortMonths = getDynamic("datetime_short_months") || invoker(bridge, 'getDateTimeShortMonths', []);
			}
			return datetimeShortMonths;

		},
		get datetime_months()
		{
			if (dateTimeMonths === null)
			{
				dateTimeMonths = getDynamic("datetime_months") || invoker(bridge, 'getDateTimeMonths', []);
			}
			return dateTimeMonths;
		},
		get phoneformat()
		{
			if (phoneFormat === null)
			{
				phoneFormat = getDynamic("phoneformat") || invoker(bridge, 'getPhoneFormat', []);
				if (phoneFormat === "" || phoneFormat === null)
					phoneFormat = undefined;
			}
			return phoneFormat;
		}
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/util/date
 * @suiteScriptVersion 2.x
 */
define( 'N/util/date',['N/FieldValidationHelper'],
	function(FieldValidationHelper){
		var MONTHLENGTH = [[31,28,31,30,31,30,31,31,30,31,30,31],[31,29,31,30,31,30,31,31,30,31,30,31]];
		var OLDEST_VALID_DATE = new Date(1601, 3, 1); // Via Issue 139785, Any date before 4/1/1601 is invalid
		var yearCharCN = "å¹´";
		var monthCharCN = "æ";
		var dayCharCN = "æ¥";
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX = /^(\d+)(\D)(\d+)((\D)(\d+))?\s*([aApP][mM])?/;
		var TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX = /^([aApP][mM])(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;
		var TIME_FORMAT_WITH_ASIAN_FORMATTING	  = /^(\d+)(\D)(\d+)(\D)((\d+)(\D))?/;

		var oracleDateTimeFormatter;

		function getOracleDateTimeFormatter()
		{
			if (!oracleDateTimeFormatter)
			{
				oracleDateTimeFormatter = new OracleDateTimeFormatter(
					FieldValidationHelper,
					{
						getJapaneseImperialEra: getJapaneseImperialEra,
						getShortJapaneseImperialEra: getShortJapaneseImperialEra,
						getJapaneseImperialYear: getJapaneseImperialYear
					}
				);
			}
			return oracleDateTimeFormatter;
		}

        function getMonthIndexFromArray(array, val, ignorecase)
        {
            for ( var i = 0; array != null && i < array.length; i++ )
                if ( val == array[i] || (ignorecase && val != null && array[i] != null && val.toLowerCase() == array[i].toLowerCase()) )
                    return i;
            return -1;
        }

		/**
		 *
		 * @alias nlGetFullYear
		 *
		 * @param {*} d
		 * @returns {*}
		 */
		function getFullYear(d)
		{
			if (typeof window !== 'undefined' && window.navigator != null && window.navigator.appName == "Netscape")
			{
				if (!d.getFullYear)
					return d.getYear();
			}
			return d.getFullYear();
		}

		var reiwaStartDate = new Date(2019, 4, 1);
		var heiseiStartDate = new Date(1989,0,8);
		var showaStartDate = new Date(1926,11,25);
		var taishoStartDate = new Date(1912,6,30);
		var meijiStartDate = new Date(1868,8,8);
		function getJapaneseImperialEra(d)
		{
			if (d >= reiwaStartDate)
				return "ä»¤å";
			else if (d >= heiseiStartDate)
				return "å¹³æ";
			else if(d >= showaStartDate)
				return "æ­å";
			else if(d >= taishoStartDate)
				return "å¤§æ­£";
			else
				return "ææ²»";
		}
		function getShortJapaneseImperialEra(d)
		{
			if (d >= reiwaStartDate)
				return "R";
			else if (d >= heiseiStartDate)
				return "H";
			else if(d >= showaStartDate)
				return "S";
			else if(d >= taishoStartDate)
				return "D";
			else
				return "M";
		}
		function getJapaneseImperialYear(d)
		{
			if (d >= reiwaStartDate)
				return getFullYear(d) - 2018;
			else if (d >= heiseiStartDate)
				return getFullYear(d) - 1988;
			else if(d >= showaStartDate)
				return getFullYear(d) - 1925;
			else if(d >= taishoStartDate)
				return getFullYear(d) - 1911;
			else
				return getFullYear(d) - 1867;
		}
		function getGregorianYear(japaneseImperialYear, era)
		{
			if (era === "ä»¤å" || era === "R")
				return japaneseImperialYear + 2018;
			else if(era === "å¹³æ" || era === "H")
				return japaneseImperialYear + 1988;
			else if(era === "æ­å" || era === "S")
				return japaneseImperialYear + 1925;
			else if(era === "å¤§æ­£" || era === "D")
				return japaneseImperialYear + 1911;
			else
				return japaneseImperialYear + 1867;
		}
	
		function getMonthIndex(sMonth)
		{
			var m = -1;
			sMonth = sMonth.toUpperCase()
			for ( var i=0; i < FieldValidationHelper.datetime_short_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_short_months[i].toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
			if(m !== -1)
				return m;
			for ( var i=0; i < FieldValidationHelper.datetime_months.length; i++ )
			{
				if ( FieldValidationHelper.datetime_months[i].toUpperCase() === sMonth )
				{
					m = i + 1; break;
				}
			}
	
			return m;
		}
		/**
		 *
		 * @alias nlSetFullYear
		 *
		 * @param {*} d
		 * @param {*} val
		 */
		function setFullYear(d,val)
		{
			if (typeof window !== 'undefined'  && window.navigator !== null && window.navigator.appName === "Netscape")
			{
				if (!d.setFullYear)
					d.setYear(val);
			}
			d.setFullYear(val);
		}
	
		function isLeapYear(year)
		{
			return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
		}
	
	
		function getMonthLength(year, month)
		{
			return MONTHLENGTH[isLeapYear(year) ? 1 : 0][month];
		}

		function addMonths(d, mtoadd)
		{
			if (mtoadd != 0)
			{
				var year = getFullYear(d);
				var dom = d.getDate();
				var month = d.getMonth() + mtoadd;
				if (month < 0)
				{
					month += 1;
					year = year + Math.ceil(month / 12) - 1;
					setFullYear(d, year);
					month = 11 + (month % 12);
				}
				else if (month > 11)
				{
					year = year + Math.floor(month / 12);
					setFullYear(d, year);
					month %= 12;

					// JS rounds leap days up (2/29/2016 + 1 yr = 3/1/2017),
					// whereas Java rounds them down (2/29/2016 + 1 yr = 2/28/2017).
					// Make JS behave like Java to be consistent with server side.
					if(dom === 29)
						d.setDate(dom); //This only works because we're setting the month later
				}
				var eom = getMonthLength(year, month);
				if (dom > eom)
					d.setDate(eom);

				d.setMonth(month);
			}
			return d;
		}

		function addDays(d, daystoadd)
		{
			if (!(d instanceof Date || Object.prototype.toString.call(d) === '[object Date]'))
				return d;
	
			var d2 = new Date(d.getTime() + 86400 * daystoadd * 1000);
			if (d2.getHours() !== d.getHours())
			{
				if ((d.getHours() > 0 && d2.getHours() < d.getHours()) || (d.getHours() === 0 && d2.getHours() === 23))
					d2.setTime(d2.getTime() + 3600*1000);
				else
					d2.setTime(d2.getTime() - 3600*1000);
			}
			d.setTime(d2.getTime());
			return d;
		}
	
		function isValidYearMonthDay(year, month, day)
		{
			return !(isNaN(year) || year < 0 || isNaN(month) || month < 0 || month > 11 || isNaN(day) || day < 1 || day > getMonthLength(year, month));
		}
	
		function trimString(str)
		{
			str = "" + str;
			return str.replace(/^\s+/,"").replace(/\s+$/,"");
		}
	
		// -- handle shorthand time notation i.e. 5p -> 5:00 pm, 18 -> 6:00 pm, 900 -> 9:00 am, 1433p -> 2:33 pm
		function hhmmToTimeString( hhmm )
		{
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var fldvalue = hhmm;
			var hour, minute;
			if ( AM.charAt(0) === PM.charAt(0) )
				re = new RegExp("^[0-9]{1,4}("+AM+"|"+PM+")*$", "i");
			else
				re = new RegExp("^[0-9]{1,4}(["+AM.charAt(0)+"|"+PM.charAt(0)+"]?)$","i");
			if ( re.test(fldvalue) )
			{
				var aorp = '';
				if ( RegExp.$1 )
				{
					if ( AM.charAt(0) === PM.charAt(0) )
						aorp = RegExp.$1.toLowerCase() === PM ? PM : AM;
					else
						aorp = RegExp.$1.toLowerCase().charAt(0) === PM.charAt(0) ? PM : AM;
				}
				if ( fldvalue.length < 3 || ( fldvalue.length === 3 && RegExp.$1 ) )
				{
					var hh = RegExp.$1 ? fldvalue.substring(0,fldvalue.length-1) : fldvalue;
					hour = parseInt( hh, 10 ) == 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh ) ;
					minute = 0;
					var ampm = RegExp.$1 ? aorp :
							   ( parseInt( fldvalue, 10 ) > 11 ? PM : AM );
				}
				else if (fldvalue.length === 3 || (fldvalue.length === 4 && RegExp.$1) )
				{
					var hh = fldvalue.substring(0,1) === "0" ? "12" : fldvalue.substring(0,1);
					hour = parseInt( hh, 10 );
					var mm = RegExp.$1 ? fldvalue.substring(1,3) : fldvalue.substring(1);
					minute = parseInt( mm, 10 );
					var ampm = RegExp.$1 ? aorp : AM;
				}
				else
				{
					var hh = fldvalue.substring(0,2);
					hour = parseInt( hh, 10 ) === 0 ? 12 : ( parseInt( hh, 10 ) > 12 ? parseInt( hh, 10 ) % 12 : hh );
					var mm = RegExp.$1 ? fldvalue.substring(2,4) : fldvalue.substring(2);
					minute = parseInt( mm, 10 );
					var ampm = parseInt( fldvalue.substring(0,2), 10 ) > 11 ? PM : AM;
					ampm = RegExp.$1 ? aorp : ampm;
				}
				if (ampm === AM && hour === 12)
					hour = 0;
				else if(ampm === PM && hour !== 12)
					hour = parseInt(hour) + 12;
				var time = new Date();
				time.setHours(hour,minute,0,0);
				fldvalue = getTimeString(time, AM, PM);
			}
			return fldvalue;
		}
	
		function regexStringToTime(date, time, includeSeconds, returnNullIfInvalid)
		{
			time = time != null ? trimString(time) : time;
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";
			var flddate = date != null ? stringToDate(date, "", returnNullIfInvalid) : new Date();
            if (flddate == null)
                return null;
			if (time != null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours = NaN;
				var minutes = NaN;
				var seconds = NaN;
	
				var delimitors;
				time = trimString(time);
	
				var TIME_FORMAT_MAP =
				{
					"HH:MI:SS am": { rcase: 0, hend: ':', mend: ':', send: ' '},
					"HH-MI-SS am": { rcase: 0, hend: '-', mend: '-', send: ' '},
					"HH24:MI:SS": { rcase: 0, hend: ':', mend: ':', send: null},
					"HH24-MI-SS": { rcase: 0, hend: '-', mend: '-', send: null},
					"amHHæMIåSSç§": { rcase:1, hend:'æ', mend:'å', send:'ç§'},
					"amHHç¹MIåSSç§": { rcase:1, hend:'ç¹', mend:'å', send:'ç§'},
					"amHHìMIë¶SSì´": { rcase:1, hend:'ì', mend:'ë¶', send:'ì´'},
					"HH24æMIåSSç§": { rcase:2, hend:'æ', mend:'å', send:'ç§'},
					"HH24ç¹MIåSSç§": { rcase:2, hend:'ç¹', mend:'å', send:'ç§'},
					"HH24ìMIë¶SSì´": { rcase:2, hend:'ì', mend:'ë¶', send:'ì´'},
					"HH:MI am": { rcase: 0, hend: ':', mend: ' ', send: null},
					"HH-MI am": { rcase: 0, hend: '-', mend: ' ', send: null},
					"HH24:MI": { rcase: 0, hend: ':', mend: null, send: null},
					"HH24-MI": { rcase: 0, hend: '-', mend: null, send: null},
					"amHHæMIå": { rcase:1, hend:'æ', mend:'å', send:null},
					"amHHç¹MIå": { rcase:1, hend:'ç¹', mend:'å', send:null},
					"amHHìMIë¶": { rcase:1, hend:'ì', mend:'ë¶', send:null},
					"HH24æMIå": { rcase:2, hend:'æ', mend:'å', send:null},
					"HH24ç¹MIå": { rcase:2, hend:'ç¹', mend:'å', send:null},
					"HH24ìMIë¶":{ rcase:2, hend:'ì', mend:'ë¶', send:null}
				};
	
				var format = getOracleDateTimeFormatter().preprocessDateTimeFormat(includeSeconds ? timeformatWithSeconds : timeformat);
				delimitors = TIME_FORMAT_MAP[format];
	
				var m;
				var ampm = null;
				var hend = null;
				var mend = null;
				var send = null;
				if (delimitors != null)
				{
					switch (delimitors.rcase)
					{
						case 0:
						{
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_SUFFIX.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[5];
								if (includeSeconds && m[4] != null)
									seconds = parseInt(m[6], 10);
								else
									seconds = 0;
								ampm = m[7];
							}
							break;
						}
						case 1:
						{
							var amtime=time.replace(/åå|ä¸å|ì¤ì /g,'am');
							amtime=amtime.replace(/åå¾|ä¸å|ì¤í/g,'pm');
							m = TIME_FORMAT_WITH_POSSIBLE_AMPM_PREFIX.exec(amtime);
							if (m !== null)
							{
								hours = parseInt(m[2], 10);
								hend = m[3];
								minutes = parseInt(m[4], 10);
								mend = m[5];
								if (includeSeconds && m[6] != null)
								{
									seconds = parseInt(m[7], 10);
									send = m[8];
								}
								else
									seconds = 0;
								ampm = m[1];
							}
							break;
						}
						case 2:
						{
							m = TIME_FORMAT_WITH_ASIAN_FORMATTING.exec(time);
							if (m !== null)
							{
								hours = parseInt(m[1], 10);
								hend = m[2];
								minutes = parseInt(m[3], 10);
								mend = m[4];
								if (includeSeconds && m[5] != null)
								{
									seconds = parseInt(m[6], 10);
									send = m[7];
								}
								else
									seconds = 0;
							}
							break;
						}
					}
					if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0 || seconds >= 60 || seconds < 0)
						return NaN;
	
					if (hend != delimitors.hend || (includeSeconds && (mend != null && mend != delimitors.mend) || (send != null && send != delimitors.send)))
						return NaN;
	
					if (ampm != null)
					{
						//noinspection JSUnresolvedVariable
						hours = getHoursIn24HourFormat((ampm.toLowerCase() == FieldValidationHelper.datetime_pm_string), hours);
					}
					flddate.setHours(hours, minutes, seconds, 0);
				} else
					flddate = NaN;
			}
			return flddate;
		}

		// to replace parseMMYYDateString (if possible)
		function stringToMMYYDate(arg, returnNullIfInvalid)
		{
			var returnValIfError = returnNullIfInvalid ? null : new Date();
	
			var mm, yy;

			var comps = trimString(arg).split(/[\.\/-]/);
	
			if(!/^[0-9\-\/\.]+$/.test(arg)) // contains other characters
			{
				if (comps.length !== 2)
					return returnValIfError;
				else
				{
					mm = getMonthIndex(comps[0]) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
			else // only contains numbers and - / or .
			{
				if (comps.length === 1)
				{
					if ((arg.length === 4) || (arg.length === 6))
					{
						mm = parseInt(arg.slice(0, 2), 10) - 1;
						yy = parseInt(arg.slice(2), 10)
					}
				}
				else if (comps.length === 2)
				{
					mm = parseInt(comps[0], 10) - 1;
					yy = parseInt(comps[1], 10);
				}
			}
	
			if (yy < 50)
				yy += 2000;
			else if (yy < 100)
				yy += 1900;
	
			if (!isValidYearMonthDay(yy, mm, 1))
				return returnValIfError;
			else
				return new Date(yy, mm);
		}
	
		function splitDateAndTime(dateTime)
		{
			var spaceCount = 0;
			var dateformat = getOracleDateTimeFormatter().preprocessDateTimeFormat(FieldValidationHelper.dateformat || "MM/DD/YYYY");
			dateTime = trimString(dateTime);

			switch (dateformat)
			{
				case "MM/DD/YYYY":
				case "DD/MM/YYYY":
				case "DD.MM.YYYY":
				case "DD-Mon-YYYY":
				case "DD-MONTH-YYYY":
				case "YYYY/MM/DD":
				case "YYYY-MM-DD":
				case "EEYYå¹´MMæDDæ¥":
				case "YYYYå¹´MMæDDæ¥":
				case "EYY.MM.DD":
					spaceCount = 0;
					break;
	
				case "DD. MON YYYY":
				case "YYYYë MMì DDì¼":
				case "DD MONTH, YYYY":
				case "DD MONTH YYYY":
					spaceCount = 2;
					break;
	
				case "DD de MONTH de YYYY":
					spaceCount = 4;
					break;
	
				default:
					return {date: dateTime, time: null};
			}
	
			var myRegex = (spaceCount === 0) ? new RegExp("^(\\S+)\\s+(.*)$") : new RegExp("^(\\S+(\\s+\\S+){" + spaceCount + "})\\s+(.*)$");
			var matches = dateTime.match(myRegex);

			if (matches)
			{
				return {date: matches[1], time: (spaceCount === 0) ? matches[2] : matches[3]}
			}
			else // assume just date if not a match
			{
				return {date: dateTime, time: null};
			}
		}
	
		function stringToDate(d, dateformat, returnNullIfInvalid, formattype)
		{
			d = trimString(d);
			var comps;
			var month, day, year;
			var yearCharIndex, monthCharIndex, dayCharIndex, era;
			if(!dateformat)
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}
			var dateStrLength = d.length;
			var endStr; //the end segment in date string (mainly used for date seg since year string's length is always 4)
			var yearLength = 4;
			var returnValIfError = returnNullIfInvalid ? null : new Date();
			// for now remove the format/strict modifiers
			// fm influences only formatting and we do not yet use fx anywhere
			// also strip quoting characters until we think of some better way to parse this
			dateformat = getOracleDateTimeFormatter().preprocessDateTimeFormat(dateformat);

			if(d.length > 0)
			{
				switch(dateformat)
				{
					case "MM/DD/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	   // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						month = parseInt(comps[0], 10) - 1;
						day = parseInt(comps[1], 10);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD/MM/YYYY":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD.MM.YYYY":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-Mon-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD-MONTH-YYYY":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "YYYY/MM/DD":
						comps = d.split("/");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "YYYY-MM-DD":
						comps = d.split("-");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						year = parseInt(comps[0], 10);
						dateStrLength = comps[1].length + endStr.length + yearLength + 2;
						break;
					case "EEYYå¹´MMæDDæ¥":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						era = d.substring(0, 2);
						year = getGregorianYear(parseInt(d.substring(2,yearCharIndex), 10), era);
						dateStrLength = dayCharIndex + 1;
						break;
					case "YYYYå¹´MMæDDæ¥":
						yearCharIndex = d.indexOf(yearCharCN);
						monthCharIndex = d.indexOf(monthCharCN);
						dayCharIndex = d.indexOf(dayCharCN);
						if(yearCharIndex < 0 || monthCharIndex < 0 || dayCharIndex < 0)
							return returnValIfError;
						day = parseInt(d.substring(monthCharIndex+1,dayCharIndex), 10);
						month = parseInt(d.substring(yearCharIndex+1,monthCharIndex), 10) - 1;
						year = parseInt(d.substring(0,yearCharIndex), 10);
						dateStrLength = dayCharIndex + 1;
						break;
					case "EYY.MM.DD":
						comps = d.split(".");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						endStr = comps[2].split(" ")[0];
						day = parseInt(endStr, 10);
						month = parseInt(comps[1], 10) - 1;
						era = comps[0].substring(0, 1);
						year = getGregorianYear(parseInt(comps[0].substring(1,comps[0].length), 10), era);
						dateStrLength = comps[0].length + comps[1].length + endStr.length + 2;
						break;
					case "DD. MON YYYY":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0].substring(0, comps[0].length - 1), 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_short_months, comps[1]);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD de MONTH de YYYY":
						comps = d.split(" de ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[0], 10);
						month = getMonthIndex(comps[1]) - 1;
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 8;
						break;
					case "YYYYë MMì DDì¼":
						comps = d.split(" ");
						if(comps.length < 3)	 // the format can contains time hh:mm:ss or hh-mm-ss
							return returnValIfError;
						day = parseInt(comps[2].substring(0, comps[2].length-1), 10);
						month = parseInt(comps[1].substring(0, comps[1].length-1), 10) - 1;
						year = parseInt(comps[0].substring(0, comps[0].length-1), 10);
						var whitespaceChars = 3;
						dateStrLength = comps[0].length + comps[1].length + comps[2].length + whitespaceChars;
						break;
					case "DD MONTH YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS AM" . length =4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1], true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
					case "DD MONTH, YYYY":
						comps = d.split(" ");
						if(comps.length < 3) //the format could be "DD MONTH YYYY HH:MI:SS PM" . length = 4
							return returnValIfError;
						day = parseInt(comps[0], 10);
						//noinspection JSUnresolvedVariable
						month = getMonthIndexFromArray(FieldValidationHelper.datetime_months, comps[1].substring(0, comps[1].length-1), true);
						year = parseInt(comps[2].substring(0, yearLength), 10);
						dateStrLength = comps[0].length + comps[1].length + yearLength + 2;
						break;
				}
			}
	
			if (!isValidYearMonthDay(year, month, day))
				return returnValIfError;
	
			// now handle the time segment
			var result;
			var t = d.substring(dateStrLength);
			if (t != null && t.length > 0)
			{
				if (formattype == 'datetimetz')
					result = regexStringToTime(d.substring(0,dateStrLength),t, true, returnNullIfInvalid);
				else if (formattype == 'datetime' || formattype == 'timeofday')
					result = regexStringToTime(d.substring(0,dateStrLength),t, false, returnNullIfInvalid);
				else
					result = stringToTime(d.substring(0,dateStrLength),t);
			}
			else
				result = new Date(year,month,day);
			if (result != null && !isNaN(result)) {
				if (year < 50)
					setFullYear(result, year + 2000);
				else if (year < 100)
					setFullYear(result, year + 1900);
            }
			return isNaN(result) && returnNullIfInvalid ? null : result;
		}
	
		function getHoursIn24HourFormat(isPM, hours)
		{
			if (!isPM && hours == 12)
				return 0;
			else if (isPM && hours < 12)
				return hours + 12;
			else
				return hours;
		}
	
		function stringToTime(date, time)
		{
			time = time != null ? trimString(time) : time;
			//noinspection JSUnresolvedVariable
			var timeformat = getOracleDateTimeFormatter().preprocessDateTimeFormat(FieldValidationHelper.timeformat || "fmHH:fmMI am");
			//noinspection JSUnresolvedVariable
			var AM = FieldValidationHelper.datetime_am_string || "";
			//noinspection JSUnresolvedVariable
			var PM = FieldValidationHelper.datetime_pm_string || "";
			var flddate = date !== null ? stringToDate(date) : new Date();
			if (time !== null && String(time).length != 0 && String(time).search(/\S/) >= 0)
			{
				var hours;
				var minutes;
				var isPM;
				var hourCharIndex;
	
				var format = timeformat.replace(/fm/g, "").replace(/"/g, "");
				if (format === "HH:MI am" || format === "HH-MI am" || format === "HH24:MI" || format === "HH24-MI")
				{
					var m = /^\s*(\d+)[-:](\d+)\s*(.*)/.exec(time);
					if (!m) return NaN;
					hours = parseInt(m[1], 10);
					minutes = parseInt(m[2], 10);
					if (format.substring(6) === "am")
					{
						isPM = (m[3].toLowerCase() === PM);
						hours = getHoursIn24HourFormat(isPM, hours);
					}
				}
				else if(format === "amHHæMIå" || format === "amHHç¹MIå" || format === "amHHìMIë¶")
				{
					hourCharIndex = time.indexOf("æ");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("ç¹");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("ì");
					var hour_start_index = 0;
					isPM = false;
	
					if(time.indexOf(AM) == 0)
						hour_start_index = AM.length;
					else if(time.indexOf(PM) == 0)
					{
						hour_start_index = PM.length;
						isPM = true;
					}
					hours = parseInt(time.substring(hour_start_index, hourCharIndex), 10);
					hours = getHoursIn24HourFormat(isPM, hours);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				else if(format === "HH24æMIå" || format === "HH24ç¹MIå" || format === "HH24ìMIë¶")
				{
					hourCharIndex = time.indexOf("æ");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("ç¹");
					if(hourCharIndex < 0)
						hourCharIndex = time.indexOf("ì");
					hours = parseInt(time.substring(0, hourCharIndex), 10);
					minutes = parseInt(time.substring(hourCharIndex + 1, time.length - 1), 10);
				}
				if(isNaN(hours) || isNaN(minutes) || hours >= 24 || hours < 0 || minutes >= 60 || minutes < 0)
					return NaN;
				flddate.setHours(hours, minutes, 0, 0);
			}
			return flddate;
		}
	
	
		function getTimeString(time, amvar, pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformat = FieldValidationHelper.timeformat || "fmHH:fmMI am";

			return getOracleDateTimeFormatter().formatDateTime(time, timeformat);
		}
	
		function getDateString(d, format)
		{
			// if dateformat is specified, use it from the format parameter
			// else use the window property (set from user preference)
			var dateformat;
			if (format)
				dateformat = format;
			else
			{
				//noinspection JSUnresolvedVariable
				dateformat = FieldValidationHelper.dateformat || "MM/DD/YYYY";
			}

			return getOracleDateTimeFormatter().formatDateTime(d, dateformat);
		}
	
		function getTimeWithSecondsString(time,amvar,pmvar)
		{
			if (!(time instanceof Date || Object.prototype.toString.call(time) === '[object Date]'))
				return time;
			//noinspection JSUnresolvedVariable
			var timeformatWithSeconds = FieldValidationHelper.timeformatwithseconds || "fmHH:fmMI:SS am";

			return getOracleDateTimeFormatter().formatDateTime(time, timeformatWithSeconds);
		}
	
		function getMMYYString(date)
		{
			var dateformat = FieldValidationHelper.dateformat || "fmMM/DDfm/YYYY";

			return getOracleDateTimeFormatter().formatMMYYDateString(date, dateformat);
		}

		function getDatetimeString(date)
		{
			return getDateString(date) + " " + getTimeString(date);
		}
	
		function getDatetimetzString(date)
		{
			return getDateString(date) + " " + getTimeWithSecondsString(date);
		}
	
		var m_j_d = [[0,31,59,90,120,151,181,212,243,273,304,334],[0,31,60,91,121,152,182,213,244,274,305,335]];
	
		var j_d = [];
		j_d[1970]=0;
		j_d[1971]=365;
		j_d[1972]=730;
		j_d[1973]=1096;
		j_d[1974]=1461;
		j_d[1975]=1826;
		j_d[1976]=2191;
		j_d[1977]=2557;
		j_d[1978]=2922;
		j_d[1979]=3287;
		j_d[1980]=3652;
		j_d[1981]=4018;
		j_d[1982]=4383;
		j_d[1983]=4748;
		j_d[1984]=5113;
		j_d[1985]=5479;
		j_d[1986]=5844;
		j_d[1987]=6209;
		j_d[1988]=6574;
		j_d[1989]=6940;
		j_d[1990]=7305;
		j_d[1991]=7670;
		j_d[1992]=8035;
		j_d[1993]=8401;
		j_d[1994]=8766;
		j_d[1995]=9131;
		j_d[1996]=9496;
		j_d[1997]=9862;
		j_d[1998]=10227;
		j_d[1999]=10592;
		j_d[2000]=10957;
		j_d[2001]=11323;
		j_d[2002]=11688;
		j_d[2003]=12053;
		j_d[2004]=12418;
		j_d[2005]=12784;
		j_d[2006]=13149;
		j_d[2007]=13514;
		j_d[2008]=13879;
		j_d[2009]=14245;
		j_d[2010]=14610;
		j_d[2011]=14975;
		j_d[2012]=15340;
		j_d[2013]=15706;
		j_d[2014]=16071;
		j_d[2015]=16436;
		j_d[2016]=16801;
		j_d[2017]=17167;
		j_d[2018]=17532;
		j_d[2019]=17897;
		j_d[2020]=18262;
		j_d[2021]=18628;
		j_d[2022]=18993;
		j_d[2023]=19358;
		j_d[2024]=19723;
		j_d[2025]=20089;
		j_d[2026]=20454;
		j_d[2027]=20819;
		j_d[2028]=21184;
		j_d[2029]=21550;
		j_d[2030]=21915;
	
		function getMonthJulian(year, month)
		{
			return m_j_d[isLeapYear(year)?1:0][month];
		}
	
	
		function get_julian_date(d)
		{
			return j_d[d.getFullYear()]+getMonthJulian(d.getFullYear(),d.getMonth())+d.getDate()-1;
		}
	
		function isDateTooOld(timeString)
		{
			return timeString < OLDEST_VALID_DATE;
		}
	
		function getOldestDateString()
		{
			return getDateString(OLDEST_VALID_DATE);
		}
	
		function _hhmm_to_mins(time) {
			return time.hrs * 60 + time.mins;
		}

		function round_hhmm_nearest(hrs, mins, round_by) {
			var up_time = round_hhmm_up(hrs, mins, round_by);
			var down_time = round_hhmm_down(hrs, mins, round_by);

			orig_mins = _hhmm_to_mins({
				hrs: hrs,
				mins: mins
			});
			up_mins = _hhmm_to_mins(up_time);
			down_mins = _hhmm_to_mins(down_time);

			if (up_mins - orig_mins > orig_mins - down_mins) {
				return down_time;
			} else {
				return up_time;
			}
		}

		function round_hhmm_up(hrs, mins, round_by) {
			mins += (mins % round_by > 0 ? (round_by - (mins % round_by)) : 0);
			if (mins >= 60) {
				var _hhmm_delta = Math.floor(mins / 60);
				mins -= (_hhmm_delta * 60);
				hrs += _hhmm_delta;
			}
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm_down(hrs, mins, round_by) {
			mins -= (mins > 0 ? (mins % round_by) : 0);
			return {
				hrs: hrs,
				mins: mins
			};
		}

		function round_hhmm(val, round_by, direction) {
			if (val == "") return val;
			var re = /^([0-9]+?):([0-9]+)$/;
			var result = re.exec(val);
			if (result == null) {
				result = format_hhmm(val);
				if (result == null) return val;
			}
			var hrs = parseFloat(result[1]);
			var mins = parseFloat(result[2]);
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return time.hrs + ':' + time.mins;
		}

		function format_hhmm(val) {
			var hours;
			var minutes;

			var re = /([0-9][0-9]?)?(:[0-9][0-9]+)?/
			var result = re.exec(val)
			if (result == null || result.index > 0 || result[0].length != val.length) {
				timeval = parseFloat(val);
				if (isNaN(timeval)) hours = -1;
				else {
					hours = Math.floor(timeval);
					minutes = Math.floor((timeval - hours) * 60 + 0.5);
				}
			} else {
				if (RegExp.$1.length > 0) hours = parseInt(RegExp.$1, 10);
				else hours = 0;
				if (typeof (RegExp.$2) != "undefined" && RegExp.$2.length > 0) {
					minutes = parseInt(RegExp.$2.substr(1), 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce
					// minutes to be less than 60
					if (minutes >= 60) {
						var hours_delta = Math.floor(minutes / 60);
						minutes -= (hours_delta * 60);
						hours += hours_delta;
					}
				} else minutes = 0;
			}
			if (hours >= 0 && minutes >= 0 && minutes < 60) {
				return [val, hours, minutes];
			}
		}

		function parse_time(val) {

			if (val == null || val.trim().length == 0)
				return null;

			var time = {hours: 0, minutes: 0, negative: false};

			var rexp = /^(\-?)(\d*)(:(\d+))?$/;
			var rexpRes = rexp.exec(val);

			if (rexpRes == null) {
				var timeval = parseFloat(val);
				if (isNaN(timeval)) {
					return null;
				} else {
					if (timeval < 0) {
						timeval = Math.abs(timeval);
						time.negative = true;
					}
					time.hours = Math.floor(timeval);
					time.minutes = Math.round((timeval - time.hours) * 60);
				}
			} else {

				if (typeof rexpRes[2] != "undefined" && rexpRes[2].trim().length > 0) {
					time.hours = parseInt(rexpRes[2], 10);
				}

				if (typeof rexpRes[4] != "undefined" && rexpRes[4].trim().length > 0) {
					time.minutes = parseInt(rexpRes[4], 10);
					// if the user entered a value >= 60 for minutes, add the extra hours to the hours var and reduce minutes to be less than 60
					if (time.minutes >= 60) {
						var delta = Math.floor(time.minutes / 60);
						time.hours += delta;
						time.minutes -= delta * 60;
					}
				}
				if (rexpRes[1] == '-' && (time.hours > 0 || time.minutes > 0))
					time.negative = true;
			}
			return time;
		}

		function round_hhmm2(val, round_by, direction) {

			var result = parse_time(val);
			if (result == null) {
				return val;
			}
			var hrs = result.hours;
			var mins = result.minutes;
			var time;
			if (direction == 'UP') {
				time = round_hhmm_up(hrs, mins, round_by);
			} else if (direction == 'DOWN') {
				time = round_hhmm_down(hrs, mins, round_by);
			} else if (direction == 'NEAR') {
				time = round_hhmm_nearest(hrs, mins, round_by);
			} else {
				throw direction + ' is not vald direction: [UP,DOWN,NEAREST]';
			}
			if (time.mins < 10) time.mins = '0' + time.mins;
			return (result.negative ? '-' : '') + time.hrs + ':' + time.mins;
		}

		function OracleDateTimeFormatter(settingsContainer, japaneseEraHandlers, shortMonthsMap, longMonthsMap) {
			var that = this;
			this.settingsContainer = settingsContainer;
			this.shortMonthsMap = shortMonthsMap === undefined ? settingsContainer.datetime_short_months : shortMonthsMap;
			this.longMonthsMap = longMonthsMap === undefined ? settingsContainer.datetime_months : longMonthsMap;

			this.getJapaneseImperialEra = japaneseEraHandlers.getJapaneseImperialEra;
			this.getShortJapaneseImperialEra = japaneseEraHandlers.getShortJapaneseImperialEra;
			this.getJapaneseImperialYear = japaneseEraHandlers.getJapaneseImperialYear;

			function DateTimeElementType(matchPattern, formatterFunction) {
				this.matchRegexp = new RegExp('^' + matchPattern, 'i');
				this.formatterFunction = formatterFunction;
			}

			function DateTimeElement(elementType, value, isUnpadded, isStrict) {
				this.elementType = elementType;
				this.value = value;
				this.isUnpadded = isUnpadded;
				this.isStrict = isStrict;
				this.formatterFunction = elementType.formatterFunction;
			}

			this.padChar = function padChar(value, length, characterToPad) {
				while (value.length < length) {
					value = characterToPad + value;
				}
				return value;
			};

			this.padZeros = function padZeros(value, length) {
				return that.padChar(value, length, '0');
			};

			this.padSpace = function padSpace(value, length) {
				return that.padChar(value, length, ' ');
			};

			this.formatDateTimeElement = function formatDateTimeElement(element, valueFromDateObject, maxWidth) {
				var width = element.value.length;

				if (maxWidth !== undefined && width > maxWidth) {
					width = maxWidth;
				}
				var isUnpadded = element.isUnpadded;
				var padFunc = isNaN(valueFromDateObject) ? that.padSpace : that.padZeros;
				var valueAsString = valueFromDateObject.toString();

				return isUnpadded ? valueAsString : padFunc(valueAsString, width);
			};

			this.formatters = Object.freeze({
				formatMeridian: function formatMeridian(dateTimeElement, dateObject) {
					//noinspection JSUnresolvedVariable
					var amvar = that.settingsContainer.datetime_am_string || '';
					//noinspection JSUnresolvedVariable
					var pmvar = that.settingsContainer.datetime_pm_string || '';
					var hours = dateObject.getHours();
					return hours < 12 ? amvar : pmvar;
				},

				formatDayOfMonth: function formatDayOfMonth(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getDate())
				},

				formatDayOfWeek: function formatDayOfWeek(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getDay());
				},

				formatLongEra: function formatLongEra(dateTimeElement, dateObject) {
					return that.getJapaneseImperialEra(dateObject);
				},

				formatShortEra: function formatShortEra(dateTimeElement, dateObject) {
					return that.getShortJapaneseImperialEra(dateObject);
				},

				format24Hour: function format24Hour(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getHours(), 2);
				},

				format12Hour: function format12Hour(dateTimeElement, dateObject) {
					var valueIn12Hour = dateObject.getHours() % 12;
					// 00 in 24h corresponds to 12 am
					if (valueIn12Hour === 0) valueIn12Hour = 12;
					return that.formatDateTimeElement(dateTimeElement, valueIn12Hour, 2);
				},

				formatISOYear: function formatISOYear(dateTimeElement, dateObject) {
					return this.formatYear(dateTimeElement, dateObject);
				},

				formatMonth: function formatMonth(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getMonth() + 1);
				},

				formatMinute: function formatMinute(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getMinutes());
				},

				formatLongMonthName: function formatLongMonthName(dateTimeElement, dateObject) {
					return that.longMonthsMap[dateObject.getMonth()];
				},

				formatShortMonthName: function formatShortMonthName(dateTimeElement, dateObject) {
					return that.shortMonthsMap[dateObject.getMonth()];
				},

				formatSeconds: function formatSeconds(dateTimeElement, dateObject) {
					return that.formatDateTimeElement(dateTimeElement, dateObject.getSeconds());
				},

				formatYear: function formatYear(dateTimeElement, dateObject) {
					var yearValue = that.getFullYear(dateObject);
					return that.formatDateTimeElement(dateTimeElement, yearValue);
				},

				formatLastDigitOfYear: function formatLastDigitOfYear(dateTimeElement, dateObject) {
					var yearAsString = that.getFullYear(dateObject).toString();
					return yearAsString.substr(-dateTimeElement.value.length);
				},

				formatText: function formatText(dateTimeElement, dateObject) {
					return dateTimeElement.value.replace(/"/g, "");
				},

				formatAsIs: function formatAsIs(dateTimeElement, dateObject) {
					return dateTimeElement.value;
				}
			});

			this.getFullYear = function getFullYearDefaultImpl(dateObject) {
				return dateObject.getFullYear();
			};

			this.dateTimeElementTypes = Object.freeze({
				AD_INDICATOR: new DateTimeElementType('A\.D\.|AD'),
				MERIDIAN: new DateTimeElementType('[AP]\.M\.|[AP]M', that.formatters.formatMeridian),
				ERA_INDICATOR: new DateTimeElementType('B\.C\.|BC'),
				CENTURY: new DateTimeElementType('S?CC'),
				DAY_NAME: new DateTimeElementType('DAY'),
				ABBREV_DAY_NAME: new DateTimeElementType('DY'),
				DAY_OF_YEAR: new DateTimeElementType('DDD'),
				DAY_OF_MONTH: new DateTimeElementType('DD', that.formatters.formatDayOfMonth),
				SHORT_DATE: new DateTimeElementType('DS'),
				LONG_DATE: new DateTimeElementType('DL'),
				DAY_OF_WEEK: new DateTimeElementType('D', that.formatters.formatDayOfWeek),
				FULL_ERA: new DateTimeElementType('EE', that.formatters.formatLongEra),
				ABBREV_ERA: new DateTimeElementType('E', that.formatters.formatShortEra),
				FRACTIONAL_SECONDS: new DateTimeElementType('FF[1-9]'),
				HOUR_OF_DAY_24: new DateTimeElementType('HH24', that.formatters.format24Hour),
				HOUR_OF_DAY_12: new DateTimeElementType('HH(12)?', that.formatters.format12Hour),
				ISO_WEEK_OF_YEAR: new DateTimeElementType('IW'),
				ISO_YEAR: new DateTimeElementType('IY{0,3}', that.formatters.formatISOYear),
				JULIAN_DAY: new DateTimeElementType('J'),
				MINUTE: new DateTimeElementType('MI', that.formatters.formatMinute),
				MONTH: new DateTimeElementType('MM', that.formatters.formatMonth),
				LONG_MONTH_NAME: new DateTimeElementType('Month', that.formatters.formatLongMonthName),
				SHORT_MONTH_NAME: new DateTimeElementType('Mon', that.formatters.formatShortMonthName),
				QUARTER_OF_YEAR: new DateTimeElementType('Q'),
				ROMAN_NUMERAL_MONTH: new DateTimeElementType('RM'),
				LONG_ROUNDED_YEAR: new DateTimeElementType('RRRR'),
				SHORT_ROUNDED_YEAR: new DateTimeElementType('RR'),
				SECONDS_PAST_MIDNIGHT: new DateTimeElementType('SSSSS'),
				SECONDS: new DateTimeElementType('SS', that.formatters.formatSeconds),
				SHORT_TIME: new DateTimeElementType('TS'),
				TZ_DAYLIGHT_SAVING: new DateTimeElementType('TZD'),
				TZ_HOUR: new DateTimeElementType('TZH'),
				TZ_MINUTE: new DateTimeElementType('TZM'),
				TZ_REGION: new DateTimeElementType('TZR'),
				WEEK_OF_YEAR: new DateTimeElementType('WW'),
				WEEK_OF_MONTH: new DateTimeElementType('W'),
				LOCAL_RADIX: new DateTimeElementType('X'),
				FOUR_DIGIT_YEAR: new DateTimeElementType('S?YYYY', that.formatters.formatYear),
				SPELLED_OUT_YEAR: new DateTimeElementType('S?YEAR'),
				LAST_DIGIT_OF_YEAR: new DateTimeElementType('Y{1,3}', that.formatters.formatLastDigitOfYear),
				TEXT: new DateTimeElementType('"[^"]*"', that.formatters.formatText),
				PUNCTUATION: new DateTimeElementType('[-/,.;:]+', that.formatters.formatAsIs),
				WHITESPACE: new DateTimeElementType('\\s+', that.formatters.formatAsIs),
				UNPAD_MOD: new DateTimeElementType('fm'),
				STRICT_MOD: new DateTimeElementType('fx'),
				SINGLE_QUOTE: new DateTimeElementType('\'\'', that.formatters.formatAsIs)
			});

			// Javascript does not guarantee ordering of object properties (obviously)
			// but we "resolve" parsing ambiguities by letting first match win
			// thus we have to explicitly order the element types to avoid parse aliasing
			this.matchOrder = [
				this.dateTimeElementTypes.AD_INDICATOR,
				this.dateTimeElementTypes.MERIDIAN,
				this.dateTimeElementTypes.ERA_INDICATOR,
				this.dateTimeElementTypes.CENTURY,
				this.dateTimeElementTypes.DAY_NAME,
				this.dateTimeElementTypes.ABBREV_DAY_NAME,
				this.dateTimeElementTypes.DAY_OF_YEAR,
				this.dateTimeElementTypes.DAY_OF_MONTH,
				this.dateTimeElementTypes.SHORT_DATE,
				this.dateTimeElementTypes.LONG_DATE,
				this.dateTimeElementTypes.DAY_OF_WEEK,
				this.dateTimeElementTypes.FULL_ERA,
				this.dateTimeElementTypes.ABBREV_ERA,
				this.dateTimeElementTypes.FRACTIONAL_SECONDS,
				this.dateTimeElementTypes.HOUR_OF_DAY_24,
				this.dateTimeElementTypes.HOUR_OF_DAY_12,
				this.dateTimeElementTypes.ISO_WEEK_OF_YEAR,
				this.dateTimeElementTypes.ISO_YEAR,
				this.dateTimeElementTypes.JULIAN_DAY,
				this.dateTimeElementTypes.MINUTE,
				this.dateTimeElementTypes.MONTH,
				this.dateTimeElementTypes.LONG_MONTH_NAME,
				this.dateTimeElementTypes.SHORT_MONTH_NAME,
				this.dateTimeElementTypes.QUARTER_OF_YEAR,
				this.dateTimeElementTypes.ROMAN_NUMERAL_MONTH,
				this.dateTimeElementTypes.LONG_ROUNDED_YEAR,
				this.dateTimeElementTypes.SHORT_ROUNDED_YEAR,
				this.dateTimeElementTypes.SECONDS_PAST_MIDNIGHT,
				this.dateTimeElementTypes.SECONDS,
				this.dateTimeElementTypes.SHORT_TIME,
				this.dateTimeElementTypes.TZ_DAYLIGHT_SAVING,
				this.dateTimeElementTypes.TZ_HOUR,
				this.dateTimeElementTypes.TZ_MINUTE,
				this.dateTimeElementTypes.TZ_REGION,
				this.dateTimeElementTypes.WEEK_OF_YEAR,
				this.dateTimeElementTypes.WEEK_OF_MONTH,
				this.dateTimeElementTypes.LOCAL_RADIX,
				this.dateTimeElementTypes.FOUR_DIGIT_YEAR,
				this.dateTimeElementTypes.SPELLED_OUT_YEAR,
				this.dateTimeElementTypes.LAST_DIGIT_OF_YEAR,
				this.dateTimeElementTypes.TEXT,
				this.dateTimeElementTypes.PUNCTUATION,
				this.dateTimeElementTypes.WHITESPACE,
				this.dateTimeElementTypes.UNPAD_MOD,
				this.dateTimeElementTypes.STRICT_MOD,
				this.dateTimeElementTypes.SINGLE_QUOTE
			];

			this.numericalMonthTypes = [
				this.dateTimeElementTypes.MONTH
			];

			this.textualMonthTypes = [
				this.dateTimeElementTypes.SHORT_MONTH_NAME,
				this.dateTimeElementTypes.LONG_MONTH_NAME
			];

			this.yearTypes = [
				this.dateTimeElementTypes.ISO_YEAR,
				this.dateTimeElementTypes.LAST_DIGIT_OF_YEAR,
				this.dateTimeElementTypes.FOUR_DIGIT_YEAR
			];

			this.separatorTypes = [
				this.dateTimeElementTypes.PUNCTUATION,
				this.dateTimeElementTypes.WHITESPACE,
				this.dateTimeElementTypes.TEXT
			];

			this.parseDateTimeFormat = function parseDateTimeFormat(formatSpecifier) {
				if (formatSpecifier === undefined) {
					formatSpecifier = this.settingsContainer.dateformat;
				}

				var elements = [];
				var isUnpadded = false;
				var isStrict = false;

				var index = 0;
				var specifierLength = formatSpecifier.length;

				while (index < specifierLength) {
					var remainder = formatSpecifier.substring(index, specifierLength);
					var matchResult = null;

					if (matchResult = this.matchDateTimeElement(this.dateTimeElementTypes.UNPAD_MOD, remainder)) {
						isUnpadded = !isUnpadded;
					} else if (matchResult = this.matchDateTimeElement(this.dateTimeElementTypes.STRICT_MOD, remainder)) {
						isStrict = !isStrict;
					} else {
						for (var i = 0; i < this.matchOrder.length; i++) {
							var dateTimeElementType = this.matchOrder[i];
							matchResult = this.matchDateTimeElement(dateTimeElementType, remainder);
							if (matchResult !== null) {
								elements.push(new DateTimeElement(dateTimeElementType, matchResult, isUnpadded, isStrict));
								break;
							}
						}
					}
					if (matchResult === null) {
						throw "Failed to parse format specifier '"+ formatSpecifier + "': Unrecognized element at position " + index;
					}
					index += matchResult.length;
				}

				return elements;
			};

			this.matchDateTimeElement = function matchDateTimeElement(dateTimeElementType, inputString) {
				var matchResult = dateTimeElementType.matchRegexp.exec(inputString);

				if (matchResult === null || matchResult.index !== 0) return null;

				return matchResult[0];
			};

			this.formatDateTime = function formatDateTime(date, formatSpecifier) {
				var elements = this.parseDateTimeFormat(formatSpecifier);

				// check if there is era among elements, if yes we have to reset the year getter to work with Japanese calendar
				var containsEra = elements.some(function (element) {
					return (
						element.elementType === that.dateTimeElementTypes.FULL_ERA ||
						element.elementType === that.dateTimeElementTypes.ABBREV_ERA
					);
				});

				if (containsEra) {
					this.getFullYear = this.getJapaneseImperialYear
				}

				return this.formatDateTimeFromElements(elements, date);
			};

			this.formatDateTimeFromElements = function formatDateTimeFromElements(elements, dateObject) {
				return elements.map(function (element) {
					var formatterFunction = element.formatterFunction;
					if (formatterFunction === undefined) {
						throw "No formatting function associated with element type " + element.elementType.toString();
					}
					return formatterFunction(element, dateObject);
				}).join('');
			};

			this.formatMMYYDateString = function formatMMYYDateString(dateObject, dateFormat) {
				var elements = this.extractMMYYElements(this.parseDateTimeFormat(dateFormat));
				return this.formatDateTimeFromElements(elements, dateObject);
			};

			this.extractMMYYElements = function extractMMYYElements(dateFormatElements) {

				var elementsLength = dateFormatElements.length;
				var index = 0;
				var monthElement = null,
					yearElement = null,
					separator = null;

				// this complex logic is needed to preserve the rules from the original code
				// namely long months are replaced by short month names and some separators (punctuation, whitespace) are replaced
				// by some long forgotten rules
				while (index < elementsLength && (monthElement === null || yearElement === null || separator === null)) {
					var currentElement = dateFormatElements[index];
					var currentType = currentElement.elementType;
					var currentValue = currentElement.value;
					var currentIsUnpadded = currentElement.isUnpadded;
					var currentIsStrict = currentElement.isStrict;

					var nextElementType = index + 1 !== elementsLength ? dateFormatElements[index + 1].elementType : undefined;

					if (monthElement === null && this.numericalMonthTypes.indexOf(currentType) !== -1) {
						monthElement = currentElement;
					} else if (monthElement === null && this.textualMonthTypes.indexOf(currentType) !== -1) {
						monthElement = new DateTimeElement(
							this.dateTimeElementTypes.SHORT_MONTH_NAME, 'Mon', currentIsUnpadded, currentIsStrict);
					} else if (yearElement === null && this.yearTypes.indexOf(currentType) !== -1) {
						yearElement = currentElement;
					} else if (separator === null && this.separatorTypes.indexOf(currentType) !== -1) {
						if (currentValue === '-' || (currentValue === '.' && nextElementType !== this.dateTimeElementTypes.WHITESPACE)) {
							separator = currentElement;
						} else {
							separator = new DateTimeElement(
								this.dateTimeElementTypes.PUNCTUATION, '/', currentIsUnpadded, currentIsStrict);
						}
					}
					index++;
				}

				return [monthElement, separator, yearElement].filter(function (value) { return value !== null });
			};

			// strip the incoming datetime format of elements that may trip up the parsing functions define here
			this.preprocessDateTimeFormat = function preprocessDateTimeFormat(inputFormat) {
				return inputFormat.replace(/f[mx]|"/ig, "");
			}
		}

		/* assign dateutil package */
		return Object.freeze({
			addMonths: addMonths,
			addDays: addDays,
			hhmmToTimeString: hhmmToTimeString,
			regexStringToTime: regexStringToTime,
			stringToTime: stringToTime,
			splitDateAndTime: splitDateAndTime,
			stringToDate: stringToDate,
			stringToMMYYDate: stringToMMYYDate,
			getTimeWithSecondsString: getTimeWithSecondsString,
			getTimeString: getTimeString,
			getDateString: getDateString,
			getMMYYString: getMMYYString,
			getDatetimeString: getDatetimeString,
			getDatetimetzString: getDatetimetzString,
			get_julian_date: get_julian_date,
			isDateTooOld: isDateTooOld,
			getOldestDateString: getOldestDateString,
			round_hhmm: round_hhmm,
			round_hhmm2: round_hhmm2,
			getMonthLength: getMonthLength
		});
	}
);

/**
 * @private
 */
define('N/restricted/dateTimeZoneApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript module
 *
 * @private
 * @module N/dateTimeZone
 * @NApiVersion 2.x
 *
 */
define('N/dateTimeZone',['N/restricted/dateTimeZoneApi', 'N/internal/invoker', 'N/utilityFunctions', 'N/error'],
   function(dateTimeZoneApi, invoker, utilityFunctions, error)
   {
   	    function isClient() { return typeof document !== 'undefined'; }

        var TIME_ZONES = Object.freeze({
                                           ETC_GMT_PLUS_12: 'Etc/GMT+12',
                                           PACIFIC_SAMOA: 'Pacific/Samoa',
                                           PACIFIC_HONOLULU: 'Pacific/Honolulu',
                                           AMERICA_ANCHORAGE: 'America/Anchorage',
                                           AMERICA_LOS_ANGELES: 'America/Los_Angeles',
                                           AMERICA_TIJUANA: 'America/Tijuana',
                                           AMERICA_DENVER: 'America/Denver',
                                           AMERICA_PHOENIX: 'America/Phoenix',
                                           AMERICA_CHIHUAHUA: 'America/Chihuahua',
                                           AMERICA_HERMOSILLO: 'America/Hermosillo',
                                           AMERICA_CHICAGO: 'America/Chicago',
                                           AMERICA_REGINA: 'America/Regina',
                                           AMERICA_GUATEMALA: 'America/Guatemala',
                                           AMERICA_MEXICO_CITY: 'America/Mexico_City',
                                           AMERICA_NEW_YORK: 'America/New_York',
                                           US_EAST_INDIANA: 'US/East-Indiana',
                                           AMERICA_BOGOTA: 'America/Bogota',
                                           AMERICA_CARACAS: 'America/Caracas',
                                           AMERICA_HALIFAX: 'America/Halifax',
                                           AMERICA_LA_PAZ: 'America/La_Paz',
                                           AMERICA_MANAUS: 'America/Manaus',
                                           AMERICA_SANTIAGO: 'America/Santiago',
                                           AMERICA_ST_JOHNS: 'America/St_Johns',
                                           AMERICA_SAO_PAULO: 'America/Sao_Paulo',
                                           AMERICA_BUENOS_AIRES: 'America/Buenos_Aires',
                                           ETC_GMT_PLUS_3: 'Etc/GMT+3',
                                           AMERICA_GODTHAB: 'America/Godthab',
                                           AMERICA_MONTEVIDEO: 'America/Montevideo',
                                           AMERICA_NORONHA: 'America/Noronha',
                                           ETC_GMT_PLUS_1: 'Etc/GMT+1',
                                           ATLANTIC_AZORES: 'Atlantic/Azores',
                                           EUROPE_LONDON: 'Europe/London',
                                           GMT: 'GMT',
                                           ATLANTIC_REYKJAVIK: 'Atlantic/Reykjavik',
                                           EUROPE_WARSAW: 'Europe/Warsaw',
                                           EUROPE_PARIS: 'Europe/Paris',
                                           ETC_GMT_MINUS_1: 'Etc/GMT-1',
                                           EUROPE_AMSTERDAM: 'Europe/Amsterdam',
                                           EUROPE_BUDAPEST: 'Europe/Budapest',
                                           AFRICA_CAIRO: 'Africa/Cairo',
                                           EUROPE_ISTANBUL: 'Europe/Istanbul',
                                           ASIA_JERUSALEM: 'Asia/Jerusalem',
                                           ASIA_AMMAN: 'Asia/Amman',
                                           ASIA_BEIRUT: 'Asia/Beirut',
                                           AFRICA_JOHANNESBURG: 'Africa/Johannesburg',
                                           EUROPE_KIEV: 'Europe/Kiev',
                                           EUROPE_HELSINKI: 'Europe/Helsinki',
                                           EUROPE_MINSK: 'Europe/Minsk',
                                           AFRICA_WINDHOEK: 'Africa/Windhoek',
                                           ASIA_RIYADH: 'Asia/Riyadh',
                                           EUROPE_MOSCOW: 'Europe/Moscow',
                                           ASIA_BAGHDAD: 'Asia/Baghdad',
                                           AFRICA_NAIROBI: 'Africa/Nairobi',
                                           ASIA_TEHRAN: 'Asia/Tehran',
                                           ASIA_MUSCAT: 'Asia/Muscat',
                                           ASIA_BAKU: 'Asia/Baku',
                                           ASIA_YEREVAN: 'Asia/Yerevan',
                                           ETC_GMT_MINUS_3: 'Etc/GMT-3',
                                           ASIA_KABUL: 'Asia/Kabul',
                                           ASIA_KARACHI: 'Asia/Karachi',
                                           ASIA_YEKATERINBURG: 'Asia/Yekaterinburg',
                                           ASIA_TASHKENT: 'Asia/Tashkent',
                                           ASIA_CALCUTTA: 'Asia/Calcutta',
                                           ASIA_KATMANDU: 'Asia/Katmandu',
                                           ASIA_ALMATY: 'Asia/Almaty',
                                           ASIA_DHAKA: 'Asia/Dhaka',
                                           ASIA_RANGOON: 'Asia/Rangoon',
                                           ASIA_BANGKOK: 'Asia/Bangkok',
                                           ASIA_KRASNOYARSK: 'Asia/Krasnoyarsk',
                                           ASIA_HONG_KONG: 'Asia/Hong_Kong',
                                           ASIA_KUALA_LUMPUR: 'Asia/Kuala_Lumpur',
                                           ASIA_TAIPEI: 'Asia/Taipei',
                                           AUSTRALIA_PERTH: 'Australia/Perth',
                                           ASIA_IRKUTSK: 'Asia/Irkutsk',
                                           ASIA_MANILA: 'Asia/Manila',
                                           ASIA_SEOUL: 'Asia/Seoul',
                                           ASIA_TOKYO: 'Asia/Tokyo',
                                           ASIA_YAKUTSK: 'Asia/Yakutsk',
                                           AUSTRALIA_DARWIN: 'Australia/Darwin',
                                           AUSTRALIA_ADELAIDE: 'Australia/Adelaide',
                                           AUSTRALIA_SYDNEY: 'Australia/Sydney',
                                           AUSTRALIA_BRISBANE: 'Australia/Brisbane',
                                           AUSTRALIA_HOBART: 'Australia/Hobart',
                                           PACIFIC_GUAM: 'Pacific/Guam',
                                           ASIA_VLADIVOSTOK: 'Asia/Vladivostok',
                                           PACIFIC_GUADALCANAL: 'Pacific/Guadalcanal',
                                           PACIFIC_KWAJALEIN: 'Pacific/Kwajalein',
                                           PACIFIC_AUCKLAND: 'Pacific/Auckland',
                                           PACIFIC_TONGATAPU: 'Pacific/Tongatapu'
                                       });

        function checkValidTimezone(timezone)
        {
	        var valid = (timezone == null || util.isNumber(timezone));
	        if (!valid && util.isString(timezone))
	        {
		        Object.getOwnPropertyNames(TIME_ZONES).forEach(function (key) {
			        valid |= timezone === TIME_ZONES[key];
		        });
		        if (!valid) utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNEXPECTED_VALUE_1_FOR_2, timezone, 'format.Timezone');
	        }

	        return valid;
        }

        function getTimeZone(timezone)
        {
            if (timezone === null || timezone === undefined)
            {
                return null;
            }

            return isNaN(timezone) ? timezone : parseInt(timezone, 10);
        }

        function parse(strict, value, timezone)
        {
        	if (strict) {
		        utilityFunctions.checkArgTypes([
			        utilityFunctions.checkArgObject(value, 'value', util.isString),
			        utilityFunctions.checkArgObject(timezone, 'timezone', checkValidTimezone)
		        ]);
	        }
            timezone = getTimeZone(timezone);
            try {
	            var timeObject = invoker(dateTimeZoneApi, 'parseWithTimeZone', [value, timezone]);
	            var date = new Date(timeObject.timeSinceEpochInMS);
	            if (timeObject.isDST === false && isDST(date) === true)
	            {
		            date.setTime(date.getTime() + getDSTOffsetInMS(date))
	            }
	            else if (timeObject.isDST === true && isDST(date) === false)
	            {
		            date.setTime(date.getTime() - getDSTOffsetInMS(date))
	            }
	            return date;
            }
            catch (e)
            {
            	if (strict)
            		throw (e);
	            return value;
            }
        }

        function format(strict, value, timezone)
        {

            if (strict)
            {
	            utilityFunctions.checkArgTypes([
		            utilityFunctions.checkArgObject(value, 'value', util.isDate),
		            utilityFunctions.checkArgObject(timezone, 'timezone', checkValidTimezone)
	            ]);
            }
	        if (!util.isDate(value))
		        return value;

	        if (isNaN(value.getDay()))
	        {
		        /* (new Date("x")).getDay()     ---> NaN
				 * (new Date("x")).toString()   ---> "INVALID DATE"  // in Chrome, Firefox
				 *
				 * For backwards compatibility, we just log it here.
				 * In new API functions, please handle this case in a fail-fast fashion:
				 *
				 *      utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, ...)
				 */
		        utilityFunctions.logSuiteScriptError(error.Type.INVALID_DATE_OBJECT);
	        }

            timezone = getTimeZone(timezone);
            try {
	            return invoker(dateTimeZoneApi, 'formatWithTimeZone', [value.getTime(), timezone, isDST(value)]);
            }
            catch (e) {
	            if (strict)
	            	throw (e);
	            return value;
            }
        }

	    function isDST(theDate) {
        	// disable the DST check on client since the new browsers with ECMAScript 6 support do not have the issue
       	    return isClient() ? null : getDSTOffsetInMS(theDate) !== 0;
        }

	   function getDSTOffsetInMS (theDate) {
		   var jan = new Date(theDate.getFullYear(), 0, 1);
		   var jul = new Date(theDate.getFullYear(), 6, 1);
		   return (theDate.getTimezoneOffset() - Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset())) * 60000;
	   }


	   return Object.freeze({
			parse: parse.bind(this, false),
			format: format.bind(this, false),
			parseStrict: parse.bind(this, true),
            formatStrict: format.bind(this, true),

            /**
             * @enum
             */
            Timezone: TIME_ZONES
        });
    });
/**
 * SuiteScript module
 *
 * @private
 * @module N/fieldTypeConstants
 * @NApiVersion 2.x
 */
define('N/fieldTypeConstants',[],
       function ()
       {
           var FIELD_TYPES = Object.freeze({
                                               DATE: "date",
                                               TIME: "time",
                                               TIMETRACK: "timetrack",
                                               TIMEOFDAY: "timeofday",
                                               DATETIME: "datetime",
                                               DATETIMETZ: "datetimetz",
                                               INTEGER: "integer",
                                               POSINTEGER: "posinteger",
                                               PERCENT: "percent",
                                               RATE: "rate",
                                               RATEHIGHPRECISION: "ratehighprecision",
											   DYNAMICPRECISION:"dynamicprecision",
	                                           FLOAT: "float",
                                               POSFLOAT: "posfloat",
                                               NONNEGFLOAT: "nonnegfloat",
                                               POSCURRENCY: "poscurrency",
                                               NONNEGCURRENCY: "nonnegcurrency",
                                               CURRENCY: "currency",
                                               CURRENCY2: "currency2",
                                               EMAIL: "email",
                                               EMAILS: "emails",
                                               URL: "url",
                                               CHECKBOX: "checkbox",
                                               CCNUMBER: "ccnumber",
                                               RADIO: "radio",
                                               PHONE: "phone",
                                               FULLPHONE: "fullphone",
                                               IDENTIFIER: "identifier",
                                               IDENTIFIERANYCASE: "identifieranycase",
                                               FUNCTION: "function",
                                               QUOTEDFUNCTION: "'function'",
                                               MMYYDATE: "mmyydate",
                                               CCEXPDATE: "ccexpdate",
                                               CCVALIDFROM: "ccvalidfrom",
                                               COLOR: "color",
                                               PACKAGE: "package",
                                               FURIGANA: "furigana",
                                               ADDRESS: "address",
                                               TEXT: "text",
                                               TEXTAREA: "textarea",
                                               CLOBTEXT: "clobtext",
                                               SELECT: "select",
                                               DOCUMENT: "document",
                                               MULTISELECT: "multiselect",
                                               SUBRECORD_FIELD_TYPE: "summary"
                                           });

	       /**
	        * Determine if given field type is a numeric type.
	        *
	        * @param {Type} fieldType
	        * @returns {boolean} true if fieldType is numeric
	        */
           function isNumeric(fieldType)
           {
           	   return (fieldType === FIELD_TYPES.INTEGER) || (fieldType === FIELD_TYPES.POSINTEGER)
	               || (fieldType === FIELD_TYPES.FLOAT)   || (fieldType === FIELD_TYPES.POSFLOAT)
	               || (fieldType === FIELD_TYPES.NONNEGFLOAT) || (fieldType === FIELD_TYPES.PERCENT)
	               || (fieldType === FIELD_TYPES.RATE) || (fieldType === FIELD_TYPES.RATEHIGHPRECISION);
           }

	       /**
	        * Determine if given field type is a currency type.
	        *
	        * @param {Type} fieldType
	        * @returns {boolean} true if fieldType is currency
	        */
           function isCurrency(fieldType)
           {
           	   return (fieldType === FIELD_TYPES.POSCURRENCY) || (fieldType === FIELD_TYPES.CURRENCY)
	               || (fieldType === FIELD_TYPES.CURRENCY2) || (fieldType === FIELD_TYPES.NONNEGCURRENCY);
           }

			function isSelectType(type)
			{
				return type === FIELD_TYPES.SELECT || type === FIELD_TYPES.MULTISELECT;
			}

			function isMultiSelectType(type)
			{
				return type === FIELD_TYPES.MULTISELECT;
			}

			function isSelectTypeOrRadio(type)
			{
				return isSelectType(type) || type === FIELD_TYPES.RADIO;
			}

			function isRateType(type)
			{
				return type === FIELD_TYPES.RATE || type === FIELD_TYPES.RATEHIGHPRECISION;
			}

           return Object.freeze({
                                    /**
                                     * @enum
                                     */
                                    Type: FIELD_TYPES,

	                                isNumeric: isNumeric,
	                                isCurrency: isCurrency,
	                                isSelectType: isSelectType,
	                                isMultiSelectType: isMultiSelectType,
	                                isSelectTypeOrRadio: isSelectTypeOrRadio,
	                                isRateType: isRateType
                                });
    }
);
/**
 * @private
 */
define('N/restricted/formatApi',['N/internal/reflet'],
	function (reflet)
	{
		return util.extend({bridge: 'formatApi'}, reflet);
	});
/**
 * SuiteScript formatI18nCommon module
 * Contains functions for:
 * 1. spellOut (author: mzurek)
 * 2. number and currency formatting (author: dsteiner)
 * 3. phone number formatting (author: dsteiner)
 *
 * @module N/formatI18nCommon
 * @NApiVersion 2.x
 *
 */
define('N/formatI18nCommon',['N/internal/invoker', 'N/utilityFunctions', 'N/restricted/formatApi', 'N/error', 'N/nsobject'],
	function (invoker, utilityFunctions, formatApi, error, nsobject)
	{
		var phoneFieldMaxLen = -1; //this value says that it must be obtained from Java code before first use
		function getPhoneFieldMaxLength() {
			if (phoneFieldMaxLen === -1) {
				phoneFieldMaxLen = invoker(formatApi, 'getPhoneFieldMaxLength', []);
			}
			return phoneFieldMaxLen;
		}

		var subsidiaryCountry = null;
		function getSubsidiaryCountry() {
			if (!subsidiaryCountry) {
				subsidiaryCountry = invoker(formatApi, 'getSubsidiaryCountry', []);
			}
			return subsidiaryCountry;
		}

		var countryCodes = undefined;
		function _getCountryCodes() {
			if (countryCodes === null || countryCodes === undefined) {
				countryCodes = invoker(formatApi, 'getValidCountryCodes', []);
			}
			return countryCodes;
		}

		// Returns country by country code e.g. (input) US -> (output) UNITEDSTATES
		// @param {string} countryCode
		// @returns {country|undefined|*}
		function _getCountryByCode(countryCode) {
			if (countryCode === undefined || countryCode === null) {
				return countryCode;
			}

			var validCountryCodes = _getCountryCodes();
			for (var country in validCountryCodes) {
				if (countryCode == validCountryCodes[country]) {
					return country;
				}
			}
		}

		function _getSuffixAfterValidPhoneNumber(val)
		{
			var pattern = new RegExp(".*[0-9](.*)");
			var res = pattern.exec(val);
			if (res === null || res === undefined || res.length < 2)
				return "";

			return res[1];
		}

		var NEGATIVE_NUMBER_FORMATS = Object.freeze({
			// constant names must be exactly the same as in Java code (INumberFormatParameters)
			BRACKETS: 'BRACKETS',
			MINUS: 'MINUS'
		});

		// dynamically generated enums (values are found out in Java code, file FormatApi.java)
		var ValidCurrencies = null;
		var PhoneNumberFormatTypes = null;
		var Countries = null;

		/**
		 * Returns number spelled out as a string of words.
		 * @governance none
		 * @param {Object} options
		 * @param {number} options.number Number to be spelled out
		 * @param {string} options.locale Locale code as a string
		 *
		 * @return {string} Number described in words
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if name parameter is missing
		 *
		 * @since 2019.1
		 */
		function doSpellOut(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'format.i18n.spellOut');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var number, locale;

			if (options != null && options.hasOwnProperty("number"))
			{
				number = options.number;
			}

			utilityFunctions.checkArgs([number], ['number'], 'spellOut');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(number, 'number', util.isNumber)]);

			locale = options.locale;

			if (utilityFunctions.isEmpty(locale))
			{
				options.locale = null;
			}
			else
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(locale, 'locale', util.isString)]);
			}

			return invoker(formatApi, 'spellOut', [number, locale], utilityFunctions.isPromiseCallback(this) ? this : null);
		}

		/**
		 * @class NumberFormatter
		 * @classdesc Object which holds all necessary information about number formatting and can perform this.
		 * @constructor
		 * @protected
		 *
		 * @since 2019.2
		 */
		function NumberFormatter(groupSeparator, decimalSeparator, precision, minPrecision, maxPrecision, negativeNumberFormat, locale)
		{
			/**
			 * Group separator
			 * @name NumberFormatter#groupSeparator
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'groupSeparator', {
				get: function () {
					return groupSeparator;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'groupSeparator');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Decimal separator
			 * @name NumberFormatter#decimalSeparator
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'decimalSeparator', {
				get: function () {
					return decimalSeparator;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'decimalSeparator');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Precision
			 * @name NumberFormatter#precision
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'precision', {
				get: function () {
					return precision;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'precision');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * MinPrecision
			 * @name NumberFormatter#minPrecision
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'minPrecision', {
				get: function () {
					return minPrecision;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'minPrecision');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * MaxPrecision
			 * @name NumberFormatter#maxPrecision
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'maxPrecision', {
				get: function () {
					return maxPrecision;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'maxPrecision');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Negative number format
			 * @name NumberFormatter#negativeNumberFormat
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'negativeNumberFormat', {
				get: function () {
					return negativeNumberFormat;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'negativeNumberFormat');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Locale
			 * @name NumberFormatter#locale
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'locale', {
				get: function () {
					return locale;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'locale');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the formatted number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {number} options.number Number to be formatted
			 *
			 * @return {string}
			 *
			 * @since 2019.2
			 */
			this.format = function format(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'NumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.number], ['number'], 'NumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isNumber)]);

				var number = options.number;
				var strNumber = number.toString();
				var idxOfDot = strNumber.indexOf('.');
				var inputNumberPrecision = idxOfDot < 0 ? 0 : strNumber.length - 1 - idxOfDot;

				// determine local minimal precision (locMinPrec) and local maximal precision (locMaxPrec) variables
				// depending on setting: precision, minPrecision, maxPrecision
				var locMinPrec, locMaxPrec;
				if (precision != null)
				{
					locMinPrec = precision;
					locMaxPrec = precision;
				} else {
					locMinPrec = minPrecision;
					locMaxPrec = maxPrecision;
					if (locMinPrec == null)
					{
						locMinPrec = 0;
					} else if (locMaxPrec == null)
					{
						locMaxPrec = Math.max(inputNumberPrecision, locMinPrec);
					}
				}
				// now both: locMinPrec and locMaxPrec contain valid numeric value

				var signPrefix = "",
					signPostfix = "";
				if (number < 0) {
					signPrefix = negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS ? "-" : "(";
					signPostfix = negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS ? "" : ")";
				}

				var wholePart = parseInt(number = Math.abs(number).toFixed(locMaxPrec)) + "";
				var wholePartProcessed = "";

				if (locale === 'en_IN' || locale === 'en-IN') {
					var wholePartTemporary = "";
					var beforeLastSeven = wholePart;

					do {
						var lenOfBeforeLastSeven = beforeLastSeven.length;
						var isShorter = lenOfBeforeLastSeven <= 7;
						var lastSeven = isShorter ? beforeLastSeven : beforeLastSeven.substring(lenOfBeforeLastSeven - 7);
						beforeLastSeven = isShorter ? "" : beforeLastSeven.substring(0, lenOfBeforeLastSeven - 7);

						var lastThree = lastSeven.length <= 3 ? lastSeven : lastSeven.substring(lastSeven.length - 3);
						var otherNumbers = lastSeven.substring(0, lastSeven.length - 3);
						if (otherNumbers != '')
							lastThree = groupSeparator + lastThree;
						wholePartTemporary = otherNumbers.replace(/\B(?=(\d{2})+(?!\d))/g, groupSeparator) + lastThree;

						if (wholePartProcessed.length > 0) {
							wholePartProcessed = wholePartTemporary + groupSeparator + wholePartProcessed;
						} else {
							wholePartProcessed = wholePartTemporary + wholePartProcessed;
						}
					} while (beforeLastSeven.length > 0);
				} else {
					var cntCharsToFirstSep = (cntCharsToFirstSep = wholePart.length) > 3 ? cntCharsToFirstSep % 3 : 0;
					wholePartProcessed = (cntCharsToFirstSep ? wholePart.substr(0, cntCharsToFirstSep) + groupSeparator : "")
						+ wholePart.substr(cntCharsToFirstSep).replace(/(\d{3})(?=\d)/g, "$1" + groupSeparator);
				}

				var clearFractPart = "";
				if (locMaxPrec > 0)
				{
					clearFractPart = Math.abs(number - wholePart).toFixed(locMaxPrec).slice(2);
					for (var i = locMaxPrec-1; i >= locMinPrec; i--)
					{
						if (clearFractPart.charAt(i) === '0')
							clearFractPart = clearFractPart.slice(0, i);
						else
							break;
					}
				}
				var fractionalPartProcessed = clearFractPart.length > 0 ? decimalSeparator + clearFractPart : "";

				return signPrefix + wholePartProcessed + fractionalPartProcessed + signPostfix;
			}

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.2
			 */
			this.toString = function()
			{
				return 'format.i18n.NumberFormatter';
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2019.2
			 */
			this.toJSON = function()
			{
				return {
					groupSeparator: groupSeparator,
					decimalSeparator: decimalSeparator,
					precision: precision,
					minPrecision: minPrecision,
					maxPrecision: maxPrecision,
					negativeNumberFormat: negativeNumberFormat,
					locale: locale
				};
			};
		}

		NumberFormatter.prototype = nsobject.getNewInstance();

		/**
		 * @class CurrencyFormatter
		 * @classdesc Object which holds all necessary information about currency (including number)
		 *                   formatting and can perform this.
		 * @constructor
		 *
		 * @since 2019.2
		 */
		function CurrencyFormatter(currency, locale, symbol, isPrefixSymbol, numberFormatter) {
			/**
			 * Currency
			 * @name CurrencyFormatter#currency
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'currency', {
				get: function () {
					return currency;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'currency');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Locale
			 * @name CurrencyFormatter#locale
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'locale', {
				get: function () {
					return locale;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'locale');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Currency symbol
			 * @name CurrencyFormatter#symbol
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'symbol', {
				get: function () {
					return symbol;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'symbol');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number formatter
			 * @name CurrencyFormatter#numberFormatter
			 * @type {object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'numberFormatter', {
				get: function () {
					return numberFormatter;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'numberFormatter');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the formatted amount with currency symbol
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {number} options.number Number to be formatted as currency string
			 *
			 * @return {string}
			 *
			 * @since 2019.2
			 */
			this.format = function format(options) {
				utilityFunctions.checkArgs([options], ['options'], 'CurrencyFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.number], ['number'], 'CurrencyFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isNumber)]);

				return isPrefixSymbol.valueOf() ? symbol + numberFormatter.format(options) : numberFormatter.format(options) + symbol;
			}

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.2
			 */
			this.toString = function()
			{
				return 'format.i18n.CurrencyFormatter';
			}

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function()
			{
				return {
					currency: currency,
					locale: locale,
					symbol: symbol,
					isPrefixSymbol: isPrefixSymbol,
					numberFormatter: numberFormatter.toJSON()
				};
			};
		}

		CurrencyFormatter.prototype = nsobject.getNewInstance();

		/**
		 * @class PhoneNumber
		 * @classdesc This object holds all necessary information about phone number.
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function PhoneNumber(countryCode, extension, nationalNumber, numberOfLeadingZeros, carrierCode, rawInput) {
			/**
			 * Country code
			 * @name PhoneNumber#countryCode
			 * @type {int}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'countryCode', {
				get: function () {
					return countryCode;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'countryCode');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Extension
			 * @name PhoneNumber#extension
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'extension', {
				get: function () {
					return extension;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'extension');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * National number
			 * @name PhoneNumber#nationalNumber
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'nationalNumber', {
				get: function () {
					return nationalNumber;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nationalNumber');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of leading zeros
			 * @name PhoneNumber#numberOfLeadingZeros
			 * @type {int}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'numberOfLeadingZeros', {
				get: function () {
					return numberOfLeadingZeros;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'numberOfLeadingZeros');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Carrier code
			 * @name PhoneNumber#carrierCode
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'carrierCode', {
				get: function () {
					return carrierCode;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'carrierCode');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Raw input
			 * @name PhoneNumber#rawInput
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'rawInput', {
				get: function () {
					return rawInput;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'rawInput');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					countryCode: countryCode,
					extension: extension,
					nationalNumber: nationalNumber,
					numberOfLeadingZeros: numberOfLeadingZeros,
					carrierCode: carrierCode,
					rawInput: rawInput
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumber';
			};
		}

		PhoneNumber.prototype = nsobject.getNewInstance();

		/**
		 * Object for formatting phone numbers.
		 * @class
		 * @classdesc Method format takes object of type PhoneNumber and returns string.
		 * @constructor
		 * @protected
		 *
		 * @param {string} formatType (enum), to specify required format (e.g. INTERNATIONAL)
		 *
		 * @since 2020.2
		 */
		function PhoneNumberFormatter(formatType) {
			var that = this;

			/**
			 * Format Type
			 * @name PhoneNumberFormatter#formatType
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'formatType', {
				get: function () {
					return formatType;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formatType');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the formatted phone number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {Object} options.number Phone number to be formatted
			 *
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.format = function format(options) { // returns just String so post-processing is not needed here
				utilityFunctions.checkArgs([options], ['options'], 'PhoneNumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				utilityFunctions.checkArgs([options.number], ['number'], 'PhoneNumberFormatter.format');
				var number = options.number;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', function(input){return input instanceof PhoneNumber;})]);

				var stringifiedNumber = JSON.stringify(number);
				var formattedNumber = invoker(formatApi, 'phoneNumberFormat', [stringifiedNumber, formatType], utilityFunctions.isPromiseCallback(this) ? this : undefined);

				if (!utilityFunctions.isPromiseCallback(this))
					return ppPhoneNumberFormatterFormat({result: formattedNumber});
			};

			/**
			 * Asynchronously formats a phone number.
			 * @governance none
			 * @return {Promise}
			 *
			 * @since 2020.2
			 */
			this.format.promise = function()
			{
				return utilityFunctions.promiseTo(that.format, arguments, ppPhoneNumberFormatterFormat);
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					formatType: formatType
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumberFormatter';
			};
		}

		PhoneNumberFormatter.prototype = nsobject.getNewInstance();

		function ppPhoneNumberFormatterFormat(options)
		{
			return options.result;
		}

		/**
		 * Object for parsing phone numbers.
		 * @class
		 * @classdesc Method 'parse' takes string and returns object of PhoneNumber type.
		 * @constructor
		 * @protected
		 *
		 * @param {string} defaultCountry (enum)
		 *
		 * @since 2020.2
		 */
		function PhoneNumberParser(defaultCountry) {
			var that = this;
			/**
			 * Default country
			 * @name PhoneNumberParser#defaultCountry
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'defaultCountry', {
				get: function () {
					return defaultCountry;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'defaultCountry');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns parsed phone number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.number Phone number to be parsed
			 *
			 * @return {PhoneNumber}
			 *
			 * @since 2020.2
			 */
			this.parse = function parse(options) { // post-processing is needed here
				utilityFunctions.checkArgs([options], ['options'], 'PhoneNumberParser.parse');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				utilityFunctions.checkArgs([options.number], ['number'], 'PhoneNumberParser.parse');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isString)]);

				var number = options.number;
				var phoneNumberParams = invoker(formatApi, 'phoneNumberParse', [number, defaultCountry], utilityFunctions.isPromiseCallback(this) ? this : undefined);

				if (!utilityFunctions.isPromiseCallback(this))
					return ppPhoneNumberParserParse({result: phoneNumberParams});
			};

			/**
			 * Asynchronously parses a string containing phone number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.number Phone number to be parsed
			 *
			 * @return {Promise}
			 *
			 * @since 2020.2
			 */
			this.parse.promise = function()
			{
				return utilityFunctions.promiseTo(that.parse, arguments, ppPhoneNumberParserParse);
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					defaultCountry: defaultCountry
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumberParser';
			};
		}

		PhoneNumberParser.prototype = nsobject.getNewInstance();

		function ppPhoneNumberParserParse(options)
		{
			var pnParams = options.result; // all fields of cfParams are string type. so isPrefix must be re-typed to Boolean
			return new PhoneNumber(pnParams.countryCode, pnParams.extension, pnParams.nationalNumber, pnParams.numberOfLeadingZeros,
				pnParams.carrierCode, pnParams.rawInput);
		}

		/**
		 * Returns CurrencyFormatter object, which can format numbers to currency strings
		 * @param {Object} options
		 * @param {string} options.currency (enum) Code of currency used by formatter.
		 * @param {string} options.locale Locale for which the formatter is created.
		 * Just one of these two parameters is mandatory but cannot be used both together.
		 * @governance none
		 * @throws {error.SuiteScriptError} NEITHER_ARGUMENT_DEFINED if both parameters are missing.
		 * @throws {error.SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS When two mutually exclusive arguments are defined.
		 * @throws {error.SuiteScriptError} SSS_INVALID_TYPE_ARG in case of wrong parameter type.
		 * @throws {error.SuiteScriptError} SSS_INVALID_CURRENCY_ID if invalid currency is used.
		 * @throws {error.SuiteScriptError} INVALID_LOCALE if locale parameter is invalid.
		 * @since 2019.2
		 */
		function doGetCurrencyFormatter(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'getCurrencyFormatter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var currency = options.currency;
			var locale = options.locale;

			// Check if exactly one agrgumet is defined
			utilityFunctions.checkMutuallyExclusiveArguments(currency, locale, 'currency', 'locale');

			if (!currency && !locale) {
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'currency', 'locale');
			}

			if (currency) {
				utilityFunctions.checkArgs([options.currency], ['currency'], 'getCurrencyFormatter');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.currency, 'currency', util.isString)]);

				// check if currency is in the list of valid currencies (dynamic enum)
				var validCurrencies = getValidCurrencies(); // check if at least one valid currency exists
				if (validCurrencies === undefined || validCurrencies === null || !(currency in validCurrencies)) {
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, 'getCurrencyFormatter', currency);
				}
				var cfParams = invoker(formatApi, 'getCurrencyFormatParametersForSSClient', [currency], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			} else { // must be locale here
				utilityFunctions.checkArgs([options.locale], ['locale'], 'getCurrencyFormatter');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.locale, 'locale', util.isString)]);

				var cfParams = invoker(formatApi, 'getCurrencyFormatParametersByLocaleForSSClient', [locale], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			}

			if (!utilityFunctions.isPromiseCallback(this))
				return ppCurrencyFormatter({result: cfParams});
		}

		function ppCurrencyFormatter(options)
		{
			var cfParams = options.result; // all fields of cfParams are string type. so isPrefix must be re-typed to Boolean

			var currency = cfParams.currency;
			var locale = cfParams.locale;
			var displaySymbol = cfParams.symbol;
			var isPrefix = new Boolean(cfParams.isPrefixSymbol == 'true');
			var numberFormatter = new NumberFormatter(cfParams.nfGroupSeparator, cfParams.nfDecimalSeparator,
				cfParams.nfPrecision, null, null, cfParams.nfNegativeNumberFormat, locale);

			return new CurrencyFormatter(currency, locale, displaySymbol, isPrefix, numberFormatter);
		}

		/**
		 * Returns NumberFormatter object, which can format numbers to number strings
		 * @governance none
		 * @param {Object} options
		 * @param {string} [options.locale=]               Locale for which the formatter is created
		 * @param {string} [options.groupSeparator=]
		 * @param {string} [options.decimalSeparator=]
		 * @param {number} [options.precision=]
		 * @param {number} [options.minPrecision=]
		 * @param {number} [options.maxPrecision=]
		 * @param {string} [options.negativeNumberFormat=] Negative number format setting comming from NegativeNumberFormat enum
		 * @return {NumberFormatter}
		 *
		 * @since 2019.2
		 */
		function doGetNumberFormatter(options)
		{
			var locale = null;
			var groupSeparator = null;
			var decimalSeparator = null;
			var precision = null;
			var minPrecision = null;
			var maxPrecision = null;
			var negativeNF = null;

			// Arguments which are given -> copy to local variables
			if (options !== undefined && options !== null) { // if at least one argument is present
				utilityFunctions.checkArgs([options], ['options'], 'getNumberFormatter');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				if (options.locale !== undefined && options.locale !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.locale, 'locale', util.isString)]);
					locale = options.locale;
				}

				if (options.groupSeparator !== undefined && options.groupSeparator !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.groupSeparator, 'groupSeparator', util.isString)]);
					groupSeparator = options.groupSeparator;
				}

				if (options.decimalSeparator !== undefined && options.decimalSeparator !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.decimalSeparator, 'decimalSeparator', util.isString)]);
					decimalSeparator = options.decimalSeparator;
				}

				if (options.precision !== undefined && options.precision !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.precision, 'precision', util.isNumber)]);
					precision = Math.max(0, options.precision); // bugfix of entered negative precision
				}

				if (options.minPrecision !== undefined && options.minPrecision !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.minPrecision, 'minPrecision', util.isNumber)]);
					minPrecision = Math.max(0, options.minPrecision); // bugfix of entered negative precision
				}

				if (options.maxPrecision !== undefined && options.maxPrecision !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.maxPrecision, 'maxPrecision', util.isNumber)]);
					maxPrecision = Math.max(0, options.maxPrecision); // bugfix of entered negative precision
				}

				if (options.negativeNumberFormat !== undefined && options.negativeNumberFormat !== null) {
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.negativeNumberFormat, 'negativeNumberFormat', util.isString || util.isObject)]);
					if (options.negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.MINUS || options.negativeNumberFormat == NEGATIVE_NUMBER_FORMATS.BRACKETS) {
						negativeNF = options.negativeNumberFormat; // value outside enum is ignored
					}
				}
			}

			// Checking of correctly given arguments precision, minPrecision, maxPrecision
			// Correct settings are:
			// a) none of them is entered
			// b) only precision is entered
			// c) minPrecision, maxPrecision entered
			// Partially correct settings:
			// a) only minPrecision entered     // b) only maxPrecision entered
			// in these cases the not given argument is set to the value of given argument so both will have the same value

			// Incorrect settings are:
			// - minPrecision > maxPrecision
			// - precision and at least one of min / max precision are given together -> exception mutually exclusive arguments
			utilityFunctions.checkMutuallyExclusiveArguments(precision, minPrecision, 'precision', 'minPrecision');
			utilityFunctions.checkMutuallyExclusiveArguments(precision, maxPrecision, 'precision', 'maxPrecision');

			if (minPrecision!=null && maxPrecision!=null && minPrecision>maxPrecision)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_ARGUMENT_DISCREPANCY, 'minPrecision is greater than maxPrecision');
			}

			// check if exists any null value here -> then DB access has to be performed
			if (groupSeparator == null || decimalSeparator == null || negativeNF == null ||
				(precision == null && minPrecision == null && maxPrecision == null))
			{
				var preProcData = {gs : groupSeparator, ds : decimalSeparator, prec: precision,
					               minPrec: minPrecision, maxPrec: maxPrecision, nnf : negativeNF, loc : locale};
				var numberFormatParams;
				if (locale !== null) {
					numberFormatParams = invoker(formatApi, 'getNumberFormatParametersByLocaleForSSClient', [locale], utilityFunctions.isPromiseCallback(this) ? this.bind(preProcData) : undefined);
				} else {
					numberFormatParams = invoker(formatApi, 'getNumberFormatParametersForSSClient', [], utilityFunctions.isPromiseCallback(this) ? this.bind(preProcData) : undefined);
				}

				if (utilityFunctions.isPromiseCallback(this))
					return;
				else
					return ppNumberFormatter({result: numberFormatParams, data: preProcData});
			}

			return new NumberFormatter(groupSeparator, decimalSeparator, precision, minPrecision, maxPrecision, negativeNF, locale);
		}

		function ppNumberFormatter(options)
		{
			var numberFormatParams = options.result; // values from DB or ICU4J library
			var preProcessedData = options.data;

			if (preProcessedData.gs == null) {
				preProcessedData.gs = numberFormatParams.groupSeparator;
			}
			if (preProcessedData.ds == null) {
				preProcessedData.ds = numberFormatParams.decimalSeparator;
			}
			if (preProcessedData.prec == null && preProcessedData.minPrec == null && preProcessedData.maxPrec == null) {
				preProcessedData.prec = numberFormatParams.precision;
			}
			if (preProcessedData.nnf == null) {
				preProcessedData.nnf = numberFormatParams.negativeNumberFormat;
			}
			if (preProcessedData.loc == null) {
				preProcessedData.loc = numberFormatParams.locale;
			}
			return new NumberFormatter(preProcessedData.gs, preProcessedData.ds, preProcessedData.prec,
				preProcessedData.minPrec, preProcessedData.maxPrec, preProcessedData.nnf, preProcessedData.loc);
		}

		function getValidCurrencies()
		{
			if (! ValidCurrencies)
			{
				ValidCurrencies = invoker(formatApi, 'getValidCurrencies', []);
			}
			return ValidCurrencies;
		}

		function getValidPhoneNumberFormatTypes()
		{
			if (! PhoneNumberFormatTypes)
			{
				PhoneNumberFormatTypes = invoker(formatApi, 'getValidPhoneNumberFormatTypes', []);
			}
			return PhoneNumberFormatTypes;
		}

		function getValidCountries()
		{
			if (! Countries)
			{
				Countries = invoker(formatApi, 'getValidCountries', []);
			}
			return Countries;
		}

		function doGetPhoneNumberFormatter(options)
		{
			var validFormatTypes = getValidPhoneNumberFormatTypes();

			utilityFunctions.checkArgs([options], ['options'], 'getPhoneNumberFormatter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var formatType = null;
			if (options.hasOwnProperty("formatType")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.formatType, 'formatType', function(param){return util.isString(param) || util.isObject(param)})]);
				formatType = options.formatType;
			}

			if (formatType !== null && (validFormatTypes === undefined || !(formatType in validFormatTypes))) {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_FORMAT_TYPE, 'getPhoneNumberFormatter', formatType);
			}

			return new PhoneNumberFormatter(formatType);
		}

		function doGetPhoneNumberParser(options)
		{
			var validCountries = getValidCountries();

			utilityFunctions.checkArgs([options], ['options'], 'getPhoneNumberParser');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var defaultCountry = null;
			if (validCountries.defaultCountryCode && validCountries.defaultCountryCode.length > 0)
			{
				defaultCountry = validCountries.defaultCountryCode;
			}
			else if (options.hasOwnProperty("defaultCountry")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.defaultCountry, 'defaultCountry', function(param){return util.isString(param) || util.isObject(param)})]);
				defaultCountry = options.defaultCountry;
			}

			if (defaultCountry != null && !(defaultCountry in validCountries)) {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_COUNTRY_ID, 'getPhoneNumberParser', defaultCountry);
			}

			return new PhoneNumberParser(defaultCountry);
		}

		return Object.freeze({
			/**
			 * Returns number spelled out as a string of words.
			 *
			 * @param {Object} options
			 * @param {number} options.number Number to be spelled out.
			 * @param {string} options.locale Locale code as a string.
			 *
			 * @return {string} Number described in words.
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if name parameter is missing.
			 *
			 * @since 2019.1
			 */
			spellOut: doSpellOut,

			/**
			 * Returns CurrencyFormatter object, which can format numbers to currency strings
			 * @param {Object} options
			 * @param {string} options.currency Code of currency used by formatter. Comes from enum Currency.
			 * @param {string} options.locale Locale for which the formatter is created.
			 * Just one of these two parameters is mandatory but cannot be used both together.
			 * @governance none
			 * @throws {error.SuiteScriptError} NEITHER_ARGUMENT_DEFINED if both parameters are missing.
			 * @throws {error.SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS When two mutually exclusive arguments are defined.
			 * @throws {error.SuiteScriptError} SSS_INVALID_TYPE_ARG in case of wrong parameter type.
			 * @throws {error.SuiteScriptError} SSS_INVALID_CURRENCY_ID if invalid currency is used.
			 * @throws {error.SuiteScriptError} INVALID_LOCALE if locale parameter is invalid.
			 * @since 2019.2
			 */
			getCurrencyFormatter: doGetCurrencyFormatter,

			/**
			 * Returns NumberFormatter object, which can format numbers to number strings
			 * @governance none
			 * @param {Object} [options=]
			 * @param {string} [options.locale=]           Locale for which the formatter is created
			 * @param {string} [options.groupSeparator=]   Grouping separator (for US: ,)
			 * @param {string} [options.decimalSeparator=] Decimal separator (for US: .)
			 * @param {number} [options.precision=]        Precision - count of decimal digits.
			 * @param {number} [options.minPrecision=]     Minimal precision.
			 * @param {number} [options.maxPrecision=]     Maximal precision.
			 * @param {string} [options.negativeNumberFormat=] Negative number format setting comming from NegativeNumberFormat enum
			 *
			 * @return {NumberFormatter}
			 * @throws {error.SuiteScriptError} INVALID_LOCALE if locale parameter is invalid. We support four letters locales,e.g. ar_KW
			 * @throws {error.SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if two mutually exclusive arguments are defined
			 *         it happens if precision and one of minPrecision, maxPrecision is given concurrently.
			 * @throws {error.SuiteScriptError} SSS_ARGUMENT_DISCREPANCY if minPrecision > maxPrecision
			 * @since 2019.2
			 */
			getNumberFormatter: doGetNumberFormatter,

			// for post-processing
			ppCurrencyFormatter: ppCurrencyFormatter,
			ppNumberFormatter: ppNumberFormatter,

			/**
			 * Holds enum of negative number formats.
			 * Static enum.
			 * @enum {string}
			 * Values: BRACKETS: 'BRACKETS',
			 *         MINUS: 'MINUS'
			 * @readonly
			 * @since 2019.2
			 */
			NegativeNumberFormat: NEGATIVE_NUMBER_FORMATS,

			/**
			 * Holds enum of all allowed currencies.
			 * Dynamic enum - generated.
			 * @enum {string}
			 * @readonly
			 * @since 2019.2
			 *
			 * Values e.g.:  USD
			 *               EUR
			 *               GBP
			 *               JPY
			 *               ... etc depending on company of logged user
			 */
			get Currency() {
				return getValidCurrencies();
			},

			/**
			 * Holds enum of all allowed format types.
			 * This enum mirrors java enum.
			 * @enum {string}
			 * @readonly
			 * @since 2020.2
			 *
			 * There are 4 format types. Values:
			 * RFC3966
			 * NATIONAL
			 * INTERNATIONAL
			 * E164
			 * Default value is INTERNATIONAL
			 */
			get PhoneNumberFormatType() {
				return getValidPhoneNumberFormatTypes();
			},

			/**
			 * Holds enum of all allowed countries. It takes values from Java class com.netledger.platform.format.common.Country.
			 * This enum mirrors java enum Country.
			 * @enum {string}
			 * @readonly
			 * @since 2020.2
			 *
			 * There are many values. E.g.:
			 * ANDORRA
			 * AFGHANISTAN
			 * ...
			 * UNITED_KINGDOM
			 * UNITEDSTATES
			 * ...
			 * ZAMBIA
			 * ZIMBABWE
			 */
			get Country() {
				return getValidCountries();
			},

			/**
			 * Returns Phone number formatter object which can format PhoneNumber objects to strings
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.formatType Specified format type comming from PhoneNumberFormatType enum
			 *
			 * @return {Object} PhoneNumberFormatter
			 *
			 * @throws {error.SuiteScriptError} SSS_INVALID_FORMAT_TYPE if wrong format type is given
			 * @since 2020.2
			 */
			getPhoneNumberFormatter: doGetPhoneNumberFormatter,

			/**
			 * Returns Phone number parser object which can parse strings containing phone number and make PhoneNumber objects from it.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.defaultCountry Specified default country. It comes from enum Country.
			 *        It is used only when country cannot be determined directly from parsed number. This is the defaulting.
			 *
			 * @return {Object} PhoneNumberParser
			 *
			 * @throws {error.SuiteScriptError} SSS_INVALID_COUNTRY_ID if wrong country is given
			 * @since 2020.2
			 */
			getPhoneNumberParser: doGetPhoneNumberParser,

			/**
			 * Returns maximum count of characters in phone field.
			 * @constant
			 * @readonly
			 * @since 2020.2
			 */
			get PhoneFieldMaxLength() {
				return getPhoneFieldMaxLength();
			},

			/**
			 * Returns default subsidiary country.
			 * @readonly
			 * @since 2022.1
			 */
			get SubsidiaryCountry() {
				return getSubsidiaryCountry();
			},

			// internal
			_getCountryCodes: _getCountryCodes,
			_getCountryByCode: _getCountryByCode,
			_getSuffixAfterValidPhoneNumber: _getSuffixAfterValidPhoneNumber
		})
	});

/**
 * SuiteScript libphonenumber module
 * Module for formatting of phone numbers
 *
 * @module N/libphonenumber
 * @suiteScriptVersion 2.x
 */
define('N/libphonenumber',[],function(){
	eval("function libPhoneNumber(t){\"use strict\";var d={version:\"1.7.40\",country_calling_codes:{1:[\"US\",\"AG\",\"AI\",\"AS\",\"BB\",\"BM\",\"BS\",\"CA\",\"DM\",\"DO\",\"GD\",\"GU\",\"JM\",\"KN\",\"KY\",\"LC\",\"MP\",\"MS\",\"PR\",\"SX\",\"TC\",\"TT\",\"VC\",\"VG\",\"VI\"],7:[\"RU\",\"KZ\"],20:[\"EG\"],27:[\"ZA\"],30:[\"GR\"],31:[\"NL\"],32:[\"BE\"],33:[\"FR\"],34:[\"ES\"],36:[\"HU\"],39:[\"IT\",\"VA\"],40:[\"RO\"],41:[\"CH\"],43:[\"AT\"],44:[\"GB\",\"GG\",\"IM\",\"JE\"],45:[\"DK\"],46:[\"SE\"],47:[\"NO\",\"SJ\"],48:[\"PL\"],49:[\"DE\"],51:[\"PE\"],52:[\"MX\"],53:[\"CU\"],54:[\"AR\"],55:[\"BR\"],56:[\"CL\"],57:[\"CO\"],58:[\"VE\"],60:[\"MY\"],61:[\"AU\",\"CC\",\"CX\"],62:[\"ID\"],63:[\"PH\"],64:[\"NZ\"],65:[\"SG\"],66:[\"TH\"],81:[\"JP\"],82:[\"KR\"],84:[\"VN\"],86:[\"CN\"],90:[\"TR\"],91:[\"IN\"],92:[\"PK\"],93:[\"AF\"],94:[\"LK\"],95:[\"MM\"],98:[\"IR\"],211:[\"SS\"],212:[\"MA\",\"EH\"],213:[\"DZ\"],216:[\"TN\"],218:[\"LY\"],220:[\"GM\"],221:[\"SN\"],222:[\"MR\"],223:[\"ML\"],224:[\"GN\"],225:[\"CI\"],226:[\"BF\"],227:[\"NE\"],228:[\"TG\"],229:[\"BJ\"],230:[\"MU\"],231:[\"LR\"],232:[\"SL\"],233:[\"GH\"],234:[\"NG\"],235:[\"TD\"],236:[\"CF\"],237:[\"CM\"],238:[\"CV\"],239:[\"ST\"],240:[\"GQ\"],241:[\"GA\"],242:[\"CG\"],243:[\"CD\"],244:[\"AO\"],245:[\"GW\"],246:[\"IO\"],247:[\"AC\"],248:[\"SC\"],249:[\"SD\"],250:[\"RW\"],251:[\"ET\"],252:[\"SO\"],253:[\"DJ\"],254:[\"KE\"],255:[\"TZ\"],256:[\"UG\"],257:[\"BI\"],258:[\"MZ\"],260:[\"ZM\"],261:[\"MG\"],262:[\"RE\",\"YT\"],263:[\"ZW\"],264:[\"NA\"],265:[\"MW\"],266:[\"LS\"],267:[\"BW\"],268:[\"SZ\"],269:[\"KM\"],290:[\"SH\",\"TA\"],291:[\"ER\"],297:[\"AW\"],298:[\"FO\"],299:[\"GL\"],350:[\"GI\"],351:[\"PT\"],352:[\"LU\"],353:[\"IE\"],354:[\"IS\"],355:[\"AL\"],356:[\"MT\"],357:[\"CY\"],358:[\"FI\",\"AX\"],359:[\"BG\"],370:[\"LT\"],371:[\"LV\"],372:[\"EE\"],373:[\"MD\"],374:[\"AM\"],375:[\"BY\"],376:[\"AD\"],377:[\"MC\"],378:[\"SM\"],380:[\"UA\"],381:[\"RS\"],382:[\"ME\"],383:[\"XK\"],385:[\"HR\"],386:[\"SI\"],387:[\"BA\"],389:[\"MK\"],420:[\"CZ\"],421:[\"SK\"],423:[\"LI\"],500:[\"FK\"],501:[\"BZ\"],502:[\"GT\"],503:[\"SV\"],504:[\"HN\"],505:[\"NI\"],506:[\"CR\"],507:[\"PA\"],508:[\"PM\"],509:[\"HT\"],590:[\"GP\",\"BL\",\"MF\"],591:[\"BO\"],592:[\"GY\"],593:[\"EC\"],594:[\"GF\"],595:[\"PY\"],596:[\"MQ\"],597:[\"SR\"],598:[\"UY\"],599:[\"CW\",\"BQ\"],670:[\"TL\"],672:[\"NF\"],673:[\"BN\"],674:[\"NR\"],675:[\"PG\"],676:[\"TO\"],677:[\"SB\"],678:[\"VU\"],679:[\"FJ\"],680:[\"PW\"],681:[\"WF\"],682:[\"CK\"],683:[\"NU\"],685:[\"WS\"],686:[\"KI\"],687:[\"NC\"],688:[\"TV\"],689:[\"PF\"],690:[\"TK\"],691:[\"FM\"],692:[\"MH\"],850:[\"KP\"],852:[\"HK\"],853:[\"MO\"],855:[\"KH\"],856:[\"LA\"],880:[\"BD\"],886:[\"TW\"],960:[\"MV\"],961:[\"LB\"],962:[\"JO\"],963:[\"SY\"],964:[\"IQ\"],965:[\"KW\"],966:[\"SA\"],967:[\"YE\"],968:[\"OM\"],970:[\"PS\"],971:[\"AE\"],972:[\"IL\"],973:[\"BH\"],974:[\"QA\"],975:[\"BT\"],976:[\"MN\"],977:[\"NP\"],992:[\"TJ\"],993:[\"TM\"],994:[\"AZ\"],995:[\"GE\"],996:[\"KG\"],998:[\"UZ\"]},countries:{AC:[\"247\",\"00\",\"(?:[01589]\\\\d|[46])\\\\d{4}\",[5,6]],AD:[\"376\",\"00\",\"(?:1|6\\\\d)\\\\d{7}|[136-9]\\\\d{5}\",[6,8,9],[[\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"[136-9]\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"1\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6\"]]]],AE:[\"971\",\"00\",\"(?:[4-7]\\\\d|9[0-689])\\\\d{7}|800\\\\d{2,9}|[2-4679]\\\\d{7}\",[5,6,7,8,9,10,11,12],[[\"(\\\\d{3})(\\\\d{2,9})\",\"$1 $2\",[\"60|8\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[236]|[479][2-8]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d)(\\\\d{5})\",\"$1 $2 $3\",[\"[479]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"5\"],\"0$1\"]],\"0\"],AF:[\"93\",\"00\",\"[2-7]\\\\d{8}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2-7]\"],\"0$1\"]],\"0\"],AG:[\"1\",\"011\",\"(?:268|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([457]\\\\d{6})$\",\"268$1\",0,\"268\"],AI:[\"1\",\"011\",\"(?:264|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2457]\\\\d{6})$\",\"264$1\",0,\"264\"],AL:[\"355\",\"00\",\"(?:700\\\\d\\\\d|900)\\\\d{3}|8\\\\d{5,7}|(?:[2-5]|6\\\\d)\\\\d{7}\",[6,7,8,9],[[\"(\\\\d{3})(\\\\d{3,4})\",\"$1 $2\",[\"80|9\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"4[2-6]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2358][2-5]|4\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[23578]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"6\"],\"0$1\"]],\"0\"],AM:[\"374\",\"00\",\"(?:[1-489]\\\\d|55|60|77)\\\\d{6}\",[8],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]0\"],\"0 $1\"],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"2|3[12]\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"1|47\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"[3-9]\"],\"0$1\"]],\"0\"],AO:[\"244\",\"00\",\"[29]\\\\d{8}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[29]\"]]]],AR:[\"54\",\"00\",\"11\\\\d{8}|(?:[2368]|9\\\\d)\\\\d{9}\",[10,11],[[\"(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\"$1 $2-$3\",[\"2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])\",\"2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)\",\"2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]\",\"2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]\"],\"0$1\",1],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2-$3\",[\"1\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[68]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2-$3\",[\"[23]\"],\"0$1\",1],[\"(\\\\d)(\\\\d{4})(\\\\d{2})(\\\\d{4})\",\"$2 15-$3-$4\",[\"9(?:2[2-469]|3[3-578])\",\"9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))\",\"9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)\",\"9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]\",\"9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]\"],\"0$1\",0,\"$1 $2 $3-$4\"],[\"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$2 15-$3-$4\",[\"91\"],\"0$1\",0,\"$1 $2 $3-$4\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$2 15-$3-$4\",[\"9\"],\"0$1\",0,\"$1 $2 $3-$4\"]],\"0\",0,\"0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?\",\"9$1\"],AS:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|684|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([267]\\\\d{6})$\",\"684$1\",0,\"684\"],AT:[\"43\",\"00\",\"1\\\\d{3,12}|2\\\\d{6,12}|43(?:(?:0\\\\d|5[02-9])\\\\d{3,9}|2\\\\d{4,5}|[3467]\\\\d{4}|8\\\\d{4,6}|9\\\\d{4,7})|5\\\\d{4,12}|8\\\\d{7,12}|9\\\\d{8,12}|(?:[367]\\\\d|4[0-24-9])\\\\d{4,11}\",[4,5,6,7,8,9,10,11,12,13],[[\"(\\\\d)(\\\\d{3,12})\",\"$1 $2\",[\"1(?:11|[2-9])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})\",\"$1 $2\",[\"517\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3,5})\",\"$1 $2\",[\"5[079]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3,10})\",\"$1 $2\",[\"(?:31|4)6|51|6(?:5[0-3579]|[6-9])|7(?:20|32|8)|[89]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3,9})\",\"$1 $2\",[\"[2-467]|5[2-6]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"5\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4,7})\",\"$1 $2 $3\",[\"5\"],\"0$1\"]],\"0\"],AU:[\"61\",\"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011\",\"1(?:[0-79]\\\\d{7,8}|8[0-24-9]\\\\d{7})|(?:[2-478]\\\\d\\\\d|550)\\\\d{6}|1\\\\d{4,7}\",[5,6,7,8,9,10],[[\"(\\\\d{2})(\\\\d{3,4})\",\"$1 $2\",[\"16\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2,4})\",\"$1 $2 $3\",[\"16\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"14|[45]\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[2378]\"],\"(0$1)\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1(?:30|[89])\"]]],\"0\",0,\"0|(183[12])\",0,0,0,[[\"(?:[237]\\\\d{5}|8(?:51(?:0(?:0[03-9]|[1247]\\\\d|3[2-9]|5[0-8]|6[1-9]|8[0-6])|1(?:1[69]|[23]\\\\d|4[0-4]))|(?:[6-8]\\\\d{3}|9(?:[02-9]\\\\d\\\\d|1(?:[0-57-9]\\\\d|6[0135-9])))\\\\d))\\\\d{3}\",[9]],[\"483[0-3]\\\\d{5}|4(?:[0-3]\\\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\\\d{6}\",[9]],[\"180(?:0\\\\d{3}|2)\\\\d{3}\",[7,10]],[\"190[0-26]\\\\d{6}\",[10]],0,0,0,[\"16\\\\d{3,7}\",[5,6,7,8,9]],[\"(?:14(?:5(?:1[0458]|[23][458])|71\\\\d)|550\\\\d\\\\d)\\\\d{4}\",[9]],[\"13(?:00\\\\d{3}|45[0-4])\\\\d{3}|13\\\\d{4}\",[6,8,10]]],\"0011\"],AW:[\"297\",\"00\",\"(?:[25-79]\\\\d\\\\d|800)\\\\d{4}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[25-9]\"]]]],AX:[\"358\",\"00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))\",\"2\\\\d{4,9}|35\\\\d{4,5}|(?:60\\\\d\\\\d|800)\\\\d{4,6}|7\\\\d{5,11}|(?:[14]\\\\d|3[0-46-9]|50)\\\\d{4,8}\",[5,6,7,8,9,10,11,12],0,\"0\",0,0,0,0,\"18\",0,\"00\"],AZ:[\"994\",\"00\",\"365\\\\d{6}|(?:[124579]\\\\d|60|88)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"90\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[12]|365\",\"[12]|365\",\"[12]|365(?:[0-46-9]|5[0-35-9])\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[3-9]\"],\"0$1\"]],\"0\"],BA:[\"387\",\"00\",\"6\\\\d{8}|(?:[35689]\\\\d|49|70)\\\\d{6}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6[1-3]|[7-9]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2-$3\",[\"[3-5]|6[56]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"6\"],\"0$1\"]],\"0\"],BB:[\"1\",\"011\",\"(?:246|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-9]\\\\d{6})$\",\"246$1\",0,\"246\"],BD:[\"880\",\"00\",\"[13469]\\\\d{9}|8[0-79]\\\\d{7,8}|[2-7]\\\\d{8}|[2-9]\\\\d{7}|[3-689]\\\\d{6}|[57-9]\\\\d{5}\",[6,7,8,9,10],[[\"(\\\\d{2})(\\\\d{4,6})\",\"$1-$2\",[\"31[5-7]|[459]1\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3,7})\",\"$1-$2\",[\"3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:28|4[14]|5)|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3,6})\",\"$1-$2\",[\"[13-9]\"],\"0$1\"],[\"(\\\\d)(\\\\d{7,8})\",\"$1-$2\",[\"2\"],\"0$1\"]],\"0\"],BE:[\"32\",\"00\",\"4\\\\d{8}|[1-9]\\\\d{7}\",[8,9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"(?:80|9)0\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[239]|4[23]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[15-8]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"4\"],\"0$1\"]],\"0\"],BF:[\"226\",\"00\",\"[025-7]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[025-7]\"]]]],BG:[\"359\",\"00\",\"[2-7]\\\\d{6,7}|[89]\\\\d{6,8}|2\\\\d{5}\",[6,7,8,9],[[\"(\\\\d)(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"2\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"43[1-6]|70[1-9]\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2,3})\",\"$1 $2 $3\",[\"[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"(?:70|8)0\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3\",[\"43[1-7]|7\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[48]|9[08]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"],\"0$1\"]],\"0\"],BH:[\"973\",\"00\",\"[136-9]\\\\d{7}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[13679]|8[047]\"]]]],BI:[\"257\",\"00\",\"(?:[267]\\\\d|31)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2367]\"]]]],BJ:[\"229\",\"00\",\"[2689]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2689]\"]]]],BL:[\"590\",\"00\",\"(?:590|69\\\\d|976)\\\\d{6}\",[9],0,\"0\",0,0,0,0,0,[[\"590(?:2[7-9]|5[12]|87)\\\\d{4}\"],[\"69(?:0\\\\d\\\\d|1(?:2[29]|3[0-5]))\\\\d{4}\"],0,0,0,0,0,0,[\"976[01]\\\\d{5}\"]]],BM:[\"1\",\"011\",\"(?:441|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-8]\\\\d{6})$\",\"441$1\",0,\"441\"],BN:[\"673\",\"00\",\"[2-578]\\\\d{6}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-578]\"]]]],BO:[\"591\",\"00(?:1\\\\d)?\",\"(?:[2-467]\\\\d\\\\d|8001)\\\\d{5}\",[8,9],[[\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"[23]|4[46]\"]],[\"(\\\\d{8})\",\"$1\",[\"[67]\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"]]],\"0\",0,\"0(1\\\\d)?\"],BQ:[\"599\",\"00\",\"(?:[34]1|7\\\\d)\\\\d{5}\",[7],0,0,0,0,0,0,\"[347]\"],BR:[\"55\",\"00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)\",\"(?:[1-46-9]\\\\d\\\\d|5(?:[0-46-9]\\\\d|5[0-24679]))\\\\d{8}|[1-9]\\\\d{9}|[3589]\\\\d{8}|[34]\\\\d{7}\",[8,9,10,11],[[\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"300|4(?:0[02]|37)\",\"4(?:02|37)0|[34]00\"]],[\"(\\\\d{3})(\\\\d{2,3})(\\\\d{4})\",\"$1 $2 $3\",[\"(?:[358]|90)0\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2-$3\",[\"(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]\"],\"($1)\"],[\"(\\\\d{2})(\\\\d{5})(\\\\d{4})\",\"$1 $2-$3\",[\"[16][1-9]|[2-57-9]\"],\"($1)\"]],\"0\",0,\"0(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\\\d{10,11}))?\",\"$2\"],BS:[\"1\",\"011\",\"(?:242|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([3-8]\\\\d{6})$\",\"242$1\",0,\"242\"],BT:[\"975\",\"00\",\"[17]\\\\d{7}|[2-8]\\\\d{6}\",[7,8],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-68]|7[246]\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1[67]|7\"]]]],BW:[\"267\",\"00\",\"90\\\\d{5}|(?:[2-6]|7\\\\d)\\\\d{6}\",[7,8],[[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"90\"]],[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-6]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"7\"]]]],BY:[\"375\",\"810\",\"(?:[12]\\\\d|33|44|902)\\\\d{7}|8(?:0[0-79]\\\\d{5,7}|[1-7]\\\\d{9})|8(?:1[0-489]|[5-79]\\\\d)\\\\d{7}|8[1-79]\\\\d{6,7}|8[0-79]\\\\d{5}|8\\\\d{5}\",[6,7,8,9,10,11],[[\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"800\"],\"8 $1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2,4})\",\"$1 $2 $3\",[\"800\"],\"8 $1\"],[\"(\\\\d{4})(\\\\d{2})(\\\\d{3})\",\"$1 $2-$3\",[\"1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])\",\"1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])\"],\"8 0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"1(?:[56]|7[467])|2[1-3]\"],\"8 0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"[1-4]\"],\"8 0$1\"],[\"(\\\\d{3})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"8 $1\"]],\"8\",0,\"0|80?\",0,0,0,0,\"8~10\"],BZ:[\"501\",\"00\",\"(?:0800\\\\d|[2-8])\\\\d{6}\",[7,11],[[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[2-8]\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{4})(\\\\d{3})\",\"$1-$2-$3-$4\",[\"0\"]]]],CA:[\"1\",\"011\",\"(?:[2-8]\\\\d|90)\\\\d{8}\",[10],0,\"1\",0,0,0,0,0,[[\"(?:2(?:04|[23]6|[48]9|50)|3(?:06|43|65)|4(?:03|1[68]|3[178]|50)|5(?:06|1[49]|48|79|8[17])|6(?:04|13|39|47|72)|7(?:0[59]|78|8[02])|8(?:[06]7|19|25|73)|90[25])[2-9]\\\\d{6}\"],[\"\"],[\"8(?:00|33|44|55|66|77|88)[2-9]\\\\d{6}\"],[\"900[2-9]\\\\d{6}\"],[\"(?:5(?:00|2[12]|33|44|66|77|88)|622)[2-9]\\\\d{6}\"],0,0,0,[\"600[2-9]\\\\d{6}\"]]],CC:[\"61\",\"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011\",\"1(?:[0-79]\\\\d|8[0-24-9])\\\\d{7}|(?:[148]\\\\d\\\\d|550)\\\\d{6}|1\\\\d{5,7}\",[6,7,8,9,10],0,\"0\",0,\"0|([59]\\\\d{7})$\",\"8$1\",0,0,[[\"8(?:51(?:0(?:02|31|60)|118)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\\\d|70[23]|959))\\\\d{3}\",[9]],[\"483[0-3]\\\\d{5}|4(?:[0-3]\\\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\\\d{6}\",[9]],[\"180(?:0\\\\d{3}|2)\\\\d{3}\",[7,10]],[\"190[0-26]\\\\d{6}\",[10]],0,0,0,0,[\"(?:14(?:5(?:1[0458]|[23][458])|71\\\\d)|550\\\\d\\\\d)\\\\d{4}\",[9]],[\"13(?:00\\\\d{3}|45[0-4])\\\\d{3}|13\\\\d{4}\",[6,8,10]]],\"0011\"],CD:[\"243\",\"00\",\"[189]\\\\d{8}|[1-68]\\\\d{6}\",[7,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"88\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"[1-6]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\"]],\"0\"],CF:[\"236\",\"00\",\"(?:[27]\\\\d{3}|8776)\\\\d{4}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[278]\"]]]],CG:[\"242\",\"00\",\"222\\\\d{6}|(?:0\\\\d|80)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"801\"]],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[02]\"]]]],CH:[\"41\",\"00\",\"8\\\\d{11}|[2-9]\\\\d{8}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8[047]|90\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2-79]|81\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"8\"],\"0$1\"]],\"0\"],CI:[\"225\",\"00\",\"[02-9]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[02-9]\"]]]],CK:[\"682\",\"00\",\"[2-578]\\\\d{4}\",[5],[[\"(\\\\d{2})(\\\\d{3})\",\"$1 $2\",[\"[2-578]\"]]]],CL:[\"56\",\"(?:0|1(?:1[0-69]|2[0-57]|5[13-58]|69|7[0167]|8[018]))0\",\"12300\\\\d{6}|6\\\\d{9,10}|[2-9]\\\\d{8}\",[9,10,11],[[\"(\\\\d{5})(\\\\d{4})\",\"$1 $2\",[\"21\"],\"($1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"44\"]],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"2[23]\"],\"($1)\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"9[2-9]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])\"],\"($1)\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"60|8\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"60\"]]]],CM:[\"237\",\"00\",\"(?:[26]\\\\d\\\\d|88)\\\\d{6}\",[8,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"88\"]],[\"(\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"[26]\"]]]],CN:[\"86\",\"00|1(?:[12]\\\\d|79|9[0235-7])\\\\d\\\\d00\",\"1[1279]\\\\d{8,9}|2\\\\d{9}(?:\\\\d{2})?|[12]\\\\d{6,7}|86\\\\d{6}|(?:1[03-68]\\\\d|6)\\\\d{7,9}|(?:[3-579]\\\\d|8[0-57-9])\\\\d{6,9}\",[7,8,9,10,11,12],[[\"(\\\\d{2})(\\\\d{5,6})\",\"$1 $2\",[\"(?:10|2[0-57-9])[19]\",\"(?:10|2[0-57-9])(?:10|9[56])\",\"(?:10|2[0-57-9])(?:100|9[56])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5,6})\",\"$1 $2\",[\"3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]\",\"(?:3(?:[157]\\\\d|35|49|9[1-68])|4(?:[17]\\\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\\\d|4[13]|5[1-5]))[19]\",\"85[23](?:10|95)|(?:3(?:[157]\\\\d|35|49|9[1-68])|4(?:[17]\\\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\\\d|4[13]|5[1-5]))(?:10|9[56])\",\"85[23](?:100|95)|(?:3(?:[157]\\\\d|35|49|9[1-68])|4(?:[17]\\\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\\\d|4[13]|5[1-5]))(?:100|9[56])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"(?:4|80)0\"]],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"10|2(?:[02-57-9]|1[1-9])\",\"10|2(?:[02-57-9]|1[1-9])\",\"10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{7,8})\",\"$1 $2\",[\"9\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"80\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[3-578]\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"1[3-9]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"[12]\"],\"0$1\",1]],\"0\",0,\"0|(1(?:[12]\\\\d|79|9[0235-7])\\\\d\\\\d)\",0,0,0,0,\"00\"],CO:[\"57\",\"00(?:4(?:[14]4|56)|[579])\",\"(?:1\\\\d|3)\\\\d{9}|[124-8]\\\\d{7}\",[8,10,11],[[\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"[14][2-9]|[25-8]\"],\"($1)\"],[\"(\\\\d{3})(\\\\d{7})\",\"$1 $2\",[\"3\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{7})\",\"$1-$2-$3\",[\"1\"],\"0$1\",0,\"$1 $2 $3\"]],\"0\",0,\"0([3579]|4(?:[14]4|56))?\"],CR:[\"506\",\"00\",\"(?:8\\\\d|90)\\\\d{8}|[24-8]\\\\d{7}\",[8,10],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[24-7]|8[3-9]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[89]\"]]],0,0,\"(19(?:0[0-2468]|1[09]|20|66|77|99))\"],CU:[\"53\",\"119\",\"[27]\\\\d{6,7}|[34]\\\\d{5,7}|(?:5|8\\\\d\\\\d)\\\\d{7}\",[6,7,8,10],[[\"(\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"2[1-4]|[34]\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{6,7})\",\"$1 $2\",[\"7\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"5\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{7})\",\"$1 $2\",[\"8\"],\"0$1\"]],\"0\"],CV:[\"238\",\"0\",\"(?:[2-59]\\\\d\\\\d|800)\\\\d{4}\",[7],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[2-589]\"]]]],CW:[\"599\",\"00\",\"(?:[34]1|60|(?:7|9\\\\d)\\\\d)\\\\d{5}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[3467]\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"9[4-8]\"]]],0,0,0,0,0,\"[69]\"],CX:[\"61\",\"001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011\",\"1(?:[0-79]\\\\d|8[0-24-9])\\\\d{7}|(?:[148]\\\\d\\\\d|550)\\\\d{6}|1\\\\d{5,7}\",[6,7,8,9,10],0,\"0\",0,\"0|([59]\\\\d{7})$\",\"8$1\",0,0,[[\"8(?:51(?:0(?:01|30|59)|117)|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\\\d|7(?:0[01]|1[0-2])|958))\\\\d{3}\",[9]],[\"483[0-3]\\\\d{5}|4(?:[0-3]\\\\d|4[047-9]|5[0-25-9]|6[06-9]|7[02-9]|8[0-2457-9]|9[0-27-9])\\\\d{6}\",[9]],[\"180(?:0\\\\d{3}|2)\\\\d{3}\",[7,10]],[\"190[0-26]\\\\d{6}\",[10]],0,0,0,0,[\"(?:14(?:5(?:1[0458]|[23][458])|71\\\\d)|550\\\\d\\\\d)\\\\d{4}\",[9]],[\"13(?:00\\\\d{3}|45[0-4])\\\\d{3}|13\\\\d{4}\",[6,8,10]]],\"0011\"],CY:[\"357\",\"00\",\"(?:[279]\\\\d|[58]0)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"[257-9]\"]]]],CZ:[\"420\",\"00\",\"(?:[2-578]\\\\d|60)\\\\d{7}|9\\\\d{8,11}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-8]|9[015-7]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"9\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"9\"]]]],DE:[\"49\",\"00\",\"[2579]\\\\d{5,14}|49(?:[05]\\\\d{10}|[46][1-8]\\\\d{4,9})|49(?:[0-25]\\\\d|3[1-689]|7[1-7])\\\\d{4,8}|49(?:[0-2579]\\\\d|[34][1-9]|6[0-8])\\\\d{3}|49\\\\d{3,4}|(?:1|[368]\\\\d|4[0-8])\\\\d{3,13}\",[4,5,6,7,8,9,10,11,12,13,14,15],[[\"(\\\\d{2})(\\\\d{3,13})\",\"$1 $2\",[\"3[02]|40|[68]9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3,12})\",\"$1 $2\",[\"2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1\",\"2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{2,11})\",\"$1 $2\",[\"[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]\",\"[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"138\"],\"0$1\"],[\"(\\\\d{5})(\\\\d{2,10})\",\"$1 $2\",[\"3\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5,11})\",\"$1 $2\",[\"181\"],\"0$1\"],[\"(\\\\d{3})(\\\\d)(\\\\d{4,10})\",\"$1 $2 $3\",[\"1(?:3|80)|9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{7,8})\",\"$1 $2\",[\"1[67]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{7,12})\",\"$1 $2\",[\"8\"],\"0$1\"],[\"(\\\\d{5})(\\\\d{6})\",\"$1 $2\",[\"185\",\"1850\",\"18500\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{7})\",\"$1 $2\",[\"18[68]\"],\"0$1\"],[\"(\\\\d{5})(\\\\d{6})\",\"$1 $2\",[\"15[0568]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{7})\",\"$1 $2\",[\"15[1279]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{8})\",\"$1 $2\",[\"18\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{7,8})\",\"$1 $2 $3\",[\"1(?:6[023]|7)\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{2})(\\\\d{7})\",\"$1 $2 $3\",[\"15[279]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{8})\",\"$1 $2 $3\",[\"15\"],\"0$1\"]],\"0\"],DJ:[\"253\",\"00\",\"(?:2\\\\d|77)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[27]\"]]]],DK:[\"45\",\"00\",\"[2-9]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2-9]\"]]]],DM:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|767|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-7]\\\\d{6})$\",\"767$1\",0,\"767\"],DO:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,0,0,0,\"8[024]9\"],DZ:[\"213\",\"00\",\"(?:[1-4]|[5-79]\\\\d|80)\\\\d{7}\",[8,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[1-4]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-8]\"],\"0$1\"]],\"0\"],EC:[\"593\",\"00\",\"1800\\\\d{6,7}|(?:[2-7]|9\\\\d)\\\\d{7}\",[8,9,10,11],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2-$3\",[\"[2-7]\"],\"(0$1)\",0,\"$1-$2-$3\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"1\"]]],\"0\"],EE:[\"372\",\"00\",\"8\\\\d{9}|[4578]\\\\d{7}|(?:[3-8]\\\\d\\\\d|900)\\\\d{4}\",[7,8,10],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]\",\"[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]\"]],[\"(\\\\d{4})(\\\\d{3,4})\",\"$1 $2\",[\"[45]|8(?:00|[1-4])\",\"[45]|8(?:00[1-9]|[1-4])\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"80\"]]]],EG:[\"20\",\"00\",\"[189]\\\\d{8,9}|[24-6]\\\\d{8}|[135]\\\\d{7}\",[8,9,10],[[\"(\\\\d)(\\\\d{7,8})\",\"$1 $2\",[\"[23]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{6,7})\",\"$1 $2\",[\"1[35]|[4-6]|8[2468]|9[235-7]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[189]\"],\"0$1\"]],\"0\"],EH:[\"212\",\"00\",\"[5-8]\\\\d{8}\",[9],0,\"0\",0,0,0,0,\"528[89]\"],ER:[\"291\",\"00\",\"[178]\\\\d{6}\",[7],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[178]\"],\"0$1\"]],\"0\"],ES:[\"34\",\"00\",\"(?:51|[6-9]\\\\d)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]00\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-9]\"]]]],ET:[\"251\",\"00\",\"(?:11|[2-59]\\\\d)\\\\d{7}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-59]\"],\"0$1\"]],\"0\"],FI:[\"358\",\"00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))\",\"[1-35689]\\\\d{4}|7\\\\d{10,11}|(?:[124-7]\\\\d|3[0-46-9])\\\\d{8}|[1-9]\\\\d{5,8}\",[5,6,7,8,9,10,11,12],[[\"(\\\\d)(\\\\d{4,9})\",\"$1 $2\",[\"[2568][1-8]|3(?:0[1-9]|[1-9])|9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3,7})\",\"$1 $2\",[\"[12]00|[368]|70[07-9]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4,8})\",\"$1 $2\",[\"[1245]|7[135]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{6,10})\",\"$1 $2\",[\"7\"],\"0$1\"]],\"0\",0,0,0,0,\"1[03-79]|[2-9]\",0,\"00\"],FJ:[\"679\",\"0(?:0|52)\",\"45\\\\d{5}|(?:0800\\\\d|[235-9])\\\\d{6}\",[7,11],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[235-9]|45\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"0\"]]],0,0,0,0,0,0,0,\"00\"],FK:[\"500\",\"00\",\"[2-7]\\\\d{4}\",[5]],FM:[\"691\",\"00\",\"[39]\\\\d{6}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[39]\"]]]],FO:[\"298\",\"00\",\"(?:[2-8]\\\\d|90)\\\\d{4}\",[6],[[\"(\\\\d{6})\",\"$1\",[\"[2-9]\"]]],0,0,\"(10(?:01|[12]0|88))\"],FR:[\"33\",\"00\",\"[1-9]\\\\d{8}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"8\"],\"0 $1\"],[\"(\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"[1-79]\"],\"0$1\"]],\"0\"],GA:[\"241\",\"00\",\"(?:[067]\\\\d|11)\\\\d{6}|[2-7]\\\\d{6}\",[7,8],[[\"(\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2-7]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"11|[67]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"0\"]]],0,0,\"0(11\\\\d{6}|6[256]\\\\d{6}|7[47]\\\\d{6})\",\"$1\"],GB:[\"44\",\"00\",\"[1-357-9]\\\\d{9}|[18]\\\\d{8}|8\\\\d{6}\",[7,9,10],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"800\",\"8001\",\"80011\",\"800111\",\"8001111\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"845\",\"8454\",\"84546\",\"845464\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"800\"],\"0$1\"],[\"(\\\\d{5})(\\\\d{4,5})\",\"$1 $2\",[\"1(?:38|5[23]|69|76|94)\",\"1(?:(?:38|69)7|5(?:24|39)|768|946)\",\"1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{5,6})\",\"$1 $2\",[\"1(?:[2-69][02-9]|[78])\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[25]|7(?:0|6[02-9])\",\"[25]|7(?:0|6(?:[03-9]|2[356]))\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{6})\",\"$1 $2\",[\"7\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1389]\"],\"0$1\"]],\"0\",0,0,0,0,0,[[\"(?:1(?:(?:1(?:3[0-58]|4[0-5]|5[0-26-9]|6[0-4]|[78][0-49])|3(?:0\\\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\\\d\\\\d|2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\\\d)\\\\d\\\\d|1(?:[0-7]\\\\d\\\\d|80[04589])))|2(?:0[01378]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\\\d{3})\\\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\\\d)|76\\\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\\\d|7[4-79])|295[5-7]|35[34]\\\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\\\d{3}\",[9,10]],[\"7(?:457[0-57-9]|700[01]|911[028])\\\\d{5}|7(?:[1-3]\\\\d\\\\d|4(?:[0-46-9]\\\\d|5[0-689])|5(?:0[0-8]|[13-9]\\\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\\\d|8[02-9]|9[0-689])|8(?:[014-9]\\\\d|[23][0-8])|9(?:[024-9]\\\\d|1[02-9]|3[0-689]))\\\\d{6}\",[10]],[\"80[08]\\\\d{7}|800\\\\d{6}|8001111\"],[\"(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\\\d|8[2-49]))\\\\d{7}|845464\\\\d\",[7,10]],[\"70\\\\d{8}\",[10]],0,[\"(?:3[0347]|55)\\\\d{8}\",[10]],[\"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\",[10]],[\"56\\\\d{8}\",[10]]],0,\" x\"],GD:[\"1\",\"011\",\"(?:473|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-9]\\\\d{6})$\",\"473$1\",0,\"473\"],GE:[\"995\",\"00\",\"(?:[3-57]\\\\d\\\\d|800)\\\\d{6}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"70\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"32\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[57]\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[348]\"],\"0$1\"]],\"0\"],GF:[\"594\",\"00\",\"(?:[56]94|976)\\\\d{6}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[569]\"],\"0$1\"]],\"0\"],GG:[\"44\",\"00\",\"(?:1481|[357-9]\\\\d{3})\\\\d{6}|8\\\\d{6}(?:\\\\d{2})?\",[7,9,10],0,\"0\",0,\"0|([25-9]\\\\d{5})$\",\"1481$1\",0,0,[[\"1481[25-9]\\\\d{5}\",[10]],[\"7(?:(?:781|839)\\\\d|911[17])\\\\d{5}\",[10]],[\"80[08]\\\\d{7}|800\\\\d{6}|8001111\"],[\"(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\\\d|8[0-3]))\\\\d{7}|845464\\\\d\",[7,10]],[\"70\\\\d{8}\",[10]],0,[\"(?:3[0347]|55)\\\\d{8}\",[10]],[\"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\",[10]],[\"56\\\\d{8}\",[10]]]],GH:[\"233\",\"00\",\"(?:[235]\\\\d{3}|800)\\\\d{5}\",[8,9],[[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"8\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[235]\"],\"0$1\"]],\"0\"],GI:[\"350\",\"00\",\"[256]\\\\d{7}\",[8],[[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"2\"]]]],GL:[\"299\",\"00\",\"(?:19|[2-689]\\\\d)\\\\d{4}\",[6],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"19|[2-689]\"]]]],GM:[\"220\",\"00\",\"[2-9]\\\\d{6}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-9]\"]]]],GN:[\"224\",\"00\",\"(?:30|6\\\\d\\\\d|722)\\\\d{6}\",[8,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"3\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[67]\"]]]],GP:[\"590\",\"00\",\"(?:590|69\\\\d|976)\\\\d{6}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[569]\"],\"0$1\"]],\"0\",0,0,0,0,0,[[\"590(?:0[1-68]|1[0-2]|2[0-68]|3[1289]|4[0-24-9]|5[3-579]|6[0189]|7[08]|8[0-689]|9\\\\d)\\\\d{4}\"],[\"69(?:0\\\\d\\\\d|1(?:2[29]|3[0-5]))\\\\d{4}\"],0,0,0,0,0,0,[\"976[01]\\\\d{5}\"]]],GQ:[\"240\",\"00\",\"222\\\\d{6}|(?:3\\\\d|55|[89]0)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[235]\"]],[\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"[89]\"]]]],GR:[\"30\",\"00\",\"5005000\\\\d{3}|(?:[2689]\\\\d|70)\\\\d{8}\",[10],[[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"21|7\"]],[\"(\\\\d{4})(\\\\d{6})\",\"$1 $2\",[\"2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2689]\"]]]],GT:[\"502\",\"00\",\"(?:1\\\\d{3}|[2-7])\\\\d{7}\",[8,11],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2-7]\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]]]],GU:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|671|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([3-9]\\\\d{6})$\",\"671$1\",0,\"671\"],GW:[\"245\",\"00\",\"[49]\\\\d{8}|4\\\\d{6}\",[7,9],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"40\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[49]\"]]]],GY:[\"592\",\"001\",\"(?:862\\\\d|9008)\\\\d{3}|(?:[2-46]\\\\d|77)\\\\d{5}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-46-9]\"]]]],HK:[\"852\",\"00(?:30|5[09]|[126-9]?)\",\"8[0-46-9]\\\\d{6,7}|9\\\\d{4}(?:\\\\d(?:\\\\d(?:\\\\d{4})?)?)?|(?:[235-79]\\\\d|46)\\\\d{6}\",[5,6,7,8,9,11],[[\"(\\\\d{3})(\\\\d{2,5})\",\"$1 $2\",[\"900\",\"9003\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2-7]|8[1-4]|9(?:0[1-9]|[1-8])\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"9\"]]],0,0,0,0,0,0,0,\"00\"],HN:[\"504\",\"00\",\"8\\\\d{10}|[237-9]\\\\d{7}\",[8,11],[[\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"[237-9]\"]]]],HR:[\"385\",\"00\",\"(?:[24-69]\\\\d|3[0-79])\\\\d{7}|80\\\\d{5,7}|[1-79]\\\\d{7}|6\\\\d{5,6}\",[6,7,8,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"6[01]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"8\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[67]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"9\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-5]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"],\"0$1\"]],\"0\"],HT:[\"509\",\"00\",\"[2-489]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[2-489]\"]]]],HU:[\"36\",\"00\",\"[2357]\\\\d{8}|[1-9]\\\\d{7}\",[8,9],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"(06 $1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]\"],\"(06 $1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-57-9]\"],\"06 $1\"]],\"06\"],ID:[\"62\",\"00[189]\",\"(?:(?:007803|8\\\\d{4})\\\\d|[1-36])\\\\d{6}|[1-9]\\\\d{8,10}|[2-9]\\\\d{7}\",[7,8,9,10,11,12,13],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"15\"]],[\"(\\\\d{2})(\\\\d{5,9})\",\"$1 $2\",[\"2[124]|[36]1\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{5,7})\",\"$1 $2\",[\"800\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5,8})\",\"$1 $2\",[\"[2-79]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{3,4})(\\\\d{3})\",\"$1-$2-$3\",[\"8[1-35-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{6,8})\",\"$1 $2\",[\"1\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"804\"],\"0$1\"],[\"(\\\\d{3})(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"80\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4,5})\",\"$1-$2-$3\",[\"8\"],\"0$1\"]],\"0\"],IE:[\"353\",\"00\",\"(?:1\\\\d|[2569])\\\\d{6,8}|4\\\\d{6,9}|7\\\\d{8}|8\\\\d{8,9}\",[7,8,9,10],[[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"2[24-9]|47|58|6[237-9]|9[35-9]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[45]0\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2569]|4[1-69]|7[14]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"70\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"81\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[78]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"]],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"4\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"8\"],\"0$1\"]],\"0\"],IL:[\"972\",\"0(?:0|1[2-9])\",\"1\\\\d{6}(?:\\\\d{3,5})?|[57]\\\\d{8}|[1-489]\\\\d{7}\",[7,8,9,10,11,12],[[\"(\\\\d{4})(\\\\d{3})\",\"$1-$2\",[\"125\"]],[\"(\\\\d{4})(\\\\d{2})(\\\\d{2})\",\"$1-$2-$3\",[\"121\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[2-489]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"[57]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3\",[\"12\"]],[\"(\\\\d{4})(\\\\d{6})\",\"$1-$2\",[\"159\"]],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3-$4\",[\"1[7-9]\"]],[\"(\\\\d{3})(\\\\d{1,2})(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3-$4\",[\"15\"]]],\"0\"],IM:[\"44\",\"00\",\"1624\\\\d{6}|(?:[3578]\\\\d|90)\\\\d{8}\",[10],0,\"0\",0,\"0|([5-8]\\\\d{5})$\",\"1624$1\",0,\"74576|(?:16|7[56])24\"],IN:[\"91\",\"00\",\"(?:000800|[2-9]\\\\d\\\\d)\\\\d{7}|1\\\\d{7,12}\",[8,9,10,11,12,13],[[\"(\\\\d{8})\",\"$1\",[\"5(?:0|2[23]|3[03]|[67]1|88)\",\"5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)\",\"5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)\"],0,1],[\"(\\\\d{4})(\\\\d{4,5})\",\"$1 $2\",[\"180\",\"1800\"],0,1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"140\"],0,1],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"11|2[02]|33|4[04]|79[1-7]|80[2-46]\",\"11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])\",\"11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]\",\"1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]\",\"1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]\"],\"0$1\",1],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807\",\"1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]\",\"1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\\\d|7(?:1(?:[013-8]\\\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\\\d|5[0-367])|70[13-7]))[2-7]\"],\"0$1\",1],[\"(\\\\d{5})(\\\\d{5})\",\"$1 $2\",[\"[6-9]\"],\"0$1\",1],[\"(\\\\d{4})(\\\\d{2,4})(\\\\d{4})\",\"$1 $2 $3\",[\"1(?:6|8[06])\",\"1(?:6|8[06]0)\"],0,1],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"18\"],0,1]],\"0\"],IO:[\"246\",\"00\",\"3\\\\d{6}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"3\"]]]],IQ:[\"964\",\"00\",\"(?:1|7\\\\d\\\\d)\\\\d{7}|[2-6]\\\\d{7,8}\",[8,9,10],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-6]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\"]],\"0\"],IR:[\"98\",\"00\",\"[1-9]\\\\d{9}|(?:[1-8]\\\\d\\\\d|9)\\\\d{3,4}\",[4,5,6,7,10],[[\"(\\\\d{4,5})\",\"$1\",[\"96\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4,5})\",\"$1 $2\",[\"(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"9\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-8]\"],\"0$1\"]],\"0\"],IS:[\"354\",\"00|1(?:0(?:01|[12]0)|100)\",\"(?:38\\\\d|[4-9])\\\\d{6}\",[7,9],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[4-9]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"3\"]]],0,0,0,0,0,0,0,\"00\"],IT:[\"39\",\"00\",\"0\\\\d{5,10}|3[0-8]\\\\d{7,10}|55\\\\d{8}|8\\\\d{5}(?:\\\\d{2,4})?|(?:1\\\\d|39)\\\\d{7,8}\",[6,7,8,9,10,11],[[\"(\\\\d{2})(\\\\d{4,6})\",\"$1 $2\",[\"0[26]\"]],[\"(\\\\d{3})(\\\\d{3,6})\",\"$1 $2\",[\"0[13-57-9][0159]|8(?:03|4[17]|9[245])\",\"0[13-57-9][0159]|8(?:03|4[17]|9(?:2|[45][0-4]))\"]],[\"(\\\\d{4})(\\\\d{2,6})\",\"$1 $2\",[\"0(?:[13-579][2-46-8]|8[236-8])\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"894\"]],[\"(\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"0[26]|5\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"1[4679]|[38]\"]],[\"(\\\\d{3})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"0[13-57-9][0159]\"]],[\"(\\\\d{2})(\\\\d{4})(\\\\d{5})\",\"$1 $2 $3\",[\"0[26]\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"0\"]],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4,5})\",\"$1 $2 $3\",[\"3\"]]],0,0,0,0,0,0,[[\"0669[0-79]\\\\d{1,6}|0(?:1(?:[0159]\\\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\\\d\\\\d|3(?:[0159]\\\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\\\d|6[0-8])|7(?:[0159]\\\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\\\d{2,7}\"],[\"3[1-9]\\\\d{8}|3[2-9]\\\\d{7}\",[9,10]],[\"80(?:0\\\\d{3}|3)\\\\d{3}\",[6,9]],[\"(?:0878\\\\d\\\\d|89(?:2|4[5-9]\\\\d))\\\\d{3}|89[45][0-4]\\\\d\\\\d|(?:1(?:44|6[346])|89(?:5[5-9]|9))\\\\d{6}\",[6,8,9,10]],[\"1(?:78\\\\d|99)\\\\d{6}\",[9,10]],0,0,0,[\"55\\\\d{8}\",[10]],[\"84(?:[08]\\\\d{3}|[17])\\\\d{3}\",[6,9]]]],JE:[\"44\",\"00\",\"1534\\\\d{6}|(?:[3578]\\\\d|90)\\\\d{8}\",[10],0,\"0\",0,\"0|([0-24-8]\\\\d{5})$\",\"1534$1\",0,0,[[\"1534[0-24-8]\\\\d{5}\"],[\"7(?:(?:(?:50|82)9|937)\\\\d|7(?:00[378]|97[7-9]))\\\\d{5}\"],[\"80(?:07(?:35|81)|8901)\\\\d{4}\"],[\"(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\\\d{4}\"],[\"701511\\\\d{4}\"],0,[\"(?:3(?:0(?:07(?:35|81)|8901)|3\\\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\\\d{4})\\\\d{4}\"],[\"76(?:0[0-2]|2[356]|34|4[0134]|5[49]|6[0-369]|77|81|9[39])\\\\d{6}\"],[\"56\\\\d{8}\"]]],JM:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|658|900)\\\\d{7}\",[10],0,\"1\",0,0,0,0,\"658|876\"],JO:[\"962\",\"00\",\"900\\\\d{5}|(?:(?:[268]|7\\\\d)\\\\d|32|53)\\\\d{6}\",[8,9],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2356]|87\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{5,6})\",\"$1 $2\",[\"[89]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"70\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\"]],\"0\"],JP:[\"81\",\"010\",\"00[1-9]\\\\d{6,14}|[257-9]\\\\d{9}|(?:00|[1-9]\\\\d\\\\d)\\\\d{6}\",[8,9,10,11,12,13,14,15,16,17],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1-$2-$3\",[\"(?:12|57|99)0\"],\"0$1\"],[\"(\\\\d{4})(\\\\d)(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51|63)|9(?:49|80|9[16])\",\"1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[78]|96)|477|51[24]|636)|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]\",\"1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[78]|96[2457-9])|477|51[24]|636[2-57-9])|9(?:496|802|9(?:1[23]|69))|1(?:45|58)[67]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"60\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"[36]|4(?:2[09]|7[01])\",\"[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[279]|49|6[0-24-689]|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])\",\"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9])|5(?:2|3[045]|4[0-369]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|49|6(?:[0-24]|5[0-3589]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:49|55|83)[29]|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:47[59]|59[89]|8(?:6[68]|9))[019]\",\"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]\",\"1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[0468][01]|[1-3]|5[0-69]|7[015-9]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17|3[015-9]))|4(?:2(?:[13-79]|2[01]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3[045]|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9(?:[019]|4[1-3]|6(?:[0-47-9]|5[01346-9])))|3(?:[29]|7(?:[017-9]|6[6-8]))|49|6(?:[0-24]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:223|8699)[014-9]|(?:48|829(?:2|66)|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3\",[\"[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3[3-8]|5[2-9])\",\"[14]|[29][2-9]|5[3-9]|7[2-4679]|8(?:[246-9]|3(?:[3-6][2-9]|7|8[2-5])|5[2-9])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"800\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"[2579]|80\"],\"0$1\"]],\"0\"],KE:[\"254\",\"000\",\"(?:[17]\\\\d\\\\d|900)\\\\d{6}|(?:2|80)0\\\\d{6,7}|[4-6]\\\\d{6,8}\",[7,8,9,10],[[\"(\\\\d{2})(\\\\d{5,7})\",\"$1 $2\",[\"[24-6]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"[17]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\"]],\"0\"],KG:[\"996\",\"00\",\"8\\\\d{9}|(?:[235-8]\\\\d|99)\\\\d{7}\",[9,10],[[\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"3(?:1[346]|[24-79])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[235-79]|88\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d)(\\\\d{2,3})\",\"$1 $2 $3 $4\",[\"8\"],\"0$1\"]],\"0\"],KH:[\"855\",\"00[14-9]\",\"1\\\\d{9}|[1-9]\\\\d{7,8}\",[8,9,10],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[1-9]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"]]],\"0\"],KI:[\"686\",\"00\",\"(?:[37]\\\\d|6[0-79])\\\\d{6}|(?:[2-48]\\\\d|50)\\\\d{3}\",[5,8],0,\"0\"],KM:[\"269\",\"00\",\"[3478]\\\\d{6}\",[7],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[3478]\"]]]],KN:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-7]\\\\d{6})$\",\"869$1\",0,\"869\"],KP:[\"850\",\"00|99\",\"85\\\\d{6}|(?:19\\\\d|2)\\\\d{7}\",[8,10],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\"]],\"0\"],KR:[\"82\",\"00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))\",\"00[1-9]\\\\d{8,11}|(?:[12]|5\\\\d{3})\\\\d{7}|[13-6]\\\\d{9}|(?:[1-6]\\\\d|80)\\\\d{7}|[3-6]\\\\d{4,5}|(?:00|7)0\\\\d{8}\",[5,6,8,9,10,11,12,13,14],[[\"(\\\\d{2})(\\\\d{3,4})\",\"$1-$2\",[\"(?:3[1-3]|[46][1-4]|5[1-5])1\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"1\"]],[\"(\\\\d)(\\\\d{3,4})(\\\\d{4})\",\"$1-$2-$3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1-$2-$3\",[\"60|8\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1-$2-$3\",[\"[1346]|5[1-5]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1-$2-$3\",[\"[57]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{5})(\\\\d{4})\",\"$1-$2-$3\",[\"5\"],\"0$1\"]],\"0\",0,\"0(8(?:[1-46-8]|5\\\\d\\\\d))?\"],KW:[\"965\",\"00\",\"(?:18|[2569]\\\\d\\\\d)\\\\d{5}\",[7,8],[[\"(\\\\d{4})(\\\\d{3,4})\",\"$1 $2\",[\"[169]|2(?:[235]|4[1-35-9])|52\"]],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[25]\"]]]],KY:[\"1\",\"011\",\"(?:345|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-9]\\\\d{6})$\",\"345$1\",0,\"345\"],KZ:[\"7\",\"810\",\"33622\\\\d{5}|(?:7\\\\d|80)\\\\d{8}\",[10],0,\"8\",0,0,0,0,\"33|7\",0,\"8~10\"],LA:[\"856\",\"00\",\"(?:2\\\\d|3)\\\\d{8}|(?:[235-8]\\\\d|41)\\\\d{6}\",[8,9,10],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2[13]|3[14]|[4-8]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"3\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"2\"],\"0$1\"]],\"0\"],LB:[\"961\",\"00\",\"[7-9]\\\\d{7}|[13-9]\\\\d{6}\",[7,8],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[7-9]\"]]],\"0\"],LC:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|758|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-7]\\\\d{6})$\",\"758$1\",0,\"758\"],LI:[\"423\",\"00\",\"90\\\\d{5}|(?:[2378]|6\\\\d\\\\d)\\\\d{6}\",[7,9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[237-9]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"69\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6\"]]],\"0\",0,\"0|(1001)\"],LK:[\"94\",\"00\",\"(?:[1-7]\\\\d|[89]1)\\\\d{7}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[1-689]\"],\"0$1\"]],\"0\"],LR:[\"231\",\"00\",\"(?:2|33|5\\\\d|77|88)\\\\d{7}|[45]\\\\d{6}\",[7,8,9],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[45]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[3578]\"],\"0$1\"]],\"0\"],LS:[\"266\",\"00\",\"(?:[256]\\\\d\\\\d|800)\\\\d{5}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2568]\"]]]],LT:[\"370\",\"00\",\"(?:[3469]\\\\d|52|[78]0)\\\\d{6}\",[8],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"52[0-79]\"],\"(8-$1)\",1],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[7-9]\"],\"8 $1\",1],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"37|4(?:[15]|6[1-8])\"],\"(8-$1)\",1],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[3-6]\"],\"(8-$1)\",1]],\"8\",0,\"[08]\"],LU:[\"352\",\"00\",\"35[013-9]\\\\d{4,8}|6\\\\d{8}|35\\\\d{2,4}|(?:[2457-9]\\\\d|3[0-46-9])\\\\d{2,9}\",[4,5,6,7,8,9,10,11],[[\"(\\\\d{2})(\\\\d{3})\",\"$1 $2\",[\"2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"20[2-689]\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,2})\",\"$1 $2 $3 $4\",[\"2(?:[0367]|4[3-8])\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"80[01]|90[015]\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"20\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,2})\",\"$1 $2 $3 $4 $5\",[\"2(?:[0367]|4[3-8])\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{1,5})\",\"$1 $2 $3 $4\",[\"[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]\"]]],0,0,\"(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\\\d)\"],LV:[\"371\",\"00\",\"(?:[268]\\\\d|90)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[269]|8[01]\"]]]],LY:[\"218\",\"00\",\"[2-9]\\\\d{8}\",[9],[[\"(\\\\d{2})(\\\\d{7})\",\"$1-$2\",[\"[2-9]\"],\"0$1\"]],\"0\"],MA:[\"212\",\"00\",\"[5-8]\\\\d{8}\",[9],[[\"(\\\\d{5})(\\\\d{4})\",\"$1-$2\",[\"5(?:29|38)\",\"5(?:29|38)[89]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"5[45]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{5})\",\"$1-$2\",[\"5(?:2[2-489]|3[5-9]|9)|892\",\"5(?:2(?:[2-49]|8[235-9])|3[5-9]|9)|892\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1-$2\",[\"8\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{6})\",\"$1-$2\",[\"[5-7]\"],\"0$1\"]],\"0\",0,0,0,0,0,[[\"5(?:29(?:[189]0|29)|38[89]0)\\\\d{4}|5(?:2(?:[015-7]\\\\d|2[02-9]|3[0-578]|4[2-46-8]|8[0235-7]|90)|3(?:[0-47]\\\\d|5[2-9]|6[02-8]|80|9[3-9])|(?:4[067]|5[03])\\\\d)\\\\d{5}\"],[\"(?:6(?:[0-79]\\\\d|8[0-247-9])|7(?:0[016-8]|6[1267]|7[0-27]))\\\\d{6}\"],[\"80\\\\d{7}\"],[\"89\\\\d{7}\"],0,0,0,0,[\"592(?:4[0-2]|93)\\\\d{4}\"]]],MC:[\"377\",\"00\",\"870\\\\d{5}|(?:[349]|6\\\\d)\\\\d{7}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"4\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[39]\"]],[\"(\\\\d)(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4 $5\",[\"6\"],\"0$1\"]],\"0\"],MD:[\"373\",\"00\",\"(?:[235-7]\\\\d|[89]0)\\\\d{6}\",[8],[[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[89]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"22|3\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[25-7]\"],\"0$1\"]],\"0\"],ME:[\"382\",\"00\",\"(?:20|[3-79]\\\\d)\\\\d{6}|80\\\\d{6,7}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[2-9]\"],\"0$1\"]],\"0\"],MF:[\"590\",\"00\",\"(?:590|69\\\\d|976)\\\\d{6}\",[9],0,\"0\",0,0,0,0,0,[[\"590(?:0[079]|[14]3|[27][79]|30|5[0-268]|87)\\\\d{4}\"],[\"69(?:0\\\\d\\\\d|1(?:2[29]|3[0-5]))\\\\d{4}\"],0,0,0,0,0,0,[\"976[01]\\\\d{5}\"]]],MG:[\"261\",\"00\",\"[23]\\\\d{8}\",[9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[23]\"],\"0$1\"]],\"0\",0,\"0|([24-9]\\\\d{6})$\",\"20$1\"],MH:[\"692\",\"011\",\"329\\\\d{4}|(?:[256]\\\\d|45)\\\\d{5}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[2-6]\"]]],\"1\"],MK:[\"389\",\"00\",\"[2-578]\\\\d{7}\",[8],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[347]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[58]\"],\"0$1\"]],\"0\"],ML:[\"223\",\"00\",\"[24-9]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[24-9]\"]]]],MM:[\"95\",\"00\",\"1\\\\d{5,7}|95\\\\d{6}|(?:[4-7]|9[0-46-9])\\\\d{6,8}|(?:2|8\\\\d)\\\\d{5,8}\",[6,7,8,9,10],[[\"(\\\\d)(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"16|2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[45]|6(?:0[23]|[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-6]\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[12]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[4-7]|8[1-35]\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{4,6})\",\"$1 $2 $3\",[\"9(?:2[0-4]|[35-9]|4[137-9])\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"92\"],\"0$1\"],[\"(\\\\d)(\\\\d{5})(\\\\d{4})\",\"$1 $2 $3\",[\"9\"],\"0$1\"]],\"0\"],MN:[\"976\",\"001\",\"[12]\\\\d{7,9}|[57-9]\\\\d{7}\",[8,9,10],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[12]1\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[57-9]\"]],[\"(\\\\d{3})(\\\\d{5,6})\",\"$1 $2\",[\"[12]2[1-3]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{5,6})\",\"$1 $2\",[\"[12](?:27|3[2-8]|4[2-68]|5[1-4689])\",\"[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]\"],\"0$1\"],[\"(\\\\d{5})(\\\\d{4,5})\",\"$1 $2\",[\"[12]\"],\"0$1\"]],\"0\"],MO:[\"853\",\"00\",\"(?:28|[68]\\\\d)\\\\d{6}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[268]\"]]]],MP:[\"1\",\"011\",\"[58]\\\\d{9}|(?:67|90)0\\\\d{7}\",[10],0,\"1\",0,\"1|([2-9]\\\\d{6})$\",\"670$1\",0,\"670\"],MQ:[\"596\",\"00\",\"69\\\\d{7}|(?:59|97)6\\\\d{6}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[569]\"],\"0$1\"]],\"0\"],MR:[\"222\",\"00\",\"(?:[2-4]\\\\d\\\\d|800)\\\\d{5}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2-48]\"]]]],MS:[\"1\",\"011\",\"66449\\\\d{5}|(?:[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|(4\\\\d{6})$\",\"664$1\",0,\"664\"],MT:[\"356\",\"00\",\"3550\\\\d{4}|(?:[2579]\\\\d\\\\d|800)\\\\d{5}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2357-9]\"]]]],MU:[\"230\",\"0(?:0|[24-7]0|3[03])\",\"(?:[2-468]|5\\\\d)\\\\d{6}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-46]|8[013]\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"5\"]]],0,0,0,0,0,0,0,\"020\"],MV:[\"960\",\"0(?:0|19)\",\"(?:800|9[0-57-9]\\\\d)\\\\d{7}|[34679]\\\\d{6}\",[7,10],[[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[3467]|9[13-9]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"]]],0,0,0,0,0,0,0,\"00\"],MW:[\"265\",\"00\",\"1\\\\d{6}(?:\\\\d{2})?|(?:[23]1|77|88|99)\\\\d{7}\",[7,9],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[2-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"3\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[17-9]\"],\"0$1\"]],\"0\"],MX:[\"52\",\"0[09]\",\"(?:1(?:[01467]\\\\d|[2359][1-9]|8[1-79])|[2-9]\\\\d)\\\\d{8}\",[10,11],[[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"33|5[56]|81\"],0,1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2-9]\"],0,1],[\"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$2 $3 $4\",[\"1(?:33|5[56]|81)\"],0,1],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$2 $3 $4\",[\"1\"],0,1]],\"01\",0,\"0(?:[12]|4[45])|1\",0,0,0,0,\"00\"],MY:[\"60\",\"00\",\"1\\\\d{8,9}|(?:3\\\\d|[4-9])\\\\d{7}\",[8,9,10],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"[4-79]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1-$2 $3\",[\"1(?:[02469]|[37][2-9]|8[1-9])|8\"],\"0$1\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1-$2 $3\",[\"3\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1-$2-$3-$4\",[\"1[36-8]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"15\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1-$2 $3\",[\"1\"],\"0$1\"]],\"0\"],MZ:[\"258\",\"00\",\"(?:2|8\\\\d)\\\\d{7}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2|8[2-7]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"8\"]]]],NA:[\"264\",\"00\",\"[68]\\\\d{7,8}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"88\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"6\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"87\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"],\"0$1\"]],\"0\"],NC:[\"687\",\"00\",\"[2-57-9]\\\\d{5}\",[6],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1.$2.$3\",[\"[2-57-9]\"]]]],NE:[\"227\",\"00\",\"[0289]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"08\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[089]|2[01]\"]]]],NF:[\"672\",\"00\",\"[13]\\\\d{5}\",[6],[[\"(\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"1\"]],[\"(\\\\d)(\\\\d{5})\",\"$1 $2\",[\"3\"]]],0,0,\"([0-258]\\\\d{4})$\",\"3$1\"],NG:[\"234\",\"009\",\"(?:[124-7]|9\\\\d{3})\\\\d{6}|[1-9]\\\\d{7}|[78]\\\\d{9,13}\",[7,8,10,11,12,13,14],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"78\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[12]|9(?:0[3-9]|[1-9])\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2,3})\",\"$1 $2 $3\",[\"[3-7]|8[2-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[7-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4,5})\",\"$1 $2 $3\",[\"[78]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5})(\\\\d{5,6})\",\"$1 $2 $3\",[\"[78]\"],\"0$1\"]],\"0\"],NI:[\"505\",\"00\",\"(?:1800|[25-8]\\\\d{3})\\\\d{4}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[125-8]\"]]]],NL:[\"31\",\"00\",\"(?:[124-7]\\\\d\\\\d|3(?:[02-9]\\\\d|1[0-8]))\\\\d{6}|[89]\\\\d{6,9}|1\\\\d{4,5}\",[5,6,7,8,9,10],[[\"(\\\\d{3})(\\\\d{4,7})\",\"$1 $2\",[\"[89]0\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"66\"],\"0$1\"],[\"(\\\\d)(\\\\d{8})\",\"$1 $2\",[\"6\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1[16-8]|2[259]|3[124]|4[17-9]|5[124679]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-57-9]\"],\"0$1\"]],\"0\"],NO:[\"47\",\"00\",\"(?:0|[2-9]\\\\d{3})\\\\d{4}\",[5,8],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[489]|5[89]\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[235-7]\"]]],0,0,0,0,0,\"[02-689]|7[0-8]\"],NP:[\"977\",\"00\",\"9\\\\d{9}|[1-9]\\\\d{7}\",[8,10],[[\"(\\\\d)(\\\\d{7})\",\"$1-$2\",[\"1[2-6]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{6})\",\"$1-$2\",[\"[1-8]|9(?:[1-579]|6[2-6])\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{7})\",\"$1-$2\",[\"9\"]]],\"0\"],NR:[\"674\",\"00\",\"(?:444|55\\\\d|888)\\\\d{4}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[458]\"]]]],NU:[\"683\",\"00\",\"(?:[47]|888\\\\d)\\\\d{3}\",[4,7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"8\"]]]],NZ:[\"64\",\"0(?:0|161)\",\"2\\\\d{7,9}|(?:[34]\\\\d|6[0-35-9])\\\\d{6}|(?:508|[79]\\\\d)\\\\d{6,7}|8\\\\d{4,9}\",[5,6,7,8,9,10],[[\"(\\\\d{2})(\\\\d{3,8})\",\"$1 $2\",[\"83\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"[89]0\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1-$2 $3\",[\"24|[346]|7[2-57-9]|9[2-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2(?:10|74)|[59]|80\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"2[028]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,5})\",\"$1 $2 $3\",[\"2(?:[169]|7[0-35-9])|7|86\"],\"0$1\"]],\"0\",0,0,0,0,0,0,\"00\"],OM:[\"968\",\"00\",\"(?:[279]\\\\d{3}|500)\\\\d{4}|8007\\\\d{4,5}\",[7,8,9],[[\"(\\\\d{3})(\\\\d{4,6})\",\"$1 $2\",[\"[58]\"]],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"2\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[79]\"]]]],PA:[\"507\",\"00\",\"(?:[1-57-9]|6\\\\d)\\\\d{6}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[1-57-9]\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1-$2\",[\"6\"]]]],PE:[\"51\",\"19(?:1[124]|77|90)00\",\"(?:[14-8]|9\\\\d)\\\\d{7}\",[8,9],[[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"80\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"1\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"[4-8]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"]]],\"0\",0,0,0,0,0,0,0,\" Anexo \"],PF:[\"689\",\"00\",\"[48]\\\\d{7}|4\\\\d{5}\",[6,8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"44\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[48]\"]]]],PG:[\"675\",\"00|140[1-3]\",\"(?:180|[78]\\\\d{3})\\\\d{4}|(?:[2-589]\\\\d|64)\\\\d{5}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"18|[2-69]|85\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[78]\"]]],0,0,0,0,0,0,0,\"00\"],PH:[\"63\",\"00\",\"1800\\\\d{7,9}|(?:2|[89]\\\\d{4})\\\\d{5}|[2-8]\\\\d{8}|[28]\\\\d{7}\",[6,8,9,10,11,12,13],[[\"(\\\\d)(\\\\d{5})\",\"$1 $2\",[\"2\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"(0$1)\"],[\"(\\\\d{4})(\\\\d{4,6})\",\"$1 $2\",[\"3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2\",\"3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))\"],\"(0$1)\"],[\"(\\\\d{5})(\\\\d{4})\",\"$1 $2\",[\"346|4(?:27|9[35])|883\",\"3469|4(?:279|9(?:30|56))|8834\"],\"(0$1)\"],[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[3-7]|8[2-8]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]],[\"(\\\\d{4})(\\\\d{1,2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3 $4\",[\"1\"]]],\"0\"],PK:[\"92\",\"00\",\"122\\\\d{6}|[24-8]\\\\d{10,11}|9(?:[013-9]\\\\d{8,10}|2(?:[01]\\\\d\\\\d|2(?:[025-8]\\\\d|1[01]))\\\\d{7})|(?:[2-8]\\\\d{3}|92(?:[0-7]\\\\d|8[1-9]))\\\\d{6}|[24-9]\\\\d{8}|[89]\\\\d{7}\",[8,9,10,11,12],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1 $2 $3\",[\"[89]0\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"1\"]],[\"(\\\\d{2})(\\\\d{7,8})\",\"$1 $2\",[\"(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{6,7})\",\"$1 $2\",[\"2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])\",\"9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]\"],\"(0$1)\"],[\"(\\\\d{5})(\\\\d{5})\",\"$1 $2\",[\"58\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{7})\",\"$1 $2\",[\"3\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"[24-9]\"],\"(0$1)\"]],\"0\"],PL:[\"48\",\"00\",\"[1-57-9]\\\\d{6}(?:\\\\d{2})?|6\\\\d{5,8}\",[6,7,8,9],[[\"(\\\\d{5})\",\"$1\",[\"19\"]],[\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"11|64\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1 $2 $3\",[\"(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1\",\"(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19\"]],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"64\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"39|45|5[0137]|6[0469]|7[02389]|8[08]\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"1[2-8]|[2-8]|9[145]\"]]]],PM:[\"508\",\"00\",\"[45]\\\\d{5}\",[6],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[45]\"],\"0$1\"]],\"0\"],PR:[\"1\",\"011\",\"(?:[589]\\\\d\\\\d|787)\\\\d{7}\",[10],0,\"1\",0,0,0,0,\"787|939\"],PS:[\"970\",\"00\",\"[2489]2\\\\d{6}|(?:1\\\\d|5)\\\\d{8}\",[8,9,10],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[2489]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"5\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"]]],\"0\"],PT:[\"351\",\"00\",\"(?:[26-9]\\\\d|30)\\\\d{7}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2[12]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[236-9]\"]]]],PW:[\"680\",\"01[12]\",\"(?:[25-8]\\\\d\\\\d|345|488|900)\\\\d{4}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-9]\"]]]],PY:[\"595\",\"00\",\"59\\\\d{4,6}|(?:[2-46-9]\\\\d|5[0-8])\\\\d{4,7}\",[6,7,8,9],[[\"(\\\\d{3})(\\\\d{3,6})\",\"$1 $2\",[\"[2-9]0\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]\"],\"(0$1)\"],[\"(\\\\d{3})(\\\\d{4,5})\",\"$1 $2\",[\"2[279]|3[13-5]|4[359]|5|6[347]|7[46-8]|85\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"87\"]],[\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-8]\"],\"0$1\"]],\"0\"],QA:[\"974\",\"00\",\"[2-7]\\\\d{7}|(?:2\\\\d\\\\d|800)\\\\d{4}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"2[126]|8\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[2-7]\"]]]],RE:[\"262\",\"00\",\"9769\\\\d{5}|(?:26|[68]\\\\d)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2689]\"],\"0$1\"]],\"0\",0,0,0,0,\"26[23]|69|[89]\"],RO:[\"40\",\"00\",\"(?:[237]\\\\d|[89]0)\\\\d{7}|[23]\\\\d{5}\",[6,9],[[\"(\\\\d{3})(\\\\d{3})\",\"$1 $2\",[\"2[3-6]\",\"2[3-6]\\\\d9\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"219|31\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[23]1\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[237-9]\"],\"0$1\"]],\"0\",0,0,0,0,0,0,0,\" int \"],RS:[\"381\",\"00\",\"38[02-9]\\\\d{6,9}|6\\\\d{7,9}|90\\\\d{4,8}|38\\\\d{5,6}|(?:7\\\\d\\\\d|800)\\\\d{3,9}|(?:[12]\\\\d|3[0-79])\\\\d{5,10}\",[6,7,8,9,10,11,12],[[\"(\\\\d{3})(\\\\d{3,9})\",\"$1 $2\",[\"(?:2[389]|39)0|[7-9]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{5,10})\",\"$1 $2\",[\"[1-36]\"],\"0$1\"]],\"0\"],RU:[\"7\",\"810\",\"[347-9]\\\\d{9}\",[10],[[\"(\\\\d{4})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"7(?:1[0-8]|2[1-9])\",\"7(?:1(?:[0-6]2|7|8[27])|2(?:1[23]|[2-9]2))\",\"7(?:1(?:[0-6]2|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2\"],\"8 ($1)\",1],[\"(\\\\d{5})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"7(?:1[0-68]|2[1-9])\",\"7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))\",\"7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]\"],\"8 ($1)\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"8 ($1)\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"[3489]\"],\"8 ($1)\",1]],\"8\",0,0,0,0,\"3[04-689]|[489]\",0,\"8~10\"],RW:[\"250\",\"00\",\"(?:06|[27]\\\\d\\\\d|[89]00)\\\\d{6}\",[8,9],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"0\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[7-9]\"],\"0$1\"]],\"0\"],SA:[\"966\",\"00\",\"92\\\\d{7}|(?:[15]|8\\\\d)\\\\d{8}\",[9,10],[[\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"9\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"5\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"81\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"]]],\"0\"],SB:[\"677\",\"0[01]\",\"(?:[1-6]|[7-9]\\\\d\\\\d)\\\\d{4}\",[5,7],[[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"7|8[4-9]|9(?:[1-8]|9[0-8])\"]]]],SC:[\"248\",\"010|0[0-2]\",\"8000\\\\d{3}|(?:[249]\\\\d|64)\\\\d{5}\",[7],[[\"(\\\\d)(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[246]\"]]],0,0,0,0,0,0,0,\"00\"],SD:[\"249\",\"00\",\"[19]\\\\d{8}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[19]\"],\"0$1\"]],\"0\"],SE:[\"46\",\"00\",\"(?:[26]\\\\d\\\\d|9)\\\\d{9}|[1-9]\\\\d{8}|[1-689]\\\\d{7}|[1-4689]\\\\d{6}|2\\\\d{5}\",[6,7,8,9,10],[[\"(\\\\d{2})(\\\\d{2,3})(\\\\d{2})\",\"$1-$2 $3\",[\"20\"],\"0$1\",0,\"$1 $2 $3\"],[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"9(?:00|39|44)\"],\"0$1\",0,\"$1 $2\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})\",\"$1-$2 $3\",[\"[12][136]|3[356]|4[0246]|6[03]|90[1-9]\"],\"0$1\",0,\"$1 $2 $3\"],[\"(\\\\d)(\\\\d{2,3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"8\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d{3})(\\\\d{2,3})(\\\\d{2})\",\"$1-$2 $3\",[\"1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])\"],\"0$1\",0,\"$1 $2 $3\"],[\"(\\\\d{3})(\\\\d{2,3})(\\\\d{3})\",\"$1-$2 $3\",[\"9(?:00|39|44)\"],\"0$1\",0,\"$1 $2 $3\"],[\"(\\\\d{2})(\\\\d{2,3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"10|7\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"8\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4\",[\"[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{3})\",\"$1-$2 $3 $4\",[\"9\"],\"0$1\",0,\"$1 $2 $3 $4\"],[\"(\\\\d{3})(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1-$2 $3 $4 $5\",[\"[26]\"],\"0$1\",0,\"$1 $2 $3 $4 $5\"]],\"0\"],SG:[\"65\",\"0[0-3]\\\\d\",\"(?:(?:1\\\\d|8)\\\\d\\\\d|7000)\\\\d{7}|[3689]\\\\d{7}\",[8,10,11],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[369]|8[1-9]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"8\"]],[\"(\\\\d{4})(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"7\"]],[\"(\\\\d{4})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]]]],SH:[\"290\",\"00\",\"(?:[256]\\\\d|8)\\\\d{3}\",[4,5],0,0,0,0,0,0,\"[256]\"],SI:[\"386\",\"00|10(?:22|66|88|99)\",\"[1-7]\\\\d{7}|8\\\\d{4,7}|90\\\\d{4,6}\",[5,6,7,8],[[\"(\\\\d{2})(\\\\d{3,6})\",\"$1 $2\",[\"8[09]|9\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"59|8\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[37][01]|4[0139]|51|6\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[1-57]\"],\"(0$1)\"]],\"0\",0,0,0,0,0,0,\"00\"],SJ:[\"47\",\"00\",\"0\\\\d{4}|(?:[4589]\\\\d|79)\\\\d{6}\",[5,8],0,0,0,0,0,0,\"79\"],SK:[\"421\",\"00\",\"[2-689]\\\\d{8}|[2-59]\\\\d{6}|[2-5]\\\\d{5}\",[6,7,9],[[\"(\\\\d)(\\\\d{2})(\\\\d{3,4})\",\"$1 $2 $3\",[\"21\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{2})(\\\\d{2,3})\",\"$1 $2 $3\",[\"[3-5][1-8]1\",\"[3-5][1-8]1[67]\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{3})(\\\\d{2})\",\"$1\/$2 $3 $4\",[\"2\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[689]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1\/$2 $3 $4\",[\"[3-5]\"],\"0$1\"]],\"0\"],SL:[\"232\",\"00\",\"(?:[2378]\\\\d|99)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"[237-9]\"],\"(0$1)\"]],\"0\"],SM:[\"378\",\"00\",\"(?:0549|[5-7]\\\\d)\\\\d{6}\",[8,10],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[5-7]\"]],[\"(\\\\d{4})(\\\\d{6})\",\"$1 $2\",[\"0\"]]],0,0,\"([89]\\\\d{5})$\",\"0549$1\"],SN:[\"221\",\"00\",\"(?:[378]\\\\d{4}|93330)\\\\d{4}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"8\"]],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[379]\"]]]],SO:[\"252\",\"00\",\"[346-9]\\\\d{8}|[12679]\\\\d{7}|(?:[1-4]\\\\d|59)\\\\d{5}|[1348]\\\\d{5}\",[6,7,8,9],[[\"(\\\\d{2})(\\\\d{4})\",\"$1 $2\",[\"8[125]\"]],[\"(\\\\d{6})\",\"$1\",[\"[134]\"]],[\"(\\\\d)(\\\\d{6})\",\"$1 $2\",[\"1|2[0-79]|3[0-46-8]|4[0-7]|59\"]],[\"(\\\\d)(\\\\d{7})\",\"$1 $2\",[\"24|[67]\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[348]|64|79[0-8]|90\"]],[\"(\\\\d{2})(\\\\d{5,7})\",\"$1 $2\",[\"1|28|6[1-35-9]|799|9[2-9]\"]]],\"0\"],SR:[\"597\",\"00\",\"(?:[2-5]|68|[78]\\\\d)\\\\d{5}\",[6,7],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1-$2-$3\",[\"56\"]],[\"(\\\\d{3})(\\\\d{3})\",\"$1-$2\",[\"[2-5]\"]],[\"(\\\\d{3})(\\\\d{4})\",\"$1-$2\",[\"[6-8]\"]]]],SS:[\"211\",\"00\",\"[19]\\\\d{8}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[19]\"],\"0$1\"]],\"0\"],ST:[\"239\",\"00\",\"(?:22|9\\\\d)\\\\d{5}\",[7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[29]\"]]]],SV:[\"503\",\"00\",\"[267]\\\\d{7}|[89]00\\\\d{4}(?:\\\\d{4})?\",[7,8,11],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[89]\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[267]\"]],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"]]]],SX:[\"1\",\"011\",\"7215\\\\d{6}|(?:[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|(5\\\\d{6})$\",\"721$1\",0,\"721\"],SY:[\"963\",\"00\",\"[1-39]\\\\d{8}|[1-5]\\\\d{7}\",[8,9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[1-5]\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"],\"0$1\",1]],\"0\"],SZ:[\"268\",\"00\",\"0800\\\\d{4}|(?:[237]\\\\d|900)\\\\d{6}\",[8,9],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[0237]\"]],[\"(\\\\d{5})(\\\\d{4})\",\"$1 $2\",[\"9\"]]]],TA:[\"290\",\"00\",\"8\\\\d{3}\",[4],0,0,0,0,0,0,\"8\"],TC:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|649|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-479]\\\\d{6})$\",\"649$1\",0,\"649\"],TD:[\"235\",\"00|16\",\"(?:22|[69]\\\\d|77)\\\\d{6}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[2679]\"]]],0,0,0,0,0,0,0,\"00\"],TG:[\"228\",\"00\",\"[279]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[279]\"]]]],TH:[\"66\",\"00[1-9]\",\"1\\\\d{8,9}|(?:[2-57]|[689]\\\\d)\\\\d{7}\",[8,9,10],[[\"(\\\\d)(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"2\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"14|[3-9]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"1\"]]],\"0\"],TJ:[\"992\",\"810\",\"(?:00|11|[3-579]\\\\d|88)\\\\d{7}\",[9],[[\"(\\\\d{6})(\\\\d)(\\\\d{2})\",\"$1 $2 $3\",[\"331\",\"3317\"],0,1],[\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[34]7|91[78]\"],0,1],[\"(\\\\d{4})(\\\\d)(\\\\d{4})\",\"$1 $2 $3\",[\"3\"],0,1],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[0457-9]|11\"],0,1]],\"8\",0,0,0,0,0,0,\"8~10\"],TK:[\"690\",\"00\",\"[2-47]\\\\d{3,6}\",[4,5,6,7]],TL:[\"670\",\"00\",\"7\\\\d{7}|(?:[2-47]\\\\d|[89]0)\\\\d{5}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[2-489]|70\"]],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"7\"]]]],TM:[\"993\",\"810\",\"[1-6]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"12\"],\"(8 $1)\"],[\"(\\\\d{3})(\\\\d)(\\\\d{2})(\\\\d{2})\",\"$1 $2-$3-$4\",[\"[1-5]\"],\"(8 $1)\"],[\"(\\\\d{2})(\\\\d{6})\",\"$1 $2\",[\"6\"],\"8 $1\"]],\"8\",0,0,0,0,0,0,\"8~10\"],TN:[\"216\",\"00\",\"[2-57-9]\\\\d{7}\",[8],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-57-9]\"]]]],TO:[\"676\",\"00\",\"(?:0800|[5-8]\\\\d{3})\\\\d{3}|[2-8]\\\\d{4}\",[5,7],[[\"(\\\\d{2})(\\\\d{3})\",\"$1-$2\",[\"[2-4]|50|6[09]|7[0-24-69]|8[05]\"]],[\"(\\\\d{4})(\\\\d{3})\",\"$1 $2\",[\"0\"]],[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[5-8]\"]]]],TR:[\"90\",\"00\",\"(?:4|8\\\\d{5})\\\\d{6}|(?:[2-58]\\\\d\\\\d|900)\\\\d{7}\",[7,10,12],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"512|8[0589]|90\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"5(?:[0-59]|61)\",\"5(?:[0-59]|616)\",\"5(?:[0-59]|6161)\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[24][1-8]|3[1-9]\"],\"(0$1)\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{6})\",\"$1 $2 $3\",[\"80\"],\"0$1\",1]],\"0\"],TT:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-46-8]\\\\d{6})$\",\"868$1\",0,\"868\"],TV:[\"688\",\"00\",\"(?:2|7\\\\d\\\\d|90)\\\\d{4}\",[5,6,7]],TW:[\"886\",\"0(?:0[25-79]|19)\",\"[2-689]\\\\d{8}|7\\\\d{9,10}|[2-8]\\\\d{7}|2\\\\d{6}\",[7,8,9,10,11],[[\"(\\\\d{2})(\\\\d)(\\\\d{4})\",\"$1 $2 $3\",[\"202\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[258]0\"],\"0$1\"],[\"(\\\\d)(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]\",\"[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[49]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4,5})\",\"$1 $2 $3\",[\"7\"],\"0$1\"]],\"0\",0,0,0,0,0,0,0,\"#\"],TZ:[\"255\",\"00[056]\",\"(?:[26-8]\\\\d|41|90)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[24]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[67]\"],\"0$1\"]],\"0\"],UA:[\"380\",\"00\",\"[89]\\\\d{9}|[3-9]\\\\d{8}\",[9,10],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]\",\"6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"4[45][0-5]|5(?:0|6[37])|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]\",\"4[45][0-5]|5(?:0|6(?:3[14-7]|7))|6(?:[12][018]|[36-8])|7|89|9[1-9]|(?:48|57)[0137-9]\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"[3-6]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[89]\"],\"0$1\"]],\"0\",0,0,0,0,0,0,\"0~0\"],UG:[\"256\",\"00[057]\",\"800\\\\d{6}|(?:[29]0|[347]\\\\d)\\\\d{7}\",[9],[[\"(\\\\d{4})(\\\\d{5})\",\"$1 $2\",[\"202\",\"2024\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{6})\",\"$1 $2\",[\"[27-9]|4(?:6[45]|[7-9])\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"[34]\"],\"0$1\"]],\"0\"],US:[\"1\",\"011\",\"[2-9]\\\\d{9}\",[10],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{4})\",\"($1) $2-$3\",[\"[2-9]\"],0,1,\"$1-$2-$3\"]],\"1\",0,0,0,0,0,[[\"(?:2(?:0[1-35-9]|1[02-9]|2[03-589]|3[149]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-57-9]|1[02-9]|2[0135]|3[0-24679]|4[167]|5[12]|6[014]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[0235]|58|6[39]|7[0589]|8[04])|5(?:0[1-57-9]|1[0235-8]|20|3[0149]|4[01]|5[19]|6[1-47]|7[013-5]|8[056])|6(?:0[1-35-9]|1[024-9]|2[03689]|[34][016]|5[0179]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-7]|3[1247]|4[037]|5[47]|6[02359]|7[02-59]|8[156])|8(?:0[1-68]|1[02-8]|2[08]|3[0-28]|4[3578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[0179]|5[12469]|7[0-389]|8[04-69]))[2-9]\\\\d{6}\"],[\"\"],[\"8(?:00|33|44|55|66|77|88)[2-9]\\\\d{6}\"],[\"900[2-9]\\\\d{6}\"],[\"5(?:00|2[12]|33|44|66|77|88)[2-9]\\\\d{6}\"],0,[\"710[2-9]\\\\d{6}\"]]],UY:[\"598\",\"0(?:0|1[3-9]\\\\d)\",\"(?:[249]\\\\d\\\\d|80)\\\\d{5}|9\\\\d{6}\",[7,8],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"8|90\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"9\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\",[\"[24]\"]]],\"0\",0,0,0,0,0,0,\"00\",\" int. \"],UZ:[\"998\",\"810\",\"[679]\\\\d{8}\",[9],[[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[679]\"],\"8 $1\"]],\"8\",0,0,0,0,0,0,\"8~10\"],VA:[\"39\",\"00\",\"0\\\\d{5,10}|3[0-8]\\\\d{7,10}|55\\\\d{8}|8\\\\d{5}(?:\\\\d{2,4})?|(?:1\\\\d|39)\\\\d{7,8}\",[6,7,8,9,10,11],0,0,0,0,0,0,\"06698\"],VC:[\"1\",\"011\",\"(?:[58]\\\\d\\\\d|784|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-7]\\\\d{6})$\",\"784$1\",0,\"784\"],VE:[\"58\",\"00\",\"[89]00\\\\d{7}|(?:[24]\\\\d|50)\\\\d{8}\",[10],[[\"(\\\\d{3})(\\\\d{7})\",\"$1-$2\",[\"[24589]\"],\"0$1\"]],\"0\"],VG:[\"1\",\"011\",\"(?:284|[58]\\\\d\\\\d|900)\\\\d{7}\",[10],0,\"1\",0,\"1|([2-578]\\\\d{6})$\",\"284$1\",0,\"284\"],VI:[\"1\",\"011\",\"[58]\\\\d{9}|(?:34|90)0\\\\d{7}\",[10],0,\"1\",0,\"1|([2-9]\\\\d{6})$\",\"340$1\",0,\"340\"],VN:[\"84\",\"00\",\"[12]\\\\d{9}|[135-9]\\\\d{8}|[16]\\\\d{7}|[16-8]\\\\d{6}\",[7,8,9,10],[[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"80\"],\"0$1\",1],[\"(\\\\d{4})(\\\\d{4,6})\",\"$1 $2\",[\"1\"],0,1],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3 $4\",[\"[69]\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[3578]\"],\"0$1\",1],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"2[48]\"],\"0$1\",1],[\"(\\\\d{3})(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"2\"],\"0$1\",1]],\"0\"],VU:[\"678\",\"00\",\"(?:[23]\\\\d|[48]8)\\\\d{3}|(?:[57]\\\\d|90)\\\\d{5}\",[5,7],[[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"[579]\"]]]],WF:[\"681\",\"00\",\"(?:[45]0|68|72|8\\\\d)\\\\d{4}\",[6],[[\"(\\\\d{2})(\\\\d{2})(\\\\d{2})\",\"$1 $2 $3\",[\"[4-8]\"]]]],WS:[\"685\",\"0\",\"[2-6]\\\\d{4}|8\\\\d{5}(?:\\\\d{4})?|[78]\\\\d{6}\",[5,6,7,10],[[\"(\\\\d{5})\",\"$1\",[\"[2-6]\"]],[\"(\\\\d{3})(\\\\d{3,7})\",\"$1 $2\",[\"8\"]],[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"7\"]]]],XK:[\"383\",\"00\",\"[23]\\\\d{7,8}|(?:4\\\\d\\\\d|[89]00)\\\\d{5}\",[8,9],[[\"(\\\\d{3})(\\\\d{5})\",\"$1 $2\",[\"[89]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[2-4]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[23]\"],\"0$1\"]],\"0\"],YE:[\"967\",\"00\",\"(?:1|7\\\\d)\\\\d{7}|[1-7]\\\\d{6}\",[7,8,9],[[\"(\\\\d)(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"[1-6]|7[24-68]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"7\"],\"0$1\"]],\"0\"],YT:[\"262\",\"00\",\"80\\\\d{7}|(?:26|63)9\\\\d{6}\",[9],0,\"0\",0,0,0,0,\"269|63\"],ZA:[\"27\",\"00\",\"[1-9]\\\\d{8}|8\\\\d{4,7}\",[5,6,7,8,9],[[\"(\\\\d{2})(\\\\d{3,4})\",\"$1 $2\",[\"8[1-4]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{2,3})\",\"$1 $2 $3\",[\"8[1-4]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"860\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"[1-9]\"],\"0$1\"]],\"0\"],ZM:[\"260\",\"00\",\"(?:63|80)0\\\\d{6}|(?:21|[79]\\\\d)\\\\d{7}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[28]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"[79]\"],\"0$1\"]],\"0\"],ZW:[\"263\",\"00\",\"2(?:[0-57-9]\\\\d{6,8}|6[0-24-9]\\\\d{6,7})|[38]\\\\d{9}|[35-8]\\\\d{8}|[3-6]\\\\d{7}|[1-689]\\\\d{6}|[1-3569]\\\\d{5}|[1356]\\\\d{4}\",[5,6,7,8,9,10],[[\"(\\\\d{3})(\\\\d{3,5})\",\"$1 $2\",[\"2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]\"],\"0$1\"],[\"(\\\\d)(\\\\d{3})(\\\\d{2,4})\",\"$1 $2 $3\",[\"[49]\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{4})\",\"$1 $2\",[\"80\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{7})\",\"$1 $2\",[\"24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2\",\"2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]\"],\"(0$1)\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{4})\",\"$1 $2 $3\",[\"7\"],\"0$1\"],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)\",\"2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{6})\",\"$1 $2\",[\"8\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3,5})\",\"$1 $2\",[\"1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]\"],\"0$1\"],[\"(\\\\d{2})(\\\\d{3})(\\\\d{3,4})\",\"$1 $2 $3\",[\"29[013-9]|39|54\"],\"0$1\"],[\"(\\\\d{4})(\\\\d{3,5})\",\"$1 $2\",[\"(?:25|54)8\",\"258|5483\"],\"0$1\"]],\"0\"]},nonGeographic:{800:[\"800\",0,\"\\\\d{8}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\"]],0,0,0,0,0,0,[0,0,[\"\\\\d{8}\"]]],808:[\"808\",0,\"\\\\d{8}\",[8],[[\"(\\\\d{4})(\\\\d{4})\",\"$1 $2\"]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,0,[\"\\\\d{8}\"]]],870:[\"870\",0,\"[35-7]\\\\d{8}\",[9],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"[35-7]\"]]],0,0,0,0,0,0,[0,[\"(?:[356]\\\\d|7[6-8])\\\\d{7}\"]]],878:[\"878\",0,\"10\\\\d{10}\",[12],[[\"(\\\\d{2})(\\\\d{5})(\\\\d{5})\",\"$1 $2 $3\",[\"1\"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,[\"10\\\\d{10}\"]]],881:[\"881\",0,\"[67]\\\\d{8}\",[9],[[\"(\\\\d)(\\\\d{3})(\\\\d{5})\",\"$1 $2 $3\",[\"[67]\"]]],0,0,0,0,0,0,[0,[\"[67]\\\\d{8}\"]]],882:[\"882\",0,\"1\\\\d{6,11}|3\\\\d{6}(?:\\\\d{2,5})?\",[7,8,9,10,11,12],[[\"(\\\\d{2})(\\\\d{5})\",\"$1 $2\",[\"16|342\"]],[\"(\\\\d{2})(\\\\d{2})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]],[\"(\\\\d{2})(\\\\d{4})(\\\\d{3})\",\"$1 $2 $3\",[\"3[23]\"]],[\"(\\\\d{2})(\\\\d{3,4})(\\\\d{4})\",\"$1 $2 $3\",[\"1\"]],[\"(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"34[57]\"]],[\"(\\\\d{3})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"34\"]],[\"(\\\\d{2})(\\\\d{4,5})(\\\\d{5})\",\"$1 $2 $3\",[\"[13]\"]]],0,0,0,0,0,0,[0,[\"3(?:37\\\\d\\\\d|42)\\\\d{4}|3(?:2|47|7\\\\d{3})\\\\d{7}\",[7,9,10,12]],0,0,0,0,0,0,[\"1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\\\d{4}|6\\\\d{5,10})|3(?:45|9\\\\d{3})\\\\d{7}\"]]],883:[\"883\",0,\"51\\\\d{7}(?:\\\\d{3})?\",[9,12],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3\",[\"510\"]],[\"(\\\\d{3})(\\\\d{3})(\\\\d{3})(\\\\d{3})\",\"$1 $2 $3 $4\",[\"510\"]],[\"(\\\\d{4})(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\",[\"5\"]]],0,0,0,0,0,0,[0,0,0,0,0,0,0,0,[\"51[013]0\\\\d{8}|5100\\\\d{5}\"]]],888:[\"888\",0,\"\\\\d{11}\",[11],[[\"(\\\\d{3})(\\\\d{3})(\\\\d{5})\",\"$1 $2 $3\"]],0,0,0,0,0,0,[0,0,0,0,0,0,[\"\\\\d{11}\"]]],979:[\"979\",0,\"\\\\d{9}\",[9],[[\"(\\\\d)(\\\\d{4})(\\\\d{4})\",\"$1 $2 $3\"]],0,0,0,0,0,0,[0,0,0,[\"\\\\d{9}\"]]]}},e=\"\".concat(\"-\u2010-\u2015\u2212\u30FC\uFF0D\").concat(\"\uFF0F\/\").concat(\"\uFF0E.\").concat(\" \u00A0\u00AD\u200B\u2060\u3000\").concat(\"()\uFF08\uFF09\uFF3B\uFF3D\\\\[\\\\]\").concat(\"~\u2053\u223C\uFF5E\");function n(t,d){return t=t||\"\",new RegExp(\"^(?:\"+d+\")$\").test(t)}var r=function t(d){!function(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.name=this.constructor.name,this.message=d,this.stack=new Error(d).stack};function $(t,d){for(var e=t.split(\".\"),n=d.split(\".\"),r=0;r<3;r++){var $=Number(e[r]),i=Number(n[r]);if($>i)return 1;if(i>$)return-1;if(!isNaN($)&&isNaN(i))return 1;if(isNaN($)&&!isNaN(i))return-1}return 0}function i(t){return(i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function a(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}function o(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function u(t,d,e){return d&&o(t.prototype,d),e&&o(t,e),t}(r.prototype=Object.create(Error.prototype)).constructor=r;var l=function(){function t(d){a(this,t),function(t){if(!t)throw new Error(\"[libphonenumber-js] `metadata` argument not passed. Check your arguments.\");if(!m(t)||!m(t.countries))throw new Error(\"[libphonenumber-js] `metadata` argument was passed but it\'s not a valid metadata. Must be an object having `.countries` child object property. Got \".concat(m(t)?\"an object of shape: { \"+Object.keys(t).join(\", \")+\" }\":\"a \"+p(t)+\": \"+t,\".\"))}(d),this.metadata=d,C.call(this,d)}return u(t,[{key:\"getCountries\",value:function(){return Object.keys(this.metadata.countries).filter((function(t){return\"001\"!==t}))}},{key:\"getCountryMetadata\",value:function(t){return this.metadata.countries[t]}},{key:\"nonGeographic\",value:function(){if(!(this.v1||this.v2||this.v3))return this.metadata.nonGeographic||this.metadata.nonGeographical}},{key:\"hasCountry\",value:function(t){return void 0!==this.getCountryMetadata(t)}},{key:\"hasCallingCode\",value:function(t){if(this.getCountryCodesForCallingCode(t))return!0;if(this.nonGeographic()){if(this.nonGeographic()[t])return!0}else{var d=this.countryCallingCodes()[t];if(d&&1===d.length&&\"001\"===d[0])return!0}}},{key:\"isNonGeographicCallingCode\",value:function(t){return this.nonGeographic()?!!this.nonGeographic()[t]:!this.getCountryCodesForCallingCode(t)}},{key:\"country\",value:function(t){return this.selectNumberingPlan(t)}},{key:\"selectNumberingPlan\",value:function(t,d){if(t&&\"001\"!==t){if(!this.hasCountry(t))throw new Error(\"Unknown country: \".concat(t));this.numberingPlan=new s(this.getCountryMetadata(t),this)}else if(d){if(!this.hasCallingCode(d))throw new Error(\"Unknown calling code: \".concat(d));this.numberingPlan=new s(this.getNumberingPlanMetadata(d),this)}else this.numberingPlan=void 0;return this}},{key:\"getCountryCodesForCallingCode\",value:function(t){var d=this.countryCallingCodes()[t];if(d){if(1===d.length&&3===d[0].length)return;return d}}},{key:\"getCountryCodeForCallingCode\",value:function(t){var d=this.getCountryCodesForCallingCode(t);if(d)return d[0]}},{key:\"getNumberingPlanMetadata\",value:function(t){var d=this.getCountryCodeForCallingCode(t);if(d)return this.getCountryMetadata(d);if(this.nonGeographic()){var e=this.nonGeographic()[t];if(e)return e}else{var n=this.countryCallingCodes()[t];if(n&&1===n.length&&\"001\"===n[0])return this.metadata.countries[\"001\"]}}},{key:\"countryCallingCode\",value:function(){return this.numberingPlan.callingCode()}},{key:\"IDDPrefix\",value:function(){return this.numberingPlan.IDDPrefix()}},{key:\"defaultIDDPrefix\",value:function(){return this.numberingPlan.defaultIDDPrefix()}},{key:\"nationalNumberPattern\",value:function(){return this.numberingPlan.nationalNumberPattern()}},{key:\"possibleLengths\",value:function(){return this.numberingPlan.possibleLengths()}},{key:\"formats\",value:function(){return this.numberingPlan.formats()}},{key:\"nationalPrefixForParsing\",value:function(){return this.numberingPlan.nationalPrefixForParsing()}},{key:\"nationalPrefixTransformRule\",value:function(){return this.numberingPlan.nationalPrefixTransformRule()}},{key:\"leadingDigits\",value:function(){return this.numberingPlan.leadingDigits()}},{key:\"hasTypes\",value:function(){return this.numberingPlan.hasTypes()}},{key:\"type\",value:function(t){return this.numberingPlan.type(t)}},{key:\"ext\",value:function(){return this.numberingPlan.ext()}},{key:\"countryCallingCodes\",value:function(){return this.v1?this.metadata.country_phone_code_to_countries:this.metadata.country_calling_codes}},{key:\"chooseCountryByCountryCallingCode\",value:function(t){this.selectNumberingPlan(null,t)}},{key:\"hasSelectedNumberingPlan\",value:function(){return void 0!==this.numberingPlan}}]),t}(),s=function(){function t(d,e){a(this,t),this.globalMetadataObject=e,this.metadata=d,C.call(this,e.metadata)}return u(t,[{key:\"callingCode\",value:function(){return this.metadata[0]}},{key:\"getDefaultCountryMetadataForRegion\",value:function(){return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode())}},{key:\"IDDPrefix\",value:function(){if(!this.v1&&!this.v2)return this.metadata[1]}},{key:\"defaultIDDPrefix\",value:function(){if(!this.v1&&!this.v2)return this.metadata[12]}},{key:\"nationalNumberPattern\",value:function(){return this.v1||this.v2?this.metadata[1]:this.metadata[2]}},{key:\"possibleLengths\",value:function(){if(!this.v1)return this.metadata[this.v2?2:3]}},{key:\"_getFormats\",value:function(t){return t[this.v1?2:this.v2?3:4]}},{key:\"formats\",value:function(){var t=this,d=this._getFormats(this.metadata)||this._getFormats(this.getDefaultCountryMetadataForRegion())||[];return d.map((function(d){return new c(d,t)}))}},{key:\"nationalPrefix\",value:function(){return this.metadata[this.v1?3:this.v2?4:5]}},{key:\"_getNationalPrefixFormattingRule\",value:function(t){return t[this.v1?4:this.v2?5:6]}},{key:\"nationalPrefixFormattingRule\",value:function(){return this._getNationalPrefixFormattingRule(this.metadata)||this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion())}},{key:\"_nationalPrefixForParsing\",value:function(){return this.metadata[this.v1?5:this.v2?6:7]}},{key:\"nationalPrefixForParsing\",value:function(){return this._nationalPrefixForParsing()||this.nationalPrefix()}},{key:\"nationalPrefixTransformRule\",value:function(){return this.metadata[this.v1?6:this.v2?7:8]}},{key:\"_getNationalPrefixIsOptionalWhenFormatting\",value:function(){return!!this.metadata[this.v1?7:this.v2?8:9]}},{key:\"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",value:function(){return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata)||this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion())}},{key:\"leadingDigits\",value:function(){return this.metadata[this.v1?8:this.v2?9:10]}},{key:\"types\",value:function(){return this.metadata[this.v1?9:this.v2?10:11]}},{key:\"hasTypes\",value:function(){return(!this.types()||0!==this.types().length)&&!!this.types()}},{key:\"type\",value:function(t){if(this.hasTypes()&&y(this.types(),t))return new h(y(this.types(),t),this)}},{key:\"ext\",value:function(){return this.v1||this.v2?\" ext. \":this.metadata[13]||\" ext. \"}}]),t}(),c=function(){function t(d,e){a(this,t),this._format=d,this.metadata=e}return u(t,[{key:\"pattern\",value:function(){return this._format[0]}},{key:\"format\",value:function(){return this._format[1]}},{key:\"leadingDigitsPatterns\",value:function(){return this._format[2]||[]}},{key:\"nationalPrefixFormattingRule\",value:function(){return this._format[3]||this.metadata.nationalPrefixFormattingRule()}},{key:\"nationalPrefixIsOptionalWhenFormattingInNationalFormat\",value:function(){return!!this._format[4]||this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat()}},{key:\"nationalPrefixIsMandatoryWhenFormattingInNationalFormat\",value:function(){return this.usesNationalPrefix()&&!this.nationalPrefixIsOptionalWhenFormattingInNationalFormat()}},{key:\"usesNationalPrefix\",value:function(){return this.nationalPrefixFormattingRule()&&!f.test(this.nationalPrefixFormattingRule())}},{key:\"internationalFormat\",value:function(){return this._format[5]||this.format()}}]),t}(),f=\/^\\(?\\$1\\)?$\/,h=function(){function t(d,e){a(this,t),this.type=d,this.metadata=e}return u(t,[{key:\"pattern\",value:function(){return this.metadata.v1?this.type:this.type[0]}},{key:\"possibleLengths\",value:function(){if(!this.metadata.v1)return this.type[1]||this.metadata.possibleLengths()}}]),t}();function y(t,d){switch(d){case\"FIXED_LINE\":return t[0];case\"MOBILE\":return t[1];case\"TOLL_FREE\":return t[2];case\"PREMIUM_RATE\":return t[3];case\"PERSONAL_NUMBER\":return t[4];case\"VOICEMAIL\":return t[5];case\"UAN\":return t[6];case\"PAGER\":return t[7];case\"VOIP\":return t[8];case\"SHARED_COST\":return t[9]}}var m=function(t){return\"object\"===i(t)},p=function(t){return i(t)};function g(t,d){return(d=new l(d)).hasCountry(t)?d.country(t).ext():\" ext. \"}function v(t,d){if((d=new l(d)).hasCountry(t))return d.country(t).countryCallingCode();throw new Error(\"Unknown country: \".concat(t))}function b(t,d){return void 0!==d.countries[t]}function C(t){this.v1=!t.version,this.v2=void 0!==t.version&&-1===$(t.version,\"1.2.0\"),this.v3=void 0!==t.version&&-1===$(t.version,\"1.7.35\"),this.v4=void 0!==t.version}function N(t){var d=\"x\uFF58#\uFF03~\uFF5E\";switch(t){case\"parsing\":d=\",;\"+d}return\";ext=([0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]{1,7})|[ \u00A0\\\\t,]*(?:e?xt(?:ensi(?:o\u0301?|\u00F3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|[\"+d+\"]|int|anexo|\uFF49\uFF4E\uFF54)[:\\\\.\uFF0E]?[ \u00A0\\\\t,-]*([0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]{1,7})#?|[- ]+([0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]{1,5})#\"}var x=N(\"parsing\"),P=N(\"matching\"),E=new RegExp(\"(?:\"+x+\")$\",\"i\");var O=new RegExp(\"^[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]{2}$|^\"+(\"[+\uFF0B]{0,1}(?:[\"+e+\"]*[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]){3,}[\"+e+\"0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]*\")+\"(?:\"+x+\")?$\",\"i\");function w(t){return t.length>=2&&O.test(t)}var A={0:\"0\",1:\"1\",2:\"2\",3:\"3\",4:\"4\",5:\"5\",6:\"6\",7:\"7\",8:\"8\",9:\"9\",\"\uFF10\":\"0\",\"\uFF11\":\"1\",\"\uFF12\":\"2\",\"\uFF13\":\"3\",\"\uFF14\":\"4\",\"\uFF15\":\"5\",\"\uFF16\":\"6\",\"\uFF17\":\"7\",\"\uFF18\":\"8\",\"\uFF19\":\"9\",\"\u0660\":\"0\",\"\u0661\":\"1\",\"\u0662\":\"2\",\"\u0663\":\"3\",\"\u0664\":\"4\",\"\u0665\":\"5\",\"\u0666\":\"6\",\"\u0667\":\"7\",\"\u0668\":\"8\",\"\u0669\":\"9\",\"\u06F0\":\"0\",\"\u06F1\":\"1\",\"\u06F2\":\"2\",\"\u06F3\":\"3\",\"\u06F4\":\"4\",\"\u06F5\":\"5\",\"\u06F6\":\"6\",\"\u06F7\":\"7\",\"\u06F8\":\"8\",\"\u06F9\":\"9\"};function T(t){return A[t]}function S(t){var d=\"\",e=t.split(\"\"),n=Array.isArray(e),r=0;for(e=n?e:e[Symbol.iterator]();;){var $;if(n){if(r>=e.length)break;$=e[r++]}else{if((r=e.next()).done)break;$=r.value}var i=T($);i&&(d+=i)}return d}function I(t){var d=\"\",e=t.split(\"\"),n=Array.isArray(e),r=0;for(e=n?e:e[Symbol.iterator]();;){var $;if(n){if(r>=e.length)break;$=e[r++]}else{if((r=e.next()).done)break;$=r.value}d+=F($,d)||\"\"}return d}function F(t,d){if(\"+\"===t){if(d)return;return\"+\"}return T(t)}var R=[\"MOBILE\",\"PREMIUM_RATE\",\"TOLL_FREE\",\"SHARED_COST\",\"VOIP\",\"PERSONAL_NUMBER\",\"PAGER\",\"UAN\",\"VOICEMAIL\"];function k(t,d,e){if(d=d||{},t.country){(e=new l(e)).selectNumberingPlan(t.country,t.countryCallingCode);var r=d.v2?t.nationalNumber:t.phone;if(n(r,e.nationalNumberPattern())){if(D(r,\"FIXED_LINE\",e))return e.type(\"MOBILE\")&&\"\"===e.type(\"MOBILE\").pattern()?\"FIXED_LINE_OR_MOBILE\":e.type(\"MOBILE\")?D(r,\"MOBILE\",e)?\"FIXED_LINE_OR_MOBILE\":\"FIXED_LINE\":\"FIXED_LINE_OR_MOBILE\";for(var $=0,i=R;$<i.length;$++){var a=i[$];if(D(r,a,e))return a}}}}function D(t,d,e){return!(!(d=e.type(d))||!d.pattern())&&(!(d.possibleLengths()&&d.possibleLengths().indexOf(t.length)<0)&&n(t,d.pattern()))}function M(t,d,e){var n=e.type(d),r=n&&n.possibleLengths()||e.possibleLengths();if(\"FIXED_LINE_OR_MOBILE\"===d){if(!e.type(\"FIXED_LINE\"))return M(t,\"MOBILE\",e);var $=e.type(\"MOBILE\");$&&(r=function(t,d){var e=t.slice(),n=d,r=Array.isArray(n),$=0;for(n=r?n:n[Symbol.iterator]();;){var i;if(r){if($>=n.length)break;i=n[$++]}else{if(($=n.next()).done)break;i=$.value}var a=i;t.indexOf(a)<0&&e.push(a)}return e.sort((function(t,d){return t-d}))}(r,$.possibleLengths()))}else if(d&&!n)return\"INVALID_LENGTH\";var i=t.length,a=r[0];return a===i?\"IS_POSSIBLE\":a>i?\"TOO_SHORT\":r[r.length-1]<i?\"TOO_LONG\":r.indexOf(i,1)>=0?\"IS_POSSIBLE\":\"INVALID_LENGTH\"}function L(t,d,e){if(void 0===d&&(d={}),e=new l(e),d.v2){if(!t.countryCallingCode)throw new Error(\"Invalid phone number object passed\");e.chooseCountryByCountryCallingCode(t.countryCallingCode)}else{if(!t.phone)return!1;if(t.country){if(!e.hasCountry(t.country))throw new Error(\"Unknown country: \".concat(t.country));e.country(t.country)}else{if(!t.countryCallingCode)throw new Error(\"Invalid phone number object passed\");e.chooseCountryByCountryCallingCode(t.countryCallingCode)}}if(e.possibleLengths())return _(t.phone||t.nationalNumber,void 0,e);if(t.countryCallingCode&&e.isNonGeographicCallingCode(t.countryCallingCode))return!0;throw new Error(\'Missing \"possibleLengths\" in metadata. Perhaps the metadata has been generated before v1.0.18.\')}function _(t,d,e){switch(M(t,void 0,e)){case\"IS_POSSIBLE\":return!0;default:return!1}}var G=new RegExp(\"([0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9])\"),B=\/^[\\d]+(?:[~\\u2053\\u223C\\uFF5E][\\d]+)?$\/;function j(t,d){return function(t){if(Array.isArray(t))return t}(t)||function(t,d){var e=[],n=!0,r=!1,$=void 0;try{for(var i,a=t[Symbol.iterator]();!(n=(i=a.next()).done)&&(e.push(i.value),!d||e.length!==d);n=!0);}catch(t){r=!0,$=t}finally{try{n||null==a.return||a.return()}finally{if(r)throw $}}return e}(t,d)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function U(t){var d,e,n=(t=t.replace(\/^tel:\/,\"tel=\")).split(\";\"),r=Array.isArray(n),$=0;for(n=r?n:n[Symbol.iterator]();;){var i;if(r){if($>=n.length)break;i=n[$++]}else{if(($=n.next()).done)break;i=$.value}var a=j(i.split(\"=\"),2),o=a[0],u=a[1];switch(o){case\"tel\":d=u;break;case\"ext\":e=u;break;case\"phone-context\":\"+\"===u[0]&&(d=u+d)}}if(!w(d))return{};var l={number:d};return e&&(l.ext=e),l}function V(t){var d=t.number,e=t.ext;if(!d)return\"\";if(\"+\"!==d[0])throw new Error(\'\"formatRFC3966()\" expects \"number\" to be in E.164 format.\');return\"tel:\".concat(d).concat(e?\";ext=\"+e:\"\")}function K(t,d,e){return d=d||{},e=new l(e),!!t.country&&(e.selectNumberingPlan(t.country,t.countryCallingCode),e.hasTypes()?void 0!==k(t,d,e.metadata):n(d.v2?t.nationalNumber:t.phone,e.nationalNumberPattern()))}function H(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}var W={formatExtension:function(t,d,e){return\"\".concat(t).concat(e.ext()).concat(d)}};function Y(t,d,e,n){if(e=e?function(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){H(t,d,e[d])}))}return t}({},W,e):W,n=new l(n),t.country&&\"001\"!==t.country){if(!n.hasCountry(t.country))throw new Error(\"Unknown country: \".concat(t.country));n.country(t.country)}else{if(!t.countryCallingCode)return t.phone||\"\";n.chooseCountryByCountryCallingCode(t.countryCallingCode)}var r,$=n.countryCallingCode(),i=e.v2?t.nationalNumber:t.phone;switch(d){case\"NATIONAL\":return i?Q(r=J(i,\"NATIONAL\",n,e),t.ext,n,e.formatExtension):\"\";case\"INTERNATIONAL\":return i?(r=J(i,\"INTERNATIONAL\",n,e),Q(r=\"+\".concat($,\" \").concat(r),t.ext,n,e.formatExtension)):\"+\".concat($);case\"E.164\":return\"+\".concat($).concat(i);case\"RFC3966\":return V({number:\"+\".concat($).concat(i),ext:t.ext});case\"IDD\":if(!e.fromCountry)return;var a=function(t,d){var e=new l(d);return e.country(t),B.test(e.IDDPrefix())?e.IDDPrefix():e.defaultIDDPrefix()}(e.fromCountry,n.metadata);if(!a)return;if(e.humanReadable){var o=$&&function(t,d,e,n,r){var $=new l(n.metadata);if($.country(e),d===$.countryCallingCode())return\"1\"===d?d+\" \"+J(t,\"NATIONAL\",n,r):J(t,\"NATIONAL\",n,r)}(i,n.countryCallingCode(),e.fromCountry,n,e);return Q(r=o||\"\".concat(a,\" \").concat($,\" \").concat(J(i,\"INTERNATIONAL\",n,e)),t.ext,n,e.formatExtension)}return\"\".concat(a).concat($).concat(i);default:throw new Error(\'Unknown \"format\" argument passed to \"formatNumber()\": \"\'.concat(d,\'\"\'))}}var Z=\/(\\$\\d)\/;function X(t,d,e,n,r){var $=t.replace(new RegExp(d.pattern()),e?d.internationalFormat():n&&d.nationalPrefixFormattingRule()?d.format().replace(Z,d.nationalPrefixFormattingRule()):d.format());return e?z($):$}function J(t,d,e,r){var $=function(t,d){var e=t,r=Array.isArray(e),$=0;for(e=r?e:e[Symbol.iterator]();;){var i;if(r){if($>=e.length)break;i=e[$++]}else{if(($=e.next()).done)break;i=$.value}var a=i;if(a.leadingDigitsPatterns().length>0){var o=a.leadingDigitsPatterns()[a.leadingDigitsPatterns().length-1];if(0!==d.search(o))continue}if(n(d,a.pattern()))return a}}(e.formats(),t);return $?X(t,$,\"INTERNATIONAL\"===d,!$.nationalPrefixIsOptionalWhenFormattingInNationalFormat()||!1!==r.nationalPrefix):t}function z(t){return t.replace(new RegExp(\"[\".concat(e,\"]+\"),\"g\"),\" \").trim()}function Q(t,d,e,n){return d?n(t,d,e):t}function q(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function tt(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var dt=function(){function t(d,e,n){if(function(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}(this,t),!d)throw new TypeError(\"`country` or `countryCallingCode` not passed\");if(!e)throw new TypeError(\"`nationalNumber` not passed\");var r=new l(n);et(d)&&(this.country=d,r.country(d),d=r.countryCallingCode()),this.countryCallingCode=d,this.nationalNumber=e,this.number=\"+\"+this.countryCallingCode+this.nationalNumber,this.metadata=n}var d,e,n;return d=t,(e=[{key:\"isPossible\",value:function(){return L(this,{v2:!0},this.metadata)}},{key:\"isValid\",value:function(){return K(this,{v2:!0},this.metadata)}},{key:\"isNonGeographic\",value:function(){return new l(this.metadata).isNonGeographicCallingCode(this.countryCallingCode)}},{key:\"isEqual\",value:function(t){return this.number===t.number&&this.ext===t.ext}},{key:\"getType\",value:function(){return k(this,{v2:!0},this.metadata)}},{key:\"format\",value:function(t,d){return Y(this,t,d?function(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){q(t,d,e[d])}))}return t}({},d,{v2:!0}):{v2:!0},this.metadata)}},{key:\"formatNational\",value:function(t){return this.format(\"NATIONAL\",t)}},{key:\"formatInternational\",value:function(t){return this.format(\"INTERNATIONAL\",t)}},{key:\"getURI\",value:function(t){return this.format(\"RFC3966\",t)}}])&&tt(d.prototype,e),n&&tt(d,n),t}(),et=function(t){return\/^[A-Z]{2}$\/.test(t)},nt=new RegExp(\"[+\uFF0B0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]\"),rt=new RegExp(\"[^0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]+$\");function $t(t,d,e){if(d=d||{},e=new l(e),d.defaultCountry&&!e.hasCountry(d.defaultCountry)){if(d.v2)throw new r(\"INVALID_COUNTRY\");throw new Error(\"Unknown country: \".concat(d.defaultCountry))}var $=function(t,d){if(t&&0===t.indexOf(\"tel:\"))return U(t);var e=it(t,d);if(!e||!w(e))return{};var n=function(t){var d=t.search(E);if(d<0)return{};for(var e=t.slice(0,d),n=t.match(E),r=1;r<n.length;){if(null!=n[r]&&n[r].length>0)return{number:e,ext:n[r]};r++}}(e);if(n.ext)return n;return{number:e}}(t,d.v2),i=$.number,a=$.ext;if(!i){if(d.v2)throw new r(\"NOT_A_NUMBER\");return{}}var o=function(t,d,e,n){var r,$=ut(t,d,n.metadata),i=$.countryCallingCode,a=$.number;if(i)n.chooseCountryByCountryCallingCode(i);else{if(!a||!d&&!e)return{};n.selectNumberingPlan(d,e),d&&(r=d),i=e||v(d,n.metadata)}if(!a)return{countryCallingCode:i};var o=function(t,d){var e=at(I(t),d),n=e.nationalNumber,r=e.carrierCode;if(d.possibleLengths())switch(M(n,void 0,d)){case\"TOO_SHORT\":case\"INVALID_LENGTH\":return{nationalNumber:t}}return{nationalNumber:n,carrierCode:r}}(a,n),u=o.nationalNumber,l=o.carrierCode,s=ot(i,u,n);s&&(r=s,\"001\"===s||n.country(r));return{country:r,countryCallingCode:i,nationalNumber:u,carrierCode:l}}(i,d.defaultCountry,d.defaultCallingCode,e),u=o.country,s=o.nationalNumber,c=o.countryCallingCode,f=o.carrierCode;if(!e.hasSelectedNumberingPlan()){if(d.v2)throw new r(\"INVALID_COUNTRY\");return{}}if(!s||s.length<2){if(d.v2)throw new r(\"TOO_SHORT\");return{}}if(s.length>17){if(d.v2)throw new r(\"TOO_LONG\");return{}}if(d.v2){var h=new dt(c,s,e.metadata);return u&&(h.country=u),f&&(h.carrierCode=f),a&&(h.ext=a),h}var y=!(d.extended?!e.hasSelectedNumberingPlan():!u)&&n(s,e.nationalNumberPattern());return d.extended?{country:u,countryCallingCode:c,carrierCode:f,valid:y,possible:!!y||!(!0!==d.extended||!e.possibleLengths()||!_(s,0,e)),phone:s,ext:a}:y?function(t,d,e){var n={country:t,phone:d};e&&(n.ext=e);return n}(u,s,a):{}}function it(t,d){if(t)if(t.length>250){if(d)throw new r(\"TOO_LONG\")}else{var e=t.search(nt);if(!(e<0))return t.slice(e).replace(rt,\"\")}}function at(t,d){if(t&&d.nationalPrefixForParsing()){var e=new RegExp(\"^(?:\"+d.nationalPrefixForParsing()+\")\"),r=e.exec(t);if(r){var $,i,a=r.length-1;if(d.nationalPrefixTransformRule()&&a>0&&r[a])$=t.replace(e,d.nationalPrefixTransformRule()),a>1&&r[a]&&(i=r[1]);else{var o=r[0];$=t.slice(o.length),a>0&&(i=r[1])}if(!n(t,d.nationalNumberPattern())||n($,d.nationalNumberPattern()))return{nationalNumber:$,carrierCode:i}}}return{nationalNumber:t}}function ot(t,d,e){var n=e.getCountryCodesForCallingCode(t);if(n)return 1===n.length?n[0]:function(t,d,e){e=new l(e);var n=t,r=Array.isArray(n),$=0;for(n=r?n:n[Symbol.iterator]();;){var i;if(r){if($>=n.length)break;i=n[$++]}else{if(($=n.next()).done)break;i=$.value}var a=i;if(e.country(a),e.leadingDigits()){if(d&&0===d.search(e.leadingDigits()))return a}else if(k({phone:d,country:a},void 0,e.metadata))return a}}(n,d,e.metadata)}function ut(t,d,e){if(!(t=I(t)))return{};if(\"+\"!==t[0]){var n=function(t,d,e){if(d){var n=new l(e);n.country(d);var r=new RegExp(n.IDDPrefix());if(0===t.search(r)){var $=(t=t.slice(t.match(r)[0].length)).match(G);if(!($&&null!=$[1]&&$[1].length>0&&\"0\"===$[1]))return t}}}(t,d,e);if(!n||n===t)return{number:t};t=\"+\"+n}if(\"0\"===t[1])return{};e=new l(e);for(var r=2;r-1<=3&&r<=t.length;){var $=t.slice(1,r);if(e.hasCallingCode($))return{countryCallingCode:$,number:t.slice(r)};r++}return{}}function lt(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function st(t,d,e){return $t(t,function(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){lt(t,d,e[d])}))}return t}({},d,{v2:!0}),e)}function ct(t){return(ct=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function ft(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function ht(t,d){return function(t){if(Array.isArray(t))return t}(t)||function(t,d){var e=[],n=!0,r=!1,$=void 0;try{for(var i,a=t[Symbol.iterator]();!(n=(i=a.next()).done)&&(e.push(i.value),!d||e.length!==d);n=!0);}catch(t){r=!0,$=t}finally{try{n||null==a.return||a.return()}finally{if(r)throw $}}return e}(t,d)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function yt(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return st(d,e,n)}function mt(t){var d,e,n,r=ht(Array.prototype.slice.call(t),4),$=r[0],i=r[1],a=r[2],o=r[3];if(\"string\"!=typeof $)throw new TypeError(\"A text for parsing must be a string.\");if(d=$,i&&\"string\"!=typeof i){if(!pt(i))throw new Error(\"Invalid second argument: \".concat(i));a?(e=i,n=a):n=i}else o?(e=a,n=o):(e=void 0,n=a),i&&(e=function(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){ft(t,d,e[d])}))}return t}({defaultCountry:i},e));return{text:d,options:e,metadata:n}}var pt=function(t){return\"object\"===ct(t)};function gt(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function vt(t,d,e){d&&d.defaultCountry&&!b(d.defaultCountry,e)&&(d=function(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){gt(t,d,e[d])}))}return t}({},d,{defaultCountry:void 0}));try{return st(t,d,e)}catch(t){if(!(t instanceof r))throw t}}function bt(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return vt(d,e,n)}function Ct(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return $t(d,e,n)}function Nt(t){return(Nt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function xt(t,d){return function(t){if(Array.isArray(t))return t}(t)||function(t,d){var e=[],n=!0,r=!1,$=void 0;try{for(var i,a=t[Symbol.iterator]();!(n=(i=a.next()).done)&&(e.push(i.value),!d||e.length!==d);n=!0);}catch(t){r=!0,$=t}finally{try{n||null==a.return||a.return()}finally{if(r)throw $}}return e}(t,d)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function Pt(){var t=Et(arguments),d=t.input,e=t.format,n=t.options,r=t.metadata;return Y(d,e,n,r)}function Et(t){var d,e,n,r,$=xt(Array.prototype.slice.call(t),5),i=$[0],a=$[1],o=$[2],u=$[3],l=$[4];if(\"string\"==typeof i)if(\"string\"==typeof o)e=o,l?(n=u,r=l):r=u,d=$t(i,{defaultCountry:a,extended:!0},r);else{if(\"string\"!=typeof a)throw new Error(\"`format` argument not passed to `formatNumber(number, format)`\");e=a,u?(n=o,r=u):r=o,d=$t(i,{extended:!0},r)}else{if(!Ot(i))throw new TypeError(\"A phone number must either be a string or an object of shape { phone, [country] }.\");d=i,e=a,u?(n=o,r=u):r=o}return\"International\"===e?e=\"INTERNATIONAL\":\"National\"===e&&(e=\"NATIONAL\"),{input:d,format:e,options:n,metadata:r}}var Ot=function(t){return\"object\"===Nt(t)};function wt(t){return(wt=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function At(t,d){return function(t){if(Array.isArray(t))return t}(t)||function(t,d){var e=[],n=!0,r=!1,$=void 0;try{for(var i,a=t[Symbol.iterator]();!(n=(i=a.next()).done)&&(e.push(i.value),!d||e.length!==d);n=!0);}catch(t){r=!0,$=t}finally{try{n||null==a.return||a.return()}finally{if(r)throw $}}return e}(t,d)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function Tt(){var t=St(arguments),d=t.input,e=t.options,n=t.metadata;return k(d,e,n)}function St(t){var d,e,n=At(Array.prototype.slice.call(t),4),r=n[0],$=n[1],i=n[2],a=n[3],o={};if(\"string\"==typeof r)\"object\"!==wt($)?(a?(o=i,e=a):e=i,d=w(r)?$t(r,{defaultCountry:$},e):{}):(i?(o=$,e=i):e=$,d=w(r)?$t(r,void 0,e):{});else{if(!It(r))throw new TypeError(\"A phone number must either be a string or an object of shape { phone, [country] }.\");d=r,i?(o=$,e=i):e=$}return{input:d,options:o,metadata:e}}var It=function(t){return\"object\"===wt(t)};function Ft(t,d,e){if(d[t])return new dt(t,d[t],e)}function Rt(){var t=St(arguments),d=t.input,e=t.options,n=t.metadata;return L(d,e,n)}function kt(){var t=St(arguments),d=t.input,e=t.options,n=t.metadata;return K(d,e,n)}function Dt(t,d,e){if(\"string\"!=typeof t)throw new TypeError(\"number must be a string\");if(\"string\"!=typeof d)throw new TypeError(\"country must be a string\");return function(t,d,e,n){return e=e||{},t.country===d&&K(t,e,n)}(w(t)?$t(t,{defaultCountry:d},e):{},d,void 0,e)}function Mt(t,d){if(t<0||d<=0||d<t)throw new TypeError;return\"{\".concat(t,\",\").concat(d,\"}\")}function Lt(t,d){var e=d.search(t);return e>=0?d.slice(0,e):d}var _t=\/[\\\\\/] *x\/;function Gt(t){return Lt(_t,t)}var Bt=\/(?:(?:[0-3]?\\d\\\/[01]?\\d)|(?:[01]?\\d\\\/[0-3]?\\d))\\\/(?:[12]\\d)?\\d{2}\/,jt=\/[12]\\d{3}[-\/]?[01]\\d[-\/]?[0-3]\\d +[0-2]\\d$\/,Ut=\/^:[0-5]\\d\/;function Vt(t,d,e){if(Bt.test(t))return!1;if(jt.test(t)){var n=e.slice(d+t.length);if(Ut.test(n))return!1}return!0}var Kt=\" \u00A0\u1680\u180E\u2000-\u200A\\u2028\\u2029\u202F\u205F\u3000\",Ht=\"[\".concat(Kt,\"]\"),Wt=\"[^\".concat(Kt,\"]\"),Yt=\"[\".concat(\"0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19\",\"]\"),Zt=\"A-Za-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\",Xt=\"[\".concat(Zt,\"]\"),Jt=new RegExp(Xt),zt=\"[\".concat(\"$\u00A2-\u00A5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20B9\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6\",\"]\"),Qt=new RegExp(zt),qt=\"[\".concat(\"\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\",\"]\"),td=new RegExp(qt),dd=new RegExp(\"[\\0-\u0080-\u00FF\u0100-\u017F\u1E00-\u1EFF\u0180-\u024F\u0300-\u036F]\");function ed(t){return!(!Jt.test(t)&&!td.test(t))&&dd.test(t)}function nd(t){return\"%\"===t||Qt.test(t)}var rd=\"[^\".concat(\"(\\\\[\uFF08\uFF3B\").concat(\")\\\\]\uFF09\uFF3D\",\"]\"),$d=\"[\".concat(\"(\\\\[\uFF08\uFF3B\").concat(\"+\uFF0B\",\"]\"),id=new RegExp(\"^\"+$d),ad=Mt(0,3),od=new RegExp(\"^(?:[(\\\\[\uFF08\uFF3B])?(?:\"+rd+\"+[)\\\\]\uFF09\uFF3D])?\"+rd+\"+(?:[(\\\\[\uFF08\uFF3B]\"+rd+\"+[)\\\\]\uFF09\uFF3D])\"+ad+rd+\"*$\"),ud=\/\\d{1,5}-+\\d{1,5}\\s{0,4}\\(\\d{1,4}\/;function ld(t,d,e,n){if(od.test(t)&&!ud.test(t)){if(\"POSSIBLE\"!==n){if(d>0&&!id.test(t)){var r=e[d-1];if(nd(r)||ed(r))return!1}var $=d+t.length;if($<e.length){var i=e[$];if(nd(i)||ed(i))return!1}}return!0}}function sd(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function cd(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}var fd=\"[+\uFF0B]{0,1}(?:[\"+e+\"]*[0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]){3,}[\"+e+\"0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]*\",hd=new RegExp(\"^[ \u00A0\u00AD\u200B\u2060\u3000]+\"),yd=new RegExp(\"[\"+e+\"]+$\");function md(t,d,e){void 0===d&&(d={});for(var n=new gd(t,d,e),r=[];n.hasNext();)r.push(n.next());return r}function pd(t,d,e){void 0===d&&(d={});var n=new gd(t,d,e);return cd({},Symbol.iterator,(function(){return{next:function(){return n.hasNext()?{done:!1,value:n.next()}:{done:!0}}}}))}var gd=function(){function t(d,e,n){!function(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}(this,t),cd(this,\"state\",\"NOT_READY\"),this.text=d,this.options=e||{},this.metadata=n,this.regexp=new RegExp(fd+\"(?:\"+x+\")?\",\"ig\")}var d,e,n;return d=t,(e=[{key:\"find\",value:function(){var t=this.regexp.exec(this.text);if(t){var d=t[0],e=t.index;d=d.replace(hd,\"\"),e+=t[0].length-d.length,d=Gt(d=d.replace(yd,\"\"));var n=this.parseCandidate(d,e);return n||this.find()}}},{key:\"parseCandidate\",value:function(t,d){if(Vt(t,d,this.text)&&ld(t,d,this.text,this.options.extended?\"POSSIBLE\":\"VALID\")){var e=$t(t,this.options,this.metadata);if(e.phone)return e.startsAt=d,e.endsAt=d+t.length,e}}},{key:\"hasNext\",value:function(){return\"NOT_READY\"===this.state&&(this.last_match=this.find(),this.last_match?this.state=\"READY\":this.state=\"DONE\"),\"READY\"===this.state}},{key:\"next\",value:function(){if(!this.hasNext())throw new Error(\"No next element\");var t=this.last_match;return this.last_match=null,this.state=\"NOT_READY\",t}}])&&sd(d.prototype,e),n&&sd(d,n),t}();function vd(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return md(d,e,n)}function bd(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return pd(d,e,n)}function Cd(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function Nd(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}var xd=function t(d,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;Nd(this,t),this.key=d,this.value=e,this.next=n,this.prev=r},Pd=function(){function t(){var d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10;Nd(this,t),this.size=0,this.limit=d,this.head=null,this.tail=null,this.cache={}}var d,e,n;return d=t,(e=[{key:\"put\",value:function(t,d){if(this.ensureLimit(),this.head){var e=new xd(t,d,this.head);this.head.prev=e,this.head=e}else this.head=this.tail=new xd(t,d);this.cache[t]=this.head,this.size++}},{key:\"get\",value:function(t){if(this.cache[t]){var d=this.cache[t].value;return this.remove(t),this.put(t,d),d}console.log(\"Item not available in cache for key \".concat(t))}},{key:\"ensureLimit\",value:function(){this.size===this.limit&&this.remove(this.tail.key)}},{key:\"remove\",value:function(t){var d=this.cache[t];null!==d.prev?d.prev.next=d.next:this.head=d.next,null!==d.next?d.next.prev=d.prev:this.tail=d.prev,delete this.cache[t],this.size--}},{key:\"clear\",value:function(){this.head=null,this.tail=null,this.size=0,this.cache={}}}])&&Cd(d.prototype,e),n&&Cd(d,n),t}();function Ed(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var Od=function(){function t(d){!function(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.cache=new Pd(d)}var d,e,n;return d=t,(e=[{key:\"getPatternForRegExp\",value:function(t){var d=this.cache.get(t);return d||(d=new RegExp(\"^\"+t),this.cache.put(t,d)),d}}])&&Ed(d.prototype,e),n&&Ed(d,n),t}(),wd={POSSIBLE:function(t,d,e){return!0},VALID:function(t,d,e){return!(!K(t,void 0,e)||!Ad(t,d.toString()))},STRICT_GROUPING:function(t,d,e,n){var r=d.toString();return!(!K(t,void 0,e)||!Ad(t,r)||Sd(t,r)||!Td(t))&&Id(t,d,e,kd,n)},EXACT_GROUPING:function(t,d,e,n){var r=d.toString();return!(!K(t,void 0,e)||!Ad(t,r)||Sd(t,r)||!Td(t))&&Id(t,d,e,Rd,n)}};function Ad(t,d,e){for(var n=0;n<d.length-1;n++){var r=d.charAt(n);if(\"x\"===r||\"X\"===r){var $=d.charAt(n+1);if(\"x\"===$||\"X\"===$){if(n++,util.isNumberMatch(t,d.substring(n))!=MatchType.NSN_MATCH)return!1}else if(S(d.substring(n))!==t.ext)return!1}}return!0}function Td(t,d){if(\"FROM_DEFAULT_COUNTRY\"!=t.getCountryCodeSource())return!0;var e=util.getRegionCodeForCountryCode(t.getCountryCode()),n=util.getMetadataForRegion(e);if(null==n)return!0;var r=util.getNationalSignificantNumber(t),$=util.chooseFormattingPatternForNumber(n.numberFormats(),r);if($&&$.getNationalPrefixFormattingRule().length>0){if($.getNationalPrefixOptionalWhenFormatting())return!0;if(PhoneNumberUtil.formattingRuleHasFirstGroupOnly($.getNationalPrefixFormattingRule()))return!0;var i=PhoneNumberUtil.normalizeDigitsOnly(t.getRawInput());return util.maybeStripNationalPrefixAndCarrierCode(i,n,null)}return!0}function Sd(t,d){var e=d.indexOf(\"\/\");if(e<0)return!1;var n=d.indexOf(\"\/\",e+1);return!(n<0)&&(!(t.getCountryCodeSource()===CountryCodeSource.FROM_NUMBER_WITH_PLUS_SIGN||t.getCountryCodeSource()===CountryCodeSource.FROM_NUMBER_WITHOUT_PLUS_SIGN)||PhoneNumberUtil.normalizeDigitsOnly(d.substring(0,e))!==String(t.getCountryCode())||d.slice(n+1).indexOf(\"\/\")>=0)}function Id(t,d,e,n,r){var $=normalizeDigits(d,!0),i=Fd(e,t,null);if(n(e,t,$,i))return!0;var a=MetadataManager.getAlternateFormatsForCountry(t.getCountryCode()),o=util.getNationalSignificantNumber(t);if(a){var u=a.numberFormats(),l=Array.isArray(u),s=0;for(u=l?u:u[Symbol.iterator]();;){var c;if(l){if(s>=u.length)break;c=u[s++]}else{if((s=u.next()).done)break;c=s.value}var f=c;if(f.leadingDigitsPatterns().length>0)if(!r.getPatternForRegExp(\"^\"+f.leadingDigitsPatterns()[0]).test(o))continue;if(n(e,t,$,i=Fd(e,t,f)))return!0}}return!1}function Fd(t,d,e){if(e){var n=util.getNationalSignificantNumber(d);return util.formatNsnUsingPattern(n,e,\"RFC3966\",t).split(\"-\")}var r=formatNumber(d,\"RFC3966\",t),$=r.indexOf(\";\");$<0&&($=r.length);var i=r.indexOf(\"-\")+1;return r.slice(i,$).split(\"-\")}function Rd(t,d,e,n){var r=e.split(NON_DIGITS_PATTERN),$=d.hasExtension()?r.length-2:r.length-1;if(1==r.length||r[$].contains(util.getNationalSignificantNumber(d)))return!0;for(var i,a,o=n.length-1;o>0&&$>=0;){if(r[$]!==n[o])return!1;o--,$--}return $>=0&&(i=r[$],a=n[0],i.indexOf(a,i.length-a.length)===i.length-a.length)}function kd(t,d,e,n){var r,$,i=0;if(d.getCountryCodeSource()!==CountryCodeSource.FROM_DEFAULT_COUNTRY){var a=String(d.getCountryCode());i=e.indexOf(a)+a.length()}for(var o=0;o<n.length;o++){if((i=e.indexOf(n[o],i))<0)return!1;if(i+=n[o].length(),0==o&&i<e.length()){var u=util.getRegionCodeForCountryCode(d.getCountryCode());if(null!=util.getNddPrefixForRegion(u,!0)&&Character.isDigit(e.charAt(i))){var l=util.getNationalSignificantNumber(d);return r=e.slice(i-n[o].length),$=l,0===r.indexOf($)}}}return e.slice(i).contains(d.getExtension())}function Dd(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){_d(t,d,e[d])}))}return t}function Md(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}function Ld(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function _d(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}var Gd=[\"\\\\\/+(.*)\/\",\"(\\\\([^(]*)\",\"(?:\".concat(Ht,\"-|-\").concat(Ht,\")\").concat(Ht,\"*(.+)\"),\"[\u2012-\u2015\uFF0D]\".concat(Ht,\"*(.+)\"),\"\\\\.+\".concat(Ht,\"*([^.]+)\"),\"\".concat(Ht,\"+(\").concat(Wt,\"+)\")],Bd=Mt(0,2),jd=Mt(0,4),Ud=Mt(0,20),Vd=\"[\".concat(e,\"]\")+jd,Kd=Yt+Mt(1,20),Hd=\"(?:\"+$d+Vd+\")\"+Bd+Kd+\"(?:\"+Vd+Kd+\")\"+Ud+\"(?:\"+P+\")?\",Wd=new RegExp(\"[^\".concat(\"0-9\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19\").concat(Zt,\"#]+$\")),Yd=Number.MAX_SAFE_INTEGER||Math.pow(2,53)-1,Zd=function(){function t(){var d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;if(Md(this,t),_d(this,\"state\",\"NOT_READY\"),_d(this,\"searchIndex\",0),_d(this,\"regExpCache\",new Od(32)),!(e=Dd({},e,{defaultCallingCode:e.defaultCallingCode,defaultCountry:e.defaultCountry&&b(e.defaultCountry,n)?e.defaultCountry:void 0,leniency:e.leniency||e.extended?\"POSSIBLE\":\"VALID\",maxTries:e.maxTries||Yd})).leniency)throw new TypeError(\"`Leniency` not supplied\");if(e.maxTries<0)throw new TypeError(\"`maxTries` not supplied\");if(this.text=d,this.options=e,this.metadata=n,this.leniency=wd[e.leniency],!this.leniency)throw new TypeError(\"Unknown leniency: \".concat(e.leniency,\".\"));this.maxTries=e.maxTries,this.PATTERN=new RegExp(Hd,\"ig\")}var d,e,n;return d=t,(e=[{key:\"find\",value:function(){for(var t;this.maxTries>0&&null!==(t=this.PATTERN.exec(this.text));){var d=t[0],e=t.index;if(Vt(d=Gt(d),e,this.text)){var n=this.parseAndVerify(d,e,this.text)||this.extractInnerMatch(d,e,this.text);if(n){if(this.options.v2){var r=new dt(n.country||n.countryCallingCode,n.phone,this.metadata);return n.ext&&(r.ext=n.ext),{startsAt:n.startsAt,endsAt:n.endsAt,number:r}}return n}}this.maxTries--}}},{key:\"extractInnerMatch\",value:function(t,d,e){for(var n=0,r=Gd;n<r.length;n++)for(var $=!0,i=void 0,a=new RegExp(r[n],\"g\");null!==(i=a.exec(t))&&this.maxTries>0;){if($){var o=Lt(Wd,t.slice(0,i.index)),u=this.parseAndVerify(o,d,e);if(u)return u;this.maxTries--,$=!1}var l=Lt(Wd,i[1]),s=this.parseAndVerify(l,d+i.index,e);if(s)return s;this.maxTries--}}},{key:\"parseAndVerify\",value:function(t,d,e){if(ld(t,d,e,this.options.leniency)){var n=$t(t,{extended:!0,defaultCountry:this.options.defaultCountry,defaultCallingCode:this.options.defaultCallingCode},this.metadata);if(n.possible&&this.leniency(n,t,this.metadata,this.regExpCache)){var r={startsAt:d,endsAt:d+t.length,phone:n.phone};return n.country&&\"001\"!==n.country?r.country=n.country:r.countryCallingCode=n.countryCallingCode,n.ext&&(r.ext=n.ext),r}}}},{key:\"hasNext\",value:function(){return\"NOT_READY\"===this.state&&(this.lastMatch=this.find(),this.lastMatch?this.state=\"READY\":this.state=\"DONE\"),\"READY\"===this.state}},{key:\"next\",value:function(){if(!this.hasNext())throw new Error(\"No next element\");var t=this.lastMatch;return this.lastMatch=null,this.state=\"NOT_READY\",t}}])&&Ld(d.prototype,e),n&&Ld(d,n),t}();function Xd(t,d,e){for(var n=new Zd(t,d,e),r=[];n.hasNext();)r.push(n.next());return r}function Jd(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata;return Xd(d,e,n)}function zd(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function Qd(){var t=mt(arguments),d=t.text,e=t.options,n=t.metadata,r=new Zd(d,e,n);return zd({},Symbol.iterator,(function(){return{next:function(){return r.hasNext()?{done:!1,value:r.next()}:{done:!0}}}}))}function qd(t){return(qd=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function te(t){for(var d=1;d<arguments.length;d++){var e=null!=arguments[d]?arguments[d]:{},n=Object.keys(e);\"function\"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(e).filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})))),n.forEach((function(d){de(t,d,e[d])}))}return t}function de(t,d,e){return d in t?Object.defineProperty(t,d,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[d]=e,t}function ee(t,d,e,n){var r=ne(d,e,n);return Jd(t,r.options,r.metadata)}function ne(t,d,e){return e?t&&(d=te({},d,{defaultCountry:t})):d?(e=d,d=t?re(t)?t:{defaultCountry:t}:void 0):(e=t,d=void 0),{options:te({},d,{v2:!0}),metadata:e}}var re=function(t){return\"object\"===qd(t)};function $e(t,d,e,n){var r=ne(d,e,n);return Qd(t,r.options,r.metadata)}function ie(t){return(ie=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function ae(t,d){for(var e=0;e<d.length;e++){var n=d[e];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var oe=ye(\"9\",15),ue=new RegExp(\"x\"),le=\/[- ]\/,se=new RegExp(\"^[\"+e+\"]*(\\\\$\\\\d[\"+e+\"]*)+$\"),ce=new RegExp(\"^\"+(\"[+\uFF0B]{0,1}[\"+e+\"0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9]*\")+\"$\",\"i\"),fe=function(){function t(d,e){var n,r,$,i,a;!function(t,d){if(!(t instanceof d))throw new TypeError(\"Cannot call a class as a function\")}(this,t),$={},(r=\"options\")in(n=this)?Object.defineProperty(n,r,{value:$,enumerable:!0,configurable:!0,writable:!0}):n[r]=$,this.metadata=new l(e),d&&(\"object\"===ie(d)?(i=d.defaultCountry,a=d.defaultCallingCode):i=d),i&&this.metadata.hasCountry(i)&&(this.defaultCountry=i),a&&(this.defaultCallingCode=a),this.reset()}var d,e,n;return d=t,(e=[{key:\"reset\",value:function(){return this.formattedOutput=\"\",this.international=void 0,this.countryCallingCode=void 0,this.digits=\"\",this.nationalNumberDigits=\"\",this.nationalPrefix=\"\",this.carrierCode=\"\",this.setCountry(this.defaultCountry,this.defaultCallingCode),this.resetFormat(),this}},{key:\"setCountry\",value:function(t,d){this.country=t,this.metadata.selectNumberingPlan(t,d),this.metadata.hasSelectedNumberingPlan()?this.initializePhoneNumberFormatsForCountry():this.matchingFormats=[]}},{key:\"resetFormat\",value:function(){this.chosenFormat=void 0,this.template=void 0,this.populatedNationalNumberTemplate=void 0,this.populatedNationalNumberTemplatePosition=-1}},{key:\"input\",value:function(t){var d=this.extractFormattedDigits(t);return ce.test(d)&&(this.formattedOutput=this.getFullNumber(this.inputDigits(S(d))||this.getNonFormattedNationalNumber())),this.formattedOutput}},{key:\"extractFormattedDigits\",value:function(t){var d=it(t)||\"\";return d||t&&t.indexOf(\"+\")>=0&&(d=\"+\"),\"+\"===d[0]&&(d=d.slice(\"+\".length),this.digits||this.startInternationalNumber()),d}},{key:\"startInternationalNumber\",value:function(){this.international=!0,this.setCountry()}},{key:\"inputDigits\",value:function(t){if(this.digits+=t,this.isInternational())if(this.countryCallingCode)this.nationalNumberDigits+=t,this.country&&!this.isCountryCallingCodeAmbiguous()||this.determineTheCountry();else{if(!this.digits)return;if(!this.extractCountryCallingCode())return;this.nationalNumberDigits=this.digits.slice(this.countryCallingCode.length),this.determineTheCountry()}else{this.nationalNumberDigits+=t,this.country||this.determineTheCountry();var d=this.nationalPrefix;this.nationalNumberDigits=this.nationalPrefix+this.nationalNumberDigits,this.extractNationalPrefix(),this.nationalPrefix!==d&&(this.initializePhoneNumberFormatsForCountry(),this.resetFormat())}return this.nationalNumberDigits&&this.matchFormats(this.nationalNumberDigits),this.formatNationalNumberWithNextDigits(t)}},{key:\"formatNationalNumberWithNextDigits\",value:function(t){var d=this.attemptToFormatCompletePhoneNumber();if(d)return d;var e=this.chosenFormat,n=this.chooseFormat();return n?n===e?this.formatNextNationalNumberDigits(t):this.reformatNationalNumber():void 0}},{key:\"chooseFormat\",value:function(){var t=this.matchingFormats,d=Array.isArray(t),e=0;for(t=d?t:t[Symbol.iterator]();;){var n;if(d){if(e>=t.length)break;n=t[e++]}else{if((e=t.next()).done)break;n=e.value}var r=n;if(this.chosenFormat===r)break;if(this.createFormattingTemplate(r)){this.chosenFormat=r,this.populatedNationalNumberTemplatePosition=-1;break}}return this.chosenFormat||this.resetFormat(),this.chosenFormat}},{key:\"reformatNationalNumber\",value:function(){return this.formatNextNationalNumberDigits(this.nationalPrefix+this.nationalNumberDigits)}},{key:\"initializePhoneNumberFormatsForCountry\",value:function(){this.matchingFormats=this.metadata.formats().filter((function(t){return se.test(t.internationalFormat())}))}},{key:\"matchFormats\",value:function(t){var d=this,e=t.length-3;e<0&&(e=0),this.matchingFormats=this.matchingFormats.filter((function(n){if(!d.isInternational()&&!d.nationalPrefix&&n.nationalPrefixIsMandatoryWhenFormattingInNationalFormat())return!1;var r=n.leadingDigitsPatterns().length;if(0===r)return!0;if(t.length<3)return!0;e=Math.min(e,r-1);var $=n.leadingDigitsPatterns()[e];return new RegExp(\"^(\".concat($,\")\")).test(t)})),this.chosenFormat&&-1===this.matchingFormats.indexOf(this.chosenFormat)&&this.resetFormat()}},{key:\"getSeparatorAfterNationalPrefix\",value:function(t){return\"1\"===this.metadata.countryCallingCode()?\" \":t&&t.nationalPrefixFormattingRule()&&le.test(t.nationalPrefixFormattingRule())?\" \":\"\"}},{key:\"attemptToFormatCompletePhoneNumber\",value:function(){var t=this.matchingFormats,d=Array.isArray(t),e=0;for(t=d?t:t[Symbol.iterator]();;){var n;if(d){if(e>=t.length)break;n=t[e++]}else{if((e=t.next()).done)break;n=e.value}var r=n;if(new RegExp(\"^(?:\".concat(r.pattern(),\")$\")).test(this.nationalNumberDigits)){var $=X(this.nationalNumberDigits,r,this.isInternational(),!1,this.metadata);if(S($)===this.nationalNumberDigits){if(this.nationalPrefix){var i=X(this.nationalNumberDigits,r,this.isInternational(),!0,this.metadata);$=S(i)===this.nationalPrefix+this.nationalNumberDigits?i:this.nationalPrefix+this.getSeparatorAfterNationalPrefix(r)+$}return this.resetFormat(),this.chosenFormat=r,this.createFormattingTemplate(r)?this.reformatNationalNumber():(this.template=this.getFullNumber($).replace(\/[\\d\\+]\/g,\"x\"),this.populatedNationalNumberTemplate=$,this.populatedNationalNumberTemplatePosition=this.populatedNationalNumberTemplate.length-1),$}}}}},{key:\"getFullNumber\",value:function(t){return this.isInternational()?this.countryCallingCode?t?\"+\".concat(this.countryCallingCode,\" \").concat(t):\"+\".concat(this.countryCallingCode):\"+\".concat(this.digits):t}},{key:\"getNonFormattedNationalNumber\",value:function(){return this.nationalPrefix+(this.nationalPrefix&&this.nationalNumberDigits&&this.getSeparatorAfterNationalPrefix())+this.nationalNumberDigits}},{key:\"extractCountryCallingCode\",value:function(){var t=ut(\"+\"+this.digits,this.defaultCountry,this.metadata.metadata),d=t.countryCallingCode,e=t.number;if(d)return this.nationalNumberDigits=e,this.countryCallingCode=d,this.metadata.chooseCountryByCountryCallingCode(d),this.initializePhoneNumberFormatsForCountry(),this.resetFormat(),this.metadata.hasSelectedNumberingPlan()}},{key:\"extractNationalPrefix\",value:function(){if(this.nationalPrefix=\"\",this.metadata.hasSelectedNumberingPlan()){var t=at(this.nationalNumberDigits,this.metadata),d=t.nationalNumber,e=t.carrierCode;if(d){var n=this.nationalNumberDigits.indexOf(d);if(n<0||n!==this.nationalNumberDigits.length-d.length)return}return e&&(this.carrierCode=e),this.nationalPrefix=this.nationalNumberDigits.slice(0,this.nationalNumberDigits.length-d.length),this.nationalNumberDigits=d,this.nationalPrefix}}},{key:\"isCountryCallingCodeAmbiguous\",value:function(){var t=this.metadata.getCountryCodesForCallingCode(this.countryCallingCode);return t&&t.length>1}},{key:\"createFormattingTemplate\",value:function(t){if(!(t.pattern().indexOf(\"|\")>=0)){var d=this.getTemplateForNumberFormatPattern(t,this.nationalPrefix);if(d)return this.template=d,this.populatedNationalNumberTemplate=d,this.isInternational()&&(this.template=\"x\"+ye(\"x\",this.countryCallingCode.length)+\" \"+d),this.template}}},{key:\"getTemplateForNumberFormatPattern\",value:function(t,d){var e=t.pattern();e=e.replace(\/\\[([^\\[\\]])*\\]\/g,\"\\\\d\").replace(\/\\d(?=[^,}][^,}])\/g,\"\\\\d\");var n=oe.match(e)[0];if(!(this.nationalNumberDigits.length>n.length)){var r=new RegExp(\"^\"+e+\"$\"),$=this.nationalNumberDigits.replace(\/\\d\/g,\"9\");r.test($)&&(n=$);var i,a=this.getFormatFormat(t);if(d&&t.nationalPrefixFormattingRule()){var o=a.replace(Z,t.nationalPrefixFormattingRule());if(S(o)===d+S(a)){a=o,i=!0;for(var u=d.length;u>0;)a=a.replace(\/\\d\/,\"x\"),u--}}var l=n.replace(new RegExp(e),a).replace(new RegExp(\"9\",\"g\"),\"x\");return d&&(i||(l=ye(\"x\",d.length)+this.getSeparatorAfterNationalPrefix(t)+l)),l}}},{key:\"formatNextNationalNumberDigits\",value:function(t){var d=t.split(\"\"),e=Array.isArray(d),n=0;for(d=e?d:d[Symbol.iterator]();;){var r;if(e){if(n>=d.length)break;r=d[n++]}else{if((n=d.next()).done)break;r=n.value}var $=r;if(this.populatedNationalNumberTemplate.slice(this.populatedNationalNumberTemplatePosition+1).search(ue)<0)return void this.resetFormat();this.populatedNationalNumberTemplatePosition=this.populatedNationalNumberTemplate.search(ue),this.populatedNationalNumberTemplate=this.populatedNationalNumberTemplate.replace(ue,$)}return he(this.populatedNationalNumberTemplate,this.populatedNationalNumberTemplatePosition+1)}},{key:\"isInternational\",value:function(){return this.international}},{key:\"getFormatFormat\",value:function(t){return this.isInternational()?z(t.internationalFormat()):t.format()}},{key:\"determineTheCountry\",value:function(){this.country=ot(this.isInternational()?this.countryCallingCode:this.defaultCallingCode,this.nationalNumberDigits,this.metadata)}},{key:\"getNumber\",value:function(){if(this.isInternational()){if(!this.countryCallingCode)return}else if(!this.country&&!this.defaultCallingCode)return;if(this.nationalNumberDigits){var t=this.country,d=this.countryCallingCode||this.defaultCallingCode,e=new dt(t||d,this.nationalNumberDigits,this.metadata.metadata);return this.carrierCode&&(e.carrierCode=this.carrierCode),e}}},{key:\"getNationalNumber\",value:function(){return this.nationalNumberDigits}},{key:\"getNonFormattedTemplate\",value:function(){return this.getFullNumber(this.getNonFormattedNationalNumber()).replace(\/[\\+\\d]\/g,\"x\")}},{key:\"getTemplate\",value:function(){if(!this.template)return this.getNonFormattedTemplate();for(var t=-1,d=0;d<(this.international?1:0)+this.digits.length;)t=this.template.indexOf(\"x\",t+1),d++;return he(this.template,t+1)}}])&&ae(d.prototype,e),n&&ae(d,n),t}();function he(t,d){return\")\"===t[d]&&d++,function(t){for(var d=[],e=0;e<t.length;)\"(\"===t[e]?d.push(e):\")\"===t[e]&&d.pop(),e++;var n=0,r=\"\";d.push(t.length);for(var $=0,i=d;$<i.length;$++){var a=i[$];r+=t.slice(n,a),n=a+1}return r}(t.slice(0,d))}function ye(t,d){if(d<1)return\"\";for(var e=\"\";d>1;)1&d&&(e+=t),d>>=1,t+=t;return e+t}function me(t,d,e){return e||(e=d,d=void 0),new fe(d,e).input(t)}function pe(t,e){gd.call(this,t,e,d)}function ge(t,e){Zd.call(this,t,e,d)}function ve(t){fe.call(this,t,d)}function be(t){return v(t,d)}pe.prototype=Object.create(gd.prototype,{}),pe.prototype.constructor=pe,ge.prototype=Object.create(Zd.prototype,{}),ge.prototype.constructor=ge,ve.prototype=Object.create(fe.prototype,{}),ve.prototype.constructor=ve,t.AsYouType=ve,t.AsYouTypeCustom=fe,t.DIGITS=A,t.DIGIT_PLACEHOLDER=\"x\",t.Metadata=l,t.ParseError=r,t.PhoneNumberMatcher=ge,t.PhoneNumberSearch=pe,t.PhoneNumberSearchCustom=gd,t.findNumbers=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Jd.apply(this,t)},t.findPhoneNumbers=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),vd.apply(this,t)},t.findPhoneNumbersCustom=vd,t.findPhoneNumbersInText=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),ee.apply(this,t)},t.format=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Pt.apply(this,t)},t.formatCustom=Pt,t.formatIncompletePhoneNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),me.apply(this,t)},t.formatNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Pt.apply(this,t)},t.formatRFC3966=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),V.apply(this,t)},t.getCountries=function(){return function(t){return new l(t).getCountries()}(d)},t.getCountryCallingCode=be,t.getCountryCallingCodeCustom=v,t.getExampleNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Ft.apply(this,t)},t.getExtPrefix=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),g.apply(this,t)},t.getNumberType=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Tt.apply(this,t)},t.getNumberTypeCustom=Tt,t.getPhoneCode=function(t){return be(t)},t.getPhoneCodeCustom=function(t,d){return v(t,d)},t.isPossibleNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Rt.apply(this,t)},t.isSupportedCountry=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),b.apply(this,t)},t.isValidNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),kt.apply(this,t)},t.isValidNumberCustom=kt,t.isValidNumberForRegion=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Dt.apply(this,t)},t.parse=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Ct.apply(this,t)},t.parseCustom=Ct,t.parseDigits=S,t.parseIncompletePhoneNumber=I,t.parseNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Ct.apply(this,t)},t.parsePhoneNumber=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),yt.apply(this,t)},t.parsePhoneNumberCharacter=F,t.parsePhoneNumberFromString=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),bt.apply(this,t)},t.parseRFC3966=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),U.apply(this,t)},t.searchNumbers=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),Qd.apply(this,t)},t.searchPhoneNumbers=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),bd.apply(this,t)},t.searchPhoneNumbersCustom=bd,t.searchPhoneNumbersInText=function(){var t=Array.prototype.slice.call(arguments);return t.push(d),$e.apply(this,t)},Object.defineProperty(t,\"__esModule\",{value:!0})}");

	var libPhoneNumberModule = {};
	libPhoneNumber(libPhoneNumberModule);

	return Object.freeze(libPhoneNumberModule);
});

/**
 * SuiteScript format/i18n module
 *
 * @module N/format/i18n
 * @NApiVersion 2.x
 *
 */
define('N/format/i18n',['N/internal/invoker', 'N/restricted/formatApi', 'N/utilityFunctions', 'N/error', 'N/formatI18nCommon','N/libphonenumber'],
	function (invoker, formatApi, utilityFunctions, error, formatI18nCommon, libphonenumber)
	{
		var _constForJsE164 = 'E.164';
		var _phoneFormatterE164 = null;

		function _getPhoneFormatterE164()
		{
			if (!_phoneFormatterE164) {
				_phoneFormatterE164 = doGetClientPhoneNumberFormatter({formatType: formatI18nCommon.PhoneNumberFormatType.E164});
			}
			return _phoneFormatterE164;
		}

		var spellOut = formatI18nCommon.spellOut;
		/**
		 * Returns number spelled out as a string of words.
		 * @governance none
		 * Asynchronous
		 *
		 * @param {Object} options
		 * @param {number} options.number Number to be spelled out
		 * @param {string} options.locale Locale code as a string
		 *
		 * @return {string} Number described in words
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if name parameter is missing
		 *
		 * @since 2019.1
		 */
		spellOut.promise = function()
		{
			return utilityFunctions.promiseTo(spellOut, arguments);
		};

		var getCurrencyFormatter = formatI18nCommon.getCurrencyFormatter;

		/**
		 * Returns CurrencyFormatter object, which can format numbers to currency strings
		 * @governance none
		 * Asynchronous
		 *
		 * @param {Object} options
		 * @param {string} [options.currency] (enum) Code of currency used by formatter.
		 * @param {string} [options.locale] Locale for which the formatter is created.
		 * Just one of these two parameters is mandatory.
		 * @governance none
		 * @throws {error.SuiteScriptError} NEITHER_ARGUMENT_DEFINED if both parameters are missing.
		 * @throws {error.SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS When two mutually exclusive arguments are defined.
		 * @throws {error.SuiteScriptError} SSS_INVALID_TYPE_ARG in case of wrong parameter type.
		 * @throws {error.SuiteScriptError} SSS_INVALID_CURRENCY_ID if invalid currency is used.
		 * @throws {error.SuiteScriptError} INVALID_LOCALE if locale parameter is invalid.
		 *
		 * @since 2019.2
		 */
		getCurrencyFormatter.promise = function()
		{
			return utilityFunctions.promiseTo(getCurrencyFormatter, arguments, formatI18nCommon.ppCurrencyFormatter);
		};

		var getNumberFormatter = formatI18nCommon.getNumberFormatter;
		/**
		 * Returns NumberFormatter object, which can format numbers to number strings
		 * @governance none
		 * Asynchronous
		 *
		 * @param {Object} [options]
		 * @param {string} [options.locale] Locale for which the formatter is created (since 2021.1)
		 * @param {string} [options.groupSeparator]
		 * @param {string} [options.decimalSeparator]
		 * @param {number} [options.precision]
		 * @param {string} [options.negativeNumberFormat] (enum)
		 *
		 *  @since 2019.2
		 */
		getNumberFormatter.promise = function()
		{
			return utilityFunctions.promiseTo(getNumberFormatter, arguments, formatI18nCommon.ppNumberFormatter);
		};

		/**
		 * @class PhoneNumber
		 * @classdesc This object holds all necessary information about phone number.
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 *
		 * Here must be different version for client side. API is the same but internal reperesentation is different
		 * because libphonenumber-js uses different approach to formatting. It calls PN.format('INTERNATIONAL')
		 * instead of our PNFormatter.format(PN) where PN is object of type PhoneNumber
		 */
		function PhoneNumber(legacyPhoneNumber, rawInput) {
			var that = this;
			/**
			 * Valid - it means legacyPhoneNumber was successfuly parsed and contains correct phone number object
			 * @name PhoneNumber#valid
			 * @type {boolean}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'valid', {
				get: function () {
					return legacyPhoneNumber !== null && legacyPhoneNumber !== undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'valid');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Country code
			 * @name PhoneNumber#countryCode
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'countryCode', {
				get: function () {
					if (that.valid)
						return legacyPhoneNumber.countryCallingCode;
					else
						return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'countryCode');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Extension
			 * @name PhoneNumber#extension
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'extension', {
				get: function () {
					if (that.valid)
						return legacyPhoneNumber.ext;
					else
						return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'extension');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * National number
			 * @name PhoneNumber#nationalNumber
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'nationalNumber', {
				get: function () {
					if (that.valid)
						return legacyPhoneNumber.nationalNumber;
					else
						return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'nationalNumber');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of leading zeros
			 * @name PhoneNumber#numberOfLeadingZeros
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'numberOfLeadingZeros', {
				get: function () {
					return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'numberOfLeadingZeros');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Carrier code
			 * @name PhoneNumber#carrierCode
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'carrierCode', {
				get: function () {
					if (that.valid)
						return legacyPhoneNumber.carrierCode;
					else
						return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'carrierCode');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			// internal, for compatibility with legacy phone number type
			Object.defineProperty(this, 'countryCodeName', {
				get: function () {
					if (that.valid)
						return legacyPhoneNumber.country;
					else
						return undefined;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'countryCodeName');
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			/**
			 * Raw input
			 * @name PhoneNumber#rawInput
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'rawInput', {
				get: function () {
					return rawInput;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'rawInput');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			this.format = function(fmtType) {
				var cUKCountryCode = '44';
				var cUKExtension = ' x';
				var cDefaultExtension = ' ext. ';

				if (legacyPhoneNumber === null || legacyPhoneNumber === undefined || fmtType === null || fmtType === undefined) {
					return rawInput;
				}
				var formattedNumber = legacyPhoneNumber.format(fmtType);
				if (fmtType === _constForJsE164 && this.extension != null) { // workaround for E.164 fmt which ignores extension !!!
					formattedNumber = formattedNumber + (this.countryCode === cUKCountryCode ? cUKExtension : cDefaultExtension)
						+ this.extension.toString();
				}
				return formattedNumber;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					countryCode: countryCode,
					extension: extension,
					nationalNumber: nationalNumber,
					numberOfLeadingZeros: numberOfLeadingZeros,
					carrierCode: carrierCode,
					countryCodeName: countryCodeName,
					rawInput: rawInput
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumber';
			};
		}

		/**
		 * Object for parsing phone numbers.
		 * @class
		 * @classdesc Method 'parse' takes string and returns object of PhoneNumber type.
		 * @constructor
		 * @protected
		 *
		 * @param {string} defaultCountry Default country for parsing (e.g. UNITEDSTATES)
		 * @param {string} defaultCountryCode Code of default country (e.g. US)
		 * @since 2020.2
		 */
		function PhoneNumberParser(defaultCountry, defaultCountryCode) {
			/**
			 * Default country
			 * @name PhoneNumberParser#defaultCountry
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'defaultCountry', {
				get: function () {
					return defaultCountry;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'defaultCountry');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Default country code
			 * @name PhoneNumberParser#defaultCountryCode
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'defaultCountryCode', {
				get: function () {
					return defaultCountryCode;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'defaultCountryCode');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns parsed phone number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.number Phone number to be parsed
			 *
			 * @return {Object} of type PhoneNumber
			 *
			 * @since 2020.2
			 */
			this.parse = function parse(options) { // post-processing is needed here
				utilityFunctions.checkArgs([options], ['options'], 'PhoneNumberParser.parse');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				utilityFunctions.checkArgs([options.number], ['number'], 'PhoneNumberParser.parse');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number', util.isString)]);
				var numberStr = options.number;
				var legacyPhoneNumber = libphonenumber.parsePhoneNumberFromString(numberStr, defaultCountryCode); // returns PhoneNumber from library

				return new PhoneNumber(legacyPhoneNumber, numberStr);
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					defaultCountry: defaultCountry,
					defaultCountryCode: defaultCountryCode
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumberParser';
			};
		}

		function doGetClientPhoneNumberParser(options)
		{
			var validCountries = formatI18nCommon.Country;
			var validCountryCodes = formatI18nCommon._getCountryCodes(); // map country -> country code

			utilityFunctions.checkArgs([options], ['options'], 'getPhoneNumberParser');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var defaultCountry = validCountries.UNITEDSTATES; // default value (if no country is set)
			if (options.hasOwnProperty("defaultCountry")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.defaultCountry, 'defaultCountry', function (param) {return util.isString(param) || util.isObject(param)})]);
				defaultCountry = options.defaultCountry;
			}

			if (defaultCountry != null && !(defaultCountry in validCountries)) {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_COUNTRY_ID, 'getPhoneNumberParser', defaultCountry);
			}
			var countryCode = validCountryCodes[defaultCountry];
			return new PhoneNumberParser(defaultCountry, countryCode);
		}

		/**
		 * Object for formatting phone numbers.
		 * @class
		 * @classdesc Method format takes object of type PhoneNumber and returns string.
		 * @constructor
		 * @protected
		 *
		 * @param {*} formatType enum, to specify required format (e.g. INTERNATIONAL)
		 *
		 * @since 2020.2
		 */
		function PhoneNumberFormatter(formatType) {
			/**
			 * Format Type
			 * @name PhoneNumberFormatter#formatType
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'formatType', {
				get: function () {
					return formatType;
				},
				set: function (val) {
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formatType');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the formatted phone number.
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {Object} options.number Phone number to be formatted
			 *
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.format = function format(options) { // returns just String so post-processing is not needed here
				utilityFunctions.checkArgs([options], ['options'], 'PhoneNumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

				utilityFunctions.checkArgs([options.number], ['number'], 'PhoneNumberFormatter.format');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.number, 'number',
					function(input){return input instanceof PhoneNumber;})]);

				return options.number.format(formatType === formatI18nCommon.PhoneNumberFormatType.E164 ?
					_constForJsE164 : formatType); // nasty hack, difference between Java/Js library
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function()
			{
				return {
					formatType: formatType
				};
			};

			/**
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function()
			{
				return 'format.i18n.PhoneNumberFormatter';
			};
		}

		function doGetClientPhoneNumberFormatter(options)
		{
			var validFormatTypes = formatI18nCommon.PhoneNumberFormatType;

			utilityFunctions.checkArgs([options], ['options'], 'getPhoneNumberFormatter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var formatType = validFormatTypes.INTERNATIONAL; // default value
			if (options !== undefined && options !== null && options.hasOwnProperty("formatType")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.formatType, 'formatType', function(param){return util.isString(param) || util.isObject(param)})]);
				formatType = options.formatType;
			}

			if (formatType != null && (validFormatTypes === undefined || validFormatTypes === null || !(formatType in validFormatTypes))) {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_FORMAT_TYPE, 'getPhoneNumberFormatter', formatType);
			}

			return new PhoneNumberFormatter(formatType);
		}

		function _doFormatToE164(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'formatToE164');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var phoneNumber = undefined;
			var countryCode = undefined;
			if (options.hasOwnProperty("phoneNumber")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.phoneNumber, 'phoneNumber', util.isString)]);
				phoneNumber = options.phoneNumber;
			} else {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_MISSING_REQD_ARGUMENT, 'phoneNumber');
			}

			if (options.hasOwnProperty("countryCode")) {
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.countryCode, 'countryCode', util.isString)]);
				countryCode = options.countryCode;
			} else {
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_MISSING_REQD_ARGUMENT, 'countryCode');
			}

			var countryName = formatI18nCommon._getCountryByCode(countryCode); // assume that countryCode is always correct
			var phoneNumberParser = doGetClientPhoneNumberParser({defaultCountry: countryName});
			var phoneNumberObject = phoneNumberParser.parse({number: phoneNumber});
			return _getPhoneFormatterE164().format({number: phoneNumberObject}) +
				   formatI18nCommon._getSuffixAfterValidPhoneNumber(phoneNumber);
		}

		function _doFormatPhoneUIField(numberToFormat, countryCode, keepSuffix, useNationalFormatIfPossible, trimLength)
		{
			var countryName = formatI18nCommon._getCountryByCode(countryCode); // assume that countryCode is always correct
			var phoneNumberParser = doGetClientPhoneNumberParser({defaultCountry: countryName});

			// this is pure client solution
			var phoneNumber = phoneNumberParser.parse({number: numberToFormat});

			// behaviour: if phonenumber country is the same as country of this role, format number in NATIONAL format
			var actualFormatType = formatI18nCommon.PhoneNumberFormatType.INTERNATIONAL;
			if (useNationalFormatIfPossible && phoneNumber !== null && phoneNumber !== undefined
				     && phoneNumber.countryCodeName === countryCode) {
				actualFormatType = formatI18nCommon.PhoneNumberFormatType.NATIONAL;
			}
			var phoneNumberFormatter = doGetClientPhoneNumberFormatter({formatType: actualFormatType});
			var fmtNumber = phoneNumberFormatter.format({number: phoneNumber});

			if (keepSuffix && phoneNumber.valid) {
				fmtNumber = fmtNumber + formatI18nCommon._getSuffixAfterValidPhoneNumber(numberToFormat);
			}

			if (trimLength > 0 && fmtNumber.length > trimLength) {
				fmtNumber = fmtNumber.substr(0, trimLength);
			}

			return fmtNumber;
		}

		return Object.freeze({
			spellOut: spellOut,

			getCurrencyFormatter: getCurrencyFormatter,

			getNumberFormatter: getNumberFormatter,

			NegativeNumberFormat: formatI18nCommon.NEGATIVE_NUMBER_FORMATS,

			get Currency() {
				return formatI18nCommon.Currency;
			},

			get PhoneNumberFormatType() {
				return formatI18nCommon.PhoneNumberFormatType;
			},

			get Country() {
				return formatI18nCommon.Country;
			},

			getPhoneNumberParser: doGetClientPhoneNumberParser,

			getPhoneNumberFormatter: doGetClientPhoneNumberFormatter,

			_formatToE164: _doFormatToE164,

			get PhoneFieldMaxLength() {
				return formatI18nCommon.PhoneFieldMaxLength;
			},

			get SubsidiaryCountry() {
				return formatI18nCommon.SubsidiaryCountry;
			},

			_getCountryByCode: formatI18nCommon._getCountryByCode,

			_formatPhoneUIField: _doFormatPhoneUIField
		})
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/formatter
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/formatter',['N/util/currencyUtility', 'N/util/date','N/FieldValidationHelper', 'N/dateTimeZone','N/error', 'N/utilityFunctions', 'N/fieldTypeConstants', 'N/format/i18n', 'require'],
	function (CurrencyUtil, DateUtil, FieldValidationHelper, dateTimeZone, error, utilityFunctions, fieldTypeConstants, formatI18n, require){
		/** FORMATTING FUNCTIONS - Used to convert INTO a user's preference format **/

		/**
		 * Takes in a numerical value and returns a string reformatted to match the user's format preference.
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLNumberToString
		 * @param {*} num - a javascript friendly numerical value. Ex: -23456.93
		 * @param {*} addPercentSign - adds a percent sign at the end of the string (or before the negative suffix)
		 * @returns {string} a String version of the numerical value meeting the user's format preference. Ex: (23.456,93)
		 */
		function formatNumber(num, addPercentSign)
		{
			if (isNaN(num) || utilityFunctions.isValEmpty(num))
				return num;
	
			var str = '' + num;
			var parts = str.split(".");
			var integerPart = parts[0];
			var decimalPart = parts.length > 1 ? FieldValidationHelper.decimalseparator + parts[1] : '';
	
			if (FieldValidationHelper.groupseparator !== '')
			{
				var regex = /(\d+)(\d{3})/;
				while (regex.test(integerPart))
				{
					integerPart = integerPart.replace(regex, '$1' + FieldValidationHelper.groupseparator + '$2');
				}
			}
	
			if (num < 0 && FieldValidationHelper.negativeprefix !== '-')
			{
				return FieldValidationHelper.negativeprefix + integerPart.replace('-', '') + decimalPart
							   + (!!addPercentSign ? "%" : "") + FieldValidationHelper.negativesuffix;
			}
			else
			{
				return integerPart + decimalPart + (!!addPercentSign ? "%" : "");
			}
	
		}
	
		/**
		 * Takes in a string representing a phone number and attempts to format it in the set user preference
		 *
		 * Will only perform reformatting if ALL of the following are true:
		 *  - A user preference is set
		 *  - phoneStr consists of only digits, spaces, periods, dashes, and parentheses
		 *  - There are exactly 7 or 10 digits, or 11 digits and phoneStr begins with a 1
		 *  Otherwise it will return back the string, unmodified
		 *
		 *  Information above is valid for old phone number formatting.
		 *  If the feature 'International phone number format' is ON then formatting will be performed
		 *  according to this feature. (this change is since 2020.2)
		 *
		 * @param {*} phoneStr - a string that contains a phone number
		 * @returns {string} a string reformatted in the user's preference (if possible)
		 */
		function formatPhoneNumber(phoneStr)
		{
			if (utilityFunctions.isValEmpty(phoneStr))
				return phoneStr;

			var returnMe = "" + phoneStr;

			var internationalPhoneNumbersOn = false;
			var country = 'US';

			if (typeof document === 'undefined') { // server
				require(['N/runtime'], function (runtime) {
					internationalPhoneNumbersOn = runtime.isFeatureInEffect("INTERNATIONALPHONENUMBERS");
					country = formatI18n.SubsidiaryCountry;
				});

				if (internationalPhoneNumbersOn) {
					returnMe = formatI18n._formatPhoneNumberForModuleFormat(returnMe, country, true, true, formatI18n.PhoneFieldMaxLength);

					// var countryName = formatI18n._getCountryByCode(country);  // e.g. US
					// var phoneNumberParser = formatI18n.getPhoneNumberParser({defaultCountry: countryName});//e.g. UNITED_STATES
					// var phoneNumberStr = returnMe;
					// var phoneNumber = phoneNumberParser.parse({number: phoneNumberStr});
					// var phoneNumberFormatter = formatI18n.getPhoneNumberFormatter({formatType: formatI18n.PhoneNumberFormatType.INTERNATIONAL});
					// returnMe = phoneNumberFormatter.format({number: phoneNumber});
					return returnMe;
				}
			} else { // client
				var context = require('N/internal/reflet').nlapiGetContext();
				internationalPhoneNumbersOn = context.getFeature("INTERNATIONALPHONENUMBERS");
				country = formatI18n.SubsidiaryCountry;

				if (internationalPhoneNumbersOn) {
					returnMe = formatI18n._formatPhoneUIField(returnMe, country, true, true, formatI18n.PhoneFieldMaxLength);
					return returnMe;
				}
			}

			var phoneFormatPref = FieldValidationHelper.phoneformat;
			if (phoneFormatPref === null || typeof phoneFormatPref === "undefined" || /[A-Za-z]/.test(returnMe))
				return returnMe;

			var valueStripped = phoneStr.replace(/[\s\.\-\(\)]/g, "");
			if (/^[0-9]+$/.test(valueStripped)) {
				var ETX_CHAR = String.fromCharCode(3);
				var phoneformat = phoneFormatPref.replace(new RegExp("[360]", "g"), ETX_CHAR);
				if (valueStripped.length === 7)
					returnMe = phoneformat.replace(phoneformat.substring(0, phoneformat.indexOf('4')), '')
						.replace('45' + ETX_CHAR, valueStripped.substring(0, 3))
						.replace('789' + ETX_CHAR, valueStripped.substring(3));
				else if (valueStripped.length === 10)
					returnMe = phoneformat.replace('12' + ETX_CHAR, valueStripped.substring(0, 3))
						.replace('45' + ETX_CHAR, valueStripped.substring(3, 6))
						.replace('789' + ETX_CHAR, valueStripped.substring(6));
				else if (valueStripped.length === 11 && valueStripped.substring(0, 1) === '1')
					returnMe = '1 ' + phoneformat.replace('12' + ETX_CHAR, valueStripped.substring(1, 4))
						.replace('45' + ETX_CHAR, valueStripped.substring(4, 7))
						.replace('789' + ETX_CHAR, valueStripped.substring(7));
			}
			return returnMe;
		}

		function isItDateAsExpected(dateObj)
		{
			/*
			 * For backwards compatibility, the invalid dates are only logged here.
			 * In new API functions, please handle these cases in a fail-fast fashion:
			 *
			 *      utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, ...)
			 */
			if (!(
				dateObj instanceof Date ||
				Object.prototype.toString.call(dateObj) === '[object Date]'
			))
			{
				utilityFunctions.logSuiteScriptError(
					error.Type.INVALID_TYPE_1_USE_2,
					utilityFunctions.getConstructorNameSafe(dateObj),
					Date.name
				);
				return false;
			}
			else if (isNaN(dateObj.getDay()))
			{
				/* (new Date("x")).getDay()     ---> NaN
				 * (new Date("x")).toString()   ---> "INVALID DATE"  // in Chrome, Firefox
				 */
				utilityFunctions.logSuiteScriptError(error.Type.INVALID_DATE_OBJECT);
				return true;
			}
			else
			{
				return true;
			}
		}

		// changes a Date object into a String that follows the user's Date Preference
		function formatDate(dateObj)
		{
			if (isItDateAsExpected(dateObj))
			{
				dateObj = new Date(dateObj);
				return DateUtil.getDateString(dateObj);
			}
			else
				return dateObj;
		}

		// changes a Date object into a String that follows the user's Time Preference
		function formatTime(timeObj)
		{
			if (isItDateAsExpected(timeObj))
			{
				timeObj = new Date(timeObj);
				return DateUtil.getTimeString(timeObj);
			}
			else
				return timeObj;
		}

		// changes a Date object into a String that follows the user's Date+Time Preference
		function formatDateTimeTz(dateTimeObj)
		{
			if (isItDateAsExpected(dateTimeObj))
				return dateTimeZone.format(dateTimeObj);
			else
				return dateTimeObj;
		}

		// changes a Date object into a String that follows the user's Date Preference (but only the MM/YYYY portion)
		function formatMMYYDate(dateObj)
		{
			if (isItDateAsExpected(dateObj))
				return DateUtil.getMMYYString(dateObj);
			else
				return dateObj;
		}
	
		// converts a numerical number (units: hours) into HH:MM format
		function formatToHHMM(numHrs)
		{
			if (isNaN(numHrs) || utilityFunctions.isValEmpty(numHrs))
				return numHrs;
	
			var isNeg = false;
			if (numHrs < 0)
			{
				isNeg = true;
				numHrs *= -1
			}
	
			var hrs = Math.floor((numHrs*60+0.5)/60);
			var mins = Math.floor((numHrs-hrs)*60+0.5);
			var sign = isNeg ? "-" : "";

			return sign + hrs + ":" + (mins < 10 ? "0" : "") + mins;
		}
	
		// formats currency based on precision / field type
		// isCurrency2 should be true for CURRENCY2 types
		function formatCurrency(num, isCurrency2, recordContext)
		{
			if (utilityFunctions.isValEmpty(num))
				return num;
	
			var formattedCurrency = isCurrency2 ? CurrencyUtil.format_currency2(num)
												: CurrencyUtil.format_currency(num, false, recordContext);
	
			return (formattedCurrency === '') ? num : formatNumber(formattedCurrency, false);
		}
	
		// Adds a % if specified, and pads with zeros to the precision defined by currencyprecision (...why?)
		// includePercentSign - Adds % if true, also pads with zeros to 10ths place if true, 100ths if false (... why?)
		function formatRate(rateNum, includePercentSign)
		{
			var strRateNum = "" + rateNum;
			if (strRateNum.indexOf('%') !== -1)
			{
				rateNum = strRateNum.replace('%', '');
				includePercentSign = true;
			}

			if (isNaN(rateNum) || utilityFunctions.isValEmpty(rateNum)) {
				return includePercentSign ? rateNum + "%" : rateNum;
			}

			var returnMe = CurrencyUtil.format_rate(rateNum, includePercentSign).replace("%", "");

			if (returnMe.toString().search(/e/i) != -1) {
				var parts = returnMe.split("e");
				if (parts.length > 1 && parseFloat(parts[1]) < 0) {
					var toFixed = parseFloat(parts[1]) * -1;
					returnMe = parseFloat(returnMe).toFixed(toFixed);
				}
			}

			return (returnMe === '') ? rateNum : formatNumber(returnMe, includePercentSign);
		}
	
		// Adds a .0 if has no decimal places and will always add a % sign
		function formatPercent(percentNum)
		{
			if (isNaN(percentNum) || utilityFunctions.isValEmpty(percentNum))
				return percentNum;
	
			var returnMe = CurrencyUtil.format_percent(percentNum).replace("%", "");
			return formatNumber(returnMe, true);
		}

		function formatCheckbox(checkboxValue)
		{
			return (typeof checkboxValue === 'boolean' && checkboxValue) || checkboxValue === 'T' ? 'T' : 'F';
		}
	
		function format(value, type, isNum, isCurr, recordContext, includePercentSign)
		{
			var returnMe;
			var isNumeric = isNum || fieldTypeConstants.isNumeric(type);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(type);

			if (utilityFunctions.isValEmpty(value))
				return value;
			if (type === fieldTypeConstants.Type.DATE)
			{
				return formatDate(value);
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				return formatTime(value);
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
			{
				return formatDateTimeTz(value);
			}
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				return formatMMYYDate(value);
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return formatToHHMM(value);
			}
			else if ( (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
			{
				return formatRate(value, includePercentSign);
			}
			else if (type === fieldTypeConstants.Type.PERCENT)
			{
				return formatPercent(value);
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return formatCheckbox(value);
			}
			else if (!!isNumeric)
			{
				return formatNumber(value, false);
			}
			else if (!!isCurrency)
			{
				return formatCurrency(value, type === fieldTypeConstants.Type.CURRENCY2, recordContext);
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return formatPhoneNumber(value);
			}
	
			return value;
		}

		//keep this in sync with groupSeparatorPositionsValid in Formatter.java
		function groupSeparatorPositionsValid(str)
		{
			if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
				str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
			if (str.length < 3)
				return false;
			var lastDecimal = util.isString(FieldValidationHelper.decimalseparator) ? str.lastIndexOf(FieldValidationHelper.decimalseparator) : -1;
			if (lastDecimal >= 0)
				str = str.substr(0, lastDecimal);
			var parts = str.split(FieldValidationHelper.groupseparator);
			if (parts.length > 1)
			{
				for (var i = 1; i < parts.length; i++)
				{
					if (parts[i].length != 3)
						return false;
				}
			}
			return true;
		}
	
		/** PARSING FUNCTIONS - used to help make values into its appropriate format for validation **/
	
		/**
		 * Takes in a string formatted in the user's format preference and returns the numerical value
		 * (Negative representation, number groupings, decimal representation)
		 *
		 * Adapted/Improved from NLUtil.jsp's NLStringToNumber
		 * @param {*} str - A number in a string in the user's format preference. Ex: "(23.456,93)"
		 * @param {*} autoplace - boolean indicating whether to divide by 100 if no decimal separator is present.
		 * @param {*} ignoreUserPrefs - ignore user's format preference
		 * @returns {number} a Numerical value that Javascript can read (isNaN will return that it is a number). Ex: -23456.93
		 */
		function formatUserPrefStringToJSNumber(str, autoplace, ignoreUserPrefs)
		{
			str = "" + str;
			if(utilityFunctions.isValEmpty(str))
				return "";
			if (!ignoreUserPrefs)
			{
				if(FieldValidationHelper.groupseparator && FieldValidationHelper.groupseparator !== '' && groupSeparatorPositionsValid(str))
					str = str.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '');
				if(FieldValidationHelper.negativeprefix !== '-' && str.indexOf(FieldValidationHelper.negativeprefix) === 0)
					str = '-' + str.replace(FieldValidationHelper.negativeprefix, '').replace(FieldValidationHelper.negativesuffix, '');
				if(FieldValidationHelper.decimalseparator === ',')
					str = str.replace(FieldValidationHelper.decimalseparator, '.');
			}

			if (isNaN(str))
				return str;
			else if (autoplace && (str.indexOf(".") === -1))
				return parseFloat(str) / 100;
			else
				return parseFloat(str);
		}
	
		/**
		 * Takes in a timeStr (or a number) and converts it into a number in hours
		 *
		 * If in HH:MM format, it will return HH + MM/60
		 * If !isNaN, it will just return the parseFloat of the value
		 * Otherwise it will return null.
		 *
		 * @param {*} timeStr - a time string in HH:MM format, or a number
		 */
		function convertTimeStringToHours(timeStr)
		{
			var isPositive = true;
            var convertedStr = "" + timeStr;
	
			if (convertedStr.slice(0, 1) === "-")
			{
				isPositive = false;
                convertedStr = convertedStr.slice(1);
			}
			var pattern = /([0-9]*)?:([0-9]+)?/;
			var result = pattern.exec(convertedStr);
	
			if (result === null) // not HH:MM format
			{
				if (isNaN(convertedStr)) // not a number
				{
					return timeStr;
				}
				else // a number
				{
					return (isPositive ? 1 : -1) * parseFloat(convertedStr);
				}
			}
			else // is in HH:MM format
			{
				var hours;
				var minutes;
				if (RegExp.$1.length > 0)
				{
					hours = parseInt(RegExp.$1, 10);
				}
				else
				{
					hours = 0;
				}
				if (typeof(RegExp.$2) !== "undefined" && RegExp.$2.length > 0)
				{
					minutes = parseInt(RegExp.$2, 10);
				}

				return (isNaN(hours) || isNaN(minutes)) ? timeStr : (isPositive ? 1 : -1) * (hours + minutes/60);
			}
		}
	
		/**
		 *  Attempts to evaluate a math equation
		 *
		 *  Will ignore a leading equals sign (=)
		 *  and perform addition(+), subtraction(-), multiplication(*), and division(/)\
		 *
		 *  Returns 'equation' back if it is empty, null, undefined, if it's a number already, or an invalid equation
		 *
		 *  @param {*} equation must only consist of + - * / . ( ) and digits
		 *  @returns {*} the equation evaluated
		 */
		function evaluateMath(equation)
		{
			if (utilityFunctions.isValEmpty(equation) || !isNaN(equation))
				return equation;
	
			var calcMe = equation;
			if(equation.charAt(0) === '=')
				calcMe = equation.substr(1);
	
			if(!!FieldValidationHelper.groupseparator && !!FieldValidationHelper.decimalseparator)
				calcMe = calcMe.replace(new RegExp( '\\' + FieldValidationHelper.groupseparator, 'g'), '')
							   .replace(new RegExp( '\\' + FieldValidationHelper.decimalseparator, 'g'), '.');
	
			if (isNaN(calcMe) && calcMe.match(/[\+\-\*\/0-9\.\(\)\s]+/))
			{
				try
				{
					calcMe = eval.apply(utilityFunctions.getGlobalScope(), [calcMe]);
				}
				catch (e)
				{
					calcMe = equation;
				}
			}
			else
			{
				calcMe = equation;
			}
	
			return calcMe;
		}
	
		/**
		 *  Attempts to convert shorthanded time into time in the user's preference
		 *
		 *  Removes leading and trailing spaces
		 *  The Time portion of timeStr must be in the form of:
		 *	  1-4 digits followed by the first character of the user's AM/PM string
		 *  Will return an empty string if equation is empty, null, or undefined
		 *
		 *  Consult DateUtil.hhmmToTimeString for further details on how it is converted to proper form
		 *
		 *  @param {*} timeStr a string containing a time or a date and time (separated by a space)
		 *  @returns {string} the string back with the time portion converted to the user's preference
		 */
		function formatShorthandedTime(timeStr)
		{
			timeStr = util.trim(timeStr);
			if (utilityFunctions.isValEmpty(timeStr))
				return "";
			var lastSpaceIdx = timeStr.lastIndexOf(" ");
			if (lastSpaceIdx > 0) // "date time" form
			{
				return timeStr.slice(0, lastSpaceIdx + 1) + DateUtil.hhmmToTimeString(timeStr.slice(lastSpaceIdx + 1))
			}
			else // "time" form
			{
				return DateUtil.hhmmToTimeString(timeStr);
			}
		}
	
		// If the string '://' is not found then pre-pend the default protocol prefix
		function addHTTPIfNecessary(urlString)
		{
			if (urlString.indexOf("://") === -1 && urlString.charAt(0) !== '/')
				urlString = "http://" + urlString;
	
			return urlString;
		}
	
		// Accepts 456?7890 or depending on user format [which is either (123) 456-7890 or 123?456?7890]
		// If matches and only numbers remain, returns a string that only contains digits.
		// Otherwise it will return back the original string.
		// Does nothing if no user preference format is selected
		function stripPhoneSeparators(phoneStr)
		{
			var phoneFormat = FieldValidationHelper.phoneformat;
			if ( typeof phoneFormat === "undefined" )
				return phoneStr;
	
			phoneStr = util.trim(phoneStr);
	
			var formatHasParens = (phoneFormat.indexOf("(") === 0);
			var formatDelimiter = phoneFormat.slice(-5, -4);
			var hasNoAreaCode   = (phoneStr.length === 8);

            if (formatDelimiter === ".")
                formatDelimiter = "\\.";
			var formatRegex = new RegExp("^(" + (formatHasParens ? "\\(" : "") + "(\\d{3})" + (formatHasParens ? "\\)\\ " : formatDelimiter) + ")?"
											  + "(\\d{3})" + formatDelimiter
											  + "(\\d{4})$");
	
			var matchResult = phoneStr.match(formatRegex);
	
			if (matchResult === null)
			{
				return phoneStr;
			}
			else
			{
				return (matchResult[2] ? matchResult[2] : "") + matchResult[3] + matchResult[4];
			}
		}
	
		function parseCCDateStr(ccStr)
		{
			var parts = ccStr.split("/");
			var returnStr = "";
			if (parts.length === 2)
			{
				if (isNaN(parts[0]) || isNaN(parts[1]))
					return ccStr;
				var monthPart = parseInt(parts[0], 10)
				var yearPart  = parseInt(parts[1], 10)
				if (isNaN(monthPart) || isNaN(yearPart) || monthPart <= 0 || monthPart > 12 || yearPart < 0)
					return ccStr;
	
				if (monthPart < 10)
					returnStr = "0" + monthPart + "/";
				else
					returnStr = monthPart + "/";
	
				if (yearPart < 50)
					returnStr += 2000 + yearPart;
				else if (yearPart < 100)
					returnStr += 1900 + yearPart;
				else
					returnStr += yearPart;
	
				return returnStr;
			}
			else
				return ccStr;
		}

        function convertToUserPreferenceTZDate(dateTimeObj)
        {
            return dateTimeZone.parse(dateTimeObj);
        }
	
		function parse(value, type, isNum, isCurr, validationType, autoplace, skipPercentage, ignoreUserPrefs)
		{
			var returnMe;
			var isNumeric = isNum || fieldTypeConstants.isNumeric(type);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(type);
	
			if (utilityFunctions.isValEmpty(value))
				return value;
	
			if ( (type !== fieldTypeConstants.Type.TEXT) && (type !== fieldTypeConstants.Type.IDENTIFIER) &&
				 (type !== fieldTypeConstants.Type.IDENTIFIERANYCASE) && (type !== fieldTypeConstants.Type.ADDRESS) &&
				 (type !== fieldTypeConstants.Type.TEXTAREA) && (type !== fieldTypeConstants.Type.CLOBTEXT) &&
				 (/[\uff01-\uff5e]/.exec(value) !== null) )
				value = value.replace(/[\uff01-\uff5e]/g, function(ch) { return String.fromCharCode(ch.charCodeAt(0) - 0xfee0); });
	
			if (type === fieldTypeConstants.Type.DATE)
			{
				returnMe = DateUtil.regexStringToTime(value, null, false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if (type === fieldTypeConstants.Type.TIMEOFDAY)
			{
				returnMe = DateUtil.regexStringToTime(null, formatShorthandedTime(value), false, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
            else if ( (type === fieldTypeConstants.Type.DATETIME) || (type === fieldTypeConstants.Type.DATETIMETZ) )
            {
                returnMe = convertToUserPreferenceTZDate(value);
                return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
            }
			else if (type === fieldTypeConstants.Type.MMYYDATE)
			{
				returnMe = DateUtil.stringToMMYYDate(value, true);
				return (isNaN(returnMe) || (returnMe === null)) ? value : returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.TIME) || (type === fieldTypeConstants.Type.TIMETRACK) )
			{
				return convertTimeStringToHours(value);
			}
			else if (!!isNumeric || !!isCurrency)
			{
				if (typeof value === 'number')
					return value;
                var strValue = "" + value;
				var isPercentage = false;
				if ( (type === fieldTypeConstants.Type.PERCENT) || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION) )
				{
					isPercentage = strValue.indexOf('%') !== -1;
					if (isPercentage)
                        strValue = strValue.replace('%', '');
				}
                var evalValue = strValue;
                var evalPerformed = false;
                if (!!isCurrency && ( strValue.substr(1).search(/[\+\-\*\/]/g) !== -1))
                {
                    evalValue = evaluateMath(strValue);
                    // autoplace does not happen if an equation has been evaluated (value (equation) is not the same evalValue)
                    if (evalValue !== strValue)
                        evalPerformed = true;
                }
                var performAutoPlace = (autoplace && ( !!isCurrency || (type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION)))
                returnMe = evalPerformed ? evalValue : formatUserPrefStringToJSNumber(evalValue, performAutoPlace, ignoreUserPrefs);
                if (isNaN(returnMe))
                	returnMe = value;
                if (((type === fieldTypeConstants.Type.RATE) || (type === fieldTypeConstants.Type.RATEHIGHPRECISION)) && isPercentage && !skipPercentage)
                	returnMe = CurrencyUtil.format_rate(returnMe, true);
				return returnMe;
			}
			else if ( (type === fieldTypeConstants.Type.URL) )
			{
				return addHTTPIfNecessary(value);
			}
			else if ( (type === fieldTypeConstants.Type.PHONE) || (type === fieldTypeConstants.Type.FULLPHONE) )
			{
				return _reformatToE164IfNeeded(stripPhoneSeparators(value));
			}
			else if (type === fieldTypeConstants.Type.CHECKBOX)
			{
				return value === 'T' || value === true;
			}
			else if (type === fieldTypeConstants.Type.IDENTIFIER)
			{
				return value.toLowerCase();
			}
			else if (type === fieldTypeConstants.Type.CCNUMBER )
			{
				return ("" + value).replace(/ /g, "").replace(/\-/g, "");
			}
			else if ( (type === fieldTypeConstants.Type.CCEXPDATE) || (type === fieldTypeConstants.Type.CCVALIDFROM) )
			{
				return parseCCDateStr(value);
			}
			else if (type === fieldTypeConstants.Type.COLOR)
			{
				return ( ((value.charAt(0) !== "#") && (value.length === 6)) ? "#" : "") + value;
			}
			else if ((type === fieldTypeConstants.Type.FUNCTION) ||
                     ( (validationType !== null) && (typeof validationType !== "undefined") &&
					  (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION) ) )
			{
				if (value.indexOf('(') > 0)
					return value.substr(0,value.indexOf('('));
			}
	
			return value;
		}
	
		function formatValueAsString(value, fieldType)
		{
			if(util.isArray(value))
				return value.join(String.fromCharCode(5));
			/* if field does not exist or field is currency/numeric, return value */
			else if (value == null)
				return value;
			else if(!fieldType)
				return String(value);
			else
				return String(format(value, fieldType))
		}

		var comparators = (function Comparators() {

			function isEmpty(val) { return val == null || !String(val).trim(); }

			function compareIsNaN(val) { return util.isNumber(val) && isNaN(val); }

			function comparator(x, y) { return x === y ? 0 : (x > y) ? 1 : -1; }

			function textComparator(val1, val2) {
				val1 = isEmpty(val1) ? "" : (String(val1)).toUpperCase();
				val2 = isEmpty(val2) ? "" : (String(val2)).toUpperCase();
				return comparator(val1, val2);
			}

			function emailComaparator(val1, val2) {
				// split name and domain
				val1 = isEmpty(val1) ? [] : (String(val1)).split('@');
				val2 = isEmpty(val2) ? [] : (String(val2)).split('@');
				// compare by name first
				var cmpName = textComparator(val1[0], val2[0]);
				// compare by domain when name is identical
				return (cmpName !== 0) ? cmpName : textComparator(val1[1], val2[1]);
			}

			function numberComparator(val1, val2) {
				val1 = isEmpty(val1) ? -Infinity :
					util.isString(val1) ? Number(parse(val1, null, true)) :
						Number(val1);
				val2 = isEmpty(val2) ? -Infinity :
					util.isString(val2) ? Number(parse(val2, null, true)) :
						Number(val2);
				val1 = compareIsNaN(val1) ? -Infinity : val1;
				val2 = compareIsNaN(val2) ? -Infinity : val2;
				return comparator(val1, val2);
			}

			function dateComparator(val1, val2) {
				val1 = isEmpty(val1) ? -Infinity : (new Date(val1)).getTime();
				val2 = isEmpty(val2) ? -Infinity : (new Date(val2)).getTime();
				val1 = compareIsNaN(val1) ? -Infinity : val1;
				val2 = compareIsNaN(val2) ? -Infinity : val2;
				return comparator(val1, val2);
			}

			function fieldTypeBasedComparator(val1, val2, fieldType) {
				val1 = parse(val1, fieldType);
				val2 = parse(val2, fieldType);
				if ((isEmpty(val1) || util.isNumber(val1)) && (isEmpty(val2) || util.isNumber(val2)))
				{
					return numberComparator(val1, val2);
				}
				return textComparator(val1, val2);
			}

			return {
				textComparator: textComparator,
				emailComaparator: emailComaparator,
				numberComparator: numberComparator,
				dateComparator: dateComparator,
				fieldTypeBasedComparator: fieldTypeBasedComparator
			};
		})();

		/* This method formats input string with phone number to format E164 if needed and also removes +1 at the beginning if the
		   preference is ON.
		 */
		function _reformatToE164IfNeeded(inputVal)
		{
			var internationalPhoneNumbersOn = false;
			var removePlusOnePref = false;
			if (typeof document === 'undefined') { // server
				require(['N/runtime'], function (runtime) {
					internationalPhoneNumbersOn = runtime.isFeatureInEffect("INTERNATIONALPHONENUMBERS");
					removePlusOnePref = internationalPhoneNumbersOn && runtime.getCurrentUser().getPreference("PHONEWITHOUTPLUSONE");
				});
			} else { // client
				var context = require('N/internal/reflet').nlapiGetContext();
				internationalPhoneNumbersOn = context.getFeature("INTERNATIONALPHONENUMBERS");
				removePlusOnePref = internationalPhoneNumbersOn && context.getPreference("PHONEWITHOUTPLUSONE");
			}

			if (internationalPhoneNumbersOn && inputVal != null)
			{
				inputVal = formatI18n._formatToE164({phoneNumber: inputVal, countryCode: formatI18n.SubsidiaryCountry});
				if (removePlusOnePref && inputVal.toString().substr(0, 2) == "+1")
				{
					inputVal = inputVal.toString().substr(2);
				}
			}

			return inputVal;
		}

		/* assign util.formatter package */
		return Object.freeze({
			 format: format,
			 evaluateMath: evaluateMath,
			 formatValueAsString: formatValueAsString,
			 parse: parse,
			 convertTimeStringToHours: convertTimeStringToHours,
			 comparators : comparators
		});
	}
);
/**
 * SuiteScript format module
 *
 * @module N/format
 * @NApiVersion 2.x
 *
 */
define('N/format',['N/util/formatter', 'N/utilityFunctions', 'N/dateTimeZone', 'N/fieldTypeConstants', 'N/format/i18n'],
    function (formatter, utilityFunctions, dateTimeZone, fieldTypeConstants, i18n)
    {
        function doParse(options, type)
        {
            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'parse');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.URL:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.CCNUMBER:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.IDENTIFIER:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.CCEXPDATE:
                case fieldTypeConstants.Type.CCVALIDFROM:
                case fieldTypeConstants.Type.COLOR:
                case fieldTypeConstants.Type.FUNCTION:
                    return formatter.parse(value, type);

                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                case fieldTypeConstants.Type.DYNAMICPRECISION:
         		return formatter.parse(value, type, true, undef, undef, undef, true);

                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                    return formatter.parse(value, type, false, true);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.parse(value, timezone);

                default:
                    return value;
            }
        }

        function doFormat(options, type)
        {

            var value,
                timezone = null,
                undef = undefined;

            if (type !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                type = options.type;
                timezone = options.timezone || null;
            }

            utilityFunctions.checkArgs([value, type], ['value', 'type'], 'format');

            switch (type)
            {
                case fieldTypeConstants.Type.DATE:
                case fieldTypeConstants.Type.TIME:
                case fieldTypeConstants.Type.TIMETRACK:
                case fieldTypeConstants.Type.TIMEOFDAY:
                case fieldTypeConstants.Type.INTEGER:
                case fieldTypeConstants.Type.POSINTEGER:
                case fieldTypeConstants.Type.PERCENT:
                case fieldTypeConstants.Type.FLOAT:
                case fieldTypeConstants.Type.POSFLOAT:
                case fieldTypeConstants.Type.NONNEGFLOAT:
                case fieldTypeConstants.Type.POSCURRENCY:
                case fieldTypeConstants.Type.NONNEGCURRENCY:
                case fieldTypeConstants.Type.CURRENCY:
                case fieldTypeConstants.Type.CURRENCY2:
                case fieldTypeConstants.Type.CHECKBOX:
                case fieldTypeConstants.Type.PHONE:
                case fieldTypeConstants.Type.FULLPHONE:
                case fieldTypeConstants.Type.MMYYDATE:
                case fieldTypeConstants.Type.RATE:
                case fieldTypeConstants.Type.RATEHIGHPRECISION:
                    return formatter.format(value, type);

                case fieldTypeConstants.Type.DATETIME:
                case fieldTypeConstants.Type.DATETIMETZ:
                    return dateTimeZone.format(value, timezone);

                default:
                    return value;
            }
        }

        return Object.freeze({
	                            i18n: i18n,
                                 /**
                                  * Parse a value from the appropriate preference formatted-value to a raw value.
                                  * @governance none
                                  * @param {Object} options
                                  * @param {string} options.value the data you wish to parse
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone the value is from.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {Date|string|number} If parseable, the parsed value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                parse: doParse,
                                 /**
                                  * Parse a value from the raw value to its appropriate preference formatted-value.
                                  * @governance none
                                  * @param {Object} options
                                  * @param {Date|string|number} options.value the data you wish to format
                                  * @param {string} options.type the field type i.e. DATE, CURRENCY, INTEGER
                                  * @param {string} options.timezone (optional & applicable to type DATETIME only) specifies which timezone to format to.
                                  *                                  default is the timezone set in the user's preferences
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if either value or type is missing
                                  *
                                  * @return {string} If format-able, the formatted value. If not or given an invalid Type, the value passed in options.value
                                  *
                                  * @since 2015.2
                                  */
                                format: doFormat,
                                 /**
                                  * Enum for field types.
                                  * @enum {string}
                                  */
                                 Type: fieldTypeConstants.Type,
                                 /**
                                  * Enum for Time Zones.
                                  * @enum {string}
                                  */
                                Timezone: dateTimeZone.Timezone
                             });
    });
/**
 * @private
 */
define('N/restricted/currencyApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript currency module
 *
 * @module N/currency
 * @NApiVersion 2.x
 *
 */
define('N/currency',['N/internal/invoker', 'N/restricted/currencyApi', 'N/format', 'N/fieldTypeConstants', 'N/utilityFunctions', 'N/error'],
    function (invoker, currencyApi, format, fieldTypeConstants, utilityFunctions, error)
    {
        function getExchRate(options)
        {
            var sourceCurrency, targetCurrency;

            if (options != null && (options.hasOwnProperty('source') || options.hasOwnProperty('target')))
            {
                sourceCurrency = options.source;
                targetCurrency = options.target;
            }

            utilityFunctions.checkArgs([sourceCurrency, targetCurrency], ['source', 'target'], 'exchangeRate');
            var effectiveDate = options.date || new Date();

            if (!util.isDate(effectiveDate) || isNaN(effectiveDate.getTime()))
            {
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.date', 'date');
            }
            else
            {
                effectiveDate = format.format(effectiveDate, fieldTypeConstants.Type.DATE);
            }

            try
            {
            	var isPromise = utilityFunctions.isPromiseCallback(this);
            	var result = invoker(currencyApi, 'nlapiExchangeRate', [sourceCurrency, targetCurrency, effectiveDate], isPromise ? this : null, false);
            	if (!isPromise)
                    return parseFloat(result);
            }
            catch (e)
            {
                handleError(e);
            }
        }

	    /**
	     * Asynchronously retrieves the exchange rate between two currencies based on the specified date.
	     * The return value comes from the Exchange Rate column of the Currency Exchange Rates record.
	     * @governance 10 units
	     *
	     * @param {Object} options
	     * @param {number|string} options.source The source currency ID or String
	     * @param {number|string} options.target The target currency ID or String
	     * @param {Date} options.date [optional] The date of the desired effective currency rate. Defaults to today.
	     *
	     * @return {number}
	     *
	     * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
	     * @throws {SuiteScriptError} SSS_INVALID_CURRENCY_ID if an invalid currency (source or target) is specified
	     *
	     * @since 2021.1
	     */
	    getExchRate.promise = function()
	    {
		    return utilityFunctions.promiseTo(getExchRate, arguments,
				function(currency){
		    	    return parseFloat(currency.result);
		        },
			    function(error){
		    	    return handleError(error.result);
			    }
			    );
	    };

        function handleError(e)
        {
	        var err = e;
	        var msg = !!e.message ? e.message.replace("fromCurrency", "source").replace("toCurrency", "target") : "";
	        if (e.name === "INVALID_CUR")
	        {
		        utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_CURRENCY_ID, msg);
	        }
	        throw err;
        }

        return Object.freeze({
                                 /**
                                  * Retrieves the exchange rate between two currencies based on the specified date.
                                  * The return value comes from the Exchange Rate column of the Currency Exchange Rates record.
                                  * @governance 10 units
                                  *
                                  * @param {Object} options
                                  * @param {number|string} options.source The source currency ID or String
                                  * @param {number|string} options.target The target currency ID or String
                                  * @param {Date} options.date [optional] The date of the desired effective currency rate. Defaults to today.
                                  *
                                  * @return {number}
                                  *
                                  * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
                                  * @throws {SuiteScriptError} SSS_INVALID_CURRENCY_ID if an invalid currency (source or target) is specified
                                  *
                                  * @since 2015.2
                                  */
                                exchangeRate: getExchRate
                             })
    });
/**
 * @private
 */
define('N/restricted/scriptSessionContext',['N/internal/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});
/**
 * @private
 */
define('N/restricted/scriptDeploymentContext',['N/internal/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});
/**
 * @private
 */
define('N/restricted/scriptSessionObjectService',['N/internal/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});
/**
 * @private
 */
define('N/restricted/scriptWorkQueueContext',['N/internal/reflet'],
	function(reflet){
		return reflet.nlapiGetContext();
	});
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */

/**
 * SuiteScript module
 *
 * @module N/runtime
 * @suiteScriptVersion 2.x
 *
 */
define('N/runtime',['N/restricted/scriptSessionContext',
		'N/restricted/scriptDeploymentContext',
		'N/restricted/scriptSessionObjectService',
		'N/restricted/scriptWorkQueueContext',
		'N/error',
		'N/nsobject',
		'N/internal/invoker',
		'N/utilityFunctions',
		'N/util/formatter',
		'N/util',
		'N/dynamicEnums',
		'N/environment'
	],
        function (scriptSessionContext, scriptDeploymentContext, scriptSessionObjectService, scriptWorkQueueContext,
                  error, nsobject, invoker, utilityFunctions, formatter, util, dynamicEnums, environment)
        {

            var ENV_TYPES = Object.freeze({
                SANDBOX: 'SANDBOX',
                PRODUCTION: 'PRODUCTION',
                BETA: 'BETA',
                INTERNAL: 'INTERNAL'
            });

            var PERMISSION = Object.freeze({
                FULL: 4,
                EDIT: 3,
                CREATE: 2,
                VIEW: 1,
                NONE: 0
            });

	        function unescape(obj)
	        {
		        if (typeof(obj) === 'string') {
			        obj = obj.replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&amp;/g, "&");
		        }
		        return obj;
	        }

            /**
             * @class Script
             * @classdesc Class for retrieving information about currently running script
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
            function Script()
            {
                /**
                 * The script logging level for the currently executing script. Returns one of the following values: DEBUG, AUDIT, ERROR, EMERGENCY.
                 * @name Script#logLevel
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'logLevel', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getLogLevel');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.logLevel' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The script ID for the currently executing script.
                 * @name Script#id
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getScriptId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.id' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The current script's runtime version
                 * @name Script#apiVersion
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'apiVersion', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getRuntimeVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.apiVersion' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * The deployment ID for the script deployment on the currently executing script.
                 * @name Script#deploymentId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'deploymentId', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getDeploymentId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.deploymentId' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * An array of bundle IDs for the bundles that include the currently executing script.
                 * @name Script#bundleIds
                 * @type {Array<string>}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'bundleIds', {
                    get: function ()
                    {
                        return invoker(scriptDeploymentContext, 'getBundleIds').map(String);
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.Script.bundleIds' );
                    },
                    enumerable: true,
                    configurable: false
                });

                /**
                 * Returns the number of usage units remaining for the currently executing script.
                 * @governance none
                 * @return {number}
                 *
                 * @since 2015.2
                 */
                this.getRemainingUsage = function getRemainingUsage()
                {
                    return invoker(scriptSessionContext, 'getRemainingUsage');
                };

                /**
                 * Returns the value of a script parameter for the currently executing script.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The name of the parameter
                 * @return {number|Date|string|boolean}
                 *
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_NAME when name is not string
                 *
                 * @since 2015.2
                 */
                this.getParameter = function getParameter(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Script.getParameter');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    var pValue = unescape(invoker(scriptDeploymentContext, 'getPreferenceObject', [name]));
                    var pType = invoker(scriptDeploymentContext, 'getPreferenceType', [name]);

                    // Fixes for Issue 642962 (float/decimal type) and Issue 764539 (currency type)
                    if ((pType == "float" || pType == "currency")
	                        && environment.isRuntimeCanaryOn())
                    	return parseFloat(pValue);
                    else
                        return formatter.parse(pValue, pType);
                };

	            /**
	             * The percent complete specified for the current scheduled script execution. This value appears in the % Complete  column on the Scheduled Script Status page. This value can be set or retrieved.
	             * @name Script#percentComplete
	             * @type {number}
	             * @throws {SuiteScriptError} SSS_OPERATION_UNAVAILABLE Thrown if the currently executing script is not a scheduled script.
	             *
	             * @since 2015.2
	             */
	            Object.defineProperty(this, 'percentComplete', {
		            get: function ()
		            {
			            return invoker(scriptWorkQueueContext, 'getPercentComplete');
		            },
		            set: function (val)
		            {
			            return invoker(scriptWorkQueueContext, 'setPercentComplete', [val]);
		            },
		            enumerable: true,
		            configurable: false
	            });

                // Functions for debugger

	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        'id': this.id,
                        'deploymentId': this.deploymentId,
                        'logLevel': this.logLevel,
                        'bundleIds': this.bundleIds
                    };
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return 'runtime.Script';
                };
            }

            /**
             * @class Session
             * @classdesc Class representing current session
             * @protected
             * @constructor
             */
            function Session()
            {
                /**
                 * Returns the user-defined session object value associated with a session object key. Both the session object value and associated key are defined using Session.set(options). If the key does not exist, this method returns null.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The key used to store the session object
                 * @return {string}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.get = function get(options)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'Session.get');
                    return invoker(scriptSessionObjectService, 'getSessionObject', [name]);
                };

	            /**
	             * Asynchronous version of Session.get method
	             * @governance none
	             * @param {Object} options
	             * @param {string} options.name The key used to store the session object
	             * @return {Promise<string>}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
	             *
	             * @since 2015.2
	             */
	            this.get.promise = function getPromise(options)
	            {
		            var name = options;
		            if (utilityFunctions.isObject(options))
		            {
			            name = options.name;
		            }
		            utilityFunctions.checkArgs([name], ['name'], 'Session.get.promise');
				    return new Promise( function(resolve, reject)
		            {
			            try
			            {
							if (environment.isClientSide())
				                invoker(scriptSessionObjectService, 'getSessionObjectAsync', [name, callback]);
							else
								invoker(scriptSessionObjectService, 'getSessionObject', [name], callback);
			            }
			            catch(e)
			            {
				            reject(e);
			            }

			            function callback(response, exception)
			            {
				            if (exception)
				            {
					            reject(exception)
				            }
				            else
				            {
					            try
					            {
						            resolve(environment.isClientSide() ? response.result : response);
					            }
					            catch(e)
					            {
						            reject(e);
					            }
				            }
			            }
		            });
	            };

                /**
                 * Add or set the value of a user-defined session object for the current user.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The key used to store the session object
                 * @param {string} options.value The value to associate with this key in the user's session
                 * @return {void}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.set = function set(options, value)
                {
                    var name = options;
                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                        value = options.value;
                    }

                    utilityFunctions.checkArgs([name], ['name'], 'Session.set');

                    return invoker(scriptSessionObjectService, 'setSessionObject', [name, value]);
                };

	            /**
	             * Checks if the session has been verified by two-factor authentication.
	             * @governance none
	             * @restriction Server SuiteScript only
	             * @restriction SuiteBanking team's apps only
	             * @return {boolean}
	             * @throws {SuiteScriptError} NOT_ENOUGH_PERMISSIONS when accessed from Non-SuiteBanking SuiteApps
	             *
	             * @since 2023.1
	             */
	            this.wasTfaChallenged = function wasTfaChallenged()
	            {
		            return invoker(scriptSessionObjectService, 'wasTfaChallenged');
	            };

                // Functions for debugger

	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    var keys = invoker(scriptSessionObjectService, 'getAllSessionObjects');
                    var result = new Object();
                    for (var i = 0; i < keys.length; i++)
                    {
                        result[keys[i]] = invoker(scriptSessionObjectService, 'getSessionObject', [keys[i]]);
                    }
                    return result;
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return "runtime.Session";
                };
            }

            /**
             * @class User
             * @classdesc Class representing current user
             * @protected
             * @constructor
             */
            function User()
            {
                /**
                 * The email address of the current user. To use this property, the email field on the user employee record must contain an email address.
                 * @name User#email
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'email', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getEmail');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.email' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The name of the current user.
                 * @name User#name
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'name', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getName');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.name' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the location of the current user.
                 * @name User#location
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'location', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getLocation');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.location' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the department for the current user.
                 * @name User#department
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'department', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getDepartment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.department' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the role for the current user.
                 * @name User#role
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'role', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRole');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.role' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The string value of the center type, or role center, for the current user.
                 * @name User#roleCenter  The string value of the logged in user's center - for example, SALES, ACCOUNTING, CLASSIC.
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleCenter', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRoleCenter');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleCenter' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The custom scriptId of the role for the current user. You can use this value instead of User.role.
                 * @name User#roleId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'roleId', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getRoleId');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.roleId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The internal ID of the current user.
                 * @name User#id
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'id', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getUser');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.id' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * The internal ID of the currently logged-in contact. If no logged-in entity or other entity than contact is logged in, then 0 is returned
	             * @name User#contact
	             * @type {number}
	             * @readonly
	             *
	             * @since 2019.1
	             */
	            Object.defineProperty(this, 'contact', {
		            get: function ()
		            {
			            return invoker(scriptSessionContext, 'getContact');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.contact' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });

                /**
                 * The internal ID of the subsidiary for the current user.
                 * @name User#subsidiary
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'subsidiary', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getSubsidiary');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'runtime.User.subsidiary' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Get a user's permission level for a given permission, which is a value from runtime.Permission enum
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.name The internal ID of a permission
                 * @return {number} one value of the Permission
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 */
                this.getPermission = function getPermission(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPermission');
                    if (typeof name != "string")
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    return invoker(scriptSessionContext, 'getPermission', [name]);
                };

                /**
                 * Returns the value set for a NetSuite preference. Currently only General Preferences and Accounting Preferences are exposed in SuiteScript.
                 * @governance none
                 * @param {Object} options
                 * @param {string} name The internal ID of the preference
                 * @return {string} The value of a NetSuite preference for the current user
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name argument is missing
                 *
                 * @since 2015.2
                 *
                 */
                this.getPreference = function getPreference(options)
                {
                    var name = options;

                    if (utilityFunctions.isObject(options))
                    {
                        name = options.name;
                    }
                    utilityFunctions.checkArgs([name], ['name'], 'User.getPreference');
                    if (!util.isString(name))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name','string' );
                    }
                    // TODO Should be just unescape()
                    var pValue = utilityFunctions.unescape(invoker(scriptDeploymentContext, 'getPreference', [name]));
                    var pType = invoker(scriptDeploymentContext, 'getPreferenceType', [name]);
                    if (('T' === pValue || 'F' === pValue) && ('boolean' === pType))
                        return 'T' === pValue;
                    else
                        return pValue;
                };

                // Functions for debugger

	            /**
	             * get JSON format of the object
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {
                        'id': this.id,
                        'name': this.name,
                        'email': this.email,
                        'location': this.location,
                        'department': this.department,
                        'role': this.role,
                        'roleId': this.roleId,
                        'roleCenter': this.roleCenter,
                        'subsidiary': this.subsidiary
                    };
                };

	            /**
	             * Returns stringified representation of this SuiteScriptError
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return 'runtime.User';
                };
            }

            Session.prototype = nsobject.getNewInstance();
            User.prototype = nsobject.getNewInstance();
            Script.prototype = nsobject.getNewInstance();

            function Runtime()
            {
            	var _contextTypes;
                /**
                 * Returns a runtime.User object that represents the properties and preferences for the user currently executing the script.
				 * Use this method to get session objects for the current user session. If you want to get properties for the script or session, use runtime.getCurrentScript() or runtime.getCurrentSession() instead.
                 * @governance none
                 * @return {User}
                 *
                 * @since 2015.2
                 */
                this.getCurrentUser = function getCurrentUser()
                {
                    return Object.freeze(new User());
                };

                /**
                 * Returns a runtime.Script object that represents the currently executing script.
                 * Use this method to get properties and parameters of the currently executing script and script deployment. If you want to get properties for the session or user, use runtime.getCurrentSession() or runtime.getCurrentUser() instead.
                 * @governance none
                 * @return {Script}
                 *
                 * @since 2015.2
                 */
                this.getCurrentScript = function getCurrentScript()
                {
                    return Object.freeze(new Script());
                };

                /**
                 * Returns a runtime.Session object that represents the user session for the currently executing script.
				 * Use this method to get session objects for the current user session. If you want to get properties for the script or user, use runtime.getCurrentScript() or runtime.getCurrentUser() instead.
                 * @governance none
                 * @return {Session}
                 *
                 * @since 2015.2
                 */
                this.getCurrentSession = function getCurrentSession()
                {
                    return Object.freeze(new Session());
                };

                /**
                 * Use this method to determine if a particular feature is enabled in a NetSuite account.
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.feature id of the feature
                 * @return {boolean}
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when feature argument is missing
                 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when feature is not string
                 *
                 * @since 2015.2
                 */
                this.isFeatureInEffect = function isFeatureInEffect(options)
                {
                    var feature = options;
                    if (utilityFunctions.isObject(options))
                    {
                        feature = options.feature;
                    }

                    utilityFunctions.checkArgs([options], ['options.feature'], 'runtime.isFeatureInEffect');

                    if (!util.isString(feature))
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'feature', 'string' );
                    }
                    return invoker(scriptSessionContext, 'getFeature', [feature]);
                };

                /**
                 * The number of scheduled script queues available in the current account.
                 * @name Runtime#queueCount
                 * @type {number}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'queueCount', {
                    get: function ()
                    {
                        return invoker(scriptWorkQueueContext, 'getQueueCount');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'queueCount' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * The number of processors available to the current account.
	             * @name Runtime#processorCount
	             * @type {number}
	             * @readonly
	             *
	             * @since 2018.1
	             */
	            Object.defineProperty(this, 'processorCount', {
		            get: function ()
		            {
			            return invoker(scriptWorkQueueContext, 'getProcessorCount');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'processorCount' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });


                /**
                 * The version of NetSuite the current account is runnning.
                 *
                 * @name Runtime#version
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'version', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getVersion');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'version' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });


                /**
                 * The account ID for the current user.
                 * @name Runtime#accountId
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'accountId', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getCompany');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'accountId' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

	            /**
	             * The country for the current company
	             * @name Runtime#country
	             * @type {string}
	             * @readonly
	             *
	             * @since 2020.2
	             */
	            Object.defineProperty(this, 'country', {
		            get: function ()
		            {
			            return invoker(scriptSessionContext, 'getCountry');
		            },
		            set: function (val)
		            {
			            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'country' );
		            },
		            enumerable: true,
		            configurable: false,
		            writeable: false
	            });

                /**
                 * The current environment in which the script is executing. This property uses values from the runtime.EnvType enum.
                 * @name Runtime#envType
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'envType', {
                    get: function ()
                    {
                        return invoker(scriptSessionContext, 'getEnvironment');
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'envType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * The trigger of the current script. This property uses values from the runtime.ContextType enum.
                 * @name Runtime#executionContext
                 * @type {string}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'executionContext', {
                    get: function ()
                    {
                    	var toRet = invoker(scriptSessionContext, 'getExecutionContext');
                        return  toRet == null ? null : toRet.toUpperCase();
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'executionContext' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                // Functions for debugger
	            /**
	             * JSON.stringify() implementation.
	             * @governance none
	             * @return {Object}
	             *
	             * @since 2015.2
	             */
                this.toJSON = function toJSON()
                {
                    return {};
                };

	            /**
	             * Returns the object type name
	             * @governance none
	             * @return {string}
	             *
	             * @since 2015.2
	             */
                this.toString = function toString()
                {
                    return "runtime.Runtime";
                };

                /**
                 * Holds all possible environment types that the current script can execute in. This is the type for the runtime.envType property.
                 * @enum {string}
                 * @readonly
                 */
                this.EnvType = ENV_TYPES;

                /**
                 * Holds the context values for script triggers. This is the type for the runtime.executionContext property.
                 * @name runtime#ContextType
                 * @type {Object}
                 * @readonly
                 *
                 * @since 2015.2
                 */
                Object.defineProperty(this, 'ContextType', {
                    get: function ()
                    {
                        if (!_contextTypes)
                            _contextTypes = dynamicEnums.runtimeContextTypes;
                        return _contextTypes;
                    },
                    set: function (val)
                    {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'ContextType' );
                    },
                    enumerable: true,
                    configurable: false,
                    writeable: false
                });

                /**
                 * Holds the user permission level for a specific permission ID. User.gerPermission(options) returns a value from this enum.
                 * @enum {number}
                 * @readonly
                 */
                this.Permission = PERMISSION;
            };
            Runtime.prototype = nsobject.getNewInstance();
            /** @alias N/runtime */
            return Object.freeze(new Runtime());
        });

/**
 * @private
 */
define('N/restricted/actionApi',['N/internal/reflet'], function(reflet){ return util.extend({bridge: 'actionApi'}, reflet); });
/**
 * SuiteScript record action task status module.
 *
 * @private
 * @module N/record/actionInternal
 * @suiteScriptVersion 2.x
 */
define('N/record/actionInternal',['N/restricted/actionApi', 'N/internal/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'],
	function (actionApi, invoker, utilityFunctions, nsobject, error)
	{
		var ALL_QUALIFIED_INSTANCES = Object.freeze({});

		/**
		 * @class RecordActionTaskStatus
		 * @classdesc Encapsulates the status of a record action task in the NetSuite scheduling queue.
		 * @protected
		 * @constructor
		 *
		 * @since 2019.1
		 */
		function RecordActionTaskStatus(taskId)
		{
			var TYPE = 'task.RecordActionTaskStatus';

			var _data = null;
			
			function getData()
			{
				if (!_data)
					_data = JSON.parse(invoker(actionApi, 'getBulkStatus', [taskId], null, false));

				return _data;
			}

			/**
			 * The taskId associated with the specified task.
			 * @name RecordActionTaskStatus#taskId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'taskId', {
				get: function ()
				{
					return taskId;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'taskId' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * Represents the task status. Returns one of the task.TaskStatus enum values.
			 * @name RecordActionTaskStatus#status
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'status', {
				get: function ()
				{
					return getData().status;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'status' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The results for successfully executed actions. The value of the property is a mapping from instance ID to
			 * the corresponding action result.
			 * @name RecordActionTaskStatus#results
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'results', {
				get: function ()
				{
					return Object.freeze(getData().results);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'results' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The error details for failed action executions. The value of the property is a mapping from record instance ID to
			 * the corresponding error detail. The error detail is an unnamed object with two properties - code and message.
			 * @name RecordActionTaskStatus#errors
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'errors', {
				get: function ()
				{
					return Object.freeze(getData().errors);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'errors' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions already executed (either failed or successful).
			 * @name RecordActionTaskStatus#complete
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'complete', {
				get: function ()
				{
					return getData().complete;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'complete' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions that executed successfully.
			 * @name RecordActionTaskStatus#succeeded
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 * 
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'succeeded', {
				get: function ()
				{
					return getData().succeeded;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'succeeded' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions whose execution failed.
			 * @name RecordActionTaskStatus#failed
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'failed', {
				get: function ()
				{
					return getData().failed;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'failed' );
				},
				enumerable: true,
				configurable: false
			});

			/**
			 * The number of record actions that are yet to be executed.
			 * @name RecordActionTaskStatus#pending
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'pending', {
				get: function ()
				{
					return getData().pending;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pending' );
				},
				enumerable: true,
				configurable: false
			});

			this.refresh = function refresh()
			{
				_data = null;
			};

			/**
			 * Returns the object type name (task.RecordActionTaskStatus).
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2019.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					taskId: this.taskId,
					status: this.status,
					results: this.results,
					errors: this.errors,
					complete: this.complete,
					succeeded: this.succeeded,
					failed: this.failed,
					pending: this.pending
				}
			}
		}

		RecordActionTaskStatus.prototype = nsobject.getNewInstance();

		function processSubmitBulkOptions(recordType, actionId, params, condition, paramCallback, actionIdArgName, contextName)
		{
			utilityFunctions.checkArgs([recordType, actionId], ['recordType', actionIdArgName], contextName);

			if (params != null)
			{
				if (!Array.isArray(params) || params.some(function(v){return v !== Object(v)}))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'params', 'array of objects');
				if (condition != null || paramCallback != null)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS);
			}
			else if (condition != null || paramCallback != null)
			{
				utilityFunctions.checkArgs([condition], ['condition'], contextName);
				if (paramCallback == null)
					paramCallback = function(v) { return {}; };
				else if (!util.isFunction(paramCallback) || !utilityFunctions.isObject(paramCallback(1)))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'paramCallback', 'function returning object');
				if (!utilityFunctions.isObject(condition))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'object');
				if (condition !== ALL_QUALIFIED_INSTANCES)
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				var instanceIds = JSON.parse(invoker(actionApi, 'findInstances', [recordType, actionId], null, false));
				params = instanceIds.map(paramCallback).map(function(v,i) { if (v.recordId==null) v.recordId = instanceIds[i]; return v; });
			}
			else
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'params', 'condition/paramCallback');

			return params;
		}

		return Object.freeze({
			RecordActionTaskStatus: RecordActionTaskStatus,

			getAllQualifiedInstancesSingleton: function() { return ALL_QUALIFIED_INSTANCES; },

			processSubmitBulkOptions: processSubmitBulkOptions
		});
	});

/**
 * SuiteScript record action module
 *
 * @module N/action
 * @suiteScriptVersion 2.x
 */
define('N/action',['N/restricted/actionApi', 'N/internal/invoker', 'N/utilityFunctions', 'N/error', 'N/record/actionInternal'],
	function (actionApi, invoker, utilityFunctions, error, actionInternal)
	{
		function recOrNull(obj)
		{
			return obj && obj.hasOwnProperty('type') && obj.hasOwnProperty('id') ? obj : null;
		}

		function doExecute(options, rec)
		{
			options = options || {};
			var recordType = rec ? rec.type : options.recordType;
			var params = utilityFunctions.isObject(options.params) ? util.extend({}, options.params) : {};
			var recordId = utilityFunctions.ensureInteger(rec ? rec.id : params.recordId, 'params.recordId');
			params.recordId = recordId;
			var actionId = options.id;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('executeAction') : 'action.execute';
			utilityFunctions.checkArgs([recordType, recordId, actionId], ['recordType', 'params.recordId', 'id'], context);

			var callback = utilityFunctions.isPromiseCallback(this) ? this : null;
			return invoker(actionApi, 'executeAction', [recordType, actionId, recordId, params], callback, false);
		}

		function execute(options)
		{
			return JSON.parse(doExecute(options, recOrNull(this)));
		}
		execute.promise = function(options)
		{
			return utilityFunctions.promiseTo(doExecute, [options, recOrNull(this)], function(ctx) { return JSON.parse(ctx.result); });
		};

		function createAction(options, recordId)
		{
			var TYPE = 'Action';

			var recordType = options.recordType.toLowerCase();
			var actionId = options.id;

			var Action = function(params)
			{
				return execute(combineOpts(params, recordType, recordId, actionId));
			};
			Action.execute = function(params)
			{
				return execute(combineOpts(params, recordType, recordId, actionId));
			};
			Action.promise = function(params)
			{
				return execute.promise(combineOpts(params, recordType, recordId, actionId));
			};
			Action.execute.promise = Action.promise;

			Action.executeBulk = function(options)
			{
				return executeBulk(util.extend({recordType: recordType, id: actionId}, options));
			};

			Action.id = actionId;
			Action.recordType = recordType;
			Action.recordId = recordId;
			Action.label = options.label || null;
			Action.description = options.description || null;
			var params = {};
			options.parameters.forEach(function(p) {
				params[p.id] = p;
				delete p.id;
			});
			Action.parameters = params;
			Action.toJSON = function toJSON(concise)
			{
				var res = {};
				for (var p in Action)
				{
					if (Action.hasOwnProperty(p) && typeof Action[p] !== 'function')
					{
						if (!concise || (Action[p] != null && (Action[p].constructor !== Object || Object.keys(Action[p]).length > 0)))
							res[p] = Action[p];
					}
				}
				return res;
			};
			Action.toString = function toString()
			{
				return TYPE + JSON.stringify(Action.toJSON(true));
			};
			Object.defineProperty(Action, 'proxy', {value: function () { return Action; }});

			return Object.freeze(Action);
		}

		function combineOpts(params, recordType, recordId, actionId)
		{
			var combinedOpts = {};
			combinedOpts.params = util.extend(recordId ? {recordId: recordId} : {}, params);
			combinedOpts.recordType = recordType;
			combinedOpts.id = actionId;
			return combinedOpts;
		}

		function processFindResult(ctx)
		{
			var metadata = JSON.parse(ctx.result);
			var options = ctx.data;

			var actions = {};
			for (var i = 0; i < metadata.length; i++)
			{
				if (options.id && options.id !== metadata[i].id)
					continue;
				var action = createAction(metadata[i], options.recordId);
				actions[action.id] = action;
			}
			if (options.id && Object.keys(actions).length === 0)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_ACTION_ID);
			return Object.freeze(actions);
		}

		function doFind(options, rec)
		{
			if (rec)
				util.extend(options, {recordType: rec.type, recordId: rec.id});
			var recordType = options.recordType;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('getActions') : 'action.find';
			utilityFunctions.checkArgs([recordType], ['recordType'], context);
			recordType = recordType.toLowerCase();
			var actionId = options.id || null;
			var recordId = utilityFunctions.ensureInteger(options.recordId, 'recordId');
			var callback = utilityFunctions.isPromiseCallback(this) ? this.bind(options) : null;

			return invoker(actionApi, 'getRecordActions', [recordType, recordId, actionId], callback, false);
		}

		function find(options)
		{
			options = util.extend({}, options);
			return processFindResult({result: doFind(options, recOrNull(this)), data: options});
		}
		find.promise = function(options)
		{
			options = util.extend({}, options);
			return utilityFunctions.promiseTo(doFind, [options, recOrNull(this)], processFindResult);
		};

		function processGetResult(ctx)
		{
			var metadata = JSON.parse(ctx.result);
			var options = ctx.data;

			var result = null;
			for (var i = 0; i < metadata.length; i++)
			{
				if (options.id === metadata[i].id)
				{
					result = createAction(metadata[i], options.recordId);
					break;
				}
			}
			if (result === null)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_ACTION_ID);
			return result;
		}

		function doGet(options, rec)
		{
			options = options || {};
			var recordType = rec ? rec.type : options.recordType;
			var actionId = options.id;
			var context = rec ? rec.getMissingArgumentErrorMessageFillerValue('getAction') : 'action.get';
			utilityFunctions.checkArgs([recordType, actionId], ['recordType', 'id'], context);

			return doFind.call(this, options, rec);
		}

		function get(options)
		{
			return processGetResult({result: doGet(options, recOrNull(this)), data: options});
		}
		get.promise = function(options)
		{
			return utilityFunctions.promiseTo(doGet, [options, recOrNull(this)], processGetResult);
		};

		function executeBulk(options)
		{
			var recordType, actionId, params, condition, paramCallback;
			if (options)
			{
				recordType = options.recordType;
				actionId = options.id;
				params = options.params;
				condition = options.condition;
				paramCallback = options.paramCallback;
			}
			params = actionInternal.processSubmitBulkOptions(recordType, actionId, params, condition, paramCallback, 'id', 'action.executeBulk');

			return invoker(actionApi, 'submitBulkAction', [recordType, actionId, JSON.stringify(params)], null, false);
		}

		function getBulkStatus(options)
		{
			var taskId = utilityFunctions.isObject(options) ? options.taskId : options;
			utilityFunctions.checkArgs([taskId], ['taskId'], 'action.getBulkStatus');
			return new actionInternal.RecordActionTaskStatus(taskId);
		}

		/**
		 * Params objects represents parameters which are usually record type specific, only recordId parameter is common for every record type
		 * @typedef {Object} Params
		 * @property {string} recordId record instance ID
		 *
		 */
		function ParamsTypedef(){}

		return Object.freeze({
			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * If the Action object is qualified, i.e. it is a result of a get/find call where recordId was provided,
			 * then it is not required to provide a recordId again and the parameter is optional. If, however, recordId is
			 * provided again upon execution, then it takes precedence over the one already stored inside the Action object.
			 * @name Action
			 * @function
			 * @param {Object} params action arguments
			 * @param {string} params.recordId record instance ID
			 * @return {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if params.recordId is missing or undefined
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2018.2
			 */

			/**
			 * Performs a search for available record actions. If only the recordType parameter is specified and either id and/or recordId is not specified, all actions available for the record type are returned.
			 * If the both id and recordId parameters are specified, then the action corresponding to the actionId that qualify for execution on the given record instance is returned.
			 * This method returns a plain JavaScript object of NetSuite record actions available for the record type. The object contains one or more action.Action objects.
			 * If there are no available actions for the specified record type and neither id or recordId is specified, an empty object is returned.
			 *
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string=} options.recordId record instance ID
			 * @param {string=} options.id action ID
			 * @return {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if an action is specified and such action doesn't exist on the said record type
			 * @throws {SuiteScriptError} CONDITION_IS_NOT_FULLY_QUALIFIED if the action does not qualify on the specific record instance
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if a record ID is specified and that record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			find: find,

			/**
			 * Returns an executable record action for the given record type. If the recordId parameter is provided, then the
			 * action object is only returned if the given record instance qualifies for execution of the given record action.
			 * Also, if recordId is provided than the returned action is "qualified" and you don't have to provide the recordId
			 * again when executing the Action object.
			 *
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {string=} options.recordId record instance ID
			 * @return {Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesnât exist on the said record type
			 * @throws {SuiteScriptError} CONDITION_IS_NOT_FULLY_QUALIFIED if the action does not qualify on the specific record instance
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if a record ID is specified and that record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			get: get,

			/**
			 * Executes the record action and returns the action results in a plain JavaScript object.
			 * If the action fails, it is listed in the results objectâs notifications property. If the action executes successfully, the notifications property is usually empty.
			 *
			 * @governance 50 units for timesheets, 10 for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {Params} options.params action arguments
			 * @return {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id or options.params.recordId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesn't exist on the said record type
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2018.2
			 */
			execute: execute,

			/**
			 * Executes an asynchronous bulk record action and returns its task ID for status queries. The options.params parameter
			 * is mutually exclusive to options.condition and options.paramCallback.
			 *
			 * @governance 50 units
			 *
			 * @param {Object} options
			 * @param {string} options.recordType record type
			 * @param {string} options.id action ID
			 * @param {Array<Params>} options.params array of parameter objects; each object corresponds to one record ID for which the action is to
			 *                                             be executed; the object has the following form: {recordId: 1, someParam: 'foo', otherParam: 'bar'}
			 *                                             recordId is always mandatory, other parameters are optional and specific to the particular action
			 * @param {string=} options.condition condition used to select record IDs for which the action is to be executed; only the
			 *                                              action.ALL_QUALIFIED_INSTANCES constant is supported at the moment
			 * @param {string=} options.paramCallback function that takes record ID and returns the parameter object for the given record ID
			 * @return {string} task ID used in a later call to getBulkStatus
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.recordType or options.id is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_RECORD_TYPE if the specified record type doesn't exist
			 * @throws {SuiteScriptError} SSS_INVALID_ACTION_ID if the specified action doesn't exist on the said record type
			 * @throws {SuiteScriptError} RECORD_DOES_NOT_EXIST if the specified record instance doesn't exist
			 *
			 * @since 2019.1
			 */
			executeBulk: executeBulk,

			/**
			 * Returns the current status of a bulk execution with the given task ID.
			 *
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.taskId a task ID that was returned by a previous call to executeBulk
			 * @return {RecordActionTaskStatus} a status object capturing the current state of the bulk action execution; see task module JSDoc
			 *
			 * @since 2019.1
			 */
			getBulkStatus: getBulkStatus,

			/**
			 * Singleton object to be used as condition parameter in executeBulk.
			 */
			ALL_QUALIFIED_INSTANCES: actionInternal.getAllQualifiedInstancesSingleton()
		});
	}
);

/**
 * @private
 */
define('N/restricted/queryApiBridge',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'queryApiBridge'}, reflet); });
/**
 * @private
 */
define('N/restricted/datasetApi',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'datasetApi'}, reflet); });
/**
 * @private
 */
define('N/restricted/workbookApi',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'workbookApi'}, reflet); });
/**
 * SuiteScript module
 *
 * @private
 * @module N/iterator
 * @NApiVersion 2.x
 */
define('N/common/pattern/iterator',['N/nsobject', 'N/utilityFunctions'], function (nsObject, utilityFunctions)
{

	/**
	 *
	 * @param {JavaLikeIterator} delegate
	 * @constructor
	 * @protected
	 */
	function Iterator(delegate)
	{

		/**
		 * ECMA 2015 style
		 *
		 * @return {{done: boolean, value: *}}
		 */
		this.next = function next()
		{
			var result = {done: !delegate.hasNext()};
			if (!result.done)
			{
				result.value = delegate.next();
			}
			return result;
		};

		/**
		 * @typedef {function({value}): boolean} iteratorFunction
		 * param {{value: *}} value
		 * return {boolean} Should continue iteration?
		 */

		/**
		 * SuiteScript style
		 *
		 * @param {iteratorFunction} iteratorFunction
		 */
		this.each = function each(iteratorFunction)
		{
			utilityFunctions.checkArgs([iteratorFunction], ['iteratorFunction'], 'Iterator.each');

			var cont = true;
			while (delegate.hasNext() && cont)
			{
				cont = !!iteratorFunction({value: delegate.next()});
			}
		};

	}

	Iterator.prototype = nsObject.getNewInstance();

	return Object.freeze({
		/**
		 * @param {JavaLikeIterator} iterable
		 * @return {Iterator}
		 */
		create: function create(iterable)
		{
			return Object.freeze(new Iterator(iterable));
		}
	});

});

/**
 * SuiteScript example util module
 *
 * @module N/queryInternal
 * @NApiVersion 2.x
 *
 */
define('N/queryInternal',['N/internal/invoker', 'N/restricted/datasetApi', 'N/restricted/workbookApi', 'N/restricted/queryApiBridge', 'N/utilityFunctions', 'N/error', 'N/common/pattern/iterator', 'N/nsobject', 'N/dynamicEnums'],
	function (invoker, datasetApi, workbookApi, queryApi, utilityFunctions, error, iteratorFactory, nsobject, dynamicEnums)
	{
		var MOD_PREFIX = 'query.';

		//values correspond to QueryFilterOperator
		//for each new operator arity needs to be specified in query module
		var OPERATOR = Object.freeze({
			AFTER: 'AFTER',
			AFTER_NOT: 'AFTER_NOT',
			ANY_OF: 'ANY_OF',
			ANY_OF_NOT: 'ANY_OF_NOT',
			BEFORE: 'BEFORE',
			BEFORE_NOT: 'BEFORE_NOT',
			BETWEEN: 'BETWEEN',
			BETWEEN_NOT: 'BETWEEN_NOT',
			CONTAIN: 'CONTAIN',
			CONTAIN_NOT: 'CONTAIN_NOT',
			EMPTY: 'EMPTY',
			EMPTY_NOT: 'EMPTY_NOT',
			ENDWITH: 'ENDWITH',
			ENDWITH_NOT: 'ENDWITH_NOT',
			EQUAL: 'EQUAL',
			EQUAL_NOT: 'EQUAL_NOT',
			EXCLUDE_ALL: 'MN_EXCLUDE',
			EXCLUDE_ANY: 'MN_EXCLUDE_ALL',
			EXCLUDE_EXACTLY: 'MN_EXCLUDE_EXACTLY',
			INCLUDE_ALL: 'MN_INCLUDE_ALL',
			INCLUDE_ANY: 'MN_INCLUDE',
			INCLUDE_EXACTLY: 'MN_INCLUDE_EXACTLY',
			GREATER: 'GREATER',
			GREATER_NOT: 'GREATER_NOT',
			GREATER_OR_EQUAL: 'GREATER_OR_EQUAL',
			GREATER_OR_EQUAL_NOT: 'GREATER_OR_EQUAL_NOT',
			IS: 'IS',
			IS_NOT: 'IS_NOT',
			LESS: 'LESS',
			LESS_NOT: 'LESS_NOT',
			LESS_OR_EQUAL: 'LESS_OR_EQUAL',
			LESS_OR_EQUAL_NOT: 'LESS_OR_EQUAL_NOT',
			ON: 'ON',
			ON_NOT: 'ON_NOT',
			ON_OR_AFTER: 'ON_OR_AFTER',
			ON_OR_AFTER_NOT: 'ON_OR_AFTER_NOT',
			ON_OR_BEFORE: 'ON_OR_BEFORE',
			ON_OR_BEFORE_NOT: 'ON_OR_BEFORE_NOT',
			START_WITH: 'START_WITH',
			START_WITH_NOT: 'START_WITH_NOT',
			WITHIN: 'WITHIN',
			WITHIN_NOT: 'WITHIN_NOT'
		});

		var operators = [];
		Object.getOwnPropertyNames(OPERATOR).forEach(function(name){
			operators.push(OPERATOR[name]);
		});

		function validateOperator(operator, errorMessage)
		{
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(operators, operator, false), errorMessage, operator);
		}

		var searchTypes;
		var searchTypeValues;
		var sortLocales;

		function validateSearchType(type)
		{
			getSearchTypes();
			if (searchTypeValues.indexOf(type.toLowerCase()) < 0 && type.toUpperCase().substr(0,12) != "CUSTOMRECORD")
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SEARCH_TYPE, type);
		}

		function getSearchTypes()
		{
			if (!searchTypes)
			{
				searchTypes = dynamicEnums.querySearchTypes;
				searchTypeValues = [];
				Object.getOwnPropertyNames(searchTypes).forEach(function(name){
					searchTypeValues.push(searchTypes[name]);
				});
			}
			return searchTypes;
		}

		function validateSortLocale(locale)
		{
			getSortLocales();
			if (!sortLocales[locale])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SORT_LOCALE, locale);
		}

		function getSortLocales()
		{
			if (!sortLocales)
				sortLocales = dynamicEnums.querySortLocales;
			return sortLocales;
		}

		var METADATA_PROVIDER_TYPES = Object.freeze({
			STATIC: "STATIC",
			SUITE_QL: "SUITE_QL"
		});

		function getMetadataProviderTypes()
		{
			return METADATA_PROVIDER_TYPES;
		}

		function convertMetaDataProviderType(options)
		{
			if (options && options.hasOwnProperty('metadataProvider'))
			{
				if (options.metadataProvider == null || METADATA_PROVIDER_TYPES[options.metadataProvider] == null)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.metadataProvider');
				}
				return options.metadataProvider;
			}
			return METADATA_PROVIDER_TYPES.SUITE_QL;
		}

		/**
		 * Set of results returned by the query.
		 * @class ResultSet
		 * @classDescription Encapsulates the set of results returned by the query. Use Query.run() or Query.run.promise() to create this object.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function ResultSet(data, columns, metadataProvider)
		{
			var TYPE = MOD_PREFIX + 'ResultSet';

			var _columns = columns;
			var _results = [];
			var _mappedResults = null;
			var _types = [];
			var _metadataProvider = metadataProvider;
			for (var i = 0; i < data.types.length; i++)
				_types.push(data.types[i]);

			var _aliases = data.aliases ? [] : undefined;
			if (_aliases)
			{
				for (var i = 0; i < data.aliases.length; i++)
					_aliases.push(data.aliases[i]);
			}

			for (var i = 0; i < data.count; i++)
				_results.push(new Result(Array.prototype.slice.call(data['v' + i]), _columns, _aliases));

			/**
			 * Standard SuiteScript 2.0 object for iterating through results
			 * @governance 10 units for each page returned
			 * @return {Iterator}
			 *
			 * @since 2018.1
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new ResultsIterator(_results));
			};

			/**
			 * Standard SuiteScript 2.0 object for iterating through results
			 * @return {Array<Object>}
			 *
			 * @since 2018.1
			 */
			this.asMappedResults = function()
			{
				if (_mappedResults === null)
				{
					_mappedResults = [];
					for (var i = 0; i < _results.length; i++)
						_mappedResults.push(_results[i].asMap());
				}
				return _mappedResults;
			};

			/**
			 * Holds an array of query.Result objects.
			 * @name ResultSet#results
			 * @type {Array<Result>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'results', {
				get: function ()
				{
					return _results;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'results' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of the return types for ResultSet.results.
			 * @name ResultSet#types
			 * @type {Array<string>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'types', {
				get: function ()
				{
					return _types;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'types' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of query return column references. The ResultSet.columns array values correspond with the ResultSet.types array values.
			 * @name ResultSet#columns
			 * @type {Array<Column>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns type of the column associated with given alias
			 * @param {Object} options
			 * @param {string} options.alias
			 * @governance none
			 * @return {string}
			 * @throws {SuiteScriptError} CANNOT_DETERMINE_TYPE_FOR_ALIAS if alias was not found or type information is not available
			 * @throws {SuiteScriptError} SSS_DUPLICATE_ALIAS if more columns in the result set have the same alias
			 *
			 * @since 2020.2
			 */
			this.getTypeForAlias = function(options)
			{
				var alias = options && options.hasOwnProperty('alias') ? options.alias : options;
				utilityFunctions.checkArgs([alias], ['alias'], 'ResultSet.getTypeForAlias');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(alias, 'options.alias', util.isString)]);
				if (_types.length == 0 || !columns)
					utilityFunctions.throwSuiteScriptError(error.Type.CANNOT_DETERMINE_TYPE_FOR_ALIAS, alias);
				for (var c = 0; c < columns.length; c++)
				{
					if (columns[c].alias == alias)
					{
						for (var i = c + 1; i < columns.length; i++)
						{
							if (columns[i].alias == alias)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
						}
						return _types[c];
					}
				}
				utilityFunctions.throwSuiteScriptError(error.Type.CANNOT_DETERMINE_TYPE_FOR_ALIAS, alias);
			};

			/**
			 * Holds name of metadata provider type used during execution.
			 * @name ResultSet#metadataProvider
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2022.1
			 */
			Object.defineProperty(this, 'metadataProvider', {
				get: function ()
				{
					return _metadataProvider;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'metadataProvider' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.ResultSet)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					columns: _columns,
					types: _types,
					results: _results,
					metadataProvider: _metadataProvider
				};
			}
		}

		ResultSet.prototype = nsobject.getNewInstance();

		function ResultsIterator(results) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < results.length;
			};

			this.next = function next() {
				return results[i++];
			}
		}
		ResultsIterator.prototype = nsobject.getNewInstance();

		/**
		 * Corresponds to a single row of the ResultSet.
		 * @class Result
		 * @classDescription Encapsulates a single row of the result set (query.ResultSet).
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Result(values, columns, aliases)
		{
			var TYPE = MOD_PREFIX + 'Result';

			var _values = values;
			var _mappedValues = null;

			this.getValue = function getValue(options)
			{
				return _values[options];
			};

			/**
			 * Returns the query result as a mapped result. A mapped result is a JavaScript object with key-value pairs. In this object, the key is either the field ID or the alias that was used for the corresponding query.Column object.
			 * @return {Object}
			 *
			 * @since 2019.2
			 */
			this.asMap = function()
			{
				if (_mappedValues === null)
				{
					if (columns)
					{
						_mappedValues = {};
						for (var i = 0; i < columns.length; i++)
						{
							var column = columns[i];
							var alias = column.alias || column.fieldId;
							if (!alias)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_MISSING_ALIAS);
							else if (_mappedValues[alias] !== undefined)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
							else
								_mappedValues[alias] = _values[i];
						}
					}
					else if (aliases)
					{
						_mappedValues = {};
						for (var i = 0; i < aliases.length; i++)
						{
							var alias = aliases[i];
							if (_mappedValues[alias] !== undefined)
								utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
							_mappedValues[alias] = _values[i];
						}
					}
				}
				return _mappedValues;
			};

			/**
			 * Returns value associated with given alias
			 * @param {Object} options
			 * @param {string} options.alias
			 * @governance none
			 * @return {string|number|boolean}
			 * @throws {SuiteScriptError} CANNOT_DETERMINE_VALUE_FOR_ALIAS if alias was not found
			 * @throws {SuiteScriptError} SSS_DUPLICATE_ALIAS if more columns in the result set have the same alias
			 *
			 * @since 2020.2
			 */
			this.getValueForAlias = function(options)
			{
				var alias = options && options.hasOwnProperty('alias') ? options.alias : options;
				utilityFunctions.checkArgs([alias], ['alias'], 'Result.getValueForAlias');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(alias, 'options.alias', util.isString)]);
				if (columns)
				{
					for (var c = 0; c < columns.length; c++) {
						if (columns[c].alias == alias) {
							for (var i = c + 1; i < columns.length; i++) {
								if (columns[i].alias == alias)
									utilityFunctions.throwSuiteScriptError(error.Type.SSS_DUPLICATE_ALIAS, alias);
							}

							return _values[c];
						}
					}
				}
				else if (aliases)
				{
					for (var a in aliases)
					{
						if (aliases[a] == alias)
							return _values[a];
					}
					utilityFunctions.throwSuiteScriptError(error.Type.CANNOT_DETERMINE_VALUE_FOR_ALIAS, alias);
				}
				utilityFunctions.throwSuiteScriptError(error.Type.CANNOT_DETERMINE_VALUE_FOR_ALIAS, alias);
			};

			/**
			 * Describes the result values. Value types correspond to the ResultSet.types property. Array values correspond to the array values for ResultSet.columns.
			 * @name Result#values
			 * @type {Array<string>|Array<number>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Result)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					values: _values
				};
			};
		}

		Result.prototype = nsobject.getNewInstance();

		function createResultSet(data, columns, metadataProvider)
		{
			return new ResultSet(data, columns, metadataProvider);
		}

		/**
		 * Object for handling paged queries
		 * @class PagedData
		 * @classDescription Encapsulates a set of paged query results. This object also contains information about the set of paged results it encapsulates.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function PagedData(options)
		{
			var TYPE = MOD_PREFIX + 'PagedData';

			var pageSize = options.pageSize;
			var query = options.queryDefinition;
			var queryData = options.queryData;
			var columns = options.columns;
			var customScriptId = options.customScriptId;
			var type = options.type;
			var metadataProvider = options.metadataProvider;
			var viewId = options.viewId;
			var pageRanges = function()
			{
				var ranges = [];
				for (var i = 0; i < queryData.numPages; i++)
					ranges.push(new PageRange({index:i, size: pageSize > 0 ? pageSize * (i + 1) > queryData.total ? queryData.total % pageSize : pageSize : 0}));
				return ranges;
			}();

			function validateAndGetIndex(options, length)
			{
				var index = (options && options.hasOwnProperty('index')) ? options.index : options;
				utilityFunctions.checkArgs([index], ['index'], 'PagedData.fetch');
				index = parseInt(index);
				if (isNaN(index))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);
				if(index < 0 || index >= length)
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch');
				return index;
			}

			/**
			 * Get page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @governance 10 units
			 *
			 * @return {Page}
			 */
			this.fetch = function(options)
			{
				var index = validateAndGetIndex(options, queryData.pages.length);
				if (type == "query")
					return new Page({resultSet: new ResultSet(util.isObject(query) ? invoker(queryApi, 'getSuiteQLQueryPage', [queryData.pages[index], query.query, JSON.stringify(query.params ? query.params : []), metadataProvider, customScriptId]) : invoker(queryApi, 'getQueryPage', [queryData.pages[index], query, metadataProvider]), columns), index: index, size: pageSize, total: queryData.total, pagedData: this, pageRange: pageRanges[index]});
				else if (type == "dataset")
					return new Page({resultSet: new ResultSet(invoker(datasetApi, "getPage", [query, queryData.pages[index], metadataProvider]), columns), pagedData: this, pageRange: pageRanges[index]});
				else
					return new Page({resultSet: new ResultSet(invoker(workbookApi, "getTableViewPage", [query, viewId, queryData.pages[index]]), columns), pagedData: this, pageRange: pageRanges[index]});

			};

			function pagedPromise(query, queryData, columns, pageSize, metadataProvider, options)
			{
				var pagedData = this;
				return new Promise(
					function(resolve, reject) {
						try {
							var index = validateAndGetIndex(options, queryData.pages.length);
							if (type == "workbook")
								invoker(workbookApi, "getTableViewPage", [query, viewId, queryData.pages[index]], callback);
							else if (type == "dataset")
								invoker(datasetApi, "getPage", [query, queryData.pages[index], metadataProvider], callback);
							else if (util.isObject(query))
								invoker(queryApi, 'getSuiteQLQueryPage', [queryData.pages[index], query.query, JSON.stringify(query.params ? query.params : []), metadataProvider, customScriptId], callback);
							else
								invoker(queryApi, 'getQueryPage', [queryData.pages[index], query, metadataProvider], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result, exception) {
							if (exception) {
								reject(exception);
								return;
							}
							try {
								resolve(new Page({resultSet: new ResultSet(result, columns), index: index, size: pageSize, total: queryData.total, pagedData: pagedData, pageRange: pageRanges[index]}));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}

			/**
			 * Asynchronously get page with given index
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.index Index of page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 *
			 * @return {Promise}
			 *
			 * @since 2018.1
			 */
			this.fetch.promise = pagedPromise.bind(this, query, queryData, columns, pageSize, metadataProvider);

			/**
			 * Standard object for iterating through pages.
			 * @governance 10 units for each page returned
			 * @return {Iterator}
			 *
			 * @since 2018.1
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new PageIterator(this, queryData));
			};

			/**
			 * Size of the page
			 * @name PageData#pageSize
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageSize', {
				get: function ()
				{
					return pageSize;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Total number of results
			 * @name PagedData#count
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'count', {
				get: function ()
				{
					return queryData.total;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'count' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Metadata Provider used during execution
			 * @name PagedData#metadataProvider
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2022.1
			 */
			Object.defineProperty(this, 'metadataProvider', {
				get: function ()
				{
					return metadataProvider;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'metadataProvider' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/*
			 * Stringified definition of underlying query
			 * @name PagedData#queryDefinition
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'queryDefinition', {
				get: function ()
				{
					return query;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'queryDefinition' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * PageRanges of PagedData
			 * @name PagedData#pageRanges
			 * @type {Array<PageRange>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageRanges', {
				get: function ()
				{
					return pageRanges;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.PagedData)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pageRanges: pageRanges,
					count: queryData.total,
					pageSize: pageSize,
					queryDefinition: query,
					metadataProvider: metadataProvider
				};
			};
		}

		PagedData.prototype = nsobject.getNewInstance();

		function PageIterator(query, queryData) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < queryData.numPages;
			};

			this.next = function next() {
				return query.fetch(i++);
			}
		}

		PageIterator.prototype = nsobject.getNewInstance();

		/**
		 * PageRange object
		 * @class PageRange
		 * @classDescription Encapsulates the range of query results for a page.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function PageRange(options)
		{
			var index = options.index;
			var size = options.size;
			/**
			 * Describes the array index for this page range.
			 * @name PageRange#index
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'index', {
				get: function ()
				{
					return index;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of results in this page range
			 * @name PageRange#size
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return size;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
		}

		/**
		 * Object corresponding to one page of results
		 * @class Page
		 * @classDescription One page of the paged query results.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Page(options)
		{
			var TYPE = MOD_PREFIX + 'Page';

			var resultSet = options.resultSet;
			var pagedData = options.pagedData;
			var pageRange = options.pageRange;
			var isFirst = !!pageRange && pageRange.index == 0;
			var isLast = !!pageRange && pagedData.pageRanges[pagedData.pageRanges.length - 1] == pageRange;

			/**
			 * ResultSet of the page
			 * @name Page#data
			 * @type {ResultSet}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'data', {
				get: function ()
				{
					return resultSet;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * References the query results contained in this page.
			 * @name QueryPage#pagedData
			 * @type {PagedData}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pagedData', {
				get: function ()
				{
					return pagedData;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The range of query results for this page.
			 * @name QueryPage#pageRange
			 * @type {PageRange}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'pageRange', {
				get: function ()
				{
					return pageRange;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the page is the first of the paged query results.
			 * @name Page#isFirst
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'isFirst', {
				get: function ()
				{
					return isFirst;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indication whether this page is the last one
			 * @name Page#isLast
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'isLast', {
				get: function ()
				{
					return isLast;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Page)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};
			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pagedData: pagedData,
					data: resultSet,
					isFirst: isFirst,
					isLast: isLast,
					pageRange: pageRange
				};
			};
		}

		Page.prototype = nsobject.getNewInstance();

		function createPagedData(options)
		{
			return new PagedData(options)
		}

		return {
			getSearchTypes: getSearchTypes,
			validateSearchType: validateSearchType,
			getSortLocales: getSortLocales,
			validateSortLocale: validateSortLocale,
			createResultSet: createResultSet,
			createPagedData: createPagedData,
			validateOperator: validateOperator,
			getMetadataProviderTypes: getMetadataProviderTypes,
			convertMetaDataProviderType: convertMetaDataProviderType,
			Operator: OPERATOR,
		}

	}
);
/**
 * SuiteScript search paging util module
 * @private Ignore for JSDoc stub generation
 * @module N/search/pagingUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/pagingUtil',[], function (){
	var PAGE_SIZE_MIN = 5,
		PAGE_SIZE_MAX = 1000,
		PAGE_SIZE_DEFAULT = 50;

    function regulatePageSize(pageSize)
    {
	    var size = parseInt(pageSize);
	    var result = isNaN(size) ? PAGE_SIZE_DEFAULT : size;

        result = result < PAGE_SIZE_MIN ? PAGE_SIZE_MIN : result;
        result = result > PAGE_SIZE_MAX ? PAGE_SIZE_MAX : result;

        return result;
    }

    return {
        regulatePageSize: regulatePageSize
    };
});
/**
 * SuiteScript new-generation query common module
 * Load the N/query module to create and run queries using the SuiteAnalytics Workbook query engine.
 *
 * @module N/query
 * @suiteScriptVersion 2.x
 */
define('N/query',['N/restricted/queryApiBridge', 'N/queryInternal', 'N/internal/invoker', 'N/nsobject', 'N/utilityFunctions', 'N/error', 'N/search/pagingUtil', 'N/format'],
	function (queryApi, queryInternal, invoker, nsobject, utilityFunctions, error, pagingUtil, format)
	{
		var MOD_PREFIX = 'query.';

		var ALLOWED_ARITY = Object.freeze({
			"AFTER" : [2, 2],
			"AFTER_NOT" : [2, 2],
			"ANY_OF" : [2, Number.MAX_VALUE],
			"ANY_OF_NOT" : [2, Number.MAX_VALUE],
			"MN_INCLUDE" : [2, Number.MAX_VALUE],
			"MN_EXCLUDE" : [2, Number.MAX_VALUE],
			"MN_INCLUDE_ALL" : [2, Number.MAX_VALUE],
			"MN_EXCLUDE_ALL" : [2, Number.MAX_VALUE],
			"MN_INCLUDE_EXACTLY" : [2, Number.MAX_VALUE],
			"MN_EXCLUDE_EXACTLY" : [2, Number.MAX_VALUE],
			"BEFORE" : [2, 2],
			"BEFORE_NOT" : [2, 2],
			"BETWEEN" : [3, 3],
			"BETWEEN_NOT" : [3, 3],
			"CONTAIN" : [2, 2],
			"CONTAIN_NOT" : [2, 2],
			"EMPTY" : [1, 1],
			"EMPTY_NOT" : [1, 1],
			"ENDWITH" : [2, 2],
			"ENDWITH_NOT" : [2, 2],
			"EQUAL" : [2, 2],
			"EQUAL_NOT" : [2, 2],
			"GREATER" : [2, 2],
			"GREATER_NOT" : [2, 2],
			"GREATER_OR_EQUAL" : [2, 2],
			"GREATER_OR_EQUAL_NOT" : [2, 2],
			"IS" : [2, 2],
			"IS_NOT" : [2, 2],
			"LESS" : [2, 2],
			"LESS_NOT" : [2, 2],
			"LESS_OR_EQUAL" : [2, 2],
			"LESS_OR_EQUAL_NOT" : [2, 2],
			"ON" : [2, 2],
			"ON_NOT" : [2, 2],
			"ON_OR_AFTER" : [2, 2],
			"ON_OR_AFTER_NOT" : [2, 2],
			"ON_OR_BEFORE" : [2, 2],
			"ON_OR_BEFORE_NOT" : [2, 2],
			"START_WITH" : [2, 2],
			"START_WITH_NOT" : [2, 2],
			"WITHIN" : [3, 3],
			"WITHIN_NOT" : [3, 3]
		});

		var AGGREGATE = Object.freeze({
			AVERAGE: 'AVERAGE',
			AVERAGE_DISTINCT: 'AVERAGE_DISTINCT',
			COUNT: 'COUNT',
			COUNT_DISTINCT: 'COUNT_DISTINCT',
			MEDIAN: 'MEDIAN',
			MAXIMUM: 'MAXIMUM',
			MAXIMUM_DISTINCT: 'MAXIMUM_DISTINCT',
			MINIMUM: 'MINIMUM',
			MINIMUM_DISTINCT: 'MINIMUM_DISTINCT',
			SUM: 'SUM',
			SUM_DISTINCT: 'SUM_DISTINCT'
		});

		var RETURN_TYPE = Object.freeze({
			BOOLEAN: 'BOOLEAN',
			DATE: 'DATE',
			DATETIME: 'DATETIME',
			FLOAT: 'FLOAT',
			INTEGER: 'INTEGER',
			STRING: 'STRING',
			DURATION: 'DURATION',
			CURRENCY: 'CURRENCY',
			KEY: 'KEY',
			RELATIONSHIP: 'RELATIONSHIP',
			ANY: 'ANY',
			CLOBTEXT: 'CLOBTEXT',
			PERCENT: 'PERCENT',
			UNKNOWN: 'UNKNOWN'
		});

		var DATE_ID = Object.freeze({
			SECONDS_AGO : "sago",
			MINUTES_AGO : "nago",
			HOURS_AGO : "hago",
			DAYS_AGO : "dago",
			WEEKS_AGO : "wago",
			MONTHS_AGO : "mago",
			QUARTERS_AGO : "qago",
			YEARS_AGO : "yago",
			SECONDS_FROM_NOW : "sfn",
			MINUTES_FROM_NOW : "nfn",
			HOURS_FROM_NOW : "hfn",
			DAYS_FROM_NOW : "dfn",
			WEEKS_FROM_NOW : "wfn",
			MONTHS_FROM_NOW : "mfn",
			QUARTERS_FROM_NOW : "qfn",
			YEARS_FROM_NOW : "yfn"
		});

		var relativeDateCodes = [];
		Object.getOwnPropertyNames(DATE_ID).forEach(function(name){
			relativeDateCodes.push(DATE_ID[name]);
		});

		var DATE_RANGE_CODE = Object.freeze({
			NEXT_ONE_QUARTER : 'NOQ',
			NEXT_ONE_HALF : 'NOH',
			NEXT_ONE_YEAR : 'NOY',
			SAME_MONTH_LAST_FISCAL_QUARTER : 'SMLFQ',
			SAME_MONTH_LAST_FISCAL_YEAR : 'SMLFY',
			SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR : 'SFQLFY',
			SAME_WEEK_LAST_FISCAL_YEAR : 'SWLFY',
			SAME_DAY_LAST_WEEK : 'SDLW',
			SAME_DAY_WEEK_BEFORE_LAST : 'SDWBL',
			SAME_DAY_LAST_MONTH : 'SDLM',
			SAME_DAY_MONTH_BEFORE_LAST : 'SDMBL',
			SAME_DAY_LAST_FISCAL_QUARTER : 'SDLFQ',
			SAME_DAY_FISCAL_QUARTER_BEFORE_LAST : 'SDFQBL',
			SAME_DAY_LAST_FISCAL_YEAR : 'SDLFY',
			SAME_FISCAL_HALF_LAST_FISCAL_YEAR : 'SFHLFY',
			SAME_MONTH_FISCAL_QUARTER_BEFORE_LAST : 'SMFQBL',
			SAME_MONTH_FISCAL_YEAR_BEFORE_LAST : 'SMFYBL',
			SAME_WEEK_FISCAL_YEAR_BEFORE_LAST : 'SWFYBL',
			SAME_DAY_FISCAL_YEAR_BEFORE_LAST : 'SDFYBL',
			SAME_FISCAL_QUARTER_FISCAL_YEAR_BEFORE_LAST : 'SFQFYBL',
			SAME_MONTH_LAST_FISCAL_QUARTER_TO_DATE : 'SMLFQTD',
			SAME_MONTH_LAST_FISCAL_YEAR_TO_DATE : 'SMLFYTD',
			SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR_TO_DATE : 'SFQLFYTD',
			SAME_FISCAL_HALF_LAST_FISCAL_YEAR_TO_DATE : 'SFHLFYTD',
			WEEK_BEFORE_LAST : 'WBL',
			MONTH_BEFORE_LAST : 'MBL',
			WEEK_AFTER_NEXT : 'WAN',
			MONTH_AFTER_NEXT : 'MAN',
			FISCAL_QUARTER_BEFORE_LAST : 'FQBL',
			FISCAL_HALF_BEFORE_LAST : 'FHBL',
			FISCAL_YEAR_BEFORE_LAST : 'FYBL',
			THREE_MONTHS_AGO : 'MB',
			THREE_FISCAL_QUARTERS_AGO : 'FQB',
			THREE_FISCAL_YEARS_AGO : 'FYB',
			THREE_MONTHS_AGO_TO_DATE : 'MBTD',
			THREE_FISCAL_QUARTERS_AGO_TO_DATE : 'FQBTD',
			THREE_FISCAL_YEARS_AGO_TO_DATE : 'FYBTD',
			WEEK_BEFORE_LAST_TO_DATE : 'WBLTD',
			WEEK_AFTER_NEXT_TO_DATE : 'WANTD',
			MONTH_BEFORE_LAST_TO_DATE : 'MBLTD',
			MONTH_AFTER_NEXT_TO_DATE : 'MANTD',
			FISCAL_QUARTER_BEFORE_LAST_TO_DATE : 'FQBLTD',
			FISCAL_HALF_BEFORE_LAST_TO_DATE : 'FHBLTD',
			FISCAL_YEAR_BEFORE_LAST_TO_DATE : 'FYBLTD',
			LAST_MONTH_ONE_FISCAL_QUARTER_AGO : 'LMLFQ',
			LAST_MONTH_ONE_FISCAL_YEAR_AGO : 'LMLFY',
			LAST_FISCAL_QUARTER_ONE_FISCAL_YEAR_AGO : 'LFQLFY',
			LAST_FISCAL_HALF_ONE_FISCAL_YEAR_AGO : 'LFHLFY',
			LAST_MONTH_TWO_FISCAL_QUARTERS_AGO : 'LMFQBL',
			LAST_MONTH_TWO_FISCAL_YEARS_AGO : 'LMFYBL',
			LAST_FISCAL_QUARTER_TWO_FISCAL_YEARS_AGO : 'LFQFYBL',
			PREVIOUS_MONTHS_THIS_FISCAL_QUARTER : 'PMTFQ',
			PREVIOUS_MONTHS_LAST_FISCAL_QUARTER : 'PMLFQ',
			PREVIOUS_MONTHS_SAME_FISCAL_QUARTER_LAST_FISCAL_YEAR : 'PMSFQLFY',
			PREVIOUS_MONTHS_THIS_FISCAL_HALF : 'PMTFH',
			PREVIOUS_MONTHS_LAST_FISCAL_HALF : 'PMLFH',
			PREVIOUS_MONTHS_SAME_FISCAL_HALF_LAST_FISCAL_YEAR : 'PMSFHLFY',
			PREVIOUS_MONTHS_THIS_FISCAL_YEAR : 'PMTFY',
			PREVIOUS_MONTHS_LAST_FISCAL_YEAR : 'PMLFY',
			PREVIOUS_FISCAL_QUARTERS_THIS_FISCAL_YEAR : 'PQTFY',
			PREVIOUS_FISCAL_QUARTERS_LAST_FISCAL_YEAR : 'PQLFY',
			TODAY : 'TODAY',
			YESTERDAY : 'YESTERDAY',
			TWO_DAYS_AGO : 'DAGO2',
			THREE_DAYS_AGO : 'DAGO3',
			FOUR_DAYS_AGO : 'DAGO4',
			FIVE_DAYS_AGO : 'DAGO5',
			TEN_DAYS_AGO : 'DAGO10',
			THIRTY_DAYS_AGO : 'DAGO30',
			SIXTY_DAYS_AGO : 'DAGO60',
			NINETY_DAYS_AGO : 'DAGO90',
			TWO_DAYS_FROM_NOW : 'DFN2',
			THREE_DAYS_FROM_NOW : 'DFN3',
			FOUR_DAYS_FROM_NOW : 'DFN4',
			FIVE_DAYS_FROM_NOW : 'DFN5',
			TEN_DAYS_FROM_NOW : 'DFN10',
			THIRTY_DAYS_FROM_NOW : 'DFN30',
			SIXTY_DAYS_FROM_NOW : 'DFN60',
			NINETY_DAYS_FROM_NOW : 'DFN90',
			TOMORROW : 'TOMORROW',
			PREVIOUS_ONE_DAY : 'OD',
			LAST_WEEK : 'LW',
			LAST_BUSINESS_WEEK : 'LBW',
			LAST_WEEK_TO_DATE : 'LWTD',
			THIS_WEEK : 'TW',
			THIS_BUSINESS_WEEK : 'TBW',
			THIS_WEEK_TO_DATE : 'TWTD',
			PREVIOUS_ONE_WEEK : 'OW',
			NEXT_WEEK : 'NW',
			NEXT_BUSINESS_WEEK : 'NBW',
			LAST_MONTH : 'LM',
			LAST_MONTH_TO_DATE : 'LMTD',
			THIS_MONTH_TO_DATE : 'TMTD',
			THIS_MONTH : 'TM',
			TODAY_TO_END_OF_THIS_MONTH : 'TODAYTTM',
			PREVIOUS_ONE_MONTH : 'OM',
			NEXT_MONTH : 'NM',
			LAST_YEAR : 'LY',
			LAST_YEAR_TO_DATE : 'LYTD',
			THIS_YEAR : 'TY',
			THIS_YEAR_TO_DATE : 'TYTD',
			NEXT_FOUR_WEEKS : 'N4W',
			FOUR_WEEKS_STARTING_THIS_WEEK : 'TWN3W',
			LAST_FISCAL_QUARTER : 'LFQ',
			LAST_FISCAL_QUARTER_TO_DATE : 'LFQTD',
			THIS_FISCAL_QUARTER : 'TFQ',
			THIS_FISCAL_QUARTER_TO_DATE : 'TFQTD',
			NEXT_FISCAL_QUARTER : 'NFQ',
			LAST_FISCAL_HALF : 'LFH',
			LAST_FISCAL_HALF_TO_DATE : 'LFHTD',
			THIS_FISCAL_HALF : 'TFH',
			THIS_FISCAL_HALF_TO_DATE : 'TFHTD',
			NEXT_FISCAL_HALF : 'NFH',
			LAST_FISCAL_YEAR : 'LFY',
			LAST_FISCAL_YEAR_TO_DATE : 'LFYTD',
			THIS_FISCAL_YEAR : 'TFY',
			THIS_FISCAL_YEAR_TO_DATE : 'TFYTD',
			THIS_ROLLING_QUARTER : 'TRQ',
			PREVIOUS_ROLLING_QUARTER : 'PRQ',
			LAST_ROLLING_QUARTER : 'LRQ',
			THIS_ROLLING_HALF : 'TRH',
			PREVIOUS_ROLLING_HALF : 'PRH',
			LAST_ROLLING_HALF : 'LRH',
			THIS_ROLLING_YEAR : 'TRY',
			PREVIOUS_ROLLING_YEAR : 'PRY',
			LAST_ROLLING_YEAR : 'LRY',
			PREVIOUS_ONE_QUARTER : 'OQ',
			PREVIOUS_ONE_HALF : 'OH',
			PREVIOUS_ONE_YEAR : 'OY',
			ONE_YEAR_BEFORE_LAST : 'OYBL',
			NEXT_FISCAL_YEAR : 'NFY',
			NEXT_ONE_WEEK : 'NOW',
			NEXT_ONE_MONTH : 'NOM'
		});

		var FIELD_CONTEXT = Object.freeze({
			RAW : "RAW",
			DISPLAY : "DISPLAY",
			HIERARCHY : "HIERARCHY",
			HIERARCHY_IDENTIFIER : "HIERARCHY_IDENTIFIER",
			SIGN_CONSOLIDATED : "SIGN_CONSOLIDATED",
			CURRENCY_CONSOLIDATED : "CURRENCY_CONSOLIDATED",
			CONVERTED : "CONVERTED"
		});

		var PERIOD_ADJUSTMENT = Object.freeze({
			NOT_LAST : "NOT_LAST",
			ALL : "ALL"
		});

		var PERIOD_TYPE = Object.freeze({
			START: "START",
			END: "END"
		});

		var PERIOD_CODE = Object.freeze({
			FIRST_FISCAL_QUARTER_LAST_FY : "Q1LFY",
			FIRST_FISCAL_QUARTER_THIS_FY : "Q1TFY",
			FISCAL_QUARTER_BEFORE_LAST : "QBL",
			FISCAL_YEAR_BEFORE_LAST : "FYBL",
			FOURTH_FISCAL_QUARTER_LAST_FY : "Q4LFY",
			FOURTH_FISCAL_QUARTER_THIS_FY : "Q4TFY",
			LAST_FISCAL_QUARTER : "LQ",
			LAST_FISCAL_QUARTER_ONE_FISCAL_YEAR_AGO : "LQOLFY",
			LAST_FISCAL_QUARTER_TO_PERIOD : "LFQTP",
			LAST_FISCAL_YEAR : "LFY",
			LAST_FISCAL_YEAR_TO_PERIOD : "LFYTP",
			LAST_PERIOD : "LP",
			LAST_PERIOD_ONE_FISCAL_QUARTER_AGO : "LPOLQ",
			LAST_PERIOD_ONE_FISCAL_YEAR_AGO : "LPOLFY",
			LAST_ROLLING_18_PERIODS : "LR18FP",
			LAST_ROLLING_6_FISCAL_QUARTERS : "LR6FQ",
			PERIOD_BEFORE_LAST : "PBL",
			SAME_FISCAL_QUARTER_LAST_FY : "TQOLFY",
			SAME_FISCAL_QUARTER_LAST_FY_TO_PERIOD: "TFQOLFYTP",
			SAME_PERIOD_LAST_FY : "TPOLFY",
			SAME_PERIOD_LAST_FISCAL_QUARTER : "TPOLQ",
			SECOND_FISCAL_QUARTER_LAST_FY : "Q2LFY",
			SECOND_FISCAL_QUARTER_THIS_FY: "Q2TFY",
			THIRD_FISCAL_QUARTER_LAST_FY : "Q3LFY",
			THIRD_FISCAL_QUARTER_THIS_FY : "Q3TFY",
			THIS_FISCAL_QUARTER : "TQ",
			THIS_FISCAL_QUARTER_TO_PERIOD : "TFQTP",
			THIS_FISCAL_YEAR : "TFY",
			THIS_FISCAL_YEAR_TO_PERIOD : "TFYTP",
			THIS_PERIOD : "TP"
		});

		var periodCodes = [];
		Object.getOwnPropertyNames(PERIOD_CODE).forEach(function(name){
			periodCodes.push(PERIOD_CODE[name]);
		});

		/**
		 * @class Period
		 * @classDescription Special object which can be used as a condition while querying periods
		 * @constructor
		 *
		 * @since 2020.1
		 */
		function Period(code, type, adjustment)
		{
			var TYPE = MOD_PREFIX + 'Period';

			var _code = code;
			var _type = type;
			var _adjustment = adjustment;

			/**
			 * Code of the Period
			 * @name Period#code
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'code', {
				get: function ()
				{
					return _code;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'code');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Type of the Period
			 * @name Period#type
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Adjustment of the Period
			 * @name Period#adjustment
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.1
			 */
			Object.defineProperty(this, 'adjustment', {
				get: function ()
				{
					return _adjustment;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'adjustment');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (query.Period)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					code: _code,
					type: _type,
					adjustment: _adjustment
				};
			};
		}

		/**
		 * @class RelativeDate
		 * @classDescription Special object which can be used as a condition while querying dates
		 * @constructor
		 * @protected
		 *
		 * @since 2019.1
		 */
		function RelativeDate(dateId, value)
		{
			var TYPE = MOD_PREFIX + 'RelativeDate';

			var _dateId = dateId;
			var _value = value;

			/**
			 * Start of relative date
			 * @name RelativeDate#start
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'start', {
				get: function ()
				{
					return {
						type: 'start',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'start');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * End of relative date
			 * @name RelativeDate#end
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'end', {
				get: function ()
				{
					return {
						type: 'end',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'end');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Interval of relative date
			 * @name RelativeDate#interval
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'interval', {
				get: function ()
				{
					return {
						type: 'interval',
						value: _value,
						dateId: _dateId
					};
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'interval');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Value of relative date
			 * @name RelativeDate#value
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'value', {
				get: function ()
				{
					return _value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Flag if this relative date represents range
			 * @name RelativeDate#isRange
			 * @type {Boolean}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'isRange', {
				get: function ()
				{
					return !_value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isRange');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Id of relative date
			 * @name RelativeDate#dateId
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'dateId', {
				get: function ()
				{
					return _dateId;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'dateId');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (query.RelativeDate)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2019.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					value: _value,
					dateId: _dateId
				};
			};
		}

		var RELATIVE_DATE_RANGES = {};
		Object.getOwnPropertyNames(DATE_RANGE_CODE).forEach(function(name){
			Object.defineProperty(RELATIVE_DATE_RANGES, name, {
				get: function ()
				{
					return new RelativeDate(DATE_RANGE_CODE[name]);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, name);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
		});

		/**
		 * @class SuiteQL
		 * @classDescription Object representing query in SuiteQL
		 * @constructor
		 * @protected
		 *
		 * @since 2018.2
		 */
		function SuiteQL(options)
		{
			var TYPE = MOD_PREFIX + 'SuiteQL';

			var _query = options.query;
			var _params = options.params;
			var _columns = options.columns;


			/**
			 * String representation of SuiteQL
			 * @name SuiteQL#query
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'query', {
				get: function ()
				{
					return _query;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'query');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Parameters
			 * @name SuiteQL#params
			 * @type {Array<string|number|boolean>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'params', {
				get: function ()
				{
					return _params;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'params');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Corresponding columns, if SuiteQL was created using toSuiteQL method
			 * @name SuiteQL#columns
			 * @type {Column[]}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Execute the query and return results.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {string} options.metadataProvider
			 * @return {ResultSet} the result set object
			 *
			 * @since 2018.2
			 */
			this.run = function run(options)
			{
				var metadataProvider = queryInternal.convertMetaDataProviderType(options);
				return runSuiteQLInternalForColumns(_query, _params, _columns, metadataProvider);
			};

			/**
			 * Execute the suiteQL query and return paged results.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {Number} options.pageSize
			 * @param {string} options.metadataProvider
			 * @return {PagedData} the paged query object
			 *
			 * @since 2018.2
			 */
			this.runPaged = function runPaged(options)
			{
				var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
				var metadataProvider = queryInternal.convertMetaDataProviderType(options);
				return runSuiteQLPagedInternalForColumns(pageSize, _query, _params, _columns, metadataProvider);
			};

			function promiseToRun(options) {
				var metadataProvider = queryInternal.convertMetaDataProviderType(options);
				return promiseToRunSuiteQLInternal(this.query, this.params, metadataProvider);
			}

			function promiseToRunPaged(options) {
				var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
				var metadataProvider = queryInternal.convertMetaDataProviderType(options);
				return promiseToRunSuiteQLPagedInternal(pageSize, this.query, this.params, metadataProvider);
			}

			/**
			 * Asynchronously execute the query and return results.
			 * @governance 10 units
			 * @return {Promise} the result set object
			 *
			 * @since 2020.1
			 */
			this.run.promise = promiseToRun.bind(this);


			/**
			 * Asynchronously execute the suiteQL query and return results.
			 * @governance 10 units
			 * @return {Promise} the result set object
			 *
			 * @since 2020.1
			 */
			this.runPaged.promise = promiseToRunPaged.bind(this);

			/**
			 * Returns the object type name (query.Columns)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.2
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					query: _query,
					params: _params,
					columns: _columns
				};
			};
		}

		/**
		 * @class Query
		 * @classDescription Encapsulates the query definition. Use query.create(options) or query.load(options) to create this object. The creation of this object is the first step in creating a query with the N/query Module.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Query(type, id, name)
		{
			var TYPE = MOD_PREFIX + 'Query';

			/* private vars */
			var _type = type;
			var _queryId = id || null;
			var _name = name || null;
			var _condition = null;
			var _columns = [];
			var _sort = [];
			var _root = new Component(type, null, null, null);

			/**
			 * Describes the initial query type of the query definition.
			 * @name Query#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * References the simple or nested condition (a query.Condition object) that narrows the query results.
			 * @name Query#condition
			 * @type {Condition}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Condition
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'condition', {
				get: function ()
				{
					return _condition;
				},
				set: function (condition)
				{
					if (!(condition instanceof Condition) && condition !== null)
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'Condition');
					_condition = condition;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds an array of result columns (query.Column objects) returned from the query.
			 * @name Query#columns
			 * @type {Array<Column>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Column array
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return _columns;
				},
				set: function (columns)
				{
					if (!util.isArray(columns))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					for (var i = 0; i < columns.length; i++)
					{
						if (!(columns[i] instanceof Column))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
					}
					_columns = columns;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds an array of query result columns (query.Column objects) used for sorting.
			 * @name Query#sort
			 * @type {Array<Sort>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting value of different type than Query.Sort array
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'sort', {
				get: function ()
				{
					return _sort;
				},
				set: function (sort)
				{
					if (!util.isArray(sort))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'Sort[]');
					for (var i = 0; i < sort.length; i++)
					{
						if (!(sort[i] instanceof Sort))
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Sort[]');
					}
					_sort = sort;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds a references to children of this component. The value of this property is an object of key/value pairs. Each key is the name of a child component. Each respective value is the corresponding query.Component object.
			 * @name Query#child
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _root.child;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds the ID of the query definition.
			 * @name Query#id
			 * @type {Number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return _queryId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Holds the name of the query definition.
			 * @name Query#name
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return _name;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * References the root component of the query definition.
			 * @name Query#root
			 * @type {Component}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return _root;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'root');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Executes the query and returns the query result set.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {string} options.metadataProvider
			 * @return {ResultSet} the result set object
			 *
			 * @since 2018.1
			 */
			this.run = function run(options)
			{
				var metadataProvider = queryInternal.convertMetaDataProviderType(options);
				var data = invoker(queryApi, 'runQuery', [this.marshal(), metadataProvider]);
				return queryInternal.createResultSet(data, _columns, metadataProvider);
			};

		/**
	     * Executes the query and returns a set of paged results.
	     * @governance 10 units
		 * @param {Object} options the options object
		 * @param {Number} options.pageSize
		 * @param {string} options.metadataProvider
	     * @return {PagedData} the paged query object
		 *
		 * @since 2018.1
	     */
	    this.runPaged = function runPaged(options)
	    {
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
		    pageSize = pagingUtil.regulatePageSize(pageSize);
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Query.runPaged');
		    var queryDefinition = this.marshal();
		    var queryData = invoker(queryApi, "pagedQuery", [pageSize, queryDefinition, metadataProvider]);
		    return queryInternal.createPagedData({
			   pageSize: pageSize,
			   queryDefinition: queryDefinition,
			   queryData: queryData,
			   columns: _columns,
			   type: "query",
			   metadataProvider: metadataProvider
		    });
	    };

	    function promiseToQuery(options)
	    {
		    var marshalled = this.marshal();
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    invoker(queryApi, 'runQuery', [marshalled, metadataProvider], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result, exception) {
					    if (exception) {
						    reject(exception);
						    return;
					    }
					    try {
						    var resultSet = queryInternal.createResultSet(result, _columns, metadataProvider);
						    resolve(resultSet);
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

	    function promiseToPaged(options)
	    {
		    var marshalled = this.marshal();
		    var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
		    pageSize = pagingUtil.regulatePageSize(pageSize);
		    var cols = this.columns;
		    return new Promise(
			    function(resolve, reject) {
				    try {
					    utilityFunctions.checkArgs([pageSize], ['pageSize'], 'Query.runPaged');
					    invoker(queryApi, "pagedQuery", [pageSize, marshalled, metadataProvider], callback);
				    }
				    catch (e) {
					    reject(e);
				    }

				    function callback(result, exception) {
					    if (exception) {
						    reject(exception);
						    return;
					    }
					    try {
						    resolve(queryInternal.createPagedData({
							    pageSize: pageSize,
							    queryDefinition: marshalled,
							    queryData: result,
							    columns: cols,
							    type: "query",
								metadataProvider: metadataProvider
						    }));
					    }
					    catch (e) {
						    reject(e);
					    }
				    }
			    }
		    );
	    }

			/**
			 * Executes the query asynchronously and returns the query result set.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {string} options.metadataProvider
			 * @return {Promise} the result set object
			 *
			 * @since 2018.1
			 */
			this.run.promise = promiseToQuery.bind(this);

			/**
			 * Executes the query asynchronously and returns a set of paged results.
			 * @governance 10 units
			 * @param {Object} options the options object
			 * @param {Number} options.pageSize
			 * @param {string} options.metadataProvider
			 * @return {Promise} the result set object
			 *
			 * @since 2018.1
			 */
			this.runPaged.promise = promiseToPaged.bind(this);

			/**
			 * Creates a join relationship.
			 * @link Component.autoJoin
			 */
			this.autoJoin = function autoJoin(options)
			{
				return _root.autoJoin(options);
			};

			/**
			 * Creates a join relationship.
			 * @link Component.join
			 */
			this.join = function join(options)
			{
				return _root.join(options);
			};

			/**
			 * Creates an explicit directional join relationship to another component from this component (a polymorphic join). This method sets the Component.target property on the returned query.Component object.
			 * @link Component.joinTo
			 */
			this.joinTo = function joinTo(options)
			{
				return _root.joinTo(options);
			};

			/**
			 * Creates an explicit directional join relationship from another component to this component (an inverse join). This method sets the Component.source property on the returned query.Component object.
			 * @link Component.joinFrom
			 */
			this.joinFrom = function joinFrom(options)
			{
				return _root.joinFrom(options);
			};

			/**
			 * This method creates a condition (query filter) based on the query.Query object.
			 * @link Component.createCondition
			 */
			this.createCondition = function createCondition(options)
			{
				return _root.createCondition(options);
			};

			/**
			 * This method creates a query result column based on the query.Query object.
			 * @link Component.createColumn
			 */
			this.createColumn = function createColumn(options)
			{
				return _root.createColumn(options);
			};

			/**
			 * This method creates a sort based on the query.Query object. The query.Sort object describes a sort that is placed on a particular query result column.
			 * @link Component.createSort
			 */
			this.createSort = function createSort(options)
			{
				return _root.createSort(options);
			};

			function convertConditions(options)
			{
				var newArguments = null;
				if (util.isObject(options) && options.hasOwnProperty("conditions"))
					newArguments = options.conditions;
				else if (util.isArray(options))
					newArguments = options;
				else
					newArguments = Array.prototype.slice.call(arguments);
				return newArguments;
			}

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical conjunction (AND) of the arguments passed to the method. The arguments must be one or more query.Condition objects.
			 * @governance none
			 * @param {Object} options The options object
			 * @param {Array<Condition>} options.condition One or more condition objects. There is no limit on the number of conditions you can specify.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.and = function and()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Query.and');
				return new Condition(convertConditions.apply(null, arguments), 'AND', null);
			};

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical disjunction (OR) of the arguments passed to the method. The arguments must be one or more query.Condition objects.
			 * @governance none
			 * @param {Object} options The options object
			 * @param {Array<Condition>} options.condition One or more condition objects. There is no limit on the number of conditions you can specify.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.or = function or()
			{
				utilityFunctions.checkArgs([arguments.length > 0], ['argument count'], 'Query.or');
				return new Condition(convertConditions.apply(null, arguments), 'OR', null);
			};

			/**
			 * Creates a new condition (a query.Condition object) that corresponds to a logical negation (NOT) of the argument passed to the method. The argument must be a query.Condition object.
			 * @governance 0 units
			 * @param {Condition} One condition object.
			 * @return {Condition}
			 *
			 * @since 2018.1
			 */
			this.not = function not()
			{
				utilityFunctions.checkArgs([arguments.length == 1], ['argument count'], 'Query.not');
				return new Condition(convertConditions.apply(null, arguments), 'NOT', null);
			};

			/**
			 * Converts a Query object to corresponding SuiteQL representation
			 * @governance none
			 * @return {SuiteQL}
			 *
			 * @since 2018.1
			 */
			this.toSuiteQL = function toSuiteQL()
			{
				var sql = invoker(queryApi, 'toSuiteQL', [this.marshal()]);
				sql.columns = _columns;
				sql.type = _type;
				return new SuiteQL(sql);
			};

			/**
			 * Asynchronously converts a Query object to corresponding SuiteQL representation
			 * @governance none
			 * @return {Promise}
			 *
			 * @since 2019.2
			 */
			this.toSuiteQL.promise = function () {
				var marshalled = this.marshal();
				return new Promise(
					function(resolve, reject) {
						try {
							invoker(queryApi, 'toSuiteQL', [marshalled], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result, exception) {
							if (exception) {
								reject(exception);
								return;
							}
							try {
								result.columns = _columns;
								result.type = _type;
								resolve(new SuiteQL(result));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}.bind(this);

			/**
			 * Converts a Query object to corresponding SuiteQL without result functions representation
			 * @governance none
			 * @return {SuiteQL}
			 *
			 * @since 2025.2
			 */
			this.toSuiteQLWithoutResultFunctions = function toSuiteQLWithoutResultFunctions()
			{
				var sql = invoker(queryApi, 'toSuiteQLWithoutResultFunctions', [this.marshal()]);
				sql.columns = _columns;
				sql.type = _type;
				return new SuiteQL(sql);
			};

			/**
			 * Asynchronously converts a Query object to corresponding SuiteQL without result functions representation
			 * @governance none
			 * @return {Promise}
			 *
			 * @since 2025.2
			 */
			this.toSuiteQLWithoutResultFunctions.promise = function () {
				var marshalled = this.marshal();
				return new Promise(
					function(resolve, reject) {
						try {
							invoker(queryApi, 'toSuiteQLWithoutResultFunctions', [marshalled], callback);
						}
						catch (e) {
							reject(e);
						}

						function callback(result, exception) {
							if (exception) {
								reject(exception);
								return;
							}
							try {
								result.columns = _columns;
								result.type = _type;
								resolve(new SuiteQL(result));
							}
							catch (e) {
								reject(e);
							}
						}
					}
				);
			}.bind(this);

			/**
			 * Returns the object type name (query)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					id: _queryId,
					name: _name,
					condition: _condition ? _condition.toJSON() : null,
					columns: jsonifyArray(_columns),
					sort: jsonifyArray(_sort),
					child: _root ? jsonifyObject(_root.child) : null,
					root: _root ? _root.toJSON() : null
				};
			};

			this.marshal = function marshal()
			{
				var col = [];
				for (var i = 0; i < _columns.length; i++)
					col.push(_columns[i].marshal());
				return JSON.stringify({
					type: _type,
					id: _queryId,
					name: _name,
					condition: _condition ? _condition.marshal() : null,
					columns: col,
					sort: jsonifyArray(_sort, true, _columns)
				});
			};
		}

		Query.prototype = nsobject.getNewInstance();

		function jsonifyArray(arr, marshal, aux)
		{
			if (arr == null)
				return null;
			var result = [];
			for (var i = 0; i < arr.length; i++)
			{
				result.push(marshal ? arr[i].marshal(aux) : arr[i].toJSON());
			}
			return result;
		}

		function jsonifyObject(obj, marshal)
		{
			if (obj == null)
				return null;
			var result = {};
			for (var i in obj)
			{
				if (obj.hasOwnProperty(i))
					result[i] = marshal ? obj[i].marshal() : obj[i].toJSON();
			}
			return result;
		}

		function jsonifyContext(context, marshal)
		{
			if (context && context.name == FIELD_CONTEXT.CONVERTED)
			{
				if (context.params.date instanceof RelativeDate)
					context.params.date = context.params.date.toJSON();
				else if (util.isDate(context.params.date))
					context.params.date = marshal ? format.format({type: format.Type.DATE, value: context.params.date})
					                              : format.format({value: params.date, type: format.Type.DATE});
			}
			return context;
		}

		/**
		 * @class Component
		 * @classDescription Encapsulates one component of the query definition. Each new component is created as a child to the previous component. All components exist as children to the query definition (query.Query).
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Component(type, target, source, parent)
		{
			var TYPE = MOD_PREFIX + 'Component';

			var _type = type;
			var _parent = parent;
			var _target = target;
			var _source = source;
			var _children = {};

			/**
			 * Describes the query type of this component.
			 * @name Component#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the query type of the component joined to this component. This property can also be described as the inverse relationship of this component.
			 * @name Component#source
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'source', {
				get: function ()
				{
					return _source;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'source');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the query type of this component. This property can also be described as the polymorphic relationship of this component.
			 * @name Component#target
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'target', {
				get: function ()
				{
					return _target;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'target');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a references to the parent query.Component object of this component.
			 * @name Component#parent
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'parent', {
				get: function ()
				{
					return _parent;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'parent');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a references to children of this component. The value of this property is an object of key/value pairs. Each key is the name of a child component. Each respective value refers to the corresponding query.Component object.
			 * @name Component#child
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'child', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'child');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Creates a join relationship.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if fieldId is undefined
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED if relationship is already used
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.autoJoin = function autoJoin(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				utilityFunctions.checkArgs([type], ['fieldId'], 'Component.autoJoin');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, null, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates a join relationship. This method is an alias to Component.autoJoin(options).
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component. This value determines the columns on which the components are joined and the type of the newly joined component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If fieldId is undefined.
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.join = function join(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				utilityFunctions.checkArgs([type], ['fieldId'], 'Component.join');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, null, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates an explicit directional join relationship to another component from this component (a polymorphic join). This method sets the Component.target property on the returned query.Component object.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @param {string} options.target The query type of the component joined to this component. This value sets the Component.target property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If fieldId is undefined.
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 *
			 * @since 2018.2
			 */
			this.joinTo = function joinTo(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				var target = (options && options.hasOwnProperty('target')) ? options.target : arguments[1];
				utilityFunctions.checkArgs([type, target], ['fieldId', 'target'], 'Component.joinTo');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(target, 'options.target', util.isString)]);
				var identifier = type + '^' + target;
				if (!!_children[identifier])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, target, null, this);
				_children[identifier] = result;
				return result;
			};

			/**
			 * Creates an explicit directional join relationship from another component to this component (an inverse join). This method sets the Component.source property on the returned query.Component object.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The column type (field type) that joins the parent component to the new component.
			 * @param {string} options.source The query type of the component joined to this component.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If relationship is undefined
			 * @throws {SuiteScriptError} RELATIONSHIP_ALREADY_USED The specified join relationship already exists.
			 * @return {Component}
			 * 
			 * @since 2018.1
			 */
			this.joinFrom = function joinFrom(options)
			{
				var type = (options && options.hasOwnProperty('fieldId')) ? options.fieldId : options;
				var source = (options && options.hasOwnProperty('source')) ? options.source : arguments[1];
				utilityFunctions.checkArgs([type, source], ['fieldId', 'source'], 'Component.joinFrom');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.fieldId', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(target, 'options.source', util.isString)]);
				if (!!_children[type])
					utilityFunctions.throwSuiteScriptError(error.Type.RELATIONSHIP_ALREADY_USED, type);
				var result = new Component(type, null, source, this);
				_children[type] = result;
				return result;
			};

			/**
			 * Creates a condition (query filter) based on the query.Component object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The name of the condition. This value sets the Condition.fieldId property.
			 * @param {string} options.operator The operator used by the condition. This value sets the Condition.operator parameter.
			 * @param {Array<string>|Array<Date>} options.values An array of values to use for the condition. This value sets the Condition.values property.
			 * @param {string} options.formula The formula used to create the condition. This value sets the Condition.formula property.
			 * @param {string} options.type If you use the options.formula parameter, use this parameter to explicitly define the formulaâs return type. Defining the formulaâs return type might be required if the return type cannot be determined correctly based on the specified formula. This value sets the Condition.type property.
			 * @param {string} [options.aggregate] Use this parameter to run an aggregate function on a condition. An aggregate function performs a calculation on the condition values and returns a single value. This value sets the Condition.aggregate property.
			 * @param {boolean} [options.caseSensitive] Indicates whether operators CONTAIN, CONTAIN_NOT, START_WITH, START_WITH_NOT, IS, IS_NOT, ANY_OF and ANY_OF_NOT for string based fields will evaluate values with case sensitivity or not.
			 * @param {Object} [options.context] The field context for values in the query result column. This value sets the Column.context property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object.
			 * @throws {SuiteScriptError} OPERATOR_ARITY_MISMATCH If requested operator cannot work with specified number of.
			 * @throws {SuiteScriptError} INVALID_SEARCH_OPERATOR If wrong query operator is used.
			 * @return {Condition}
			 * 
			 * @since 2018.1
			 */
			this.createCondition = function createCondition(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createCondition');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Condition(null, options, this);
			};

			/**
			 * Creates a query result column based on the query.Component object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.fieldId The name of the query result column. This value sets the Column.fieldId property.
			 * @param {string} options.formula The formula used to create the query result column. This value sets the Column.formula property.
			 * @param {string} options.type If you use the options.formula parameter, use this parameter to explicitly define the formulaâs return type. Defining the formulaâs return type might be required if the return type cannot be determined correctly based on the specified formula. This value sets the Column.type property.
			 * @param {string} options.label Field (column) label
			 * @param {string} [options.aggregate] Use this parameter to run an aggregate function on your query result column. An aggregate function performs a calculation on the column values and returns a single value. This value sets the Column.aggregate property.
			 * @param {boolean} [options.groupBy] Indicates whether the query results are grouped by this query result column. This value sets the Column.groupBy property.
			 * @param {Object} [options.context] The field context for values in the query result column. This value sets the Column.context property.
			 * @param {Object} [options.alias] The alternate name for the query result column; the alias is used in mapped results.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS When two mutually arguments are defined
			 * @throws {SuiteScriptError} NEITHER_ARGUMENT_DEFINED When neither of two mandatory arguments is defined
			 * @return {Column}
			 * 
			 * @since 2018.1
			 */
			this.createColumn = function createColumn(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createColumn');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');
				return new Column(options, this);
			};

			/**
			 * Creates a sort based on the query.Component object. The query.Sort object describes a sort that is placed on a particular query result column or condition.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.column The query result column that you want to sort by. This value sets the Sort.column property.
			 * @param {boolean} [options.ascending] Indicates whether the sort direction is ascending. This value sets the Sort.ascending property.
			 * @param {boolean} [options.nullsLast] Where to put results with null value. Defaults to value of ascending flag
			 * @param {boolean} [options.caseSensitive] Indicates whether query results with null values are listed at the end of the query results. This value sets the Sort.nullsLast property.
			 * @param {string} [options.locale] The locale to use for the sort. This value sets the Sort.locale property.
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object
			 * @return {Sort}
			 *
			 * @since 2018.1
			 */
			this.createSort = function createSort(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'Component.createSort');
				if (!util.isObject(options))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'Object');

				var	column = options.column;
				utilityFunctions.checkArgs([column], ['column'], 'Component.createSort');
				if (!(column instanceof Column))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'column', 'Column');

				var locale;
				if (!util.isString(options.locale))
					locale = null;
				else
				{
					queryInternal.validateSortLocale(options.locale);
					locale = options.locale;
				}

				var	ascending = options.ascending == null ? true : !!options.ascending;
				var	nullsLast = options.nullsLast == null ? ascending : !!options.nullsLast;
				var	caseSensitive = !!options.caseSensitive;

				return new Sort(column, ascending, nullsLast, caseSensitive, locale);
			};

			/**
			 * Returns the object type name (query.Component)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: _type,
					source: _source,
					target: _target,
					parent: _parent
				};
			};

			this.getJoins = function getJoins(field, includeRoot)
			{
				var result = field;
				for (var comp = this; (includeRoot ? comp : comp.parent) != null; comp = comp.parent)
				{
					if (comp.source)
						result = comp.type + "<" + comp.source + '.' + result;
					else if (comp.target)
						result = comp.type + "^" + comp.target + '.' + result;
					else
						result = comp.type + '.' + result;
				}
				return String(result);
			}
		}

		Component.prototype = nsobject.getNewInstance();

		/**
		 * Specifies a return column.
		 *
		 * @class Column
		 * @classDescription Encapsulates a query result column.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Column(options, component)
		{
			var TYPE = MOD_PREFIX + 'Column';

			var _fieldId = options.fieldId ? options.fieldId : null;
			var _component = component;
			var _formula = options.formula ? options.formula : null;
			var _type = options.type ? options.type : null;
			var _aggregate = options.aggregate ? options.aggregate : null;
			var _groupBy = options.groupBy === true;
			var _label = options.label;
			var _context = options.context;
			var _alias = options.alias;

			if (_context)
			{
				if (util.isString(_context))
					_context = {name: _context};
				validateContext(_context, 'Component.createColumn');
			}
			if (!_fieldId && !_formula)
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'fieldId', 'formula');
			else if (_fieldId && _formula)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'fieldId', 'formula');
			if (_aggregate && _groupBy)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'aggregate', 'groupBy');
			if (_formula && !RETURN_TYPE[_type])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FORMULA_TYPE, _type);
			if (_aggregate && !AGGREGATE[_aggregate])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_AGGREGATE_TYPE, _aggregate);

			/**
			 * Holds the name of the query result column.
			 * @name Column#fieldId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'fieldId', {
				get: function ()
				{
					return _fieldId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Represents an alias for this column. An alias is an alternate name for a column, and the alias is used in mapped results.
			 * @name Column#alias
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-string is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'alias', {
				get: function ()
				{
					return _alias;
				},
				set: function (val)
				{
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(val, 'Column.alias', util.isString)]);
					_alias = val;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds a reference to the query.Component object to which this query result column belongs.
			 * @name Column#component
			 * @type {Component}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes a formula used to create the query result column.
			 * @name Column#formula
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the return type of the formula used to create the query result column.
			 * @name Column#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes an aggregate function that is performed on the query result column. An aggregate function performs a calculation on the column values and returns a single value.
			 * @name Column#aggregate
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the query results are grouped by this query result column.
			 * @name Column#groupBy
			 * @type {Boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'groupBy', {
				get: function ()
				{
					return _groupBy;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'groupBy');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the field context for values in the query result column.
			 * @name Column#context
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2019.1
			 */
			Object.defineProperty(this, 'context', {
				get: function ()
				{
					return _context;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'context');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Label.
			 * @name Column#label
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-string is attempted
			 *
			 * @since 2019.2
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return _label;
				},
				set: function (val)
				{
					utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(val, 'Column.label', util.isString)])
					_label = val
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Column)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					fieldId: _formula ? null : _component ? _component.getJoins(_fieldId, true) : _fieldId,
					component: _component ? _component.toJSON() : null,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					groupBy: _groupBy,
					label: _label,
					context: jsonifyContext(_context, false),
					alias: _alias
				};
			};

			this.marshal = function marshal()
			{
				var res = {};
				if (_formula)
				{
					res.formula = _formula;
					if (_type)
						res.type = _type;
				}
				else
				{
					res.name = this.getJoins();
				}
				if (_aggregate)
					res.aggregate = _aggregate;
				if (_groupBy)
					res.groupBy = _groupBy;
				if (_label)
					res.label = _label;
				if (_alias)
					res.alias = _alias;
				res.context = jsonifyContext(_context, true);
				if (_component)
				{
					if (_component.target)
						res.target = _component.target;
					if (_component.source)
						res.source = _component.source;
				}
				return res;
			};

			this.getJoins = function getJoins()
			{
				return _component ? _component.getJoins(_fieldId) : _fieldId;
			}
		}

		Column.prototype = nsobject.getNewInstance();

		/**
		 * @class Sort
		 * @classDescription Encapsulates a sort based on the query.Query or query.Component object. The query.Sort object describes a sort that is placed on a particular query result column.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Sort(column, ascending, nullsLast, caseSensitive, locale)
		{
			var TYPE = MOD_PREFIX + 'Sort';

			var _column = column;
			var _ascending = ascending;
			var _nullsLast = nullsLast;
			var _caseSensitive = caseSensitive;
			var _locale = locale;
			/**
			 * Describes the query result column that the query results are sorted by.
			 * @name Sort#column
			 * @type {Column}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'column', {
				get: function ()
				{
					return _column;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'column');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the sort direction is ascending.
			 * @name Sort#ascending
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting wrong sort order is attempted
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'ascending', {
				get: function ()
				{
					return _ascending;
				},
				set: function (ascending)
				{
					if (!util.isBoolean(ascending))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'ascending', 'Boolean');
					_ascending = ascending;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the sort is case sensitive.
			 * @name Sort#caseSensitive
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'caseSensitive', {
				get: function ()
				{
					return _caseSensitive;
				},
				set: function (caseSensitive)
				{
					if (!util.isBoolean(caseSensitive))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'Boolean');
					_caseSensitive = caseSensitive;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether query results with null values are listed at the end of the query results.
			 * @name Sort#nullsLast
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'nullsLast', {
				get: function ()
				{
					return _nullsLast;
				},
				set: function (nullsLast)
				{
					if (!util.isBoolean(nullsLast))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'nullsLast', 'Boolean');
					_nullsLast = nullsLast;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Sort locale
			 * @name Sort#locale
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'locale', {
				get: function ()
				{
					return _locale;
				},
				set: function (locale)
				{
					if (!util.isString(locale))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'locale', 'String');
					queryInternal.validateSortLocale(locale);
					_locale = locale;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Sort)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					column: _column ? _column.toJSON() : null,
					ascending: _ascending,
					nullsLast: _nullsLast,
					caseSensitive: _caseSensitive,
					locale: _locale
				};
			};

			this.marshal = function marshal(columns)
			{
				var colOfs = -1;
				for (var i = 0; i < columns.length; i++)
				{
					if (columns[i] === _column)
					{
						colOfs = i;
						break;
					}
				}
				var res = {
					col: colOfs,
					ascending: _ascending,
					caseSensitive: _caseSensitive,
					nullsLast: _nullsLast,
					locale: _locale
				};

				if (_column.component.target)
					res.target = _column.component.target;
				if (_column.component.source)
					res.source = _column.component.source;

				return res;
			};
		}

		Sort.prototype = nsobject.getNewInstance();

		/**
		 * Specifies the condition used to filter the results. It can consist of other Condition objects.
		 * @class Condition
		 * @classDescription A condition narrows the query results. The query.Condition object acts in the same capacity as the search.Filter object in the N/search Module. The primary difference is that query.Condition objects can contain other query.Condition objects.
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function Condition(children, options, component)
		{
			var TYPE = MOD_PREFIX + 'Condition';

			var undef = undefined;
			var _children = null;
			var _fieldId = null;
			var _op = null;
			var _values = null;
			var _formula = null;
			var _type = null;
			var _aggregate = null;
			var _context = null;
			var _component = null;
			var _caseSensitive = false;

			if (children)
			{
				_children = children;
				_op = options;
			}
			else
			{
				_fieldId = options.fieldId ? options.fieldId : null;
				_op = options.operator ? options.operator : null;
				_values = options.values === undef ? null : options.values;
				_formula = options.formula ? options.formula : null;
				_type = options.type ? options.type : null;
				_aggregate = options.aggregate ? options.aggregate : null;
				_context = options.context ? options.context : null;
				_component = component;
				_caseSensitive = options.caseSensitive ? options.caseSensitive : false;

				if (_context)
				{
					if (util.isString(_context))
						_context = {name: _context};
					validateContext(_context, 'Component.createCondition');
				}

				if (!_fieldId && !_formula)
					utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'fieldId', 'formula');
				else if (_fieldId && _formula)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'fieldId', 'formula');
				utilityFunctions.checkArgs([_op], ['operator'], 'Component.createCondition');
				queryInternal.validateOperator(_op, error.Type.INVALID_SEARCH_OPERATOR);
				if (_formula && !RETURN_TYPE[_type])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FORMULA_TYPE, _type);
				if (_aggregate && !AGGREGATE[_aggregate])
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_AGGREGATE_TYPE, _aggregate);

				if (util.isArray(_values))
				{
					for (var i = 0; i < _values.length; i++)
					{
						if (_values[i] === undef)
							_values[i] = null;
					}
				}
				_checkOperatorArity(_op, _values)
			}

			/**
			 * Holds an array of child conditions used to create the parent condition.
			 * @name Condition#children
			 * @type {Array<Condition>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'children', {
				get: function ()
				{
					return _children;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'children');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds the name of the condition.
			 * @name Condition#fieldId
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'fieldId', {
				get: function ()
				{
					return _fieldId;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds the name of the operator used to create the condition.
			 * @name Condition#operator
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'operator', {
				get: function ()
				{
					return _op;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Holds an array of values used by an operator to create the condition.
			 * @name Condition#values
			 * @type {Array<string>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return _values;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the formula used to create the condition.
			 * @name Condition#formula
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'formula', {
				get: function ()
				{
					return _formula;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the return type of the formula used to create the condition.
			 * @name Condition#type
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return _type;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes an aggregate function that is performed on the condition. An aggregate function performs a calculation on the condition values and returns a single value.
			 * @name Condition#aggregate
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'aggregate', {
				get: function ()
				{
					return _aggregate;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'aggregate');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the field context affiliated with the condition
			 * @name Condition#context
			 * @type {Object}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2022.1
			 */
			Object.defineProperty(this, 'context', {
				get: function ()
				{
					return _context;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'context');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Describes the component used to created the condition
			 * @name Condition#component
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'component', {
				get: function ()
				{
					return _component;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'component');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the filter in condition is case sensitive.
			 * @name Condition#caseSensitive
			 * @type {Boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
			 *
			 * @since 2018.2
			 */
			Object.defineProperty(this, 'caseSensitive', {
				get: function ()
				{
					return _caseSensitive;
				},
				set: function (caseSensitive)
				{
					if (!util.isBoolean(caseSensitive))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'Boolean');
					_caseSensitive = caseSensitive;
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (query.Condition)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2018.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2018.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					children: jsonifyArray(_children),
					fieldId: _fieldId,
					operator: _op,
					formula: _formula,
					type: _type,
					aggregate: _aggregate,
					values: _values,
					context: jsonifyContext(_context, false),
					component: _component ? _component.toJSON() : null,
					caseSensitive: _caseSensitive
				};
			};

			this.marshal = function marshal()
			{
				var res = {};
				if (_children)
				{
					res.children = jsonifyArray(_children, true);
					res.operator = _op;
				}
				else
				{
					if (_formula)
					{
						res.formula = _formula;
						res.type = _type;
					}
					else
						res.field = _component ? _component.getJoins(_fieldId) : _fieldId;

					res.operator = _op;
					if (_values instanceof RelativeDate || _values instanceof Period)
						res.values = _values.toJSON();
					else if (util.isDate(_values))
						res.values = format.format({type: format.Type.DATE, value: _values});
					else if (util.isArray(_values))
						res.values = _values.map(function(elem){ return (elem instanceof RelativeDate || elem instanceof Period) ? elem.toJSON() : util.isDate(elem) ? format.format({type: format.Type.DATE, value: elem}) : elem;});
					else
						res.values = _values;

					if (_component)
					{
						if (_component.target)
							res.target = _component.target;
						if (_component.source)
							res.source = _component.source;
					}

					if (_aggregate)
						res.aggregate = _aggregate;

					if (_caseSensitive)
						res.caseSensitive = _caseSensitive;
					else
						res.caseSensitive = false;
					res.context = jsonifyContext(_context, true);
				}
				return res;
			};
		}

		Condition.prototype = nsobject.getNewInstance();

		function createQuery(options)
		{
			var type = (options && options.hasOwnProperty('type')) ? options.type : options;
			utilityFunctions.checkArgs([type], ['type'], 'createQuery');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.type', util.isString)]);
			queryInternal.validateSearchType(type);
			var result = new Query(type);
			if (util.isObject(options.condition))
				result.condition = result.createCondition(options.condition);
			if (util.isArray(options.columns))
			{
				var cols = [];
				for (var i = 0; i < options.columns.length; i++)
					cols.push(result.createColumn(options.columns[i]));
				result.columns = cols;
			}
			if (util.isArray(options.sort))
			{
				var sorts = [];
				for (var i = 0; i < options.sort.length; i++)
				{
					var sort = options.sort[i];
					sort.column = result.createColumn(sort);
					sorts.push(result.createSort(sort));
				}
				result.sort = sorts;
			}
			return result;
		}

		function handleJoins(fieldId, joinsMap, search)
		{
			var joins = fieldId.split(".");
			var lastJoin = search;
			var joinId = "";
			if (joins.length > 1) {
				for (var j = 0; j < joins.length - 1; j++) {
					var join = joins[j];
					joinId += join;
					var sourcePos = join.indexOf("<");
					var targetPos = join.indexOf("^");
					if (sourcePos > 0) {
						var field = join.substr(0, sourcePos);
						var src = join.substr(sourcePos + 1);
						if (!joinsMap[joinId])
							joinsMap[joinId] = lastJoin.joinFrom({fieldId: field, source: src});
					}
					else if (targetPos > 0) {
						var field = join.substr(0, targetPos);
						var tgt = join.substr(targetPos + 1);
						if (!joinsMap[joinId])
							joinsMap[joinId] = lastJoin.joinTo({fieldId: field, target: tgt});
					}
					else if (!joinsMap[joinId])
						joinsMap[joinId] = lastJoin.autoJoin({fieldId: join});

					lastJoin = joinsMap[joinId];
					joinId += ".";
				}
			}
			return {join: lastJoin, fieldId: joins[joins.length -1]};
		}

		function listTables(options)
		{
			var id = listTablesPreProcess(options);
			var useString = invoker(queryApi, 'listTables', [id], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			if (!utilityFunctions.isPromiseCallback(this))
				return useString;
		}

		function listTablesPreProcess(options)
		{
			var workbookId = (options && options.hasOwnProperty('workbookId')) ? options.workbookId : options;
			utilityFunctions.checkArgs([workbookId], ['workbookId'], 'query.listTables');
			if (!util.isString(workbookId))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'workbookId', 'string');
			return workbookId;
		}

		/**
		 * @typedef {Object} TableViewHeader
		 * @property {string} name - Name of the table view
		 * @property {string} scriptId - Script id of the table view
		 */
		//this is a public @typedef and needs a code to be attached to to be stubbed
		function TableViewHeaderTypedef(){}

		/**
		 * Asynchronously lists table views for specified workbook
		 * @governance 5 units
		 * @param {string} workbookId Script id of a workbook
		 * @return {Array<TableViewHeader>} Array of table views present in workbook with given script id
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If workbookId parameter is missing
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If workbookId parameter isn't string
		 *
		 * @since 2020.1
		 * @deprecated - should be replaced by using NX/workbook instead
		 */
		listTables.promise = function()
		{
			return utilityFunctions.promiseTo(listTables, arguments);
		};

		function loadQuery(options)
		{
			var id = loadPreProcess(options);
			var data = invoker(queryApi, 'loadSearch', [id]);
			return loadPostProcess(data, id);
		}

		function loadPreProcess(options)
		{
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'query.load');
			if (!util.isString(id))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'String');
			return id;
		}

		function loadPostProcess(data, id)
		{
			var search = new Query(data.type, id, data.name);
			var joinsMap = {};
			var columnMap = {};

			for (var i = 0; i < data.columns.length; i++)
			{
				var column = data.columns[i];
				if (column.formula)
				{
					var col = search.createColumn({alias: column.alias, formula: column.formula, type: column.type, aggregate: column.aggregate, groupBy: column.groupBy, label: column.label});
					search.columns.push(col);
					columnMap[column.formula] = col;
				}
				else
				{
					var handle = handleJoins(column.fieldId, joinsMap, search);
					var col = handle.join.createColumn({alias: column.alias, fieldId: handle.fieldId, aggregate: column.aggregate, groupBy: column.groupBy, label: column.label, context: column.context});
					search.columns.push(col);
					columnMap[handle.fieldId] = col;
				}
			}

			for (var i = 0; i < data.sorts.length; i++)
			{
				var column = data.sorts[i].column;
				var direction = data.sorts[i].direction;
				var ascending, nullsLast, caseSensitive, locale;

				if (direction == "DESCENDING_NULLS_LAST")
				{
					ascending = false;
					nullsLast = true;
				}
				else if (direction == "DESCENDING")
				{
					ascending = false;
					nullsLast = false;
				}
				else if (direction == "ASCENDING_NULLS_FIRST")
				{
					ascending = true;
					nullsLast = false;
				}
				else
				{
					ascending = true;
					nullsLast = true;
				}
				caseSensitive = data.sorts[i].caseSensitive;
				locale = data.sorts[i].locale;

				if (column.formula)
				{
					if (columnMap[column.formula])
						search.sort.push(search.createSort({column: columnMap[column.formula], ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					else
					{
						var sortCol = search.createColumn({formula: column.formula, type: column.type, aggregate: column.aggregate, groupBy: column.groupBy});
						search.sort.push(search.createSort({column: sortCol, ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					}
				}
				else
				{
					var handle = handleJoins(column.fieldId, joinsMap, search);
					if (columnMap[handle.fieldId])
						search.sort.push(handle.join.createSort({column: columnMap[handle.fieldId], ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					else
					{
						var sortCol = handle.join.createColumn({fieldId: handle.fieldId, aggregate: column.aggregate, groupBy: column.groupBy});
						search.sort.push(search.createSort({column: sortCol, ascending: ascending, nullsLast: nullsLast, caseSensitive: caseSensitive, locale: locale}));
					}
				}
			}

			search.condition = data.condition != null ? loadCondition(data.condition, joinsMap, search) : null;

			return search;
		}

		function promiseToLoad(options)
		{
			var id = loadPreProcess(options);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'loadSearch', [id], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							var query = loadPostProcess(result, id);
							resolve(query);
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously loads an existing query as a query.Query object.
		 * @governance 5 units
		 * @param {Object} options The options object.
		 * @param {string} options.id The script ID of the query to load.
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
		 * @throws {SuiteScriptError} A query with the specified ID cannot be loaded because the query does not exist or you do not have permission to load it.
		 * @return {Promise}
		 *
		 * @since 2019.2
		 */
		loadQuery.promise = promiseToLoad;

		function loadCondition(condition, joinsMap, search)
		{

			var components = [];
			if (condition.children)
			{
				for (var i = 0; i < condition.children.length; i++)
				{
					var nestedCondition = loadCondition(condition.children[i], joinsMap, search);
					if (nestedCondition !== null)
						components.push(nestedCondition);
				}
			}
			if (condition.filters)
			{
				for (var i = 0; i < condition.filters.length; i++)
				{
					var vals = condition.filters[i].values;
					if (util.isArray(vals))
					{
						var newVals = [];
						for (var j = 0; j < vals.length; j++)
						{
							if (util.isObject(vals[j]) && vals[j].hasOwnProperty("dateId") && !vals[j].hasOwnProperty("type"))
								newVals.push(new RelativeDate(vals[j].dateId, vals[j].value));
							else if (util.isObject(vals[j]) && vals[j].hasOwnProperty("adjustment"))
								newVals.push(new Period(vals[j].code, vals[j].type, vals[j].adjustment));
							else
								newVals.push(vals[j]);
						}
						vals = newVals;
					}
					else if (util.isObject(vals) && vals.hasOwnProperty("dateId") && !vals[j].hasOwnProperty("type"))
						vals = new RelativeDate(vals.dateId, vals.value);
					if (util.isObject(vals) && vals.hasOwnProperty("adjustment"))
						vals = new Period(vals.code, vals.type, vals.adjustment);

					if (condition.filters[i].formula)
					{
						var filter = search.createCondition({formula: condition.filters[i].formula, values: vals, operator: condition.filters[i].operator, type: condition.filters[i].type, aggregate: condition.filters[i].aggregate, caseSensitive: condition.filters[i].caseSensitive});
						components.push(filter);
					}
					else
					{
						var handle = handleJoins(condition.filters[i].fieldId, joinsMap, search);
						var filter = handle.join.createCondition({fieldId: handle.fieldId, values: vals, operator: condition.filters[i].operator, aggregate: condition.filters[i].aggregate, caseSensitive: condition.filters[i].caseSensitive, context: condition.filters[i].context});
						components.push(filter);
					}
				}
			}
			if (components.length == 0)
				return null;
			else if (components.length == 1)
				return components[0];

			var rc = condition.operator === "AND" ? search.and(components) : search.or(components);
			if (condition.negation)
				rc = search.not(rc);
			return rc;
		}

		function deleteQuery(options)
		{
			var id = deletePreProcess(options);
			invoker(queryApi, 'deleteSearch', [id]);
		}

		function deletePreProcess(options)
		{
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'query.delete');

			if (!util.isString(id))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'String');
			return id;
		}

		function promiseToDelete(options)
		{
			var id = deletePreProcess(options);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'deleteSearch', [id], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(result);
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously deletes query by id
		 * @governance 5 units
		 * @param {Object} options
		 * @param {string} options.id Id of query to be delete
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
		 * @throws {SuiteScriptError} UNABLE_TO_DELETE_QUERY A query with the specified ID cannot be deleted because the query does not exist or you do not have permission to delete it.
		 * @return {Promise}
		 *
		 * @since 2018.2
		 * @deprecated - should be replaced by using NX/dataset and NX/workbook instead
		 */
		deleteQuery.promise = promiseToDelete;

		function runSuiteQL(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQL");
			var input = preProcessFunction(options);
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			return runSuiteQLInternalForScriptId(input.query, input.params, metadataProvider, input.customScriptId);
		}

		/**
		 * Used for internal invocation of 'runSuiteQL' method of QueryApi with followed parametres
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {Array<Column>=} columns Array of objects to be used as query columns
		 * @param {string} metadataProvider type
		 * @returns {ResultSet}
		 */
		function runSuiteQLInternalForColumns(query, params, columns, metadataProvider)
		{
			var data = invoker(queryApi, 'runSuiteQL', [query, JSON.stringify(params ? params : []), metadataProvider]);
			return queryInternal.createResultSet(data, columns, metadataProvider);
		}

		/**
		 * Used for internal invocation of 'runSuiteQL' method of QueryApi with followed parametres
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {string} metadataProvider type
		 * @param {string=} customScriptId Custom script id defined by user
		 * @returns {ResultSet}
		 */
		function runSuiteQLInternalForScriptId(query, params, metadataProvider, customScriptId)
		{
			var data = invoker(queryApi, 'runSuiteQL', [query, JSON.stringify(params ? params : []), metadataProvider, customScriptId]);
			return queryInternal.createResultSet(data, null, metadataProvider);
		}

		function runSuiteQLPaged(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQLPaged");
			var input = preProcessFunction(options);
			var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			return runSuiteQLPagedInternalForScriptId(pageSize, input.query, input.params, metadataProvider, input.customScriptId);
		}

		/**
		 * Used for internal invocation of 'suiteQLPagedQuery' method of QueryApi with followed parametres
		 * @param {number} pageSize Size of returned page
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {Array<Column>=} columns Array of objects to be used as query columns
		 * @param {string} metadataProvider type
		 * @returns {PagedData}
		 */
		function runSuiteQLPagedInternalForColumns(pageSize, query, params, columns, metadataProvider)
		{
			var size = pagingUtil.regulatePageSize(pageSize);
			var queryData = invoker(queryApi, 'suiteQLPagedQuery', [size, query, JSON.stringify(params ? params : []), metadataProvider]);
			return queryInternal.createPagedData({
				pageSize: size,
				queryDefinition: {query: query, params: params},
				queryData: queryData,
				type: "query",
				columns: columns,
				metadataProvider: metadataProvider
			});
		}

		/**
		 * Used for internal invocation of 'suiteQLPagedQuery' method of QueryApi with followed parametres
		 * @param {number} pageSize Size of returned page
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {string} metadataProvider type
		 * @param {string=} customScriptId Custom script id defined by user
		 * @returns {PagedData}
		 */
		function runSuiteQLPagedInternalForScriptId(pageSize, query, params, metadataProvider, customScriptId)
		{
			var size = pagingUtil.regulatePageSize(pageSize);
			var queryData = invoker(queryApi, 'suiteQLPagedQuery', [size, query, JSON.stringify(params ? params : []), metadataProvider, customScriptId]);
			return queryInternal.createPagedData({
				pageSize: size,
				queryDefinition: {query: query, params: params},
				queryData: queryData,
				type: "query",
				customScriptId: customScriptId,
				metadataProvider: metadataProvider
			});
		}

		function runSuiteQLPreProcess(options)
		{
			utilityFunctions.checkArgs([options], ['options'], this);
			var query = (options && options.hasOwnProperty('query')) ? options.query : options;
			var params = (options && options.hasOwnProperty('params')) ? options.params : [];
			var customScriptId = (options && options.hasOwnProperty('customScriptId')) ? options.customScriptId : '';
			utilityFunctions.checkArgs([query], ['query'], this);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(query, 'options.query', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(params, 'options.params', util.isArray)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(customScriptId, 'options.customScriptId', util.isString)]);
			for (var i = 0; i < params.length; i++)
			{
				if (!util.isNumber(params[i]) && !util.isString(params[i]) && !util.isBoolean(params[i]))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.params[' + i + ']');
			}
			return {
				query: query,
				params: params,
				customScriptId: customScriptId
			}
		}

		function promiseToRunSuiteQL(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQL");
			var input = preProcessFunction(options);
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			return promiseToRunSuiteQLInternal(input.query, input.params, metadataProvider, input.customScriptId)
		}

		/**
		 * Returns promise object for asynchronous invocation of 'runSuiteQL' method of QueryApi with followed parametres
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {string} metadataProvider type
		 * @param {string=} customScriptId Custom script id defined by user
		 * @returns {Promise}
		 */
		function promiseToRunSuiteQLInternal(query, params, metadataProvider, customScriptId)
		{
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'runSuiteQL', [query, JSON.stringify(params ? params : []), metadataProvider, customScriptId], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(queryInternal.createResultSet(result, null, metadataProvider));
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		function promiseToRunSuiteQLPaged(options)
		{
			var preProcessFunction = runSuiteQLPreProcess.bind("query.runSuiteQLPaged");
			var input = preProcessFunction(options);
			var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			return promiseToRunSuiteQLPagedInternal(pageSize, input.query, input.params, metadataProvider, input.customScriptId);
		}

		/**
		 * Returns promise object for asynchronous invocation of 'suiteQLPagedQuery' method of QueryApi with followed parametres
		 * @param {number} pageSize Size of returned page
		 * @param {string} query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>} params Bind values for SuiteQL query
		 * @param {string} metadataProvider type
		 * @param {string=} customScriptId Custom script id defined by user
		 * @returns {Promise}
		 */
		function promiseToRunSuiteQLPagedInternal(pageSize, query, params, metadataProvider, customScriptId)
		{
			var size = pagingUtil.regulatePageSize(pageSize);
			return new Promise(
				function(resolve, reject) {
					try {
						invoker(queryApi, 'suiteQLPagedQuery', [size, query, JSON.stringify(params ? params : []), metadataProvider, customScriptId], callback);
					}
					catch (e) {
						reject(e);
					}

					function callback(result, exception) {
						if (exception) {
							reject(exception);
							return;
						}
						try {
							resolve(queryInternal.createPagedData({
								pageSize: size,
								queryDefinition: {query: query, params: params},
								queryData: result,
								customScriptId: customScriptId,
								type: "query",
								metadataProvider: metadataProvider
							}));
						}
						catch (e) {
							reject(e);
						}
					}
				}
			);
		}

		/**
		 * Asynchronously runs suiteQL query, parameter can be string, suiteQL object or object containing properties query and (optionally) params
		 * @governance 10 units
		 * @param {Object} options
		 * @param {String} options.query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>=} options.params
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
		 * @return {Promise}
		 *
		 * @since 2019.2
		 */
		runSuiteQL.promise = promiseToRunSuiteQL;
		/**
		 * Asynchronously execute the suiteQL query and return paged results.
		 * @governance 10 units
		 * @param {Object} options
		 * @param {String} options.query String representation of SuiteQL query
		 * @param {Array<string|number|boolean>=} options.params
		 * @return {Promise}
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
		 *
		 * @since 2020.1
		 */
		runSuiteQLPaged.promise = promiseToRunSuiteQLPaged;

		function createRelativeDate(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'query.createRelativeDate');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			var dateId = options.dateId;
			var value = options.value;
			utilityFunctions.checkArgs([dateId], ['dateId'], 'query.createRelativeDate');
			utilityFunctions.checkArgs([value], ['value'], 'query.createRelativeDate');
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(relativeDateCodes, dateId, false), error.Type.INVALID_DATE_ID, dateId);
			if (!util.isNumber(value))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'value', 'number');
			return new RelativeDate(dateId, value);
		}

		function createPeriod(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'query.createPeriod');
			var code, type, adjustment;
			if (util.isString(options))
			{
				code = options;
				type = PERIOD_TYPE.START;
				adjustment = PERIOD_ADJUSTMENT.NOT_LAST;
			}
			else
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.code], ['options.code'], 'query.createPeriod');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.code, 'options.code', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.adjustment, 'options.adjustment', util.isString)]);
				code = options.code;
				type = options.type || PERIOD_TYPE.START;
				adjustment = options.adjustment || PERIOD_ADJUSTMENT.NOT_LAST;
			}

			if (type != PERIOD_TYPE.START && type != PERIOD_TYPE.END)
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PERIOD_TYPE, type);
			if (adjustment != PERIOD_ADJUSTMENT.NOT_LAST && adjustment != PERIOD_ADJUSTMENT.ALL)
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PERIOD_ADJUSTMENT, adjustment);
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(periodCodes, code, false), error.Type.INVALID_PERIOD_CODE, code);
			return new Period(code, type, adjustment);
		}

		function _checkOperatorArity(operator, values)
		{
			var numValues = util.isArray(values) ? values.length : values === null ? 0 : 1;
			var arity = ALLOWED_ARITY[operator];
			if (numValues + 1 > arity[1] || numValues + 1 < arity[0])
			{
				if (!(numValues == 1 && (operator == "WITHIN" || operator == "WITHIN_NOT") && ((values instanceof RelativeDate || values[0] instanceof RelativeDate) || (values instanceof Period || values[0] instanceof Period))))
					utilityFunctions.throwSuiteScriptError(error.Type.OPERATOR_ARITY_MISMATCH, operator);
			}
		}

		function _isRelativeDate(options)
		{
			return options instanceof RelativeDate;
		}

		function validateContext(context, funcName)
		{
			if (!util.isObject(context))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'context', 'Object');
			utilityFunctions.checkArgs([context], ['context'], funcName);
			utilityFunctions.checkArgs([context.name], ['context.name'], funcName);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(context.name, 'context.name', util.isString)]);
			if (!FIELD_CONTEXT[context.name])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_CONTEXT, context.name);
			if (context.name == FIELD_CONTEXT.CONVERTED) {
				utilityFunctions.checkArgs([context.params], ['context.params'], funcName);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(context.params, 'context.params', util.isObject)]);
				utilityFunctions.checkArgs([context.params.currencyId], ['context.params.currencyId'], funcName);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(context.params.currencyId, 'context.params.currencyId', util.isNumber)]);
				utilityFunctions.checkArgs([context.params.date], ['context.params.date'], funcName);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(context.params.date, 'context.value.date', function (options) {
					return util.isDate(options) || util.isString(options) || (options instanceof RelativeDate && options.isRange) ||
						(util.isObject(options) && options.dateId);
				})]);
			}
		}

		return Object.freeze({
			/**
			 * Creates a query.Query object.
			 * @governance none
			 * @param {Object} options The options object.
			 * @param {string} options.type The query type that you want to use for the initial query definition.
			 * @param {Array<Object>} [options.columns] Array of objects to be used as query columns (createColumn method will be called on all of them).
			 * @param {Array<Object>} [options.sort] Array of objects representing sort options (createColumn and createSort methods will be called on all of them).
			 * @param {Object} [options.condition] Condition of query (createCondition method will be called on supplied object).
			 * @return {Query}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or type are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} INVALID_RCRD_TYPE The specified query type is invalid.
			 *
			 * @since 2018.1
			 */
			create: createQuery,
			/**
			 * Runs suiteQL query, parameter can be string, suiteQL object or object containing properties query and (optionally) params
			 * @governance 10 units
			 * @param {Object} options
			 * @param {String} options.query String representation of SuiteQL query
			 * @param {Array<string|number|boolean>=} options.params
			 * @return {ResultSet}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
			 *
			 * @since 2018.2
			 */
			runSuiteQL: runSuiteQL,

			/**
			 * Execute the suiteQL query and return paged results.
			 * @governance 10 units
			 * @param {Object} options
			 * @param {String} options.query String representation of SuiteQL query
			 * @param {Array<string|number|boolean>=} options.params
			 * @return {PagedData}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options or query are undefined
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if there's parameter of different type than string/number/boolean in params array
			 *
			 * @since 2020.1
			 */
			runSuiteQLPaged: runSuiteQLPaged,

			/**
			 * Loads an existing query as a query.Query object.
			 * @governance 5 units
			 * @param {Object} options The options object.
			 * @param {string} options.id The script ID of the query to load.
			 * @return {Query}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} A query with the specified ID cannot be loaded because the query does not exist or you do not have permission to load it.
			 *
			 * @since 2018.1
			 */
			load: loadQuery,
			/**
			 * Lists table views for specified workbook
			 * @governance 5 units
			 * @param {string} workbookId Script id of a workbook
			 * @return {Array<TableViewHeader>} Array of table views present in workbook with given script id
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If workbookId parameter is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If workbookId parameter isn't string
			 *
			 * @since 2020.1
			 */
			listTables: listTables,

			/**
			 * Deletes query by id
			 * @governance 5 units
			 * @param {Object} options
			 * @param {string} options.id Id of query to be delete
			 * @return {void}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 * @throws {SuiteScriptError} UNABLE_TO_DELETE_QUERY A query with the specified ID cannot be deleted because the query does not exist or you do not have permission to delete it.
			 *
			 * @since 2018.2
			 */
			'delete': deleteQuery,

			/**
			 * Creates a query.RelativeDate object that represents a date relative to the current date.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.dateId The ID of the relative date to create.
			 * @param {number} options.value The value to use to create the relative date.
			 * @return {RelativeDate}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or id are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options isn't object or id isn't string.
			 *
			 * @since 2019.2
			 */
			createRelativeDate: createRelativeDate,

			/**
			 * Creates a query.Period object, which can be used as a filter value
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.code code of the period
			 * @param {string} [options.type] type of the period
			 * @param {string} [options.adjustment] adjustment of the period
			 * @return {Period}
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or code are undefined.
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If any of the parameters is not string
			 * @throws {SuiteScriptError} INVALID_PERIOD_TYPE If type is a value outside of PeriodType enum
			 * @throws {SuiteScriptError} INVALID_PERIOD_ADJUSTMENT If adjustment is a value outside of PeriodAdjustment enum
			 * @throws {SuiteScriptError} INVALID_PERIOD_CODE If code is a value outside of PediodCode enum
			 *
			 * @since 2020.1
			 */
			createPeriod: createPeriod,
			_checkOperatorArity: _checkOperatorArity,
			_isRelativeDate: _isRelativeDate,

			/**
			 * Holds the string values for operators supported with the N/query Module. This enum is used to pass the operator argument to Query.createCondition(options) and Component.createCondition(options).
			 * @enum {string}
			 * @readonly
			 */
			get Operator()
			{
				return queryInternal.Operator;
			},

			/**
			 * Holds the string values for aggregate functions supported with the N/query Module. An aggregate function performs a calculation on the column or condition values and returns a single value.
			 * @enum {string}
			 * @readonly
			 */
			Aggregate: AGGREGATE,

			/**
			 * Holds the string values for the formula return types supported with the N/query Module.
			 * @enum {string}
			 * @readonly
			 */
			ReturnType: RETURN_TYPE,

			/**
			 * Holds query.RelativeDate object values for supported date ranges in relative dates.
			 * @enum {string}
			 * @readonly
			 */
			RelativeDateRange: Object.freeze(RELATIVE_DATE_RANGES),

			/**
			 * Holds the string values for supported date codes in relative dates.
			 * @enum {string}
			 * @readonly
			 */
			DateId: DATE_ID,

			/**
			 * Holds the string values for the field context to use when creating a column using Query.createColumn(options) or Component.createColumn(options).
			 * @enum {string}
			 * @readonly
			 */
			FieldContext: FIELD_CONTEXT,
			/**
			 * Holds the string values for possible period types (START, END)
			 * @enum {string}
			 * @readonly
			 */
			PeriodType: PERIOD_TYPE,
			/**
			 * Holds the string values for possible period adjustments (NOT_LAST, ALL)
			 * @enum {string}
			 * @readonly
			 */
			PeriodAdjustment: PERIOD_ADJUSTMENT,
			/**
			 * Holds the string values for possible period codes
			 * @enum {string}
			 * @readonly
			 */
			PeriodCode: PERIOD_CODE,

			/**
			 * Holds the string values for sort locales supported with the N/query Module. This enum is used to pass the locale argument to Query.createSort(options) and Component.createSort(options).
			 * @enum {string}
			 * @readonly
			 */
			get SortLocale()
			{
				return queryInternal.getSortLocales();
			},

			/**
			 * Holds the string values for query types used in the query definition. This enum is used to pass the initial query type argument to query.create(options).
			 * @enum {string}
			 * @readonly
			 */
			get Type()
			{
				return queryInternal.getSearchTypes();
			},

			/**
			 * Holds the string values for possible metadata provider types
			 * @enum {string}
			 * @readonly
			 */
			MetadataProvider: queryInternal.getMetadataProviderTypes()
		});
	});

/**
 * @private
 */
define('N/restricted/translationBridge',['N/internal/reflet'],
	function (reflet)
	{
		return util.extend({bridge: 'translationBridge'}, reflet);
	});
/**
 * Translation module
 *
 * @module N/translation
 * @NApiVersion 2.x
 */
define('N/translation',[
		'N/error',
		'N/log',
		'N/nsobject',
		'N/internal/invoker',
		'N/restricted/translationBridge',
		'N/utilityFunctions'
	],
	function(
		error,
		log,
		nsobject,
		invoker,
		apiBridge,
		utilityFunctions
	)
	{
		var localesCached;

		function createTranslator(translatorOptions)
		{
			/**
			 * This is the translator function which returns strings with parameters injected into them if necessary
			 *
			 * @param {Array} [options.params] - an optional list of parameters
			 *
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if parameters were not passed as an array
			 *
			 * @return {string} - returns the string enhanced with parameters
			 */
			return function (options) {
				var retString = translatorOptions.result;
				if (options !== undefined && options !== null)
				{
					var params = options && options.params;
					if (!Array.isArray(params))
					{
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'params', 'array');
					}
					for (var i = 0; i < params.length; i++)
					{
						var paramRegExp = new RegExp('{' + (i + 1) + '[^}]*}');
						retString = retString.replace(paramRegExp, params[i]);
					}
				}
				return retString;
			};
		}

		function createHandle(options) {
			if (options.result.warning !== undefined)
			{
				log.error(options.result.warning.title, options.result.warning.details);
			}
			return new Handle(options.result.data, options.data.locales, options.data.defaultLocale);
		}

		/**
		 * Creates a translator function for the chosen key in the desired locale
		 *
		 * @param {string} options.collection - the scriptid of the collection the key is in
		 * @param {string} options.key - a valid key from the collection
		 * @param {Locale} [options.locale] - a valid locale from Locale enum or the session locale if not specified
		 *
		 * @return {Function} - returns a translator function
		 *
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if collection or key is missing
		 * @throws {SuiteScriptError} INVALID_TRANSLATION_KEY if key is of an invalid format
		 * @throws {SuiteScriptError} INVALID_TRANSLATION_COLLECTION if collection is of an invalid format
		 * @throws {SuiteScriptError} INVALID_LOCALE if locale is of an invalid format
		 * @throws {SuiteScriptError} TRANSLATION_KEY_NOT_FOUND if translation key was not found
		 *
		 * @since 2019.1
		 */
		function get(options)
		{
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			var key = options.key;
			var collection = options.collection;
			var locale = options.locale;
			utilityFunctions.checkArgs([key, collection], ['collection', 'key'], 'translations.get');
			if (locale === undefined)
			{
				locale = getLocales().CURRENT;
			}
			var useString = invoker(apiBridge, 'getSingleTranslation', [collection, key, locale], utilityFunctions.isPromiseCallback(this) ? this : undefined);
			if (!utilityFunctions.isPromiseCallback(this))
				return createTranslator({result: useString});
		}

		get.promise = function()
		{
			return utilityFunctions.promiseTo(get, arguments, createTranslator);
		};

		/**
		 * Pre-loads a translations.Handle with translations for the specified collections and locales.
		 * If no locale was specified the session locale (Locale.CURRENT) will be used as the handler's locale.
		 * If locales were specified the first locale in the array will be used as the handler's locale.
		 *
		 * @param {Array} options.collections - a list of objects defining the collections to be loaded
		 * @param {String} options.collections.alias - an alias used later in the script to refer to the collection to be loaded
		 * @param {String} options.collections.collection - the scriptid of the collection to be loaded
		 * @param {Array} [options.collections.keys] - a list of translation keys from the collection to be loaded
		 * @param {Array} [options.locales] - a list of valid locales
		 *
		 * @return {Handle} - returns a translations.Handle
		 *
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if collections, collections or locales are not of Array type
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if collections doesn't have at least one collection defined
		 * @throws {SuiteScriptError} INVALID_TRANSLATION_KEY if a key has an invalid format
		 * @throws {SuiteScriptError} INVALID_TRANSLATION_COLLECTION if a collection has an invalid format
		 * @throws {SuiteScriptError} INVALID_ALIAS if an alias has an invalid format
		 * @throws {SuiteScriptError} INVALID_LOCALE if a locale is of an invalid format
		 *
		 * @since 2019.1
		 */
		function load(options)
		{
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			var collections = options.collections;
			var locales = options.locales;
			utilityFunctions.checkArgs([collections], ['collections'], 'translations.load');
			if (!Array.isArray(collections))
			{
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'collections', 'array');
			}
			else
			{
				for (var i = 0; i < collections.length; i++)
				{
					utilityFunctions.checkArgs([collections[i].collection], ['collections.collection'], 'translations.load');
					utilityFunctions.checkArgs([collections[i].keys], ['collections.keys'], 'translations.load');
					if (!utilityFunctions.isEmpty(collections[i].keys) && !Array.isArray(collections[i].keys))
					{
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'collections.keys', 'array');
					}
				}
			}
			if (utilityFunctions.isEmpty(locales))
			{
				locales = [getLocales().CURRENT];
			}
			else if (!Array.isArray(locales))
			{
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'locales', 'array');
			}
			var localeConfig = {locales: locales, defaultLocale: locales[0]};
			var loadedTranslations = invoker(apiBridge, 'bulkLoadTranslations', [JSON.stringify(collections), JSON.stringify(locales)], utilityFunctions.isPromiseCallback(this) ? this.bind(localeConfig) : undefined);
			if (!utilityFunctions.isPromiseCallback(this))
			{
				return createHandle({result: loadedTranslations, data: localeConfig});
			}
		}

		load.promise = function()
		{
			return utilityFunctions.promiseTo(load, arguments, createHandle);
		};

		/**
		 * Creates a translations.Handle from an existing Handle for a specific locale
		 *
		 * @param {Handle} options.handle - a translations.Handle object
		 * @param {Locale} options.locale - a valid locale supported by the handle
		 *
		 * @return {Handle} - returns a translations.Handle in the specified locale
		 *
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if handle or locale is missing
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if handle is not a translations.Handle object
		 * @throws {SuiteScriptError} INVALID_LOCALE if an unknown or unsupported locale is used in the scope of the handle
		 * @throws {SuiteScriptError} TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE if the handle passed is in an illegal state
		 *
		 * @since 2019.1
		 */
		function selectLocale(options)
		{
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			var handle = options.handle;
			var locale = options.locale;
			utilityFunctions.checkArgs([handle, locale], ['handle', 'locale'], 'translations.localize');
			utilityFunctions.checkArgObject(handle, 'handle', isHandle);

			return new Handle(handle.toJSON().allRawTranslations, handle.toJSON().locales, locale);
		}

		function getLocales() {
			if (!localesCached)
			{
				localesCached = invoker(apiBridge, 'getLocales');
			}
			return localesCached;
		}

		function isHandle(object)
		{
			if (object && typeof object === "object" && util.isFunction(object.toString))
			{
				return (object.toString() === "translations.Handle");
			}
			return false;
		}

		/**
		 * Translations.Handle has a hierarchical structure.
		 *
		 * Each of its nodes is either another Handle or a translator function
		 */
		function Handle(allTranslations, locales, recentLocale)
		{
			var TYPE = 'translation.Handle';

			var _allTranslations = allTranslations;
			var _locales = locales;
			var _recentLocale = recentLocale;

			if (_locales.indexOf(recentLocale) < 0)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_LOCALE, recentLocale);
			}

			if (_allTranslations.type !== 'branch')
			{
				utilityFunctions.throwSuiteScriptError(error.Type.TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE);
			}

			var _allTranslationObjects = {};
			for (nodeKey in _allTranslations.values)
			{
				var node = _allTranslations.values[nodeKey];
				if (node.type === 'branch')
				{
					_allTranslationObjects[nodeKey] = new Handle(node, locales, recentLocale);
				}
				else if (node.type === 'leaf')
				{
					_allTranslationObjects[nodeKey] = createTranslator({result: node.values[recentLocale]});
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.TRANSLATION_HANDLE_IS_IN_AN_ILLEGAL_STATE);
				}
			}

			for (nodeKey in _allTranslationObjects)
			{
				Object.defineProperty(this, nodeKey, {
					value: _allTranslationObjects[nodeKey],
					enumerable: true
				});
			}

			/**
			 * JSON.stringify() implementation.
			 *
			 * @returns {{type: string, allRawTranslations: Object, allTranslations: Object, locales: Array, recentLocale: Locale}}
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					allRawTranslations: _allTranslations,
					allTranslations: _allTranslationObjects,
					locales: _locales,
					recentLocale: _recentLocale
				};
			};

			/**
			 * Returns the object type name (translations.Handle)
			 *
			 * @returns {string}
			 */
			this.toString = function toString()
			{
				return TYPE;
			}
		}

		Handle.prototype = nsobject.getNewInstance();

		return Object.freeze({
			get: get,
			load: load,
			selectLocale: selectLocale,
			get Locale()
			{
				return getLocales();
			}
		});
	}
);
/**
 * @private
 */
define('N/restricted/recordContextSignificantFieldsApiBridge',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'recordContextSignificantFieldsApiBridge'}, reflet); });
/**
 * SuiteScript module
 *
 * @private
 * @module N/recordContextSignificantFields
 * @NApiVersion 2.x
 */
define('N/recordContextSignificantFields',['N/utilityFunctions', 'N/error', 'N/dynamicData', 'N/internal/invoker', 'N/restricted/recordContextSignificantFieldsApiBridge'], function(utilityFunctions, error, dynamicData, invoker, bridge){

	function getFields(options)
	{
		var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
		utilityFunctions.checkArgs([recordType], ['recordType'], 'getFields');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordType, 'recordType', util.isString)]);
		var significantFieldsMap = dynamicData.get('recordContextSignificantFields');
		var significantFields = significantFieldsMap ? significantFieldsMap[recordType.toLowerCase()] : invoker(bridge, "getFields", [recordType.toLowerCase()]);
		if (significantFields == null)
		{
			utilityFunctions.throwSuiteScriptError(error.Type.INVALID_OR_UNSUPPORTED_RECORD_TYPE_1, recordType);
		}
		return significantFields;
	}

	return Object.freeze({
		getFields: getFields
	});
});
/**
 * @private
 */
define('N/restricted/recordContextApiBridge',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'recordContextApiBridge'}, reflet); });
/**
 * @private
 */
define('N/restricted/localizationApiBridge',['N/internal/reflet'], function(reflet){ return util.extend({bridge :'localizationApiBridge'}, reflet); });
/**
 * SuiteScript localization module
 *
 * @module N/localization
 * @suiteScriptVersion 2.x
 *
 */

define('N/localization',['N/restricted/localizationApiBridge', 'N/internal/invoker', 'N/utilityFunctions'],
	function (localizationApi, invoker, utilityFunctions)
	{

		function guessContext(options)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			var isPromiseCallback = utilityFunctions.isPromiseCallback(this);
			var moduleName = (isPromiseCallback) ? 'guessContext.promise' : 'guessContext';
			utilityFunctions.checkArgs(recordType, 'recordType', moduleName);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordType, 'recordType', util.isString)]);
			return invoker(localizationApi, "guessContext", [recordType], isPromiseCallback ? this : undefined);
		}

		guessContext.promise = function()
		{
			return utilityFunctions.promiseTo(
				guessContext, arguments, function(options){
					return options.result;
				});
		};

		function getContext(options, fields)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			var significantFields = (options && options.hasOwnProperty('fields')) ? options.fields : fields;
			var isPromiseCallback = utilityFunctions.isPromiseCallback(this);
			var moduleName = (isPromiseCallback) ? 'getContext.promise' : 'getContext';
			utilityFunctions.checkArgs([recordType, significantFields], ['recordType', 'significantFields'], moduleName);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordType, 'recordType', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(significantFields, 'significantFields', util.isObject)]);
			return invoker(localizationApi, "getContext", [recordType, JSON.stringify(significantFields)], isPromiseCallback ? this : undefined);
		}

		getContext.promise = function()
		{
			return utilityFunctions.promiseTo(
				getContext, arguments, function(options){
					return options.result;
				});
		};

		function getContextRecId(options, recordId)
		{
			var recordType = (options && options.hasOwnProperty('recordType')) ? options.recordType : options;
			var recordId = (options && options.hasOwnProperty('recordId')) ? options.recordId : recordId;
			var isPromiseCallback = utilityFunctions.isPromiseCallback(this);
			var moduleName = (isPromiseCallback) ? 'getContextRecId.promise' : 'getContextRecId';
			utilityFunctions.checkArgs([recordType, recordId], ['recordType', 'recordId'], moduleName);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordType, 'recordType', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordId, 'recordId',
				function (value) { return util.isString(value) || util.isNumber(value) })]);
			return invoker(localizationApi, "getContextRecId", [recordType, recordId], isPromiseCallback ? this : undefined);
		}

		getContextRecId.promise = function()
		{
			return utilityFunctions.promiseTo(
				getContextRecId, arguments, function(options){
					return options.result;
				});
		};

		return Object.freeze({
			guessContext: guessContext,
			getContext: getContext,
			getContextRecId: getContextRecId
		});
	});
/**
 * SuiteScript record context module
 *
 * @module N/recordContext
 * @suiteScriptVersion 2.x
 *
 */
define('N/recordContext',['N/recordContextSignificantFields', 'N/restricted/recordContextApiBridge', 'N/internal/invoker', 'N/utilityFunctions', 'N/localization', 'N/error'],
	function (recordCtxSignificantFields, recordContextApi, invoker, utilityFunctions, localization, error)
	{
		// Constant with cvalue of separator of sublist and field in definition of significant fields
		// Should be synchronized with java constant with same name from com.netledger.platform.i18n.context.definition.country.CountryCtxSignificantField
		var SUBLIST_FIELD_SEPARATOR = ".";

		//enums
		var CONTEXT_TYPE = Object.freeze({
			LOCALIZATION: 'LOCALIZATION'
		});

		/**
		 * Returns Record Context object for given record instance. Instance can be defined by
		 * type and id for not loaded records or by record object for already loaded records.
		 *
		 * @param {Object} options
		 * @param {String=} options.recordType Type of not loaded record
		 * @param {Number|String=} options.recordId Id of not loaded record
		 * @param {Record=} options.record Already loaded record object
		 * @param {Array<String>=} options.contextTypes Required context types (optional, defaults to array of all available contexts)
		 * @returns {Object} Name-value pairs containing contexts of the record. More values can be return in array e.g. {"localization":["US", "CA"]} for localization context type.
		 *
		 * @throws {SuiteScriptError} MUTUALY_EXCLUSIVE_ARGUMENT if record is present alongside recordId or recordType
		 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if recordId parameter is missing and recordType is present or vice versa
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG in case of wrong parameter type
		 * @throws {SuiteScriptError} UNKNOWN_CONTEXT_TYPE in case of unknown context type selection
		 * @throws {SuiteScriptError} INVALID_UNSUPRTD_RCRD_TYP in case of invalid or unsupported record type
		 *
		 * @since 2020.2
		 **/
		function getContext(options) {
			utilityFunctions.checkArgs([options], ['options'], 'getContext');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);

			var recordType = options.recordType;
			var recordId = options.recordId;
			var record = options.record;
			var contextTypes = options.contextTypes;

			// Check if exactly one agrgumet is defined of recordType and record
			utilityFunctions.checkMutuallyExclusiveArguments(recordType, record, 'recordType', 'record');
			// Check if exactly one agrgumet is defined of recordId and record
			utilityFunctions.checkMutuallyExclusiveArguments(recordId, record, 'recordId', 'record');

			// Check arguments types
			var isRecordLoaded;
			if (record === undefined || record === null)
			{
				isRecordLoaded = false;
				utilityFunctions.checkArgs([recordType, recordId], ['recordType', 'recordId'], 'getContext');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordType, 'recordType', util.isString)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(recordId, 'recordId',
					function (value) { return util.isString(value) || util.isNumber(value) })]);
				// Convert string to number
				if (util.isString(recordId))
				{
					recordId = parseInt(recordId);
				}
			}
			else
			{
				isRecordLoaded = true;
			}

			// Check contextTypes
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(contextTypes, 'contextTypes',
				function (value) { return util.isString(value) || util.isArray(value) })]);
			var requiredContextTypes;
			var availableContextTypes = Object.keys(CONTEXT_TYPE);
			if (contextTypes === undefined || contextTypes === null || contextTypes === [])
			{
				// Setup all available context types as a default
				requiredContextTypes = availableContextTypes;
			}
			else
			{
				// Parse contextTypes and check if these context types are defined
				requiredContextTypes = utilityFunctions.normalizeArrayOrSingularObjectArg(contextTypes);
				for (var i = 0; i < requiredContextTypes.length; i++)
				{
					if (!utilityFunctions.arrayContains(availableContextTypes, requiredContextTypes[i]))
					{
						utilityFunctions.throwSuiteScriptError(error.Type.UNKNOWN_CONTEXT_TYPE, 'getContext',
							'unknownContextType: ' + requiredContextTypes[i]);
					}
				}
			}
			if (isRecordLoaded)
			{
				recordType = record.type;
				var significantFields = {};
				var significantFieldNames = recordCtxSignificantFields.getFields({recordType: recordType});
				if (significantFieldNames !== undefined && significantFieldNames !== null && significantFieldNames.length > 0)
				{
					for (var i = 0; i < significantFieldNames.length; i++)
					{
						var fieldName = significantFieldNames[i];
						if (fieldName.indexOf(SUBLIST_FIELD_SEPARATOR) !== -1)
						{
							var sublistField = fieldName.split(SUBLIST_FIELD_SEPARATOR);
							var sublist = sublistField[0];
							var field = sublistField[1];
							var values = [];
							var lineCount = record.getLineCount({sublistId: sublist});
							for (var line = 0; line < lineCount; line++)
							{
								values[line] = record.getSublistValue({
									sublistId: sublist,
									fieldId: field,
									line: line
								});
							}
							var resultStringValue = "";
							if (values.length > 1)
							{
								resultStringValue += "[";
								for (var j = 0; j < values.length; j++)
								{
									if (j > 0)
									{
										resultStringValue += ",";
									}
									resultStringValue += "\"" + values[j] + "\"";
								}
								resultStringValue += "]";
							}
							else if (values.length == 1)
							{
								resultStringValue = values[0];
							}
							significantFields[fieldName] = resultStringValue;
						}
						else
						{
							significantFields[fieldName] = record.getValue(fieldName);
						}
					}
				}
				return invoker(recordContextApi, "getContextsByFields", [recordType, JSON.stringify(significantFields), JSON.stringify(requiredContextTypes)],
					utilityFunctions.isPromiseCallback(this) ? this : undefined);
			}
			else
			{
				return invoker(recordContextApi, "getContextsById", [recordType, recordId, JSON.stringify(requiredContextTypes)],
					utilityFunctions.isPromiseCallback(this) ? this : undefined);
			}
		}

		getContext.promise = function()
		{
			return utilityFunctions.promiseTo(
				getContext, arguments, function(options) {
					return options.result;
				});
		};

		return Object.freeze({
			ContextType: CONTEXT_TYPE,
			getContext: getContext
		});
	});
/**
 * SuiteScript expression module
 * Expression for N/dataset and N/workbook modules
 *
 * @module N/expression
 * @suiteScriptVersion 2.x
 */
define('N/expression',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/dynamicEnums'],
	function(nsobject, error, utilityFunctions, dynamicEnums)
	{
		var EXPRESSIONS = Object.freeze({
			AND: "AND",
			ANY_OF: "ANY_OF",
			BETWEEN: "BETWEEN",
			CHILD_OF: "CHILD_OF",
			COMPARE: "COMPARE",
			CONSTANT: "CONSTANT",
			CURRENCY_CONVERSION: "CURRENCY_CONVERSION",
			DATASET_COLUMN: "DATASET_COLUMN",
			DATE_RANGE_SELECTOR_ID: "DATE_RANGE_SELECTOR_ID",
			DATE_SELECTOR_ID: "DATE_SELECTOR_ID",
			DATE_TIME_PROPERTY: "DATE_TIME_PROPERTY",
			DIVIDE: "DIVIDE",
			EQUALS: "EQUALS",
			FIELD: "FIELD",
			HIERARCHY: "HIERARCHY",
			HIERARCHY_TO_TEXT: "HIERARCHY_TO_TEXT",
			IF: "IF",
			IN_RANGE: "IN_RANGE",
			IS_NULL: "IS_NULL",
			LAMBDA: "LAMBDA",
			MEASURE_VALUE: "MEASURE_VALUE",
			MINUS: "MINUS",
			MULTIPLY: "MULTIPLY",
			NOT: "NOT",
			OR: "OR",
			PLUS: "PLUS",
			RECORD_DISPLAY_VALUE: "RECORD_DISPLAY_VALUE",
			RECORD_KEY: "RECORD_KEY",
			SIMPLE_CONSOLIDATE: "SIMPLE_CONSOLIDATE",
			TRANSLATE: "TRANSLATE",
			TRUNCATE_DATE_TIME: "TRUNCATE_DATE_TIME"
		});

		var COMPARISON_TYPE = Object.freeze({
			EQUAL: "EQUAL",
			GREATER: "GREATER",
			GREATER_OR_EQUAL: "GREATER_OR_EQUAL",
			LESS: "LESS",
			LESS_OR_EQUAL: "LESS_OR_EQUAL"
		});

		var TEMPORAL_UNIT = Object.freeze({
			NANOS: "NANOS",
			MICROS: "MICROS",
			MILLIS: "MILLIS",
			SECONDS: "SECONDS",
			MINUTES: "MINUTES",
			HOURS: "HOURS",
			HALF_DAYS: "HALF_DAYS",
			DAYS: "DAYS",
			WEEKS: "WEEKS",
			MONTHS: "MONTHS",
			YEARS: "YEARS",
			DECADES: "DECADES",
			CENTURIES: "CENTURIES",
			MILLENIA: " MILLENIA",
			ERA: "ERA"
		});

		var CONSTANT_TYPE = Object.freeze({
			BOOLEAN: 'BOOLEAN',
			NUMBER: 'NUMBER',
			CURRENCY: 'CURRENCY',
			DATE: 'DATE',
			DATE_TIME: 'DATE_TIME',
			DECIMAL: 'DECIMAL',
			DURATION: 'DURATION',
			INTEGER: 'INTEGER',
			RANGE: 'RANGE',
			TEXT: 'TEXT',
			RECORD_KEY: 'RECORD_KEY'
		});

		var DATE_TIME_HIERARCHY = Object.freeze({
			MONTH_BASED: "MONTH_BASED",
			WEEK_BASED: "WEEK_BASED"
		});

		var DATE_TIME_PROPERTY = Object.freeze({
			YEAR: "YEAR",
			QUARTER: "QUARTER",
			MONTH: "MONTH",
			WEEK_OF_YEAR: "WEEK_OF_YEAR",
			DAY_OF_MONTH: "DAY_OF_MONTH",
			DAY_OF_WEEK: "DAY_OF_MONTH",
			DATE: "DATE"
		});

		var validConstantTypes = [];
		Object.getOwnPropertyNames(CONSTANT_TYPE).forEach(function(constant){
			validConstantTypes.push(CONSTANT_TYPE[constant]);
		});

		var validExpressions = [];
		Object.getOwnPropertyNames(EXPRESSIONS).forEach(function(expr){
			validExpressions.push(EXPRESSIONS[expr]);
		});

		/**
		 * @class Expression
		 * @classDescription Expression object to be used in dimension items or measures
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Expression(options)
		{
			var functionId = options.functionId;
			var parameters = options.parameters;

			/**
			 * Id of a function to be used in this expression
			 * @name Expression#functionId
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'functionId', {
				get: function ()
				{
					return functionId;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'functionId', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validExpressions, options.val, false), error.Type.INVALID_EXPRESSION, options.val);
					functionId = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * This expressions' parameters
			 * @name Expression#parameters
			 * @type {Object} Map of key value pairs
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'parameters', {
				get: function ()
				{
					return parameters;
				},
				set: function (val)
				{
					if (!util.isObject(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'parameters', 'object');
					checkParameters(val);
					parameters = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Expression)
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Expression";
			};

			/**
			 * get JSON format of the object
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					functionId: functionId,
					parameters: parameters
				};
			};
		}

		Expression.prototype = nsobject.getNewInstance();

		/**
		 * Creates an Expression
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @param {Object} options
		 * @param {string} options.functionId - id of function to use
		 * @param {Object} [options.parameters] - parameters of this expression
		 * @returns {Expression}
		 *
		 * @since 2020.2
		 */
		function createExpression(options)
		{
			var functionId = (options && options.hasOwnProperty('functionId')) ? options.functionId : options;
			utilityFunctions.checkArgs([functionId], ['functionId'], 'workbook.createExpression');
			if (!EXPRESSIONS[functionId])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_EXPRESSION, functionId);
			var parameters = null;
			if (util.isObject(options))
			{
				if (options.parameters)
					checkParameters(options.parameters);
				parameters = options.parameters;
			}
			return new Expression({functionId: functionId, parameters: parameters});
		}

		function check(val)
		{
			if (util.isArray(val))
				return checkArray(val);
			else if (utilityFunctions.isObject(val))
				return checkObject(val);
			else
				return checkValue(val);
		}

		function checkArray(array)
		{
			for (var i in array)
			{
				if (!check(array[i]))
					return false;
			}
			return true;
		}

		function checkObject(obj)
		{
			for (var i in obj)
			{
				if (!util.isString(i))
					return false;
				if (util.isFunction(obj[i]))
					continue;
				if (!check(obj[i]))
					return false;
			}
			return true;
		}

		function checkValue(val)
		{
			return val == null || util.isString(val) || util.isNumber(val) || util.isBoolean(val) || util.isDate(val) || utilityFunctions.checkObjectType(val, "workbook.Expression") || utilityFunctions.checkObjectType(val, "workbook.DataMeasure") || utilityFunctions.checkObjectType(val, "workbook.CalculatedMeasure");
		}

		function checkParameters(parameters)
		{
			for (var key in parameters){
				utilityFunctions.checkArgTypes([
					utilityFunctions.checkArgObject(key, 'parameter.key', util.isString),
				]);
				var value = parameters[key];
				utilityFunctions.checkArgTypes([
					utilityFunctions.checkArgObject(value, 'parameter.value', check)
				]);
			}
		}

		function createTranslation(options)
		{
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.key, 'options.key', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.collection, 'options.collection', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.translationId, 'options.translationId', util.isString)]);
			return new Expression({functionId: "TRANSLATE", parameters: {key: options.key, collection: options.collection, translationId: options.translationId}});
		}

		/**
		 * Creates a constant Expression
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @param {Object} options
		 * @param {string|number|boolean|Date} options.constant - id of function to use
		 * @param {Object} [options.type] - type for this constant (it is defaulted based on the type of constant value, but sometimes one needs to specify it, like currencyType, if the constant is number)
		 * @returns {Expression}
		 *
		 * @since 2020.2
		 */
		function createConstant(options)
		{
			var constant = (options && options.hasOwnProperty('constant')) ? options.constant : options;
			utilityFunctions.checkArgsPresent([constant], ['constant'], 'workbook.createConstant');
			var type = (options && options.hasOwnProperty('type')) ? options.type : null;
			var autoType;
			if (util.isBoolean(constant))
				autoType = "BOOLEAN";
			else if (util.isNumber(constant))
				autoType = "INTEGER";
			else if (util.isString(constant))
				autoType = "TEXT";
			else if (utilityFunctions.checkObjectType(constant, "workbook.Duration"))
				autoType = "DURATION";
			else if (utilityFunctions.checkObjectType(constant, "workbook.Currency"))
				autoType = "CURRENCY";
			else if (utilityFunctions.checkObjectType(constant, "workbook.Range"))
				autoType = "RANGE";
			else if (utilityFunctions.checkObjectType(constant, "workbook.RecordKey"))
			{
				autoType = {
					id: "RECORD_KEY",
				};
				var properties = [];
				for (var prop in constant.properties)
				{
					var property = {propertyId: prop};
					property["type"] = util.isString(constant.properties[prop]) ? "TEXT" : "INTEGER";
					properties.push(property);
				}
				autoType["properties"] = properties;
			}
			if (type)
			{
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validConstantTypes, type, false), error.Type.SSS_INVALID_TYPE_ARG, 'type');
				if ((autoType && type != autoType && type != "DATE" && type != "DATE_TIME" && type != "DECIMAL" && type != "NUMBER")
					|| (type == "DECIMAL" && !util.isNumber(constant))
					|| (type == "NUMBER" && !util.isNumber(constant))
					|| (type == "DATE" && !util.isString(constant))
					|| (type == "DATE_TIME" && !util.isString(constant)))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'constant');
			}
			else if (autoType)
				type = autoType;
			utilityFunctions.checkArgs([type], ['type'], 'workbook.createConstant');
			return new Expression({functionId: "CONSTANT", parameters: {type: type, value: constant}});
		}

		function isTranslation(options)
		{
			return options instanceof Expression && options.functionId == "TRANSLATE" && util.isObject(options.parameters) && util.isString(options.parameters.key) && util.isString(options.parameters.collection);
		}

		var currencies;

		return Object.freeze(({
			isTranslation: isTranslation,
			create: createExpression,
			createConstant: createConstant,
			createTranslation: createTranslation,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Expression: EXPRESSIONS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			ConstantType: CONSTANT_TYPE,
			/**
			 * @enum {string}
			 * @readonly
			 */
			DateTimeHierarchy: DATE_TIME_HIERARCHY,
			/**
			 * @enum {string}
			 * @readonly
			 */
			DateTimeProperty: DATE_TIME_PROPERTY,
			/**
			 * @enum {string}
			 * @readonly
			 */
			ComparisonType: COMPARISON_TYPE,
			/**
			 * @enum {string}
			 * @readonly
			 */
			TemporalUnit: TEMPORAL_UNIT,
			/**
			 * @enum {string}
			 * @readonly
			 */
			get Currency()
			{
				if (!currencies)
				{
					currencies = dynamicEnums.currencies;
				}
				return currencies;
			}
		}));
	}
);

/**
 * Internal module for listing information about workbooks/datasets
 *
 * @module N/analyticsListing
 * @suiteScriptVersion 2.x
 */
define('N/analyticsListing',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/common/pattern/iterator', 'N/internal/invoker', 'N/search/pagingUtil'],
	function(nsobject, error, utilityFunctions, iteratorFactory, invoker, pagingUtil)
	{
		var OWNER_CATEGORY = Object.freeze({
			TEMPLATE: "TEMPLATE",
			MINE: "MINE",
			SHARED: "SHARED",
			EMPLOYEE: "EMPLOYEE",
			ALL: "ALL",
		});

		function InfoPageIterator(pagedInfo) {
			var i = 0;
			this.hasNext = function hasNext() {
				return i < pagedInfo.pages;
			};

			this.next = function next() {
				return pagedInfo.fetch(i++);
			}
		}

		InfoPageIterator.prototype = nsobject.getNewInstance();

		/**
		 * Object corresponding to one page of results
		 * @class InfoPage
		 * @classDescription One page of the paged dataset listing result
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function InfoPage(options)
		{
			var TYPE = 'InfoPage';

			var data = options.data;
			var pagedInfoData = options.pagedInfoData;
			var pageRange = options.pageRange;
			var isFirst = !!pageRange && pageRange.index == 0;
			var isLast = !!pageRange && pagedInfoData.pageRanges[pagedInfoData.pageRanges.length - 1] == pageRange;

			/**
			 * ResultSet of the page
			 * @name InfoPage#data
			 * @type {Array<Object>}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'data', {
				get: function ()
				{
					return data;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * References the query results contained in this page.
			 * @name InfoPage#pagedInfoData
			 * @type {PagedInfoData}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'pagedInfoData', {
				get: function ()
				{
					return pagedInfoData;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedInfoData' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * The range of query results for this page.
			 * @name InfoPage#pageRange
			 * @type {InfoPageRange}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'pageRange', {
				get: function ()
				{
					return pageRange;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indicates whether the page is the first of the paged query results.
			 * @name InfoPage#isFirst
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'isFirst', {
				get: function ()
				{
					return isFirst;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Indication whether this page is the last one
			 * @name InfoPage#isLast
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'isLast', {
				get: function ()
				{
					return isLast;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (InfoPage)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};
			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pagedInfoData: pagedInfoData,
					data: data,
					isFirst: isFirst,
					isLast: isLast,
					pageRange: pageRange
				};
			};
		}

		InfoPage.prototype = nsobject.getNewInstance();

		/**
		 * InfoPageRange object
		 * @class InfoPageRange
		 * @classDescription Encapsulates the range of dataset listing results for a page
		 * @constructor
		 * @protected
		 *
		 * @since 2018.1
		 */
		function InfoPageRange(options)
		{
			var TYPE = 'InfoPageRange';

			var index = options.index;
			var size = options.size;
			/**
			 * Describes the array index for this page range.
			 * @name InfoPageRange#index
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'index', {
				get: function ()
				{
					return index;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Number of results in this page range
			 * @name InfoPageRange#size
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return size;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (InfoPageRange)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};
			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					index: index,
					size: size
				};
			};
		}

		InfoPageRange.prototype = nsobject.getNewInstance();

		/**
		 * @class PagedInfoData
		 * @classDescription Object holding pages with information about all datasets
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function PagedInfoData(args)
		{
			var TYPE = 'PagedInfoData';

			var that = this;
			var pageSize = args.pageSize;
			var count = args.total;
			var numPages = args.pages;
			var category = args.category;
			var pageRanges = function()
			{
				var ranges = [];
				for (var i = 0; i < numPages; i++)
					ranges.push(new InfoPageRange({index:i, size: i  == numPages -1 ? count - (numPages - 1) * pageSize : numPages}));
				return ranges;
			}();

			/**
			 * Size of the page
			 * @name PagedInfoData#pageSize
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'pageSize', {
				get: function ()
				{
					return pageSize;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Total number of datasets
			 * @name PagedInfoData#count
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2018.1
			 */
			Object.defineProperty(this, 'count', {
				get: function ()
				{
					return count;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'count' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Total number of info pages
			 * @name PagedInfoData#pageRanges
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'pageRanges', {
				get: function ()
				{
					return pageRanges;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			/**
			 * Paging category
			 * @name PagedInfoData#category
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'category', {
				get: function ()
				{
					return category;
				},
				set: function ()
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'category' );
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});

			function validateAndGetIndex(options)
			{
				var index = (options && options.hasOwnProperty('index')) ? options.index : options;
				utilityFunctions.checkArgs([index], ['index'], 'PagedInfoData.fetch');
				index = parseInt(index);
				if (isNaN(index))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);
				if(index < 0 || index >= numPages)
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch');
				return index;
			}

			/**
			 * Get info page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of omfp page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @governance 10 units
			 *
			 * @return {InfoPage}
			 */
			this.fetch = function(options)
			{
				var index = validateAndGetIndex(options);
				var isPromiseCallback = utilityFunctions.isPromiseCallback(this);
				var data = invoker(args.delegate, "getInfoPage",[category, index, pageSize], isPromiseCallback ? this : undefined);
				if (!isPromiseCallback)
					return new InfoPage({data: data, pagedInfoData: that, pageRange: pageRanges[index]});
			}

			/**
			 * Asynchronously get info page with given index
			 * @param {Object} options
			 * @param {string} options.index Index of info page to return
			 * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT if options are undefined
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE if options isn't object nor number
			 * @governance 10 units
			 *
			 * @return {InfoPage}
			 */
			this.fetch.promise = function(options)
			{
				return utilityFunctions.promiseTo(that.fetch, arguments, function(data){
					return new InfoPage({data: data.result, pagedInfoData: that, pageRange: that.pageRanges[validateAndGetIndex(options)]});
				});
			}

			/**
			 * Standard object for iterating through pages.
			 * @governance none
			 * @return {Iterator}
			 *
			 * @since 2021.1
			 */
			this.iterator = function iterator() {
				return iteratorFactory.create(new InfoPageIterator(this));
			}

			/**
			 * Returns the object type name (PagedInfoData)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return TYPE;
			};
			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					pageSize: pageSize,
					count: count,
					pageRanges: pageRanges
				};
			};
		}

		PagedInfoData.prototype = nsobject.getNewInstance();


		function ListingHandle(delegate)
		{
			var that = this;
			/**
			 * Lists all datasets/workbooks
			 * @restriction Server SuiteScript only
			 * @governance 10 units
			 * @param {Object} [options]
			 * @param {string} [options.category] category of dataset/workbooks to list
			 * @throws {SuiteScriptError} INVALID_OWNER_CATEGORY if category parameter is outside of OwnerCategory enum
			 * @return {Array<Object>}
			 *
			 * @since 2020.2
			 */
			this.list = function(options)
			{
				var category = "ALL";
				if (util.isObject(options) && options.category)
				{
					if (!OWNER_CATEGORY[options.category])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_OWNER_CATEGORY, options.category);
					category = options.category;
				}
				var isPromise = utilityFunctions.isPromiseCallback(this);
				var result = invoker(delegate, "list", [category], isPromise ? this : undefined);
				if (!isPromise)
					return result;
			}

			/**
			 * Asynchronously lists all datasets/workbook
			 * @restriction Server SuiteScript only
			 * @governance 10 units
             * @param {Object} [options]
			 * @param {string} [options.category] category of dataset/workbooks to list
			 * @throws {SuiteScriptError} INVALID_OWNER_CATEGORY if category parameter is outside of OwnerCategory enum
			 * @return {Promise}
			 *
			 * @since 2021.1
			 */
			this.list.promise = function()
			{
				return utilityFunctions.promiseTo(that.list, arguments);
			}

			/**
			 * Returns pages with metadata about datasets
			 * @restriction Server SuiteScript only
			 * @governance 10 units
			 * @param {Object} options
			 * @param {number} options.pageSize
			 * @param {string} [options.category] category of dataset/workbooks to get paginated listing for
			 * @throws {SuiteScriptError} INVALID_OWNER_CATEGORY if category parameter is outside of OwnerCategory enum
			 * @return {PagedInfoData}
			 *
			 * @since 2021.1
			 */
			this.listPaged = function(options)
			{

				var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
				var category = "ALL";
				if (util.isObject(options) && options.category)
				{
					if (!OWNER_CATEGORY[options.category])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_OWNER_CATEGORY, options.category);
					category = options.category;
				}
				pageSize = pagingUtil.regulatePageSize(pageSize);
				var isPromise = utilityFunctions.isPromiseCallback(this);
				var data = invoker(delegate, "listPaged", [category, pageSize], isPromise ? this : undefined);
				if (!isPromise)
					return new PagedInfoData(util.extend({delegate: delegate}, data));
			}

			/**
			 * Asynchronously returns pages with metadata about datasets
			 * @restriction Server SuiteScript only
			 * @governance 10 units
			 * @param {Object} options
			 * @param {number} options.pageSize
			 * @param {string} [options.category] category of dataset/workbooks to get paginated listing for
			 * @throws {SuiteScriptError} INVALID_OWNER_CATEGORY if category parameter is outside of OwnerCategory enum
			 * @return {Promise}
			 *
			 * @since 2021.1
			 */
			this.listPaged.promise = function()
			{
				return utilityFunctions.promiseTo(that.listPaged, arguments, function (value) {
					return new PagedInfoData(util.extend({delegate: delegate}, value.result));
				});
			}
		}

		function getListingHandle(delegate)
		{
			return new ListingHandle(delegate);
		}

		return Object.freeze({
			getListingHandle: getListingHandle,
			/**
			 * @enum {string}
			 * @readonly
			 */
			OwnerCategory: OWNER_CATEGORY
		})

	}
);
/**
 * SuiteScript dataset module
 * Create/Load a dataset and execute it using the SuiteAnalytics Workbook query engine. Or use it as a data source for the workbook
 * itself.
 *
 * @module N/dataset
 * @suiteScriptVersion 2.x
 */
define('N/dataset',['N/restricted/datasetApi', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/error', 'N/common/pattern/iterator', 'N/search/pagingUtil', 'N/expression', 'N/query', 'N/queryInternal', 'N/analyticsListing'],
	function(datasetApi, nsobject, invoker, utilityFunctions, error, iteratorFactory, pagingUtil, expression,query, queryInternal, analyticsListing)
	{

	/**
	 * @class Dataset
	 * @classDescription Object representing SuiteAnalytics dataset
	 * @constructor
	 * @protected
	 *
	 * @since 2020.2
	 */
	function Dataset(options)
	{
		var condition = options.condition;
		var columns = options.columns;
		var name = options.name;
		var description = options.description;
		var type = options.type;
		var id = options.id;
		var _id = options._id;

		function runInternal(definition, columns, options)
		{
			var isPromise = utilityFunctions.isPromiseCallback(this);
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			var data = invoker(datasetApi, "run", [definition, metadataProvider], isPromise ? this.bind(columns) : undefined);
			if (!isPromise)
				return queryInternal.createResultSet(data, columns);
		}

		/**
		 * Executes the dataset and returns the result set (the same as in query module)
		 * @restriction Server SuiteScript only
		 * @governance 10 units
		 * @param {Object} options
		 * @param {string} options.metadataProvider
		 * @return {ResultSet}
		 *
		 * @since 2020.2
		 */
		this.run = function(options)
		{
			return runInternal(JSON.stringify(this), columns, options);
		};

		function runPostProcess(options)
		{
			var data = options.result;
			var columns = options.data;
			return queryInternal.createResultSet(data, columns);
		}

		function promiseToRun(options)
		{
			return utilityFunctions.promiseTo(runInternal, [JSON.stringify(this), this.columns, options], runPostProcess);
		}

		/**
		 * Asynchronously executes the dataset and returns the result set (the same as in query module)
		 * @restriction Server SuiteScript only
		 * @governance 10 units
		 * @param {Object} options
		 * @param {string} options.metadataProvider
		 * @return {Promise}
		 *
		 * @since 2020.2
		 */
		this.run.promise = promiseToRun.bind(this);

		function runPagedInternal(options, definition, columns)
		{
			var pageSize = (options && options.hasOwnProperty('pageSize')) ? options.pageSize : options;
			pageSize = pagingUtil.regulatePageSize(pageSize);
			var metadataProvider = queryInternal.convertMetaDataProviderType(options);
			var isPromise = utilityFunctions.isPromiseCallback(this);
			var data = invoker(datasetApi, "runPaged", [definition, pageSize, metadataProvider], isPromise ? this.bind({definition: definition, pageSize: pageSize, columns: columns, metadataProvider: metadataProvider}) : undefined);
			if (!isPromise)
				return queryInternal.createPagedData({queryDefinition: definition, queryData: data, pageSize: pageSize, columns: columns, type: "dataset", metadataProvider: metadataProvider});
		}

		/**
		 * Executes the dataset and returns paginated data (the same as in query module)
		 * @restriction Server SuiteScript only
		 * @governance 10 units
		 * @param {Object} options
		 * @param {number} options.pageSize
		 * @param {string} options.metadataProvider
		 * @return {PagedData}
		 *
		 * @since 2020.2
		 */
		this.runPaged = function(options)
		{
			return runPagedInternal(options, JSON.stringify(this), columns);
		};

		function runPagedPostProcess(options)
		{
			var data = options.result;
			var definition = options.data.definition;
			var pageSize = options.data.pageSize;
			var columns = options.data.columns;
			var metadataProvider = options.data.metadataProvider;
			return queryInternal.createPagedData({queryDefinition: definition, queryData: data, pageSize: pageSize, columns: columns, type: "dataset", metadataProvider: metadataProvider});
		}

		function runPagedPromise(options)
		{
			return utilityFunctions.promiseTo(runPagedInternal, [options, JSON.stringify(this), this.columns], runPagedPostProcess);
		}

		/**
		 * Asynchronously executes the dataset and returns paginated data (the same as in query module)
		 * @restriction Server SuiteScript only
		 * @governance 10 units
		 * @param {Object} options
		 * @param {number} options.pageSize
		 * @param {string} options.metadataProvider
		 * @return {Promise}
		 *
		 * @since 2020.2
		 */
		this.runPaged.promise = runPagedPromise.bind(this);

		/**
		 * Returns expression which can be used in workbook
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @param {Object} options
		 * @param {number} options.columnId
		 * @param {string} options.alias
		 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS both columnId and alias are used
		 * @throws {SuiteScriptError} NEITHER_ARGUMENT_DEFINED neither columnId nor alias parameters are defined
		 * @return {Expression}
		 *
		 * @since 2020.2
		 */
		this.getExpressionFromColumn = function getExpressionFromColumn(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'dataset.getExpressionFromColumn');
			var alias;
			if (util.isString(options))
				alias = options;
			else
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.alias], ['options.alias'], 'dataset.getExpressionFromColumn');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.alias, 'options.alias', util.isString)]);
				alias = options.alias;
			}
			return expression.create({functionId: expression.Expression.DATASET_COLUMN, parameters: {dataset: this, alias: alias}});
		};

		/**
		 * Saves the dataset
		 * @restriction Server SuiteScript only
		 * @governance 10 units
		 * @param {Object} options
		 * @param {string|Expression} options.name name of the dataset
		 * @param {string|Expression} [options.description] decription of the dataset
		 * @param {string} [options.id] target id for the saved dataset
		 * @throws {SuiteScriptError} INVALID_ID_PREFIX when desired dataset id does not start with 'custdataset'
		 * @return {Object}
		 *
		 * @since 2020.2
		 */
		this.save = function save(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'dataset.save');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name], ['options.name'], 'dataset.save');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.name, 'options.name', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.description, 'options.description', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'options.id', util.isString)]);
			if (options.id && options.id.substr(0, 11) !== "custdataset")
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_ID_PREFIX, "custdataset");
			var toSave = this.toJSON();
			toSave.id = options.id ? options.id : null;
			toSave.name = expression.isTranslation(options.name) ? options.name.toJSON() : options.name;
			toSave.description = options.description ? expression.isTranslation(options.description) ? options.description.toJSON() : options.description : null;
			var data =  invoker(datasetApi, "save", [JSON.stringify(toSave)]);
			name = options.name;
			description = options.description;
			id = options.id ? options.id : data.id;
			_id = data.internalid;
			return {id: data.id};
		};

		/**
		 * Condition for the whole dataset (criterion)
		 * @name Dataset#condition
		 * @type {Condition}
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than dataset.Condition
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'condition', {
			get: function ()
			{
				return condition;
			},
			set: function (val)
			{
				if (!utilityFunctions.checkObjectType(val, "dataset.Condition"))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'dataset.Condition');
				condition = val;
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * id of the dataset
		 * @name Dataset#id
		 * @type {string}
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than string
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'id', {
			get: function ()
			{
				return id;
			},
			set: function (val)
			{
				if (!util.isString(val))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'string');
				if (val.substring(0, 11).toLowerCase() != "custdataset")
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_DATASET_ID);
				id = val;
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		Object.defineProperty(this, '_id', {
			get: function ()
			{
				return _id;
			},
			set: function (val)
			{
				//do nothing, pretend it's not here
			},
			enumerable: false,
			configurable: false,
			writeable: false
		});

		/**
		 * Columns in the dataset
		 * @name Dataset#columns
		 * @type {Array<Column>}
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than Array<dataset.Column>
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'columns', {
			get: function ()
			{
				return columns;
			},
			set: function (val)
			{
				if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(value){
					return utilityFunctions.checkObjectType(value, "dataset.Column");
				}))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'Column[]');
				columns = val;
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * base record type
		 * @name Dataset#type
		 * @type {string}
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than string
		 * @throws {SuiteScriptError} INVALID_SEARCH_TYPE when the type is invalid
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'type', {
			get: function ()
			{
				return type;
			},
			set: function (val)
			{
				if (!util.isString(val))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'type', 'string');
				queryInternal.validateSearchType(val);
				type = val;
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Name of the dataset
		 * @name Dataset#name
		 * @type {string}
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'name', {
			get: function ()
			{
				return name;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Description of the dataset
		 * @name Dataset#description
		 * @type {string}
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'description', {
			get: function ()
			{
				return description;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Returns the object type name (dataset.Dataset)
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {string}
		 *
		 * @since 2020.2
		 */
		this.toString = function toString()
		{
			return "dataset.Dataset";
		};

		/**
		 * get JSON format of the object
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {Object}
		 *
		 * @since 2020.2
		 */
		this.toJSON = function toJSON()
		{
			return {
				name: name,
				description: description,
				type: type,
				columns: columns,
				condition: condition,
				id: id
			}
		}
	}

	Dataset.prototype = nsobject.getNewInstance();

	/**
	 * @class Column
	 * @classDescription Object representing dataset column
	 * @constructor
	 * @protected
	 *
	 * @since 2020.2
	 */
	function Column(options)
	{
		var formula = options.formula || null;
		var type = options.type || null;
		var join = options.join || null;
		var fieldId = options.fieldId || null;
		var label = options.label || null;
		var alias = options.alias || null;
		var id = options.id || null;

		/**
		 * formula of the column
		 * @name Column#formula
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'formula', {
			get: function ()
			{
				return formula;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'formula');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * label of the column
		 * @name Column#label
		 * @type {string|Expression}
		 * @readonly
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'label', {
			get: function ()
			{
				return label;
			},
			set: function (val)
			{
				if (!util.isString(val) && !expression.isTranslation(val))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'label', 'string or Expression<TRANSLATE>');
				label = val;
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * alias of the column
		 * @name Column#alias
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting value of different type than string
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'alias', {
			get: function ()
			{
				return alias;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'alias');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * internal id of the column, populated only in loaded datasets
		 * @name Column#id
		 * @type {number}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting value of different type than string
		 *
		 * @since 2021.2
		 */
		Object.defineProperty(this, 'id', {
			get: function ()
			{
				return id;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * return type of the formula
		 * @name Column#type
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'type', {
			get: function ()
			{
				return type;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Join for the column, polulated only if the column is not on a base record
		 * @name Column#join
		 * @type {Join}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'join', {
			get: function ()
			{
				return join;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * id of the field of the column
		 * @name Column#fieldId
		 * @type {string}
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'fieldId', {
			get: function ()
			{
				return fieldId;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Returns the object type name (dataset.Column)
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {string}
		 *
		 * @since 2020.2
		 */
		this.toString = function toString()
		{
			return "dataset.Column";
		};

		/**
		 * get JSON format of the object
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {Object}
		 *
		 * @since 2020.2
		 */
		this.toJSON = function toJSON()
		{
			return {
				formula: formula,
				type: type,
				fieldId: fieldId,
				join: join,
				alias: alias,
				label: label,
				id: id
			};
		};
	}

	Column.prototype = nsobject.getNewInstance();

	/**
	 * @class Condition
	 * @classDescription Object dataset condition
	 * @constructor
	 * @protected
	 *
	 * @since 2020.2
	 */
	function Condition(delegate)
	{
		var column = delegate.column || null;
		var values = delegate.values || [];
		var operator = delegate.operator;
		var children = delegate.children || [];
		var caseSensitive = delegate.caseSensitive || false;

		/**
		 * column on which the condition is placed
		 * @name Condition#column
		 * @type {Column}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'column', {
			get: function ()
			{
				return column;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'column');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * children of this condition (e. g. subconditions ANDed or ORed)
		 * @name Condition#children
		 * @type {Array<Condition>}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'children', {
			get: function ()
			{
				return children;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'children');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * operator of the condition
		 * @name Condition#operator
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 */
		Object.defineProperty(this, 'operator', {
			get: function ()
			{
				return operator;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * values for this condition
		 * @name Condition#values
		 * @type {Array<Date | number | string | boolean | Object>}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 */
		Object.defineProperty(this, 'values', {
			get: function ()
			{
				return values;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'values');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Indicates whether the sort is case sensitive.
		 * @name Condition#caseSensitive
		 * @type {Boolean}
		 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when setting non-boolean parameter
		 *
		 * @since 2018.2
		 */
		Object.defineProperty(this, 'caseSensitive', {
			get: function ()
			{
				return caseSensitive;
			},
			set: function (caseSensitive)
			{
				if (!util.isBoolean(caseSensitive))
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'Boolean');
			},
			enumerable: true,
			configurable: false,
			writeable: false
		});

		/**
		 * Returns the object type name (dataset.Condition)
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {string}
		 *
		 * @since 2020.2
		 */
		this.toString = function toString()
		{
			return "dataset.Condition";
		};

		/**
		 * get JSON format of the object
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {Object}
		 *
		 * @since 2020.2
		 */
		this.toJSON = function toJSON()
		{
			return {
				values : values,
				operator: operator,
				column: column,
				children: children,
				caseSensitive: caseSensitive
			}
		}
	}

	Condition.prototype = nsobject.getNewInstance();

	/**
	 * @class Join
	 * @classDescription object for joining fields from other record types
	 * @constructor
	 * @protected
	 *
	 * @since 2020.2
	 */
	function Join(delegate)
	{
		var fieldId = delegate.fieldId;
		var source = delegate.source || null;
		var target = delegate.target || null;
		var join = delegate.join || null;

		/**
		 * id of the field on which the join was performed
		 * @name Join#fieldId
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'fieldId', {
			get: function ()
			{
				return fieldId;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fieldId');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * source record type of the join
		 * @name Join#source
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'source', {
			get: function ()
			{
				return source;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'source');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * polymorphic target of the join
		 * @name Join#target
		 * @type {string}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'target', {
			get: function ()
			{
				return target;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'target');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * child join if this is a multilevel join
		 * @name Join#join
		 * @type {Join}
		 * @readonly
		 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
		 *
		 * @since 2020.2
		 */
		Object.defineProperty(this, 'join', {
			get: function ()
			{
				return join;
			},
			set: function (val)
			{
				utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join');
			},
			enumerable: true,
			configurable: false,
			writeable: true
		});

		/**
		 * Returns the object type name (dataset.Join)
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {string}
		 *
		 * @since 2020.2
		 */
		this.toString = function toString()
		{
			return "dataset.Join";
		};

		/**
		 * get JSON format of the object
		 * @restriction Server SuiteScript only
		 * @governance none
		 * @return {Object}
		 *
		 * @since 2020.2
		 */
		this.toJSON = function toJSON()
		{
			return {
				fieldId: fieldId,
				target: target,
				source: source,
				join: join
			}
		}
	}

	Join.prototype = nsobject.getNewInstance();

	/**
	 * Create a Dataset join
	 * @restriction Server SuiteScript only
	 * @governance none
	 * @param {Object} options
	 * @param {string} options.fieldId
	 * @param {string=} options.source - for inverse joins
	 * @param {string=} options.target - for polymorphic joins
	 * @param  {Join=}  options.join - for multi-level joins
	 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS when both source and target parameters are specified
	 * @return {Join}
	 *
	 * @since 2020.2
	 */
	function createJoin(options)
	{
		utilityFunctions.checkArgs([options], ['options'], 'dataset.createJoin');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
		utilityFunctions.checkArgs([options.fieldId], ['options.fieldId'], 'dataset.createJoin');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fieldId, 'options.fieldId', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.source, 'options.source', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.target, 'options.target', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.join, 'options.join', function (join){
			return utilityFunctions.checkObjectType(join, "dataset.Join");
		})]);
		if (options.target && options.source)
			utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'source', 'target');
		return new Join(options);
	}

	/**
	 * Create a Dataset object
	 * @restriction Server SuiteScript only
	 * @governance none
	 * @param {Object} options
	 * @param {string} options.type Record type on which to build the dataset
	 * @param {Condition} [options.condition] Dataset's condition
	 * @param {Array<Column>} [options.columns] Dataset's columns
	 * @throws {SuiteScriptError} INVALID_SEARCH_TYPE when the type is invalid
	 * @return {Dataset}
	 *
	 * @since 2020.2
	 */
	function createDataset(options)
	{
		utilityFunctions.checkArgs([options], ['options'], 'dataset.create');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
		utilityFunctions.checkArgs([options.type], ['options.type'], 'dataset.create');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
		queryInternal.validateSearchType(options.type);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.columns, 'options.columns', function (columns){
			return util.isArray(columns) && utilityFunctions.checkArrayType(columns, function(value){
				return utilityFunctions.checkObjectType(value, "dataset.Column");
			});
		})]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.condition, 'options.condition', function (condition){
			return utilityFunctions.checkObjectType(condition, "dataset.Condition");
		})]);
		return new Dataset({type: options.type, columns: options.columns, condition: options.condition});
	}

	/**
	 * Loads a dataset
	 * @restriction Server SuiteScript only
	 * @governance 10 units
	 * @param {Object} options
	 * @param {string} options.id id of the dataset to load
	 * @return {Dataset}
	 *
	 * @since 2020.2
	 */
	function loadDataset(options)
	{
		var id = (options && options.hasOwnProperty('id')) ? options.id : options;
		utilityFunctions.checkArgs([id], ['id'], 'dataset.load');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isString)]);
		var isPromise = utilityFunctions.isPromiseCallback(this);
		var data = invoker(datasetApi, 'load', [id], isPromise ? this.bind({id: id}) : undefined);
		if (!isPromise)
			return loadPostProcess({result: data, data: {id: id}});
	}

	function loadPostProcess(options)
	{
		var data = options.result;
		var columns = unwrapColumns(data.columns);
		var condition = unwrapCondition(data.condition);
		var id = options.data.id;
		return new Dataset({columns: columns, condition: condition, name: data.name, type: data.type, description: data.description, id: id, _id: data.internalid});
	}

	/**
	 * Asynchronously loads a dataset
	 * @restriction Server SuiteScript only
	 * @governance 10 units
	 * @param {Object} options
	 * @param {string} options.id id of the dataset to load
	 * @return {Promise}
	 *
	 * @since 2020.2
	 */
	loadDataset.promise = function()
	{
		return 	utilityFunctions.promiseTo(loadDataset, arguments, loadPostProcess);
	};

	function unwrapJoins(joins)
	{
		if (!joins)
			return undefined;
		joins["join"] = unwrapJoins(joins["join"]);
		return createJoin(joins);
	}

	function unwrapColumns(columns)
	{
		var cols = [];
		for (var i in columns)
		{
			var col = columns[i];
			col["join"] = unwrapJoins(col["join"]);
			cols.push(new Column(col));
		}
		return cols;
	}

	function unwrapCondition(condition) {
		if (!condition)
			return null;
		var children = condition["children"];
		if (children)
		{
			for (var i = 0; i < children.length; i++)
				children[i] = unwrapCondition(children[i]);
		}
		else
		{
			var col = condition["column"];
			col["join"] = unwrapJoins(col["join"]);
			condition["column"] = new Column(col);
		}
		if (condition.values) {
			for (var j = 0; j < condition.values.length; j++) {
				if (util.isObject(condition.values[j]) && condition.values[j].hasOwnProperty("dateId") && !condition.values[j].hasOwnProperty("type")) {
					if (condition.values[j].value) {
						condition.values[j] = query.createRelativeDate({
							dateId: condition.values[j].dateId,
							value: condition.values[j].value
						});
					} else {
						for (var i in query.RelativeDateRange) {
							if (query.RelativeDateRange[i].dateId == condition.values[j].dateId) {
								condition.values[j] = query.RelativeDateRange[i];
								break;
							}
						}
					}
				} else if (util.isObject(condition.values[j]) && condition.values[j].hasOwnProperty("adjustment"))
					condition.values[j] = query.createPeriod({
						code: condition.values[j].code,
						type: condition.values[j].type,
						adjustment: condition.values[j].adjustment
					});
			}
		}
		return createCondition(condition);
	}

	/**
	 * Creates a dataset column
	 * @restriction Server SuiteScript only
	 * @governance none
	 * @param {Object} options
	 * @param {string} [options.formula] formula for the column
	 * @param {string} [options.type] return type of the formula
	 * @param {string} [options.fieldId] fieldId for the column (exclusive with formula/type)
	 * @param {string|Expression} [options.label] label for the column to display in UI
	 * @param {string} [options.alias] Alias for the column which can be used to get corresponding expression for the column,
	 *     which can later be used in a workbook, also used in results mapping
	 * @param {Join} options.join join record on which the field is present
	 * @throws {SuiteScriptError} INVALID_FORMULA_TYPE when invalid formula return type was entered
	 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS when both formula and fieldId parameters are specified, or both
	 *     formula and join are specified
	 * @return {Column}
	 *
	 * @since 2020.2
	 */
	function createColumn(options)
	{
		utilityFunctions.checkArgs([options], ['options'], 'workbook.createColumn');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.formula, 'options.formula', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.alias, 'options.alias', util.isString)]);
		if (options.alias != null && !options.alias.match(/^$|^[0-9a-zA-Z_ ]+$/))
			utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLUMN_ALIAS, options.alias);
		if (options.formula)
		{
			if (!options.type)
				utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, 'options.type', 'workbook.createColumn');
			else if (!query.ReturnType[options.type])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FORMULA_TYPE, options.type);
		}
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fieldId, 'options.fieldId', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.join, 'options.join', function (join){
			return utilityFunctions.checkObjectType(join, "dataset.Join");
		})]);
		if (options.formula && options.fieldId)
			utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'formula', 'fieldId');
		if (!options.formula && !options.fieldId)
			utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'fieldId', 'formula');
		if (options.formula && options.join)
			utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'formula', 'join');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.label, 'options.label', function(val){
			return util.isString(val) || expression.isTranslation(val);
		})]);
		delete options["id"];
		return new Column(options);
	}

	/**
	 * Creates a Dataset condition
	 * @restriction Server SuiteScript only
	 * @governance none
	 * @param {Object} options
	 * @param {Column=} options.column column to apply this filter on
	 * @param {string} options.operator filter's operator
	 * @param {Array<string | number | boolean | Date | Object>=} options.values
	 * @param {Array<Condition>} options.children child conditions (when AND/OR operator is used)
	 * @throws {SuiteScriptError} INVALID_OPERATOR if invalid operator is used
	 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS when both column and children parameters are specified
	 * @return {Condition}
	 *
	 * @since 2020.2
	 */
	function createCondition(options)
	{
		utilityFunctions.checkArgs([options], ['options'], 'dataset.createCondition');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
		utilityFunctions.checkArgs([options.operator], ['options.operator'], 'dataset.createCondition');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.operator, 'options.operator', util.isString)]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.column, 'options.column', function (column){
			return utilityFunctions.checkObjectType(column, "dataset.Column");
		})]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.values, 'options.values', function (values){
			return util.isArray(values) && utilityFunctions.checkArrayType(values, function(value){
				return value === null || util.isNumber(value) || util.isBoolean(value) || util.isString(value) || util.isDate(value) || utilityFunctions.isObject(value);
			});
		})]);
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.children, 'options.children', function (children){
			return util.isArray(children) && utilityFunctions.checkArrayType(children, function(child){
				return utilityFunctions.checkObjectType(child, "dataset.Condition");
			});
		})]);
		if (options.children)
		{
			if (options.column)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'children', 'column');
			if (options.operator != "OR" && options.operator != "AND")
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_OPERATOR, options.operator);
		}
		else
		{
			utilityFunctions.checkArgs([options.column], ['options.column'], 'dataset.createCondition');
			queryInternal.validateOperator(options.operator, error.Type.INVALID_OPERATOR);
			query._checkOperatorArity(options.operator, options.values === undefined ? null : options.values);
		}
		return new Condition(options);
	}

	/**
	 * Create translation expression
	 * @param {Object} options
	 * @param {string} {options.key} Key of the translation
	 * @param {string} {options.collection} Collection of the translation
	 * @return {Expression} Expression for the translation
	 *
	 * @since 2021.2
	 */
	function createTranslation(options)
	{
		utilityFunctions.checkArgs([options], ['options'], 'dataset.createTranslation');
		if (!util.isString(options.translationId)) {
			utilityFunctions.checkArgs([options.key], ['options.key'], 'dataset.createTranslation');
			utilityFunctions.checkArgs([options.collection], ['options.collection'], 'dataset.createTranslation');
		}
		return expression.createTranslation(options);
	}

	/**
	 * Describes a dataset. Returns name, description and list of columns/formulas with their labels and types
	 * @restriction Server SuiteScript only
	 * @governance 10 units
	 * @param {Object} options
	 * @param {string} options.id id of the dataset to describe
	 * @return {Array<Object>}
	 *
	 * @since 2021.1
	 */
	function describe(options)
	{
		var id = (options && options.hasOwnProperty('id')) ? options.id : options;
		utilityFunctions.checkArgs([id], ['id'], 'dataset.describe');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isString)]);
		var isPromise = utilityFunctions.isPromiseCallback(this);
		var data = invoker(datasetApi, 'describe', [id], isPromise ? this : undefined);
		if (!isPromise)
			return data;
	}

	/**
	 * Asynchronously describes a dataset. Returns name, description and list of columns/formulas with their labels and types
	 * @restriction Server SuiteScript only
	 * @governance 10 units
	 * @param {Object} options
	 * @param {string} options.id id of the dataset to load
	 * @return {Promise}
	 *
	 * @since 2021.1
	 */
	describe.promise = function()
	{
		return utilityFunctions.promiseTo(describe, arguments);
	};

	return Object.freeze({
		create: createDataset,
		load: loadDataset,
		createColumn: createColumn,
		createCondition: createCondition,
		createJoin: createJoin,
		list: analyticsListing.getListingHandle(datasetApi).list,
		listPaged: analyticsListing.getListingHandle(datasetApi).listPaged,
		describe: describe,
		createTranslation: createTranslation,
		_loadInternal: loadPostProcess
	});
});
/**
 * SuiteScript datasetLink module
 * Create a DatasetLink object which can be constructed using multiple datasets and expression matrix.
 * Such object can be used in Pivot/Chart
 *
 * @module N/datasetLink
 * @suiteScriptVersion 2.x
 */
define('N/datasetLink',['N/nsobject', 'N/utilityFunctions', 'N/error'],
	function(nsobject,
	         utilityFunctions,
	         error){
		/**
		 * @class DatasetLink
		 * @classDescription Object representing SuiteAnalytics DatasetLink - multiple datasets linked by expressions matrix
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function DatasetLink(options)
		{
			var datasets = options.datasets;
			var expressions = options.expressions || [[]];
			var id = options.id;

			/**
			 * id of the dataset link
			 * @name DatasetLink#id
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'string');
					id = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * datasets of the link
			 * @name DatasetLink#datasets
			 * @type {Array<Dataset>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than Array<Dataset>
			 * @throws {SuiteScriptError} NO_DATASET_DEFINED when assigning empty array
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'datasets', {
				get: function ()
				{
					return datasets;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(dataset){
						return utilityFunctions.checkObjectType(dataset, "dataset.Dataset");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'datasets', 'dataset.Dataset[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_DATASET_DEFINED);
					datasets = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Mapping expressions
			 * @name DatasetLink#expressions
			 * @type {Array<Array<Expression>>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when assigning something else than Array<Array<Expresion>>
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'expressions', {
				get: function ()
				{
					return expressions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(mapping){
						return util.isArray(mapping) && utilityFunctions.checkArrayType(mapping, function(expression){
							utilityFunctions.checkObjectType(expression, "workbook.Expression");
						});
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expressions', 'workbook.Expression[][]');
					expressions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (datasetLink.DatasetLink)
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "datasetLink.DatasetLink";
			};

			/**
			 * get JSON format of the object
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					datasets: datasets,
					expressions: expressions,
					id: id
				}
			}
		}

		DatasetLink.prototype = nsobject.getNewInstance();

		/**
		 * Creates a dataset link
		 * @governance none
		 * @param {Object} options
		 * @param {Array<Dataset>} options.datasets Datasets for this link
		 * @param {Array<Array<Expression>>} options.expressions Mapping expressions
		 * @param {string} options.id id of this dataset link
		 * @return {DatasetLink}
		 * @throws {SuiteScriptError} NO_DATASET_DEFINED when assigning empty array for datasets
		 *
		 * @since 2021.2
		 */
		function createDatasetLink(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'datasetLink.createDatasetLink');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.id], ['options'], 'datasetLink.createDatasetLink');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'datasetLink.id', util.isString)]);
			utilityFunctions.checkArgs([options.datasets], ['options.datasets'], 'datasetLink.createDatasetLink');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.datasets, 'options.datasets', function (datasets){
				return util.isArray(datasets) && utilityFunctions.checkArrayType(datasets, function(dataset){
					return utilityFunctions.checkObjectType(dataset, "dataset.Dataset");
				});
			})]);
			if (options.datasets.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_DATASET_DEFINED);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.expressions, 'options.expressions', function (mapping){
				return util.isArray(mapping) && utilityFunctions.checkArrayType(mapping, function(expressions){
					return util.isArray(expressions) && utilityFunctions.checkArrayType(expressions, function(expression) {
						return utilityFunctions.checkObjectType(expression, "workbook.Expression");
					});
				});
			})]);
			return new DatasetLink(options);
		}

		return Object.freeze({
			create: createDatasetLink
		});
});
/**
 * SuiteScript workbook module
 * Create/Load a workbook with possibility to execute Pivots and TableViews
 *
 * @module N/workbook
 * @suiteScriptVersion 2.x
 */
define('N/workbook',['N/restricted/workbookApi', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/error', 'N/common/pattern/iterator', 'N/search/pagingUtil', 'N/dataset', 'N/format', 'N/expression', 'N/query', 'N/queryInternal', 'N/analyticsListing', 'N/datasetLink', 'N/environment'],
	function(workbookApi, nsobject, invoker, utilityFunctions, error, iteratorFactory, pagingUtil, dataset, format, expression, query, queryInternal, analyticsListing, datasetLink, environment)
	{
		var COLORS = Object.freeze({
			BLACK: "BLACK",
			BLUE: "BLUE",
			BROWN: "BROWN",
			GRAY: "GRAY",
			GREEN: "GREEN",
			ORANGE: "ORANGE",
			PINK: "PINK",
			PURPLE: "PURPLE",
			RED: "RED",
			YELLOW: "YELLOW",
			WHITE: "WHITE"
		});

		var IMAGES = Object.freeze({
			EXCLAMATION: "EXCLAMATION",
			QUESTION: "QUESTION",
			SMILE: "SMILE"
		});

		var FONT_SIZES = Object.freeze({
			MEDIUM: "MEDIUM",
			XX_SMALL: "XX_SMALL",
			X_SMALL: "X_SMALL",
			SMALL: "SMALL",
			LARGE: "LARGE",
			X_LARGE: "X_LARGE",
			XX_LARGE: "XX_LARGE",
			SMALLER: "SMALLER",
			LARGER: "LARGER"
		});

		var FONT_STYLES = Object.freeze({
			NORMAL: "NORMAL",
			ITALIC: "ITALIC",
			OBLIQUE: "OBLIQUE"
		});

		var FONT_WEIGHTS = Object.freeze({
			NORMAL: "NORMAL",
			BOLD: "BOLD"
		});

		var TEXT_ALIGNS = Object.freeze({
			LEFT: "LEFT",
			RIGHT: "RIGHT",
			CENTER: "CENTER",
			JUSTIFY: "JUSTIFY"
		});

		var TEXT_DECORATION_LINES = Object.freeze({
			NONE: "NONE",
			UNDERLINE: "UNDERLINE",
			OVERLINE: "OVERLINE",
			LINE_THROUGH: "LINE_THROUGH"
		});

		var TEXT_DECORATION_STYLES = Object.freeze({
			SOLID: "SOLID",
			DOUBLE: "DOUBLE",
			DOTTED: "DOTTED",
			DASHED: "DASHED",
			WAVY: "WAVY"
		});

		var POSITIONS = Object.freeze({
			LEFT: "LEFT",
			RIGHT: "RIGHT",
			CENTER: "CENTER",
			TOP: "TOP",
			BOTTOM: "BOTTOM"
		});

		var UNITS = Object.freeze({
			CM: "CM",
			MM: "MM",
			IN: "IN",
			PX: "PX",
			PT: "PT",
			PC: "PC",
			EM: "EM",
			EX: "EX",
			CH: "CH",
			REM: "REM",
			VW: "VW",
			VH: "VH",
			VMIN: "VMIN",
			VMAX: "VMAX"
		});

		var ASPECTS = Object.freeze({
			VALUE: "value",
			COLOR: "color"
		});

		var validAspectTypes = [];
		Object.getOwnPropertyNames(ASPECTS).forEach(function(aspectType){
			validAspectTypes.push(ASPECTS[aspectType]);
		});

		var CHART_TYPE = Object.freeze({
			AREA: "AREA",
			BAR: "BAR",
			LINE: "LINE",
			COLUMN: "COLUMN"
		});

		var validChartTypes = [];
		Object.getOwnPropertyNames(CHART_TYPE).forEach(function(chartType){
			validChartTypes.push(CHART_TYPE[chartType]);
		});

		var STACKING = Object.freeze({
			DISABLED: 'DISABLED',
			NORMAL: 'NORMAL',
			PERCENT: 'PERCENT'
		});

		var validStackings = [];
		Object.getOwnPropertyNames(STACKING).forEach(function(stacking){
			validStackings.push(STACKING[stacking]);
		});

		var AGGREGATION = Object.freeze({
			AVG: "AVG",
			MIN: "MIN",
			MAX: "MAX",
			MEDIAN: "MEDIAN",
			COUNT: "COUNT",
			COUNT_DISTINCT: "COUNT_DISTINCT",
			SUM: "SUM"
		});

		var validAggregations = [];
		Object.getOwnPropertyNames(AGGREGATION).forEach(function(agg){
			validAggregations.push(AGGREGATION[agg]);
		});

		var TOTAL_LINE = Object.freeze({
			HIDDEN: "HIDDEN",
			FIRST_LINE: "FIRST_LINE",
			LAST_LINE: "LAST_LINE"
		});

		var validTotalling = [];
		Object.getOwnPropertyNames(TOTAL_LINE).forEach(function(total){
			validTotalling.push(TOTAL_LINE[total]);
		});

		/**
		 * @class DescendantOrSelfNodesSelector
		 * @classDescription Used to select all sub nodes from a certain path in a pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function DescendantOrSelfNodesSelector()
		{
			/**
			 * Returns the object type name (workbook.DescendantOrSelfNodesSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.DescendantOrSelfNodesSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					selectorName: 'DescendantOrSelfNodes'
				};
			};
		}

		DescendantOrSelfNodesSelector.prototype = nsobject.getNewInstance();

		var descendantOrSelfNodesSelector = new DescendantOrSelfNodesSelector();

		/**
		 * @class Aspect
		 * @classDescription Aspect of a series in a chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Aspect(options)
		{
			var type = options.type || "value";
			var measure = options.measure;

			/**
			 * type of this aspect - color|measure
			 * @name Aspect#type
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_ASPECT_TYPE when the type outside of the AspectType enum
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return type;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'type', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validAspectTypes, val, false), error.Type.INVALID_ASPECT_TYPE, val);
					type = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * measure of this aspect
			 * @name Aspect#measure
			 * @type {DataMeasure | CalculatedMeasure}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * 
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'measure', {
				get: function ()
				{
					return measure;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataMeasure") && !utilityFunctions.checkObjectType(val, "workbook.CalculatedMeasure"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measure', 'workbook.DataMeasure|workbook.CalculatedMeasure');
					measure = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			this.toString = function toString()
			{
				return "workbook.Aspect";
			};

			this.toJSON = function toJSON()
			{
				return {
					type: type,
					measure: measure
				};
			};
		}

		Aspect.prototype = nsobject.getNewInstance();

		/**
		 * @class Category
		 * @classDescription Category of a chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Category(options)
		{
			var axis = options.axis;
			var root = options.root;
			var sortDefinitions = options.sortDefinitions || [];

			/**
			 * Axis for this category
			 * @name Category#axis
			 * @type {ChartAxis}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'axis', {
				get: function ()
				{
					return axis;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.ChartAxis"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'axis', 'workbook.ChartAxis');
					axis = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Section or data dimension
			 * @name Category#root
			 * @type {Section | DataDimension}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return root;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Section") && !utilityFunctions.checkObjectType(val, "workbook.DataDimension"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'root', 'workbook.Section|workbook.DataDimension');
					root = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Sort definitions
			 * @name Category#sortDefinitions
			 * @type {Array<SortDefinition>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sortDefinitions', {
				get: function ()
				{
					return sortDefinitions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(sortDefinition){
							return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
						}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sortDefinitions', 'workbook.SortDefinitions[]');
					sortDefinitions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Category)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Category";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					axis: axis,
					root: root,
					sortDefinitions: sortDefinitions
				};
			};
		}

		/**
		 * @class Chart
		 * @classDescription Object representing a chart of a workbook
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Chart(options)
		{
			var name = options.name;
			var portletName = options.portletName || null;
			var title = options.title || "";
			var subTitle = options.subTitle || "";
			var type = options.type || "COLUMN";
			var id = options.id;
			var stacking = options.stacking || "DISABLED";
			var dataset = options.dataset || null;
			var datasetLink = options.datasetLink || null;
			var legend = options.legend;
			var category = options.category;
			var filterExpressions = options.filterExpressions || [];
			var series = options.series || [];
			var aggregationFilters = options.aggregationFilters || [];

			/**
			 * name of the chart
			 * @name Chart#name
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name', 'string or Expression<TRANSLATE>');
					name = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * portlet name of the chart
			 * @name Chart#portletName
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'portletName', {
				get: function ()
				{
					return portletName;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'portletName', 'string or Expression<TRANSLATE>');
					portletName = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * title of the chart
			 * @name Chart#title
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'title', {
				get: function ()
				{
					return title;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'title', 'string or Expression<TRANSLATE>');
					title = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Subtitle of the chart
			 * @name Chart#subTitle
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'subTitle', {
				get: function ()
				{
					return subTitle;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'subTitle', 'string or Expression<TRANSLATE>');
					subTitle = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the chart
			 * @name Chart#id
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'string');
					id = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * stacking settings
			 * @name Chart#stacking
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_STACKING_TYPE when assigned value is outside of Stacking enum
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'stacking', {
				get: function ()
				{
					return stacking;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'stacking', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validStackings, val, false), error.Type.INVALID_STACKING_TYPE, val);
					stacking = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Filter expressions
			 * @name Chart#filterExpressions
			 * @type {Array<Expression>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'filterExpressions', {
				get: function ()
				{
					return filterExpressions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(filter){
							return utilityFunctions.checkObjectType(filter, "workbook.Expression");
						}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filterExpressions', 'workbook.Expression[]');
					filterExpressions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Limiting and conditional filters
			 * @name Chart#aggregationFilters
			 * @type {Array<LimitingFilter> | Array<ConditionalFilter>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'aggregationFilters', {
				get: function ()
				{
					return aggregationFilters;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(aggregationFilter){
						return utilityFunctions.checkObjectType(aggregationFilter, "workbook.ConditionalFilter") || utilityFunctions.checkObjectType(aggregationFilter, "workbook.LimitingFilter");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'aggregationFilters', '(workbook.ConditionalFilter|workbook.LimitingFilter)[]');
					aggregationFilters = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Legend of the chart
			 * @name Chart#legend
			 * @type {Legend}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'legend', {
				get: function ()
				{
					return legend;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Legend"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'legend', 'workbook.Legend');
					legend = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Category of the chart
			 * @name Chart#category
			 * @type {Category}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'category', {
				get: function ()
				{
					return category;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Category"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'category', 'workbook.Category');
					category = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Series of the chart
			 * @name Chart#series
			 * @type {Series}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'series', {
				get: function ()
				{
					return series;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(series){
						return utilityFunctions.checkObjectType(series, "workbook.Series");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'series', 'workbook.Series[]');
					series = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Type of the chart
			 * @name Chart#type
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_CHART_TYPE when value outside of ChartType enum is used for type parameter
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return type;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'type', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validChartTypes, val, false), error.Type.INVALID_CHART_TYPE, val);
					type = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Underlying dataset
			 * @name Chart#dataset
			 * @type {Dataset}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'dataset', {
				get: function ()
				{
					return dataset;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "dataset.Dataset"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'dataset', 'dataset.Dataset');
					if (datasetLink)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'dataset', 'datasetLink');
					dataset = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Underlying datasetLink
			 * @name Chart#datasetLink
			 * @type {DatasetLink}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'datasetLink', {
				get: function ()
				{
					return datasetLink;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "datasetLink.DatasetLink"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'datasetLink', 'datasetLink.DatasetLink');
					if (dataset)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'datasetLink', 'dataset');
					datasetLink = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Chart)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Chart";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					name: name,
					portletName: portletName,
					title: title,
					type: type,
					subTitle: subTitle,
					category: category,
					legend: legend,
					id: id,
					stacking: stacking,
					dataset: dataset,
					datasetLink: datasetLink,
					series: series,
					filterExpressions: filterExpressions,
					aggregationFilters: aggregationFilters
				};
			};
		}

		Chart.prototype = nsobject.getNewInstance();

		/**
		 * @class ChartAxis
		 * @classDescription Axis of a chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function ChartAxis(options)
		{
			var title = options.title;

			/**
			 * Title of the axis
			 * @name ChartAxis#title
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'title', {
				get: function ()
				{
					return title;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'title', 'string or Expression<TRANSLATE>');
					title = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.ChartAxis)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.ChartAxis";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					title: title
				};
			};
		}

		/**
		 * @class ChildNodesSelector
		 * @classDescription Used to select all child nodes from a certain path in a pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function ChildNodesSelector()
		{
			/**
			 * Returns the object type name (workbook.ChildNodesSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.ChildNodesSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					selectorName: 'ChildNodes'
				};
			};
		}

		ChildNodesSelector.prototype = nsobject.getNewInstance();

		var childNodesSelector = new ChildNodesSelector();

		/**
		 * @class ConditionalFilter
		 * @classDescription Object for pivot filtering based on a measure
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function ConditionalFilter(options)
		{
			var row = options.row;
			var measure = options.measure;
			var rowSelector = options.rowSelector;
			var columnSelector = options.columnSelector;
			var predicate = options.predicate;

			/**
			 * Indicator, whether filtering is appliad on rows (on columns if set to false)
			 * @name ConditionalFilter#row
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'row', {
				get: function ()
				{
					return row;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'row', 'boolean');
					row = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Measure for this filter
			 * @name ConditionalFilter#measure
			 * @type {DataMeasure | CalculatedMeasure}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'measure', {
				get: function ()
				{
					return measure;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataMeasure") && !utilityFunctions.checkObjectType(val, "workbook.CalculatedMeasure"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measure', 'workbook.DataMeasure|workbook.CalculatedMeasure');
					measure = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Row selector
			 * @name ConditionalFilter#rowSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'rowSelector', {
				get: function ()
				{
					return rowSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'rowSelector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					rowSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Column selector
			 * @name ConditionalFilter#columnSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'columnSelector', {
				get: function ()
				{
					return columnSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columnSelector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					columnSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * The actual predicate which sayes whether the condition is met
			 * @name ConditionalFilter#predicate
			 * @type {Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'predicate', {
				get: function ()
				{
					return predicate;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Expression"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'predicate', 'workbook.Expression');
					predicate = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (dataset.Dataset)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.ConditionalFilter";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */

			this.toJSON = function toJSON()
			{
				return {
					row: row,
					measure: measure,
					rowSelector: rowSelector,
					columnSelector: columnSelector,
					predicate: predicate
				};
			};

		}

		ConditionalFilter.prototype = nsobject.getNewInstance();

		/**
		 * @class DataDimension
		 * @classDescription Object representing data dimension in a pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function DataDimension(options)
		{
			var totalLine = options.totalLine || "HIDDEN";
			var children = options.children || [];
			var items = options.items;

			/**
			 * Value of total line - HIDDEN/FIRST_LINE/LAST_LINE
			 * @name DataDimension#totalLine
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_TOTAL_LINE when the value is outside of TotalLine enum
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'totalLine', {
				get: function ()
				{
					return totalLine;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'totalLine', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validTotalling, val, false), error.Type.INVALID_TOTAL_LINE, val);
					totalLine = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Children of this data dimension
			 * @name DataDimension#children
			 * @type {Array<Section> | Array<DataDimension> | Array<DataMeasure> | Array<CalculatedMeasure>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'children', {
				get: function ()
				{
					return children;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(child){
							return utilityFunctions.checkObjectType(child, "workbook.Section") || utilityFunctions.checkObjectType(child, "workbook.DataDimension") || utilityFunctions.checkObjectType(child, "workbook.DataMeasure") || utilityFunctions.checkObjectType(child, "workbook.CalculatedMeasure");
						}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'children', '(workbook.Section|workbook.DataDimension|workbook.DataMeasure|workbook.CalculatedMeasure)[]');
					children = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * items of this data dimension
			 * @name DataDimension#items
			 * @type {Array<DataDimensionItem>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'items', {
				get: function ()
				{
					return items;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(child){
						return utilityFunctions.checkObjectType(child, "workbook.DataDimensionItem")
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'items', 'workbook.DataDimensionItem[]');
					if (val.length)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_DIMENSION_ITEM_DEFINED);
					items = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.DataDimension)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.DataDimension";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					totalLine: totalLine,
					children: children,
					items: items
				};
			};
		}

		DataDimension.prototype = nsobject.getNewInstance();

		/**
		 * @class DataDimensionItem
		 * @classDescription Object representing data dimension item of a data dimension
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function DataDimensionItem(options)
		{
			var label = options.label || null;
			var expr = options.expression;

			/**
			 * Label
			 * @name DataDimensionItem#label
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return label;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'label', 'string or Expression<TRANSLATE>');
					label = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Expression for data dimension item
			 * @name DataDimensionItem#expression
			 * @type {Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'expression', {
				get: function ()
				{
					return expr;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Expression"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expression', 'workbook.Expression');
					expr = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.DataDimensionItem)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.DataDimensionItem";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					expression: expr,
					label: label
				};
			};
		}

		DataDimensionItem.prototype = nsobject.getNewInstance();

		/**
		 * @class DimensionSelector
		 * @classDescription Used to select a dimension in a pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function DimensionSelector(options)
		{
			var dimension = options.dimension;

			/**
			 * Dimension of this selector
			 * @name DimensionSelector#dimension section or data dimension
			 * @type {Section | DataDimension}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'dimension', {
				get: function ()
				{
					return dimension;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataDimension") && !utilityFunctions.checkObjectType(val, "workbook.Section"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'dimension', 'workbook.DataDimension|workbook.Section');
					dimension = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.DimensionSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.DimensionSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					dimension: dimension,
					selectorName: 'Dimension'
				};
			};
		}

		DimensionSelector.prototype = nsobject.getNewInstance();

		/**
		 * @class SortByDataDimensionItem
		 * @classDescription Sort by option for data dimension items
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function SortByDataDimensionItem(options)
		{
			var sort = options.sort;
			var item = options.item;

			/**
			 * Sort object for this dimension sort
			 * @name SortByDataDimensionItem#sort
			 * @type {Sort}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sort', {
				get: function ()
				{
					return sort;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Sort"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'workbook.Sort');
					sort = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Data dimension item
			 * @name SortByDataDimensionItem#item
			 * @type {DataDimensionItem}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'item', {
				get: function ()
				{
					return item;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataDimensionItem"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'item', 'workbook.DataDimensionItem');
					item = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.SortByDataDimensionItem)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.SortByDataDimensionItem";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					sort: sort,
					item: item
				};
			};
		}

		SortByDataDimensionItem.prototype = nsobject.getNewInstance();

		/**
		 * @class FieldContext
		 * @classDescription Object for specifying in which context should the field in the table view column be displayed
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function FieldContext(options)
		{
			var name = options.name;
			var parameters = options.parameters || {};

			/**
			 * Name of the context (DISPLAY, CURRENCY_CONSOLIDATED, CONVERTED ...)
			 * @name FieldContext#name
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name', 'string');
					name = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * parameters of the context
			 * @name FieldContext#parameters
			 * @type {Object}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'parameters', {
				get: function ()
				{
					return parameters;
				},
				set: function (val)
				{
					if (!util.isObject(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'parameters', 'object');
					if (!util.isNumber(val.currencyId))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'parameters.currencyId', 'number');
					if (!util.isDate(parameters.date))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'parameters.data', 'date');
					parameters = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.FieldContext)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.FieldContext";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				var params = parameters;
				if (params.date)
				{
					if (query._isRelativeDate(params.date))
						params.date = params.date.toJSON();
					else if (util.isDate(params.date))
					params.date = format.format({value: params.date, type: format.Type.DATE});
				}
				return {
					name: name,
					parameters: params
				};
			};
		}

		FieldContext.prototype = nsobject.getNewInstance();

		/**
		 * @class LimitingFilter
		 * @classDescription Object representing limiting aggregation filter
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function LimitingFilter(options)
		{
			var row = options.row;
			var filteredNodesSelector = options.filteredNodesSelector;
			var sortBys = options.sortBys;
			var limit = options.limit;

			/**
			 * Row axis indicator
			 * @name LimitingFilter#row
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'row', {
				get: function ()
				{
					return row;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'row', 'boolean');
					row = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Sort by elements of this filter
			 * @name LimitingFilter#sortBys
			 * @type {Array<SortByDataDimensionItem> | Array<SortByMeasure>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sortBys', {
				get: function ()
				{
					return sortBys;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(sortBy){
						return utilityFunctions.checkObjectType(sortBy, "workbook.SortByMeasure") || utilityFunctions.checkObjectType(sortBy, "workbook.SortByDataDimensionItem")
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sortBys', '(workbook.SortByDataDimensionItem|workbook.SortByMeasure)[]');
					sortBys = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * What to filter
			 * @name LimitingFilter#filteredNodesSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'filteredNodesSelector', {
				get: function ()
				{
					return filteredNodesSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filteredNodesSelector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					filteredNodesSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Limit number for this filter
			 * @name LimitingFilter#limit
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'limit', {
				get: function ()
				{
					return limit;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'limit', 'number');
					limit = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.LimitingFilter)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.LimitingFilter";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					row: row,
					sortBys: sortBys,
					filteredNodesSelector: filteredNodesSelector,
					limit: limit
				};
			};
		}

		LimitingFilter.prototype = nsobject.getNewInstance();

		/**
		 * @class CalculatedMeasure
		 * @classDescription Object representing calculated measure to be used in pivot or chart
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function CalculatedMeasure(options)
		{
			var expression = options.expression;
			var label = options.label;
			var _id = options.id;

			/**
			 * expression for this calculated measure
			 * @name CalculatedMeasure#expression
			 * @type {Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'expression', {
				get: function ()
				{
					return expression;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Expression"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expression', 'workbook.Expression');
					expression = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * label of the measure
			 * @name CalculatedMeasure#label
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return label;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'label', 'string or Expression<TRANSLATE>');
					label = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the measure
			 * @name CalculatedMeasure#_id
			 * @type {number}
			 *
			 * @since 2024.2
			 */
			Object.defineProperty(this, '_id', {
				get: function ()
				{
					return _id;
				},
				set: function (val)
				{

				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (workbook.CalculatedMeasure)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.CalculatedMeasure";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					expression: expression,
					label: label,
					id: _id
				};
			};
		}

		CalculatedMeasure.prototype = nsobject.getNewInstance();

		/**
		 * @class DataMeasure
		 * @classDescription Object representing data measure to be used in pivot or chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function DataMeasure(options)
		{
			var aggregation = options.aggregation;
			var expr = options.expression;
			var expressions = options.expressions;
			var label = options.label;
			var _id = options.id;

			/**
			 * desired aggregation of the measure
			 * @name DataMeasure#aggregation
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_AGGREGATION when the the value is outside of Aggregation enum
			 * @throws {SuiteScriptError} EXPRESSIONS_MUST_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION when trying to assign count distinct aggregation while expressions are not specified
			 * @throws {SuiteScriptError} EXPRESSION_MUST_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION when trying to assign other that count distinct aggregation while expression is not specified
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'aggregation', {
				get: function ()
				{
					return aggregation;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'aggregation', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validAggregations, val, false), error.Type.INVALID_AGGREGATION, val);
					if (val == "COUNT_DISTINCT" && !expressions)
						utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSIONS_MUST_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION);
					if (val != "COUNT_DISTINCT" && !options.expression)
						utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSION_MUST_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION);
					aggregation = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * expression for this measure, used if this is a single expression measure (cannot be used when doing COUNT_DISTINCT aggregation)
			 * @name DataMeasure#expression
			 * @type {Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS when expressions are already defined
			 * @throws {SuiteScriptError} EXPRESSION_CANNOT_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION when count distinct aggregation is used
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'expression', {
				get: function ()
				{
					return expr;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Expression"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expression', 'workbook.Expression');
					if (expressions)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'expression', 'expressions');
					if (aggregation == "COUNT_DISTINCT")
						utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSION_CANNOT_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION);
					expr = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * expressions for this measure, used if this is a multi expression measure (needed when COUNT_DISTINCT aggregation is used)
			 * @name DataMeasure#expressions
			 * @type {Array<Expression>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS expression is already defined
			 * @throws {SuiteScriptError} AT_LEAST_ONE_EXPRESSION_IS_NEEDED supplied expressions array is empty
			 * @throws {SuiteScriptError} EXPRESSIONS_CANNOT_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION when other than count distinct aggregation is used
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'expressions', {
				get: function ()
				{
					return expressions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(expression){
						return utilityFunctions.checkObjectType(expression, "workbook.Expression");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expressions', 'workbook.Expression[]');
					if (expr)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'expression', 'expressions');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.AT_LEAST_ONE_EXPRESSION_IS_NEEDED);
					if (aggregation != "COUNT_DISTINCT")
						utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSIONS_CANNOT_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION);
					expressions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * label of the measure
			 * @name DataMeasure#label
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return label;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'label', 'string or Expression<TRANSLATE>');
					label = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the measure
			 * @name DataMeasure#_id
			 * @type {number}
			 *
			 * @since 2024.2
			 */
			Object.defineProperty(this, '_id', {
				get: function ()
				{
					return _id;
				},
				set: function (val)
				{
				},
				enumerable: false,
				configurable: false,
				writeable: false
			});

			/**
			 * Returns the object type name (workbook.DataMeasure)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.DataMeasure";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					aggregation: aggregation,
					expression: expr,
					expressions: expressions,
					label: label,
					id: _id
				};
			};
		}

		DataMeasure.prototype = nsobject.getNewInstance();

		/**
		 * @class Legend
		 * @classDescription Legend of a chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Legend(options)
		{
			var axes = options.axes || [];
			var root = options.root;
			var sortDefinitions = options.sortDefinitions || [];

			/**
			 * Axes of this legend
			 * @name Legend#axes
			 * @type {Array<ChartAxis>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'axes', {
				get: function ()
				{
					return axes;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(axis){
						return utilityFunctions.checkObjectType(axis, "workbook.ChartAxis");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'axes', '(workbook.SortByDataDimensionItem|workbook.SortByMeasure)[]');
					axes = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Section or data dimension
			 * @name Legend#root
			 * @type {Section | DataDimension}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return root;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Section") && !utilityFunctions.checkObjectType(val, "workbook.DataDimension"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'root', 'workbook.Section|workbook.DataDimension');
					root = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Sort definitions
			 * @name Legend#sortDefinitions
			 * @type {Array<SortDefinition>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sortDefinitions', {
				get: function ()
				{
					return sortDefinitions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(sortDefinition){
						return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sortDefinitions', 'workbook.SortDefinition[]');
					sortDefinitions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Legend)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Legend";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					axes: axes,
					root: root,
					sortDefinitions: sortDefinitions,
				};
			};
		}

		/**
		 * @class MeasureSelector
		 * @classDescription Selector for measures to be used in conditional formatting of pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function MeasureSelector(options)
		{
			var measures = options.measures;
			/**
			 * Measures of this selector
			 * @name MeasureSelector#measures
			 * @type {Array<CalculatedMeasure> | Array<DataMeasure>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the array is empty
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'measures', {
				get: function ()
				{
					return measures;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(child){
						return utilityFunctions.checkObjectType(child, "workbook.DataMeasure") || utilityFunctions.checkObjectType(child, "workbook.CalculatedMeasure");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measures', '(workbook.DataMeasure|workbook.CalculatedMeasure)[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_MEASURES_DEFINED);
					measures = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.MeasureSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.MeasureSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					measures: measures
				};
			};
		}

		MeasureSelector.prototype = nsobject.getNewInstance();

		/**
		 * @class SortByMeasure
		 * @classDescription Sort by option for measures
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function SortByMeasure(options)
		{
			var sort = options.sort;
			var measure = options.measure;
			var otherAxisSelector = options.otherAxisSelector;

			/**
			 * Sort object for this sort
			 * @name SortByMeasure#sort
			 * @type {Sort}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sort', {
				get: function ()
				{
					return sort;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Sort"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'workbook.Sort');
					sort = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * This sort's measure
			 * @name SortByMeasure#parameters
			 * @type {DataMeasure | CalculatedMeasure}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 */
			Object.defineProperty(this, 'measure', {
				get: function ()
				{
					return measure;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataMeasure") && !utilityFunctions.checkObjectType(val, "workbook.CalculatedMeasure"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measure', 'workbook.DataMeasure|workbook.CalculatedMeasure');
					measure = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * In a sort definition, the sort is applied to a row or column, this is the selector for the other axis
			 * @name SortByMeasure#otherAxisSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'otherAxisSelector', {
				get: function ()
				{
					return otherAxisSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'otherAxisSelector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					otherAxisSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.SortByMeasure)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.SortByMeasure";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					sort: sort,
					measure: measure,
					otherAxisSelector: otherAxisSelector
				};
			};
		}

		SortByMeasure.prototype = nsobject.getNewInstance();

		/**
		 * @class MeasureValueSelector
		 * @classDescription Selector for selecting a measure value using row, column and list of measures to use
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function MeasureValueSelector(options)
		{
			var measureSelector = options.measureSelector;
			var rowSelector = options.rowSelector;
			var columnSelector = options.columnSelector;

			/**
			 * Measure selector
			 * @name MeasureValueSelector#measureSelector
			 * @type {Array<MeasureSelector>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'measureSelector', {
				get: function ()
				{
					return measureSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.MeasureSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measureSelector', 'workbook.MeasureSelector');
					measureSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * select row where to apply styling
			 * @name ReportStyle#rowSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'rowSelector', {
				get: function ()
				{
					return rowSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'selector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					rowSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * select column where to apply styling
			 * @name ReportStyle#rowSelector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'columnSelector', {
				get: function ()
				{
					return columnSelector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'selector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					columnSelector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});


			/**
			 * Returns the object type name (workbook.MeasureValueSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.MeasureValueSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					measureSelector: measureSelector,
					columnSelector: columnSelector,
					rowSelector: rowSelector
				};
			};
		}

		MeasureValueSelector.prototype = nsobject.getNewInstance();

		/**
		 * @class PathSelector
		 * @classDescription Used to select a portion of a pivot aither for sorting or filtering
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function PathSelector(options)
		{
			var elements = options.elements;

			/**
			 * Elements denoting 'xpath' of this selector
			 * @name DimensionSelector#dimension section or data dimension
			 * @type {DescendantOrSelfNodesSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_ELEMENTS_DEFINED when the array is empty
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'elements', {
				get: function ()
				{
					return elements;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(selector){
						return utilityFunctions.checkObjectType(selector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(selector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(selector, "workbook.ChildNodesSelector");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'elements', '(workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.ChildNodesSelector)[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_ELEMENTS_DEFINED);
					elements = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PathSelector)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.PathSelector";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					elements: elements,
					selectorName: 'Path'
				};
			};
		}

		PathSelector.prototype = nsobject.getNewInstance();

		/**
		 * @class Pivot
		 * @classDescription Object representing SuiteAnalytics pivot
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Pivot(options)
		{
			var filterExpressions = options.filterExpressions || [];
			var aggregationFilters = options.aggregationFilters || [];
			var name = options.name;
			var portletName = options.portletName || null;
			var id = options.id;
			var rowAxis = options.rowAxis;
			var columnAxis = options.columnAxis;
			var dataset = options.dataset || null;
			var datasetLink = options.datasetLink || null;
			var reportStyles = options.reportStyles || [];

			/**
			 * Filter expressions
			 * @name Pivot#filterExpressions
			 * @type {Array<Expression>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'filterExpressions', {
				get: function ()
				{
					return filterExpressions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(filter){
						return utilityFunctions.checkObjectType(filter, "workbook.Expression");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filterExpressions', 'workbook.Expression[]');
					filterExpressions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Limiting and conditional filters
			 * @name Pivot#aggregationFilters
			 * @type {Array<LimitingFilter> | Array<ConditionalFilter>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'aggregationFilters', {
				get: function ()
				{
					return aggregationFilters;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(aggregationFilter){
						return utilityFunctions.checkObjectType(aggregationFilter, "workbook.ConditionalFilter") || utilityFunctions.checkObjectType(aggregationFilter, "workbook.LimitingFilter");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'aggregationFilters', '(workbook.ConditionalFilter|workbook.LimitingFilter)[]');
					aggregationFilters = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * name of the pivot
			 * @name Pivot#name
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name', 'string or Expression<TRANSLATE>');
					name = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * portlet name of the pivot
			 * @name Pivot#portletName
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'portletName', {
				get: function ()
				{
					return portletName;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'portletName', 'string or Expression<TRANSLATE>');
					portletName = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the pivot
			 * @name Pivot#id
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'string');
					id = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Column axis of this pivot
			 * @name Pivot#columnAxis
			 * @type {PivotAxis}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'columnAxis', {
				get: function ()
				{
					return columnAxis;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.PivotAxis"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columnAxis', 'workbook.PivotAxis');
					columnAxis = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Row axis of this pivot
			 * @name Pivot#rowAxis
			 * @type {PivotAxis}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'rowAxis', {
				get: function ()
				{
					return rowAxis;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.PivotAxis"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'rowAxis', 'workbook.PivotAxis');
					rowAxis = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Underlying dataset
			 * @name Pivot#dataset
			 * @type {Dataset}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'dataset', {
				get: function ()
				{
					return dataset;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "dataset.Dataset"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'dataset', 'dataset.Dataset');
					if (datasetLink)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'dataset', 'datasetLink');
					dataset = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Underlying datasetLink
			 * @name Pivot#datasetLink
			 * @type {DatasetLink}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'datasetLink', {
				get: function ()
				{
					return datasetLink;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "datasetLink.DatasetLink"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'datasetLink', 'datasetLink.DatasetLink');
					if (dataset)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'datasetLink', 'dataset');
					datasetLink = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Report styles
			 * @name Pivot#reportStyles
			 * @type {Array<ReportStyle>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'reportStyles', {
				get: function ()
				{
					return reportStyles;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(filter){
						return utilityFunctions.checkObjectType(filter, "workbook.ReportStyle");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'reportStyles', 'workbook.ReportStyle[]');
					reportStyles = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Pivot)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Pivot";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					filterExpressions: filterExpressions,
					aggregationFilters: aggregationFilters,
					name: name,
					portletName: portletName,
					id: id,
					columnAxis: columnAxis,
					rowAxis: rowAxis,
					dataset: dataset,
					datasetLink: datasetLink,
					reportStyles: reportStyles
				};
			};
		}

		Pivot.prototype = nsobject.getNewInstance();

		/**
		 * @class Pivot axis
		 * @classDescription Pivot axis holds root dimension a its sorts
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function PivotAxis(options)
		{
			var root = options.root;
			var sortDefinitions = options.sortDefinitions || [];

			/**
			 * Root data definition
			 * @name PivotAxis#root
			 * @type {DataDimension | Section}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'root', {
				get: function ()
				{
					return root;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Section") && !utilityFunctions.checkObjectType(val, "workbook.DataDimension"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'root', 'workbook.Section|workbook.DataDimension');
					root = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Sort definitions
			 * @name Category#sortDefinitions
			 * @type {Array<SortDefinition>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sortDefinitions', {
				get: function ()
				{
					return sortDefinitions;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(sortDefinition){
						return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sortDefinitions', 'workbook.SortDefinition[]');
					sortDefinitions = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PivotAxis)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.PivotAxis";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					root: root,
					sortDefinitions: sortDefinitions
				};
			};
		}

		/**
		 * @class Series
		 * @classDescription Series of a chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Series(options)
		{
			var aspects = options.aspects;

			/**
			 * Aspects for this series
			 * @name Series#aspects
			 * @type {Array<Aspect>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_ASPECTS_DEFINED when the array is empty
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'aspects', {
				get: function ()
				{
					return aspects;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(aspect){
						return utilityFunctions.checkObjectType(aspect, "workbook.Aspect");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'aspects', 'workbook.Aspect[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_ASPECTS_DEFINED);
					aspects = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Series)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Series";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					aspects: aspects
				};
			};
		}

		Series.prototype = nsobject.getNewInstance();

		/**
		 * @class Section
		 * @classDescription Object representing section of a pivot - used for creating a hierarchy tree
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Section(options)
		{
			var totalLine = options.totalLine || "HIDDEN";
			var children = options.children || [];

			/**
			 * Value of total line - HIDDEN/FIRST_LINE/LAST_LINE
			 * @name Section#totalLine
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_TOTAL_LINE when the value is outside of TotalLine enum
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'totalLine', {
				get: function ()
				{
					return totalLine;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'totalLine', 'string');
					utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validTotalling, val, false), error.Type.INVALID_TOTAL_LINE, val);
					totalLine = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Children of this section
			 * @name Section#children
			 * @type {Array<CalculatedMeasure> | Array<DataMeasure> | Array<DataDimension> | Array<Section>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_CHILDREN_DEFINED when the array is empty
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'children', {
				get: function ()
				{
					return children;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(child){
						return utilityFunctions.checkObjectType(child, "workbook.Section") || utilityFunctions.checkObjectType(child, "workbook.DataDimension") || utilityFunctions.checkObjectType(child, "workbook.DataMeasure") || utilityFunctions.checkObjectType(child, "workbook.CalculatedMeasure");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'children', '(workbook.Section|workbook.DataDimension|workbook.DataMeasure|workbook.CalculatedMeasure)[]');
					children = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Section)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Section";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */

			this.toJSON = function toJSON()
			{
				return {
					totalLine: totalLine,
					children: children
				};
			};
		}

		Section.prototype = nsobject.getNewInstance();

		/**
		 * @class Sort
		 * @classDescription Object which can be used in sort definitions
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Sort(options)
		{
			var caseSensitive = options.caseSensitive;
			var ascending = options.ascending;
			var nullsLast = options.nullsLast;
			var locale = options.locale || null;
			var order = options.order || 0;

			/**
			 * ascending indicator
			 * @name Sort#ascending
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'ascending', {
				get: function ()
				{
					return ascending;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'ascending', 'boolean');
					ascending = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * locale of the sort
			 * @name Sort#locale
			 * @type {string}
			 * @throws {SuiteScriptError} INVALID_SORT_LOCALE if the locale is invalid
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'locale', {
				get: function ()
				{
					return locale;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'locale', 'string');
					queryInternal.validateSortLocale(val);
					locale = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * nullsLast indicator
			 * @name Sort#nullsLast
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'nullsLast', {
				get: function ()
				{
					return nullsLast;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'nullsLast', 'boolean');
					nullsLast = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * case sensitivity indicator
			 * @name Sort#caseSensitive
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'caseSensitive', {
				get: function ()
				{
					return caseSensitive;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'boolean');
					caseSensitive = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

            /**
             * sort order indicator
             * @name Sort#order
             * @type {number}
             * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
             *
             * @since 2022.2
             */
            Object.defineProperty(this, 'order', {
				get: function ()
				{
					return order;

				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sort', 'number');
					order = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

            /**
			 * Returns the object type name (workbook.Sort)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Sort";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					caseSensitive: caseSensitive,
					nullsLast: nullsLast,
					ascending: ascending,
					locale: locale
				};
			};
		}

		Sort.prototype = nsobject.getNewInstance();

		/**
		 * @class SortDefinition
		 * @classDescription Object used for defining a sort in a pivot or chart
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function SortDefinition(options)
		{
			var sortBys = options.sortBys;
			var selector = options.selector;

			/**
			 * Dimension and measure sorts
			 * @name LimitingFilter#sortBys
			 * @type {Array<SortByDataDimensionItem> | Array<SortByMeasure>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'sortBys', {
				get: function ()
				{
					return sortBys;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(sortBy){
						return utilityFunctions.checkObjectType(sortBy, "workbook.SortByMeasure") || utilityFunctions.checkObjectType(sortBy, "workbook.SortByDataDimensionItem")
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'sortBys', '(workbook.SortByMeasure|workbook.SortByDataDimensionItem)[]');
					sortBys = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Selector for this definition
			 * @name SortDefinition#selector
			 * @type {DescendantOrSelfNodesSelector | PathSelector | DimensionSelector | ChildNodesSelector}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'selector', {
				get: function ()
				{
					return selector;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DescendantOrSelfNodesSelector") && !utilityFunctions.checkObjectType(val, "workbook.DimensionSelector") && !utilityFunctions.checkObjectType(val, "workbook.PathSelector") && utilityFunctions.checkObjectType(val, "workbook.ChildNodesSelector"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'selector', 'workbook.DescendantOrSelfNodesSelector|workbook.DimensionSelector|workbook.PathSelector|workbook.ChildNodesSelector');
					selector = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.SortDefinition)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.SortDefinition";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					sortBys: sortBys,
					selector: selector
				};
			};
		}

		SortDefinition.prototype = nsobject.getNewInstance();

		/**
		 * @class Table
		 * @classDescription Object representing SuiteAnalytics table
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Table(options)
		{
			var dataset = options.dataset;
			var name = options.name;
			var portletName = options.portletName || null;
			var id = options.id;
			var columns = options.columns;

			/**
			 * Dataset used in table view
			 * @name Table#dataset
			 * @type {Dataset}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'dataset', {
				get: function ()
				{
					return dataset;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "dataset.Dataset"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'dataset', 'dataset.Dataset');
					dataset = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * name of the table view
			 * @name Table#name
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'name', 'string or Expression<TRANSLATE>');
					name = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * portlet name of the table view
			 * @name Table#portletName
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'portletName', {
				get: function ()
				{
					return portletName;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'portletName', 'string or Expression<TRANSLATE>');
					portletName = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the table view
			 * @name Table#id
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'id', 'string');
					id = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Columns used in table view
			 * @name Table#columns
			 * @type {Array<TableColumn>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'columns', {
				get: function ()
				{
					return columns;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(column){
						return utilityFunctions.checkObjectType(column, "workbook.TableColumn");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns', 'workbook.TableColumn[]');
					columns = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			this.toString = function toString()
			{
				return "workbook.Table";
			};

			this.toJSON = function toJSON()
			{
				return {
					dataset: dataset,
					id: id,
					name: name,
					portletName: portletName,
					columns: columns
				};
			};
		}

		Table.prototype = nsobject.getNewInstance();

		/**
		 * @class TableColumn
		 * @classDescription Column of a table view
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function TableColumn(options)
		{
			var condition = options.condition || null;
			var conditionalFormats = options.conditionalFormats || [];
			var width = options.width || null;
			var label = options.label || null;
			var sort = options.sort || null;
			var datasetColumnAlias = options.datasetColumnAlias;
			var fieldContext = options.fieldContext || null;

			/**
			 * condition for the column
			 * @name TableColumn#condition
			 * @type {TableColumnCondition}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'condition', {
				get: function ()
				{
					return condition;
				},
				set: function (val)
				{
					if (utilityFunctions.checkObjectType(val, "workbook.TableColumnCondition"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'condition', 'workbook.TableColumnCondition');
					condition = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * conditional formats for the column
			 * @name TableColumn#conditionalFormats
			 * @type {Array<ConditionalFormat>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'conditionalFormats', {
				get: function ()
				{
					return conditionalFormats;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(column){
						return utilityFunctions.checkObjectType(column, "workbook.ConditionalFormat");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'conditionalFormats', 'workbook.ConditionalFormats[]');
					conditionalFormats = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Context specification for the field used in this column
			 * @name TableColumn#fieldContext
			 * @type {FieldContext}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'fieldContext', {
				get: function ()
				{
					return fieldContext;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.FieldContext"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'fieldContext', 'workbook.FieldContext');
					fieldContext = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Alias of dataset column from which was this column created
			 * @name TableColumn#datasetColumnAlias
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS datasetColumnId is already defined
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'datasetColumnAlias', {
				get: function ()
				{
					return datasetColumnAlias;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'datasetColumnAlias', 'string');
					if (datasetColumnId)
						utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'datasetColumnId', 'datasetColumnAlias');
					datasetColumnAlias = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * desired width of the column in UI
			 * @name TableColumn#width
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 */
			Object.defineProperty(this, 'width', {
				get: function ()
				{
					return width;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'width', 'number');
					width = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * label of the column
			 * @name TableColumn#label
			 * @type {string | Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return label;
				},
				set: function (val)
				{
					if (!util.isString(val) && !expression.isTranslation(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'label', 'string or Expression<TRANSLATE>');
					label = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.TableColumn)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.TableColumn";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					width: width,
					sort: sort,
					label: label,
					fieldContext: fieldContext,
					datasetColumnAlias: datasetColumnAlias,
					conditionalFormats: conditionalFormats,
					condition: condition
				};
			};
		}

		TableColumn.prototype = nsobject.getNewInstance();

		/**
		 * @class TableColumnFilter
		 * @classDescription Filter for a table view column
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function TableColumnFilter(options)
		{
			var operator = options.operator;
			var values = options.values;
			var caseSensitive = options.caseSensitive;

			/**
			 * values for this filter
			 * @name TableColumnFilter#values
			 * @type {Array<boolean> | Array<number> | Array<string> | Array<Date> | Array<Object>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'values', {
				get: function ()
				{
					return values;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(value){
						return value == null || util.isString(value) || util.isBoolean(value) || util.isNumber(value) || util.isDate(value) || utilityFunctions.isObject(value);
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'values', '(null|string|boolean|number|date|object)[]');
					values = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * operator of this filter
			 * @name TableColumnFilter#operator
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID OPERATOR when the value is outside of query.Operator enum
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'operator', {
				get: function ()
				{
					return operator;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'operator', 'string');
					queryInternal.validateOperator(val, error.Type.INVALID_OPERATOR);
					operator = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * case sensitivity indicator
			 * @name Sort#caseSensitive
			 * @type {boolean}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'caseSensitive', {
				get: function ()
				{
					return caseSensitive;
				},
				set: function (val)
				{
					if (!util.isBoolean(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'caseSensitive', 'boolean');
					caseSensitive = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.TableColumnFilter)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.TableColumnFilter";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					values: values,
					operator: operator,
					caseSensitive: caseSensitive
				};
			};
		}

		TableColumnFilter.prototype = nsobject.getNewInstance();

		/**
		 * @class TableColumnCondition
		 * @classDescription Condition for a table view column
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function TableColumnCondition(options)
		{
			var operator = options.operator;
			var filters = options.filters;

			/**
			 * filters for this condition
			 * @name TableColumnCondition#filters
			 * @type {Array<TableColumnFilter>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'filters', {
				get: function ()
				{
					return filters;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(value){
						return utilityFunctions.checkObjectType(value, "workbook.TableColumnFilter");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filters', 'TableColumnFilter[]');
					filters = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * operator of this filter
			 * @name TableColumnCondition#operator
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID OPERATOR when the value is neither AND nor OR
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'operator', {
				get: function ()
				{
					return operator;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'operator', 'string');
					utilityFunctions.assertTrue(val == "OR" || val == "AND", error.Type.INVALID_OPERATOR, val);
					operator = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.TableColumnCondition)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.TableColumnCondition";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					filters: filters,
					operator: operator
				};
			};
		}

		TableColumnCondition.prototype = nsobject.getNewInstance();

		function ReportStyleRule(options)
		{
			var expression = options.expression;
			var style = options.style;

			/**
			 * boolean expression determining whether style should be applied
			 * @name ReportStyleRule#expression
			 * @type {Expression}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'expression', {
				get: function ()
				{
					return expression;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Expression"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'expression', 'workbook.Expression');
					expression = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * style to be applied
			 * @name ReportStyleRule#style
			 * @type {Style}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'style', {
				get: function ()
				{
					return style;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Style"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'style', 'workbook.Style');
					style = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.ReportStyleRule)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.ReportStyleRule";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					expression: expression,
					style: style
				};
			};
		}

		ReportStyleRule.prototype = nsobject.getNewInstance();

		/**
		 * @class ReportStyle
		 * @classDescription Conditional formatting object for reports
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function ReportStyle(options)
		{
			var selectors = options.selectors;
			var rules = options.rules;


			/**
			 * Selectors
			 * @name ReportStyle#selectors
			 * @type {Array<MeasureValueSelector>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_SELECTORS_DEFINED when the array is empty
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'selectors', {
				get: function ()
				{
					return selectors;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(child){
						return utilityFunctions.checkObjectType(child, "workbook.MeasureValueSelector");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'selectors', 'workbook.MeasureValueSelector[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_SELECTORS_DEFINED);
					selectors = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * measure of this report style
			 * @name ReportStyle#measure
			 * @type {DataMeasure | CalculatedMeasure}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'measure', {
				get: function ()
				{
					return measure;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.DataMeasure") && !utilityFunctions.checkObjectType(val, "workbook.CalculatedMeasure"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'measure', 'workbook.DataMeasure|workbook.CalculatedMeasure');
					measure = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Formatting rules for this report style
			 * @name ReportStyle#rules
			 * @type {Array<ReportStyleRule>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_RULE_DEFINED when the array is empty
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'rules', {
				get: function ()
				{
					return rules;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(pivot){
						return utilityFunctions.checkObjectType(pivot, "workbook.ConditionalFormatRule");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'rules', 'workbook.ReportStyleRule[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_RULE_DEFINED);
					rules = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.ReportStyle)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.ReportStyle";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					selectors: selectors,
					rules: rules
				};
			};

		};

		ReportStyle.prototype = nsobject.getNewInstance();

		/**
		 * @class ConditionalFormat
		 * @classDescription Conditional format object holding conditional format rules
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function ConditionalFormat(options)
		{
			var rules = options.rules;

			/**
			 * Formatting rules for this conditional format
			 * @name ConditionalFormat#rules
			 * @type {Array<ConditionalFormatRule>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} NO_RULE_DEFINED when the array is empty
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'rules', {
				get: function ()
				{
					return rules;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(pivot){
						return utilityFunctions.checkObjectType(pivot, "workbook.ConditionalFormatRule");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'rules', 'workbook.ConditionalFormatRule[]');
					if (val.length == 0)
						utilityFunctions.throwSuiteScriptError(error.Type.NO_RULE_DEFINED);
					rules = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.ConditionalFormat)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.ConditionalFormat";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					rules: rules
				};
			};
		}

		/**
		 * @class ConditionalFormatRule
		 * @classDescription Conditional format rule object for styling resulting cells of a table column
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function ConditionalFormatRule(options)
		{
			var filter = options.filter;
			var style = options.style;

			/**
			 * filter determining which rows/cells to apply the style to
			 * @name ConditionalFormatRule#filter
			 * @type {TableColumnFilter}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'filter', {
				get: function ()
				{
					return filter;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.TableColumnFilter"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filter', 'workbook.TableColumnFilter');
					filter = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * style for particular row/cell
			 * @name ConditionalFormatRule#style
			 * @type {Style}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'style', {
				get: function ()
				{
					return style;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.Style"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'style', 'workbook.Style');
					style = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.ConditionalFormatRule)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.ConditionalFormatRule";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					filter: filter,
					style: style
				};
			};
		}

		ConditionalFormatRule.prototype = nsobject.getNewInstance();

		/**
		 * @class Color
		 * @classDescription Color for row/cell background
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function Color(options)
		{
			var red = options.red || 0;
			var green = options.green || 0;
			var blue = options.blue || 0;
			var alpha = options.alpha || null;

			/**
			 * red portion of the color
			 * @name Color#red
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_COLOR_VALUE when the value is not between 0 and 255
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'red', {
				get: function ()
				{
					return red;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'red', 'number');
					else if (val < 0 || val > 255)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, val);
					red = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * green portion of the color
			 * @name Color#green
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_COLOR_VALUE when the value is not between 0 and 255
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'green', {
				get: function ()
				{
					return green;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'green', 'number');
					else if (val < 0 || val > 255)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, val);
					green = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * blue portion of the color
			 * @name Color#blue
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_COLOR_VALUE when the value is not between 0 and 255
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'blue', {
				get: function ()
				{
					return blue;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'blue', 'number');
					else if (val < 0 || val > 255)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, val);
					blue = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * opacity - transparency of the color
			 * @name Color#alpha
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_ALPHA_VALUE when the value is not between 0 and 255
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'alpha', {
				get: function ()
				{
					return alpha;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'alpha', 'number');
					else if (val < 0.0 || val > 1.0)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_ALPHA_VALUE, val);
					alpha = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Color)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.Color";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					red: red,
					green: green,
					blue: blue,
					alpha: alpha
				};
			};
		}

		Color.prototype = nsobject.getNewInstance();

		/**
		 * @class PositionPercent
		 * @classDescription Position background using percentage values
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function PositionPercent(options)
		{
			var percentX = options.percentX;
			var percentY = options.percentY;

			/**
			 * Percent of X dimension
			 * @name PositionPercent#percentX
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'percentX', {
				get: function ()
				{
					return percentX;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'percentX', 'number');
					percentX = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Percent of Y dimension
			 * @name PositionPercent#percentY
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'percentY', {
				get: function ()
				{
					return percentY;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'percentY', 'number');
					percentX = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PositionPercent)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.PositionPercent";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					percentX: percentX,
					percentY: percentY
				};
			};
		}

		PositionPercent.prototype = nsobject.getNewInstance();

		/**
		 * @class PositionValues
		 * @classDescription Position background using horizontal and vertical values
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function PositionValues(options)
		{
			var horizontal = options.horizontal;
			var vertical = options.vertical;

			/**
			 * Horizontal setting
			 * @name PositionValues#horizontal
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_POSITION when the assigned value is outside of Position enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'horizontal', {
				get: function ()
				{
					return horizontal;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'horizontal', 'string');
					else if (!POSITIONS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_POSITION, val);
					horizontal = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Vertical setting
			 * @name PositionPercent#vertical
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_POSITION when the assigned value is outside of Position enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'vertical', {
				get: function ()
				{
					return vertical;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'vertical', 'string');
					else if (!POSITIONS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_POSITION, val);
					vertical = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PositionValues)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.PositionValues";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					horizontal: horizontal,
					vertical: vertical
				};
			};
		}

		PositionValues.prototype = nsobject.getNewInstance();

		/**
		 * @class PositionUnits
		 * @classDescription Position background using selected units
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function PositionUnits(options)
		{
			var x = options.x;
			var y = options.y;
			var unit = options.unit;

			/**
			 * X setting
			 * @name PositionUnits#x
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'x', {
				get: function ()
				{
					return x;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'x', 'number');
					x = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Y setting
			 * @name PositionUnits#y
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'y', {
				get: function ()
				{
					return y;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'y', 'number');
					y = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Units setting
			 * @name PositionUnits#unit
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_UNIT when assigned value is outside of Unit enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'unit', {
				get: function ()
				{
					return unit;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'unit', 'string');
					else if (!UNITS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_UNIT, val);
					unit = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PositionUnits)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.PositionUnits";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					x: x,
					y: y,
					unit: unit
				};
			};
		}

		PositionUnits.prototype = nsobject.getNewInstance();

		/**
		 * @class FontSize
		 * @classDescription Font size defined by units
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function FontSize(options)
		{
			var size = options.size;
			var unit = options.unit;

			/**
			 * Size
			 * @name FontSize#size
			 * @type {number}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return size;
				},
				set: function (val)
				{
					if (!util.isNumber(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'size', 'number');
					size = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Units of the font size
			 * @name FontSize#unit
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_UNIT when assigned value is outside of Unit enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'unit', {
				get: function ()
				{
					return unit;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'unit', 'string');
					else if (!UNITS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_UNIT, val);
					unit = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PositionUnits)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.FontSize";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					size: size,
					unit: unit
				};
			};
		}

		FontSize.prototype = nsobject.getNewInstance();

		/**
		 * @class Style
		 * @classDescription Style to be used in conditional filter
		 * @constructor
		 * @protected
		 *
		 * @since 2021.1
		 */
		function Style(options)
		{
			var backgroundImage = options.backgroundImage || null;
			var backgroundColor = options.backgroundColor || null;
			var backgroundPosition = options.backgroundPosition || null;
			var fontSize = options.fontSize || null;
			var fontStyle = options.fontStyle || null;
			var fontWeight = options.fontWeight || null;
			var textAlign = options.textAlign || null;
			var color = options.color || null;
			var textDecorationColor = options.textDecorationColor || null;
			var textDecorationLine = options.textDecorationLine || null;
			var textDecorationStyle = options.textDecorationStyle || null;

			/**
			 * Background image
			 * @name Style#backgroundImage
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_IMAGE when assigned value is outside of Image enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'backgroundImage', {
				get: function ()
				{
					return backgroundImage;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'backgroundImage', 'string');
					else if (!IMAGES[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_IMAGE, val);
					backgroundImage = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Background color
			 * @name Style#backgroundColor
			 * @type {Color | string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} UNSUPPORTED_COLOR when a string value outside of Color enum is used to set the value
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'backgroundColor', {
				get: function ()
				{
					return backgroundColor;
				},
				set: function (val)
				{
					if (util.isString(val))
					{
						if (!COLORS[val])
							utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, val);
					}
					else if (!utilityFunctions.checkObjectType(val, "workbook.Color"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'backgroundColor', 'Color|string');
					backgroundColor = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Background position
			 * @name Style#backgroundPosition
			 * @type {PositionUnits | PositionValues | PositionPercent}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'backgroundPosition', {
				get: function ()
				{
					return backgroundPosition;
				},
				set: function (val)
				{
					if (!utilityFunctions.checkObjectType(val, "workbook.PositionValues") && !utilityFunctions.checkObjectType(val, "workbook.PositionUnits") && !utilityFunctions.checkObjectType(val, "workbook.PositionPercent"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'backgroundPosition', 'PositionUnits|PositionValues|PositionPercent');
					backgroundPosition = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Font size
			 * @name Style#fontSize
			 * @type {string | FontSize}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_FONT_SIZE when assigned value is outside of FontSize enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'fontSize', {
				get: function ()
				{
					return fontSize;
				},
				set: function (val)
				{
					if (util.isString(val))
					{
						if (!FONT_SIZES[val])
							utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FONT_SIZE, val);
					}
					else if (!utilityFunctions.checkObjectType(val, "workbook.FontSize"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'fontSize', 'string|FontSize');
					fontSize = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Font style
			 * @name Style#fontStyle
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_FONT_STYLE when assigned value is outside of FontStyle enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'fontStyle', {
				get: function ()
				{
					return fontStyle;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'fontStyle', 'string');
					else if (!FONT_STYLES[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FONT_STYLE, val);
					fontStyle = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Font weight
			 * @name Style#fontWeight
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_FONT_WEIGHT when assigned value is outside of FontWeight enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'fontWeight', {
				get: function ()
				{
					return fontWeight;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'fontWeight', 'string');
					else if (!FONT_WEIGHTS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FONT_WEIGHT, val);
					fontWeight = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Text align
			 * @name Style#textAlign
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_TEXT_ALIGN when assigned value is outside of TextAlign enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'textAlign', {
				get: function ()
				{
					return textAlign;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'textAlign', 'string');
					else if (!TEXT_ALIGNS[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_ALIGN, val);
					textAlign = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Color
			 * @name Style#color
			 * @type {Color | string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} UNSUPPORTED_COLOR when a string value outside of Color enum is used to set the value
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'color', {
				get: function ()
				{
					return color;
				},
				set: function (val)
				{
					if (util.isString(val))
					{
						if (!COLORS[val])
							utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, val);
					}
					else if (!utilityFunctions.checkObjectType(val, "workbook.Color"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'color', 'Color|string');
					color = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Text decoration color
			 * @name Style#textDecorationColor
			 * @type {Color | string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} UNSUPPORTED_COLOR when a string value outside of Color enum is used to set the value
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'textDecorationColor', {
				get: function ()
				{
					return textDecorationColor;
				},
				set: function (val)
				{
					if (util.isString(val))
					{
						if (!COLORS[val])
							utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, val);
					}
					else if (!utilityFunctions.checkObjectType(val, "workbook.Color"))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'textDecorationColor', 'Color|string');
					textDecorationColor = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Text decoration line
			 * @name Style#textDecorationLine
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_TEXT_DECORATION_LINE when assigned value is outside of TextDecorationLine enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'textDecorationLine', {
				get: function ()
				{
					return textDecorationLine;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'textDecorationLine', 'string');
					else if (!TEXT_DECORATION_LINES[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_DECORATION_LINE, val);
					textDecorationLine = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Text decoration style
			 * @name Style#textDecorationStyle
			 * @type {string}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 * @throws {SuiteScriptError} INVALID_TEXT_DECORATION_STYLE when assigned value is outside of TextDecorationStyle enum
			 *
			 * @since 2021.1
			 */
			Object.defineProperty(this, 'textDecorationStyle', {
				get: function ()
				{
					return textDecorationStyle;
				},
				set: function (val)
				{
					if (!util.isString(val))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'textDecorationStyle', 'string');
					else if (!TEXT_DECORATION_STYLES[val])
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_DECORATION_STYLE, val);
					textDecorationStyle = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Style)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.1
			 */
			this.toString = function toString()
			{
				return "workbook.Style";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.1
			 */
			this.toJSON = function toJSON()
			{
				return {
					backgroundImage: backgroundImage,
					backgroundColor: backgroundColor,
					backgroundPosition: backgroundPosition,
					fontSize: fontSize,
					fontStyle: fontStyle,
					fontWeight: fontWeight,
					textAlign: textAlign,
					color: color,
					textDecorationColor: textDecorationColor,
					textDecorationLine: textDecorationLine,
					textDecorationStyle: textDecorationStyle
				};
			};
		}

		Style.prototype = nsobject.getNewInstance();

		/**
		 * @class PivotResultsIterator
		 * @classDescription Iterator over pivot intersections
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function PivotResultsIterator(delegate)
		{
			this.hasNext = function hasNext() {
				return invoker(delegate, "hasNext", []);
			};

			this.next = function next() {
				return loadPivotIntersection(invoker(delegate, "next", []));
			}
		}

		PivotResultsIterator.prototype = nsobject.getNewInstance();

		/**
		 * @class PivotIntersection
		 * @classDescription Intersection of row and column holding measure values
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function PivotIntersection(options)
		{
			var row = options.row;
			var column = options.column;
			var measureValues = options.measureValues;

			/**
			 * Row dimension value
			 * @name PivotIntersection#row
			 * @type {DimensionValue|SectionValue}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'row', {
				get: function ()
				{
					return row;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'row');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Column dimension values
			 * @name PivotIntersection#column
			 * @type {DimensionValue|SectionValue}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'column', {
				get: function ()
				{
					return column;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'column');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Measure values in the intersection
			 * @name PivotIntersection#measureValues
			 * @type {Array<MeasureValue>}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'measureValues', {
				get: function ()
				{
					return measureValues;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'measureValues');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.PivotIntersection)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.PivotIntersection";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					row: row,
					column: column,
					measureValues: measureValues
				};
			};
		}

		PivotIntersection.prototype = nsobject.getNewInstance();

		/**
		 * @class SectionValue
		 * @classDescription Value of the section from pivot intersection
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function SectionValue(options)
		{
			var section = options.section;

			/**
			 * Section
			 * @name SectionValue#section
			 * @type {Section}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'section', {
				get: function ()
				{
					return section;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'section');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.SectionValue)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.SectionValue";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					section: section
				};
			};
		}

		SectionValue.prototype = nsobject.getNewInstance();

		/**
		 * @class DataDimensionValue
		 * @classDescription Value of the data dimension from pivot intersection
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function DataDimensionValue(options)
		{
			var dataDimension = options.dataDimension;
			var itemValues = options.itemValues;

			/**
			 * Data dimension
			 * @name DataDimensionValue#dataDimension
			 * @type {DataDimension}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'dataDimension', {
				get: function ()
				{
					return dataDimension;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'dataDimension');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Item values
			 * @name DataDimensionValue#itemValues
			 * @type {Array<DataDimensionItemValue>}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'itemValues', {
				get: function ()
				{
					return itemValues;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'itemValues');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.DataDimensionValue)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.DataDimensionValue";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					dataDimension: dataDimension,
					itemValues: itemValues
				};
			};
		}

		DataDimensionValue.prototype = nsobject.getNewInstance();

		/**
		 * @class DataDimensionItemValue
		 * @classDescription Class holding reference to the dimension item and its value
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function DataDimensionItemValue(options)
		{
			var item = options.item;
			var value = options.value;

			/**
			 * Data dimension item
			 * @name DataDimensionItemValue#dataDimensionItem
			 * @type {DataDimension}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'item', {
				get: function ()
				{
					return item;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'item');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Value of the data dimension item
			 * @name DataDimensionItemValue#value
			 * @type {string|number|boolean|Record|Currency|Range}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'value', {
				get: function ()
				{
					return value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.DataDimensionItemValue)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.DataDimensionItemValue";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					item: item,
					value: value
				};
			};
		}

		DataDimensionItemValue.prototype = nsobject.getNewInstance();

		/**
		 * @class MeasureValue
		 * @classDescription Value of the measure from pivot intersection
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function MeasureValue(options)
		{
			var measure = options.measure;
			var value = options.value;

			/**
			 * Measure
			 * @name MeasureValue#measure
			 * @type {MeasureValue}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'measure', {
				get: function ()
				{
					return measure;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'measure');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Value of the measure
			 * @name MeasureValue#value
			 * @type {string|number|boolean|Range|Record|Currency}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'value', {
				get: function ()
				{
					return value;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.MeasureValue)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.MeasureValue";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					measure: measure,
					value: value
				};
			};
		}

		MeasureValue.prototype = nsobject.getNewInstance();

		/**
		 * @class Currency
		 * @classDescription Simple container for currency id and amount
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function Currency(options)
		{
			var id = options.id;
			var amount = options.amount;
			/**
			 * id of the currency (USD|EUR|GBP ...)
			 * @name Currency#id
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * amount of the currency
			 * @name Currency#amount
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'amount', {
				get: function ()
				{
					return amount;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'amount');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Currency)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.Currency";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					id: id,
					amount: amount
				};
			};
		}

		Currency.prototype = nsobject.getNewInstance();

		/**
		 * @class Duration
		 * @classDescription Simple container for currency id and amount
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function Duration(options)
		{
			var units = options.units;
			var amount = options.amount;
			/**
			 * Duration units
			 * @name Duration#units
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'units', {
				get: function ()
				{
					return units;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'units');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Amount of units in this duration
			 * @name Duration#amount
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'amount', {
				get: function ()
				{
					return amount;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'amount');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Currency)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.Duration";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					units: units,
					amount: amount
				};
			};
		}

		Duration.prototype = nsobject.getNewInstance();

		/**
		 * @class Record
		 * @classDescription Record returned from pivot execution
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function Record(options)
		{
			var primaryKey = options.primaryKey;
			var name = options.name;
			var properties = options.properties;

			/**
			 * Primary key of this record
			 * @name Record#primaryKey
			 * @type {number}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'primaryKey', {
				get: function ()
				{
					return primaryKey;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'primaryKey');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Properties of this record
			 * @name Record#properties
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'properties', {
				get: function ()
				{
					return properties;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'properties');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});


			/**
			 * Name of the record type
			 * @name Record#name
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Record)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.Record";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					primaryKey: primaryKey,
					name: name,
					properties: properties
				};
			};
		}

		Record.prototype = nsobject.getNewInstance();

		/**
		 * @class RecordKey
		 * @classDescription RecordKey can either be returned from pivot execution or created as an input to constant expression
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function RecordKey(options)
		{
			var properties = options;

			/**
			 * Properties of the record key
			 * @name RecordKey#properties
			 * @type {Object}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'properties', {
				get: function ()
				{
					return properties;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'properties');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.RecordKey)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.RecordKey";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					properties: properties
				};
			};
		}

		RecordKey.prototype = nsobject.getNewInstance();

		/**
		 * @class Range
		 * @classDescription Range value returned from pivot execution
		 * @constructor
		 * @protected
		 *
		 * @since 2021.2
		 */
		function Range(options)
		{
			var start = options.start;
			var end = options.end;

			/**
			 * Start date/dateTime of this range (formatted according to user preferences)
			 * @name Range#start
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'start', {
				get: function ()
				{
					return start;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'start');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * End date/dateTime of this range (formatted according to user preferences)
			 * @name Range#end
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2021.2
			 */
			Object.defineProperty(this, 'end', {
				get: function ()
				{
					return end;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'end');

				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns the object type name (workbook.Range)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2021.2
			 */
			this.toString = function toString()
			{
				return "workbook.Range";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2021.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					start: start,
					end: end
				};
			};
		}

		Range.prototype = nsobject.getNewInstance();

		/**
		 * @class Workbook
		 * @classDescription Object representing SuiteAnalytics workbook
		 * @constructor
		 * @protected
		 *
		 * @since 2020.2
		 */
		function Workbook(options)
		{
			var name = options.name;
			var description = options.description || null;
			var charts = options.charts || [];
			var tables = options.tables || [];
			var pivots = options.pivots || [];
			var id = options.id;

			/**
			 * name of the workbook
			 * @name Workbook#name
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return name;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * description of the workbook
			 * @name Workbook#description
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'description', {
				get: function ()
				{
					return description;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'description');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Workbook's pivots
			 * @name Workbook#pivots
			 * @type {Array<Pivot>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'pivots', {
				get: function ()
				{
					return pivots;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(pivot){
						return utilityFunctions.checkObjectType(pivot, "workbook.Pivot");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'pivots', 'workbook.Pivot[]');
					pivots = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Workbook's charts
			 * @name Workbook#charts
			 * @type {Array<Chart>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'charts', {
				get: function ()
				{
					return charts;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(chart){
						return utilityFunctions.checkObjectType(chart, "workbook.Chart");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'charts', 'workbook.Chart[]');
					charts = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Workbook's tables
			 * @name Workbook#tables
			 * @type {Array<Table>}
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when the type is not right
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'tables', {
				get: function ()
				{
					return tables;
				},
				set: function (val)
				{
					if (!util.isArray(val) || !utilityFunctions.checkArrayType(val, function(view){
						return utilityFunctions.checkObjectType(view, "workbook.Table");
					}))
						utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'tables', 'workbook.Table[]');
					tables = val;
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * id of the workbook
			 * @name Workbook#id
			 * @type {string}
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2020.2
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return id;
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * Runs pivot and returns array of intersections
			 * @param {Object} options
			 * @param {string} options.id id of the pivot
			 * @governance 10 units for each intersection returned
			 * @return {Array<PivotIntersection>}
			 * @throws {SuiteScriptError} PIVOT_DOES_NOT_EXIST when there is no pivot under supplied id in the workbook
			 *
			 * @since 2021.2
			 */
			this.runPivot = function runPivot(options)
			{
				return runPivotInternal(options, JSON.stringify(this), pivots);
			};

			function runPivotInternal(options, definition, pivots)
			{
				var id = (options && options.hasOwnProperty('id')) ? options.id : options;
				utilityFunctions.checkArgs([id], ['id'], 'Workbook.runPivot');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isString)]);

				var pivot = null;
				for (var i in pivots)
				{
					if (pivots[i].id == id)
					{
						pivot = pivots[i];
						break;
					}
				}
				if (pivot == null)
					utilityFunctions.throwSuiteScriptError(error.Type.PIVOT_DOES_NOT_EXIST, id);
				var isPromise = utilityFunctions.isPromiseCallback(this);
				var data = invoker(workbookApi, "runPivot", [definition, id], isPromise ? this : undefined);
				if (!isPromise)
					return loadPivotIntersections({result: data});
			}

			function promiseToRunPivot(options){
				return utilityFunctions.promiseTo(runPivotInternal, [options, JSON.stringify(this), this.pivots], loadPivotIntersections);
			}
			/**
			 * Runs pivot and returns array of intersections asynchronously
			 * @param {Object} options
			 * @param {string} options.id id of the pivot
			 * @governance 10 units for each intersection returned
			 * @return {Promise}
			 *
			 * @since 2021.2
			 */
			this.runPivot.promise = promiseToRunPivot.bind(this);

			/**
			 * Returns the object type name (workbook.Workbook)
			 * @governance none
			 * @return {string}
			 *
			 * @since 2020.2
			 */
			this.toString = function toString()
			{
				return "workbook.Workbook";
			};

			/**
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2020.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					name: name,
					description: description,
					pivots: pivots,
					charts: charts,
					tables: tables,
					id: id
				};
			};
		}

		Workbook.prototype = nsobject.getNewInstance();

		function loadPivotPostProcess(options)
		{
			return iteratorFactory.create(new PivotResultsIterator(options.result));
		}

		/**
		 * Loads a workbook
		 * @governance 10 units
		 * @param {Object} options
		 * @param {string} options.id id of the workbook to load

		 * @return {Workbook}
		 *
		 * @since 2020.2
		 */
		function loadWorkbook(options)
		{
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'workbook.load');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isString)]);
			var isPromise = utilityFunctions.isPromiseCallback(this);
			var data = invoker(workbookApi, "load", [id], isPromise ? this.bind({id: id}) : undefined);
			if (!isPromise)
				return loadPostProcess({result: data, data: {id: id}});
		}

		function getOrLoadDatasetLink(link, allDatasets, datasetLinkCache, datasetCache)
		{
			if (datasetLinkCache[link.id])
				return datasetLinkCache[link.id];
			var datasets = [];
			for (var dataset in link.datasets)
				datasets.push(getOrLoadDataset(link.datasets[dataset], allDatasets, datasetCache));
			var expressions = undefined;
			if (link.expressions)
			{
				expressions = [];
				for (var expGroup in link.expressions)
				{
					var group = [];
					for (var exp in link.expressions[expGroup])
					{
						group.push(loadExpression(link.expressions[expGroup][exp]))
					}
					expressions.push(group);
				}
			}
			var toReturn = datasetLink.create({datasets: datasets, expressions: expressions, id: link.id});
			datasetLinkCache[link.id] = toReturn;
			return toReturn;
		}

		function loadPostProcess(options)
		{
			var data = options.result;
			var pivots = [];
			var charts = [];
			var tableViews = [];
			var datasetCache = {};
			var datasetLinkCache = {};
			for (var pivot in data.pivots)
			{
				var pivot = data.pivots[pivot];
				pivots.push(loadPivot(pivot, pivot.dataset ? getOrLoadDataset(pivot.dataset, data.allDatasets, datasetCache)  : getOrLoadDatasetLink(pivot.datasetLink, data.allDatasets, datasetLinkCache, datasetCache)));
			}
			for (var chart in data.charts)
			{
				var chart = data.charts[chart];
				charts.push(loadChart(chart, chart.dataset ? getOrLoadDataset(chart.dataset, data.allDatasets, datasetCache) : getOrLoadDatasetLink(chart.datasetLink, data.allDatasets, datasetLinkCache, datasetCache)));
			}
			for (var tableView in data.tableViews)
			{
				var tableViewDefinition = data.tableViews[tableView];
				tableViews.push(loadTable(tableViewDefinition, getOrLoadDataset(tableViewDefinition.dataset, data.allDatasets, datasetCache)));
			}
			var id = options.data.id;
			return new Workbook({pivots:pivots, tables:tableViews, charts: charts, name: data.name, description: data.description, id: id});
		}

		/**
		 * Asynchronously loads a workbook
		 * @governance 10 units
		 * @param {Object} options
		 * @param {string} options.id id of the workbook to load

		 * @return {Promise}
		 *
		 * @since 2020.2
		 */
		loadWorkbook.promise = function()
		{
			return utilityFunctions.promiseTo(loadWorkbook, arguments, loadPostProcess);
		};

		function getOrLoadDataset(id, allDatasets, datasetCache)
		{
			if (datasetCache[id])
				return datasetCache[id];
			else
			{
				var toReturn = dataset._loadInternal({result: allDatasets[id], data: {id: id}});
				datasetCache[id] = toReturn;
				return toReturn;
			}
		}

		function loadTable(tableView, dataset)
		{
			var name = tableView.name;
			var portletName = tableView.portletName;
			var id = tableView.id;
			var columns = loadTableViewColumns(tableView.columns, dataset);
			return new Table({name: name, portletName: portletName, id: id, columns: columns, dataset: dataset});
		}

		function loadTableViewColumns(tableViewColumns, dataset)
		{
			var rc = [];
			for (var tableViewColumn in tableViewColumns)
				rc.push(loadTableViewColumn(tableViewColumns[tableViewColumn], dataset));
			return rc;
		}

		function loadTableViewColumn(tableViewColumn, dataset)
		{
			var alias = null;
			for (var i in dataset.columns)
			{
				if (dataset.columns[i].id == tableViewColumn.datasetColumnId)
					alias = dataset.columns[i].alias;
			}
			return new TableColumn({label: tableViewColumn.label, width: tableViewColumn.width, sort: loadSort(tableViewColumn.sort), condition: loadTableViewCondition(tableViewColumn.condition), datasetColumnId: tableViewColumn.datasetColumnId, datasetColumnAlias: alias, fieldContext: loadFieldContext(tableViewColumn.fieldContext), conditionalFormats: loadConditionalFormats(tableViewColumn.conditionalFormats)});
		}

		function loadConditionalFormats(conditionalFormats)
		{
			var rc = [];
			for (var conditionalFormat in conditionalFormats)
				rc.push(loadConditionalFormat(conditionalFormats[conditionalFormat]));
			return rc;
		}

		function loadConditionalFormat(conditionalFormat)
		{
			var rules = loadConditionalFormatRules(conditionalFormat.rules);
			return new ConditionalFormat({rules: rules});
		}

		function loadConditionalFormatRules(conditionalFormatRules)
		{
			var rc = [];
			for (var conditionalFormatRule in conditionalFormatRules)
				rc.push(loadConditionalFormatRule(conditionalFormatRules[conditionalFormatRule]));
			return rc;
		}

		function loadConditionalFormatRule(conditionalFormatRule)
		{
			var filter = loadTableViewFilter(conditionalFormatRule.filter);
			var style = loadStyle(conditionalFormatRule.style);
			return new ConditionalFormatRule({style: style, filter: filter});
		}

		function loadStyle(style)
		{
			var fontStyle = style.fontStyle;
			var fontWeight = style.fontWeight;
			var textAlign = style.textAlign;
			var textDecorationStyle = style.textDecorationStyle;
			var textDecorationLine = style.textDecorationLine;
			var backgroundImage = style.backgroundImage;
			var fontSize = style.fontSize;
			if (fontSize && util.isObject(fontSize))
				fontSize = new FontSize({size: fontSize.size, unit: fontSize.unit});
			var backgroundPosition = loadPosition(style.backgroundPosition);
			var backgroundColor = loadColor(style.backgroundColor);
			var color = loadColor(style.color);
			var textDecorationColor = loadColor(style.textDecorationColor);
			return new Style({
				fontStyle: fontStyle,
				fontWeight: fontWeight,
				textAlign: textAlign,
				textDecorationStyle: textDecorationStyle,
				textDecorationLine: textDecorationLine,
				backgroundImage: backgroundImage,
				fontSize: fontSize,
				backgroundPosition: backgroundPosition,
				backgroundColor: backgroundColor,
				color: color,
				textDecorationColor: textDecorationColor
			});
		}

		function loadColor(color)
		{
			if (!color)
				return null;
			else if (util.isString(color))
				return color;
			else
				return new Color({red: color.red, green: color.green, blue: color.blue, alpha: color.alpha});
		}

		function loadPosition(position)
		{
			if (!position)
				return null;
			else
			{
				if (position.percentX)
					return new PositionPercent({percentX: position.percentX, percentY: position.percentY});
				else if (position.unit)
					return new PositionUnits({unit: position.unit, x: position.x, y: position.y});
				else
					return new PositionValues({horizontal: position.horizontal, vertical: position.vertical});
			}
		}

		function loadFieldContext(fieldContext)
		{
			if (!fieldContext)
				return null;
			var parameters = fieldContext.parameters;
			if (parameters && parameters.date && util.isNumber(parameters.date))
				parameters.date = new Date(parameters.date);
			return new FieldContext({name: fieldContext.name, parameters: parameters});
		}

		function loadTableViewFilters(tableViewFilters)
		{
			var rc = [];
			for (var tableViewFilter in tableViewFilters)
				rc.push(loadTableViewFilter(tableViewFilters[tableViewFilter]));
			return rc;
		}

		function loadTableViewCondition(tableViewCondition)
		{
			return new TableColumnCondition({operator: tableViewCondition.operator, filters: loadTableViewFilters(tableViewCondition.filters)});
		}

		function loadTableViewFilter(filter)
		{
			for (var i = 0; i < filter.values.length; i++)
			{
				if (util.isObject(filter.values[i]) && filter.values[i].hasOwnProperty("dateId") && !filter.values[i].hasOwnProperty("type")) {
					if (filter.values[i].value) {
						filter.values[i] = query.createRelativeDate({
							dateId: filter.values[i].dateId,
							value: filter.values[i].value
						});
					}
					else {
						for (var j in query.RelativeDateRange) {
							if (query.RelativeDateRange[i].dateId == filter.values[i].dateId) {
								filter.values[i] = query.RelativeDateRange[j];
								break;
							}
						}
					}
				}
				else if (util.isObject(filter.values[i]) && filter.values[i].hasOwnProperty("adjustment"))
					filter.values[i] = query.createPeriod({
						code: filter.values[i].code,
						type: filter.values[i].type,
						adjustment: filter.values[i].adjustment
					});
			}
			return new TableColumnFilter({values: filter.values, operator: filter.operator, caseSensitive: filter.caseSensitive});
		}

		function loadChart(chart, datasetOrDatasetLink)
		{
			var name = chart.name;
			var portletName = chart.portletName;
			var id = chart.id;
			var title = chart.title;
			var subTitle = chart.subTitle;
			var chrt = chart.chart;
			var stacking = chrt.stacking;
			var type = chrt.type;
			var legend = loadLegend(chrt.legend);
			var category = loadCategory(chrt.category);
			var filterExpressions = loadFilters(chrt.filterExpressions);
			var aggregationFilters = loadAggregationFilters(chrt.aggregationFilters);
			var series = loadSeries(chrt.series);
			var dataset = datasetOrDatasetLink.toString() == "dataset.Dataset" ? datasetOrDatasetLink : null;
			var datasetLink = datasetOrDatasetLink.toString() == "datasetLink.DatasetLink" ? datasetOrDatasetLink : null;
			return new Chart({datasetLink: datasetLink, dataset: dataset, name: name, portletName: portletName, id: id, title: title, subTitle: subTitle, stacking: stacking, type: type, legend: legend, category: category, filterExpressions: filterExpressions, aggregationFilters: aggregationFilters, series: series});
		}

		function loadSeries(series)
		{
			var rc = [];
			for (var serie in series)
				rc.push(loadSerie(series[serie]));
			return rc;
		}

		function loadSerie(serie)
		{
			return new Series({aspects: loadAspects(serie.aspects)});
		}

		function loadAspects(aspects)
		{
			var rc = [];
			for (var aspect in aspects)
				rc.push(loadAspect(aspects[aspect]));
			return rc;
		}

		function loadAspect(aspect)
		{
			return new Aspect({type: aspect.type, measure: loadMeasure(aspect.measure)});
		}

		function loadCategory(category)
		{
			return new Category({sortDefinitions:loadSortDefinitions(category.sortDefinitions), root: loadNode(category.fields), axis: loadAxis(category.axis)});
		}

		function loadAxis(axis)
		{
			return new ChartAxis({title: axis.title});
		}

		function loadLegend(legend)
		{
			return new Legend({sortDefinitions:loadSortDefinitions(legend.sortDefinitions), root: loadNode(legend.fields), axis: loadAxes(legend.axes)});
		}

		function loadAxes(axes)
		{
			var rc = [];
			for (var axis in axes)
				rc.push(loadAxis(axes[axis]));
			return rc;
		}

		function loadPivot(pivot, datasetOrDatasetLink)
		{
			var report = pivot.report;
			var rowAxis = loadPivotAxis(report.rowRoot);
			var columnAxis = loadPivotAxis(report.columnRoot);
			var aggregationFilters = loadAggregationFilters(report.aggregationFilters);
			var filterExpressions = loadFilters(report.filterExpressions);
			var reportStyles = loadReportStyles(report.reportStyles);
			var dataset = datasetOrDatasetLink.toString() == "dataset.Dataset" ? datasetOrDatasetLink : null;
			var datasetLink = datasetOrDatasetLink.toString() == "datasetLink.DatasetLink" ? datasetOrDatasetLink : null;
			return new Pivot({name: pivot.name, id: pivot.id, portletName: pivot.portletName, filterExpressions: filterExpressions, aggregationFilters: aggregationFilters, rowAxis: rowAxis, columnAxis: columnAxis, dataset: dataset, datasetLink: datasetLink, reportStyles: reportStyles});
		}

		function loadReportStyles(reportStyles)
		{
			var styles = [];
			for (var r in reportStyles)
				styles.push(loadReportStyle(reportStyles[r]));
			return styles;
		}

		function loadReportStyle(reportStyle)
		{
			var rules = loadReportStyleRules(reportStyle.rules);
			var selectors = loadMeasureValueSelectors(reportStyle.selectors);
			return new ReportStyle({selectors: selectors, rules: rules});
		}

		function loadMeasureValueSelectors(measureValueSelectors)
		{
			var selectors = [];
			for (var mvs in measureValueSelectors)
				selectors.push(loadMeasureValueSelector(measureValueSelectors[mvs]));
			return selectors;
		}

		function loadMeasureValueSelector(measureValueSelector)
		{
			var rowSelector = loadSelector(measureValueSelector.rowSelector);
			var columnSelector = loadSelector(measureValueSelector.columnSelector);
			var measureSelector = loadMeasureSelector(measureValueSelector.measureSelector);
			return new MeasureValueSelector({rowSelector: rowSelector, columnSelector: columnSelector, measureSelector: measureSelector});
		}

		function loadMeasureSelector(measureSelector)
		{
			var measures = [];
			for (var measure in measureSelector.measures)
				measures.push(loadMeasure(measureSelector.measures[measure]));
			return new MeasureSelector({measures: measures});
		}

		function loadReportStyleRules(reportStyleRules)
		{
			var rules = [];
			for (var r in reportStyleRules)
				rules.push(loadReportStyleRule(reportStyleRules[r]));
			return rules;
		}

		function loadReportStyleRule(reportStyleRule)
		{
			return new ReportStyleRule({expression: loadExpression(reportStyleRule.expression), style: loadStyle(reportStyleRule.style)});
		}

		function loadFilters(filters)
		{
			var flts = [];
			for (var f in filters)
				flts.push(loadExpression(filters[f]));
			return flts;
		}

		function loadAggregationFilters(aggregationFilters)
		{
			var rc = [];
			for (var aggFlt in aggregationFilters)
				rc.push(loadAggregationFilter(aggregationFilters[aggFlt]));
			return rc;
		}

		function loadAggregationFilter(aggregationFilter)
		{
			if (aggregationFilter.measure)
				return new ConditionalFilter({row:aggregationFilter.row, measure: loadMeasure(aggregationFilter.measure), predicate: loadExpression(aggregationFilter.predicate), rowSelector: loadSelector(aggregationFilter.rowSelector), columnSelector: loadSelector(aggregationFilter.columnSelector)});
			else
				return new LimitingFilter({row:aggregationFilter.row, limit: aggregationFilter.limit, sortBys: loadSortBys(aggregationFilter.sortBy), filteredNodesSelector: loadSelector(aggregationFilter.filteredNodesSelector)});
		}

		function loadPivotAxis(axis)
		{
			return new PivotAxis({root: loadNode(axis.root), sortDefinitions: loadSortDefinitions(axis.sortDefinitions)});
		}

		function loadSortDefinitions(sortDefinitions)
		{
			if (!sortDefinitions)
				return [];
			var defs = [];
			for (var sortDef in sortDefinitions)
				defs.push(loadSortDefinition(sortDefinitions[sortDef]));
			return defs;
		}

		function loadSortDefinition(sortDefinition)
		{
			return new SortDefinition({sortBys: loadSortBys(sortDefinition.sortBys), selector: loadSelector(sortDefinition.selector)});
		}

		function loadSortBys(sortBys)
		{
			var srts = [];
			for (var sortBy in sortBys)
				srts.push(loadSortBy(sortBys[sortBy]));
			return srts;
		}

		function loadSortBy(sortBy)
		{
			if (sortBy.item)
				return new SortByDataDimensionItem({sort: loadSort(sortBy.sort), item: loadDataDimensionItem(sortBy.item)});
			else
				return new SortByMeasure({sort: loadSort(sortBy.sort), measure: loadMeasure(sortBy.measure), otherAxisSelector: loadSelector(sortBy.selector)});
		}

		function loadSort(sort)
		{
			if (!sort)
				return null;
			return new Sort({ascending: sort.ascending, caseSensitive: sort.caseSensitive, nullsLast: sort.nullsLast, locale: sort.locale});
		}

		function loadSelector(selector)
		{
			if (selector.dataDimension)
				return new DimensionSelector({dimension: loadNode(selector.dataDimension)});
			else if (selector.elements)
			{
				var elements = [];
				for (var elem in selector.elements)
					elements.push(loadSelector(selector.elements[elem]));
				return new PathSelector({elements: elements});
			}
			else if (selector.selectorName == "ChildNodes")
				return childNodesSelector;
			else
				return descendantOrSelfNodesSelector;

		}

		function loadNode(node)
		{
			if (!node)
				return null;
			if (node.items)
				return loadDataDimension(node);
			else if (node.expression || node.expressions)
				return loadMeasure(node);
			else
				return loadSection(node);
		}

		function loadSection(section)
		{
			var children = [];
			for (var child in section.children)
				children.push(loadNode(section.children[child]));
			return new Section({totalLine: section.totalLine, children: children});
		}

		function loadDataDimension(dimension)
		{
			var children = [];
			for (var child in dimension.children)
				children.push(loadNode(dimension.children[child]));
			var items = [];
			for (var item in dimension.items)
				items.push(loadDataDimensionItem(dimension.items[item]));
			return new DataDimension({totalLine: dimension.totalLine, children: children, items: items});
		}

		function loadMeasure(measure)
		{
			var opts = {};
			opts.aggregation = measure.aggregation;
			opts.label = measure.label;
			opts.id = measure.id;
			if (measure.expression)
				opts.expression = loadExpression(measure.expression);
			else
				opts.expressions = loadExpressions(measure.expressions);
			if (opts.aggregation)
				return new DataMeasure(opts);
			else
				return new CalculatedMeasure(opts);
		}

		function loadDataDimensionItem(item)
		{
			return new DataDimensionItem({expression: loadExpression(item.expression), label: item.label});
		}

		function loadExpression(expr)
		{
			if (!expr)
				return null;
			return expression.create({functionId: expr.functionId, parameters: loadParameters(expr.parameters)});
		}

		function loadExpressions(expressions)
		{
			var rc = [];
			for (var i in expressions)
				rc.push(expression.create({functionId: expressions[i].functionId, parameters: loadParameters(expressions[i].parameters)}));
			return rc;
		}

		function loadParameters(parameters) {
			if (util.isArray(parameters))
			{
				var array = [];
				for (var i in parameters)
					array.push(loadParameter(parameters[i]));
				return array;
			}
			else if (util.isObject(parameters))
			{
				var	obj = {};
				for (var p in parameters)
					obj[p] = loadParameter(parameters[p]);
				return obj;
			}
			return parameters;
		}

		function loadParameter(param)
		{
			if (utilityFunctions.isObject(param))
			{
				if (param.functionId)
					return loadExpression(param);
				else if (param.selectorName)
					return loadSelector(param);
				else if (param.expression || param.expressions)
					return loadMeasure(param);
			}
			return loadParameters(param);
		}

		function loadPivotIntersections(options)
		{
			var intersections = [];
			for (var intersection in options.result)
				intersections.push(loadPivotIntersection(options.result[intersection]));
			return intersections;
		}

		function loadPivotIntersection(intersection)
		{
			var column = loadDimensionValue(intersection.column);
			var row = loadDimensionValue(intersection.row);
			var measureValues = loadMeasureValues(intersection.measureValues);
			return new PivotIntersection({row: row, column: column, measureValues: measureValues});
		}

		function loadDimensionValue(dimensionValue)
		{
			if (dimensionValue.section)
				return new SectionValue({section: loadSection(dimensionValue.section)});
			else
			{
				var dataDimension = loadDataDimension(dimensionValue.dataDimension);
				var itemValues = loadItemValues(dimensionValue.itemValues);
				return new DataDimensionValue({dataDimension: dataDimension, itemValues: itemValues});
			}
		}

		function loadItemValues(itemValues)
		{
			var values = []
			for (var itemValue in itemValues)
				values.push(loadItemValue(itemValues[itemValue]));
			return values;
		}

		function loadItemValue(itemValue)
		{
			var item = loadDataDimensionItem(itemValue.item);
			var value = loadValue(itemValue.value);
			return new DataDimensionItemValue({item: item, value: value});
		}

		function loadValue(value)
		{
			if (util.isObject(value))
			{
				if (value.start)
					value = new Range(value);
				else if (value.primaryKey)
					value = new Record(value);
				else if (value.properties)
					value = new RecordKey(value.properties);
				else if (value.units)
					value = new Duration(value);
				else if (value.amount)
					value = new Currency(value);
			}
			return value;
		}

		function loadMeasureValues(measureValues)
		{
			var values = [];
			for (var measureValue in measureValues)
				values.push(loadMeasureValue(measureValues[measureValue]));
			return values;
		}

		function loadMeasureValue(measureValue)
		{
			var measure = loadMeasure(measureValue.measure);
			var value = loadValue(measureValue.value);
			return new MeasureValue({measure: measure, value: value});
		}

		/**
		 * Creates an aspect for chart series
		 * @governance none
		 * @param {Object} options
		 * @param {string}  [options.type] type of this aspect (value|color) - default is value
		 * @param {DataMeasure|CalculatedMeasure}  options.measure measure of the series
		 * @return {Aspect}
		 *
		 * @since 2020.2
		 */
		function createAspect(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createAspect');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.measure], ['options.measure'], 'workbook.createAspect');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.measure, 'options.measure', function (measure){
				return utilityFunctions.checkObjectType(measure, "workbook.DataMeasure") || utilityFunctions.checkObjectType(measure, "workbook.CalculatedMeasure");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
			if (options.type)
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validAspectTypes, options.type, false), error.Type.INVALID_ASPECT_TYPE, options.type);
			return new Aspect(options);
		}

		/**
		 * Creates a chart category
		 * @governance none
		 * @param {Object} options
		 * @param {ChartAxis}  options.axis category axis definition
		 * @param {Section|DataDimension} options.root data to feed the chart from
		 * @param {Array<SortDefinition>} [options.sortDefinitions] Sorting for this category
		 * @return {Category}
		 *
		 * @since 2020.2
		 */
		function createCategory(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createCategory');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.root], ['options.root'], 'workbook.createCategory');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.root, 'options.root', function (root){
				return utilityFunctions.checkObjectType(root, "workbook.Section") || utilityFunctions.checkObjectType(root, "workbook.DataDimension");
			})]);
			utilityFunctions.checkArgs([options.axis], ['options.axis'], 'workbook.createCategory');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.axis, 'options.axis', function (axis){
				return utilityFunctions.checkObjectType(axis, "workbook.ChartAxis");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sortDefinitions, 'options.sortDefinitions', function (sortDefinitions){
				return util.isArray(sortDefinitions) && utilityFunctions.checkArrayType(sortDefinitions, function(sortDefinition){
					return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
				});
			})]);
			return new Category(options);
		}

		/**
		 * Creates a chart
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression} options.name name of the chart
		 * @param {string|Expression} options.portletName portletName of the chart
		 * @param {string|Expression} [options.title] title of the chart
		 * @param {string|Expression} [options.subTitle] subTitle of the chart
		 * @param {string} options.id id of the chart
		 * @param {string} options.type type of the chart (BAR|AREA|COLUMN ...)
		 * @param {string} [options.stacking] stacking indicator (defaults to DISABLED)
		 * @param {Category} options.category Category for this chart
		 * @param {Legend} options.legend Legend for this chart
		 * @param {Array<Series>} options.series Series for this chart
		 * @param {Array<Expression>} [options.filterExpressions] simple non-aggregated filters
		 * @param {Array<(LimitingFilter|ConditionalFilter)>} [options.aggregationFilters] conditional and limiting filters
		 * @param {Dataset=} options.dataset Dataset on which is this chart is based
		 * @param {DatasetLink=} options.datasetLink DatasetLink on which this chart is based
		 * @throws {SuiteScriptError} INVALID_STACKING_TYPE when value outside of Stacking enum is used for stacking parameter
		 * @throws {SuiteScriptError} INVALID_CHART_TYPE when value outside of ChartType enum is used for type parameter
		 * @return {Chart}
		 *
		 * @since 2020.2
		 */
		function createChart(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createChart');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name], ['options.name'], 'workbook.createChart');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.name, 'options.name', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.portletName, 'options.portletName', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.title, 'options.title', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.subTitle, 'options.subTitle', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.type, 'options.type', util.isString)]);
			if (options.type)
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validChartTypes, options.type, false), error.Type.INVALID_CHART_TYPE, options.type);
			utilityFunctions.checkArgs([options.id], ['options.id'], 'workbook.createChart');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'options.id', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.stacking, 'options.stacking', util.isString)]);
			if (options.stacking)
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validStackings, options.stacking, false), error.Type.INVALID_STACKING_TYPE, options.stacking);
			if (!options.dataset && !options.datasetLink)
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'dataset', 'datasetLink');
			if (options.dataset && options.datasetLink)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'dataset', 'datasetLink');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.dataset, 'options.dataset', function (dataset){
				return utilityFunctions.checkObjectType(dataset, "dataset.Dataset");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.datasetLink, 'options.datasetLink', function (datasetLink){
				return utilityFunctions.checkObjectType(datasetLink, "datasetLink.DatasetLink");
			})]);
			utilityFunctions.checkArgs([options.legend], ['options.legend'], 'workbook.createChart');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.legend, 'options.legend', function (legend){
				return utilityFunctions.checkObjectType(legend, "workbook.Legend");
			})]);
			utilityFunctions.checkArgs([options.category], ['options.category'], 'workbook.createChart');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.category, 'options.category', function (category){
				return utilityFunctions.checkObjectType(category, "workbook.Category");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.series, 'options.series', function (series){
				return util.isArray(series) && utilityFunctions.checkArrayType(series, function(series){
					return utilityFunctions.checkObjectType(series, "workbook.Series");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filterExpressions, 'options.filterExpressions', function (filters){
				return util.isArray(filters) && utilityFunctions.checkArrayType(filters, function(filter){
					return utilityFunctions.checkObjectType(filter, "workbook.Expression");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.aggregationFilters, 'options.aggregationFilters', function (aggregationFilters){
				return util.isArray(aggregationFilters) && utilityFunctions.checkArrayType(aggregationFilters, function(aggregationFilter){
					return utilityFunctions.checkObjectType(aggregationFilter, "workbook.ConditionalFilter") || utilityFunctions.checkObjectType(aggregationFilter, "workbook.LimitingFilter");
				});
			})]);
			return new Chart(options);
		}

		/**
		 * Creates a chart axis
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression}  options.title title of the axis
		 * @return {ChartAxis}
		 *
		 * @since 2020.2
		 */
		function createChartAxis(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createChartAxis');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.title], ['options.title'], 'workbook.createChartAxis');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.title, 'options.title', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			return new ChartAxis(options);
		}

		/**
		 * Creates a Conditional filter
		 * @governance none
		 * @param {Object} options
		 * @param {boolean} options.row indicates whether to filter on rows (filters on column if set to false)
		 * @param {DimensionSelector|DescendantOrSelfNodesSelector|PathSelector|ChildNodesSelector} options.rowSelector selector for row
		 * @param {DimensionSelector|DescendantOrSelfNodesSelector|PathSelector|ChildNodesSelector} options.columnSelector - selector for column
		 * @param {DataMeasure|CalculatedMeasure} options.measure - filter measure
		 * @param {Expression} options.predicate - predicate expression for this filter
		 * @return {ConditionalFilter}
		 *
		 * @since 2020.2
		 */
		function createConditionalFilter(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgsPresent([options.row], ['options.row'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.row, 'options.row', util.isBoolean)]);
			utilityFunctions.checkArgs([options.measure], ['options.measure'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.measure, 'options.measure', function (measure){
				return utilityFunctions.checkObjectType(measure, "workbook.DataMeasure") || utilityFunctions.checkObjectType(measure, "workbook.CalculatedMeasure");
			})]);
			utilityFunctions.checkArgs([options.predicate], ['options.predicate'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.predicate, 'options.predicate', function (predicate){
				return utilityFunctions.checkObjectType(predicate, "workbook.Expression");
			})]);
			utilityFunctions.checkArgs([options.rowSelector], ['options.rowSelector'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rowSelector, 'options.rowSelector', function (rowSelector){
				return utilityFunctions.checkObjectType(rowSelector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.PathSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.ChildNodesSelector");
			})]);
			utilityFunctions.checkArgs([options.columnSelector], ['options.columnSelector'], 'workbook.createConditionalFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.columnSelector, 'options.columnSelector', function (columnSelector){
				return utilityFunctions.checkObjectType(columnSelector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.PathSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.ChildNodesSelector");
			})]);
			return new ConditionalFilter(options);
		}

		/**
		 * Creates a DataDimension
		 * @governance none
		 * @param {Object} options
		 * @param {string} [options.totalLine]
		 * @param {Array<(DataDimension|Section|DataMeasure|CalculatedMeasure)>} [options.children]
		 * @param {Array<DataDimensionItem>} options.items
		 * @throws {SuiteScriptError} INVALID_TOTAL_LINE when using value outside of TotalLine enum for totalLine
		 * @throws {SuiteScriptError} NO_DIMENSION_ITEM_DEFINED when array of dimension items is empty
		 * @return {DataDimension}
		 *
		 * @since 2020.2
		 */
		function createDataDimension(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createDataDimension');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.items], ['options.items'], 'workbook.createDataDimension');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.items, 'options.items', function (items){
				return util.isArray(items) && utilityFunctions.checkArrayType(items, function(item){
					return utilityFunctions.checkObjectType(item, "workbook.DataDimensionItem");
				});
			})]);
			if (options.items.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_DIMENSION_ITEM_DEFINED);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.children, 'options.children', function (children){
				return util.isArray(children) && utilityFunctions.checkArrayType(children, function(child){
					return utilityFunctions.checkObjectType(child, "workbook.DataDimension") || utilityFunctions.checkObjectType(child, "workbook.Section") || utilityFunctions.checkObjectType(child, "workbook.DataMeasure") || utilityFunctions.checkObjectType(child, "workbook.CalculatedMeasure");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.totalLine, 'options.totalLine', util.isString)]);
			if (options.totalLine)
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validTotalling, options.totalLine, false), error.Type.INVALID_TOTAL_LINE, options.totalLine);
			return new DataDimension(options);
		}

		/**
		 * Creates a DataDimensionItem
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression} [options.label] - label to use
		 * @param {Expression} options.expression - expression for this data dimension item
		 * @return {DataDimensionItem}
		 *
		 * @since 2020.2
		 */
		function createDataDimensionItem(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createDataDimensionItem');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.label, 'options.label', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgs([options.expression], ['options.expression'], 'workbook.createDataDimensionItem');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.expression, 'options.expression', function (expr){
				return utilityFunctions.checkObjectType(expr, "workbook.Expression");
			})]);
			return new DataDimensionItem(options);
		}

		/**
		 * Creates a DimensionSelector
		 * @governance none
		 * @param {Object} options
		 * @param {DataDimension|Section} options.dimension - dimension to select
		 * @return {DimensionSelector}
		 *
		 * @since 2020.2
		 */
		function createDimensionSelector(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createDimensionSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.dimension, 'options.dimension', function (dim){
				return utilityFunctions.checkObjectType(dim, "workbook.DataDimension") || utilityFunctions.checkObjectType(dim, "workbook.Section");
			})]);
			return new DimensionSelector(options);
		}

		/**
		 * Creates a SortByDataDimensionItem object
		 * @governance none
		 * @param {Object} options
		 * @param {DataDimensionItem} options.item item to sort by
		 * @param {Sort} options.sort - sort object
		 * @return {SortByDataDimensionItem}
		 *
		 * @since 2020.2
		 */
		function createSortByDataDimensionItem(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createSortByDataDimensionItem');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.sort], ['options.sort'], 'workbook.createSortByDataDimensionItem');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sort, 'options.sort', function (sort){
				return utilityFunctions.checkObjectType(sort, "workbook.Sort");
			})]);
			utilityFunctions.checkArgs([options.item], ['options.item'], 'workbook.createSortByDataDimensionItem');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.item, 'options.item', function (item){
				return utilityFunctions.checkObjectType(item, "workbook.DataDimensionItem");
			})]);
			return new SortByDataDimensionItem(options);
		}

		/**
		 * Creates a field context for table view column
		 * @governance none
		 * @param {Object} options
		 * @param {string}  options.name name of this context
		 * @param   {Object} [options.parameters] parameters of this context
		 * @return {FieldContext}
		 *
		 * @since 2020.2
		 */
		function createFieldContext(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createFieldContext');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name], ['options.name'], 'workbook.createFieldContext');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.name, 'options.name', util.isString)]);
			if (!query.FieldContext[options.name])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_CONTEXT, options.name);
			if (options.name == query.FieldContext.CONVERTED)
			{
				utilityFunctions.checkArgs([options.parameters], ['options.parameters'], 'workbook.createFieldContext');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.parameters, 'options.parameters', util.isObject)]);
				utilityFunctions.checkArgs([options.parameters.currencyId], ['options.parameters.currencyId'], 'workbook.createFieldContext');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.parameters.currencyId, 'options.parameters.currencyId', util.isNumber)]);
				utilityFunctions.checkArgs([options.parameters.date], ['options.parameters.date'], 'workbook.createFieldContext');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.parameters.date, 'options.parameters.date', function(date){
					return util.isDate(date) || (query._isRelativeDate(date) && date.isRange);
				})]);
			}
			return new FieldContext(options);
		}

		/**
		 * Creates a Limiting filter
		 * @governance none
		 * @param {Object} options
		 * @param {boolean} options.row indicates whether this filter is for a row axis (if set to false, then it is on column axis)
		 * @param {number} options.limit limit for this filter
		 * @param {Array<(MeaureSort|SortByDataDimensionItem)>} options.sortBys  - Particular sort by elements
		 * @param {DimensionSelector|DescendantOrSelfNodesSelector|PathSelector|ChildNodesSelector} options.filteredNodesSelector - selector for this filter
		 * @return {LimitingFilter}
		 *
		 * @since 2020.2
		 */
		function createLimitingFilter(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createLimitingFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgsPresent([options.row], ['options.row'], 'workbook.createLimitingFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.row, 'options.row', util.isBoolean)]);
			utilityFunctions.checkArgs([options.filteredNodesSelector], ['options.filteredNodesSelector'], 'workbook.createLimitingFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filteredNodesSelector, 'options.filteredNodesSelector', function (selector){
				return utilityFunctions.checkObjectType(selector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(selector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(selector, "workbook.PathSelector") || utilityFunctions.checkObjectType(selector, "workbook.ChildNodesSelector");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sortBys, 'options.sortBys', function (sortBys){
				return util.isArray(sortBys) && utilityFunctions.checkArrayType(sortBys, function(sortBy){
					return utilityFunctions.checkObjectType(sortBy, "workbook.SortByMeasure") || utilityFunctions.checkObjectType(sortBy, "workbook.SortByDataDimensionItem");
				});
			})]);
			utilityFunctions.checkArgs([options.limit], ['options.limit'], 'workbook.createLimitingFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.limit, 'options.limit', util.isNumber)]);
			return new LimitingFilter(options);
		}

		/**
		 * Creates a DataMeasure
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression} [options.label] label to use
		 * @param {string} options.aggregation - aggregation to use
		 * @param {Expression} options.expression - expression for this measure (if this is a single expression measure)
		 * @param {Array<Expression>} options.expressions - expressions for this measure (if this is a multi expression measure)
		 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both expressions and expression parameters are defined
		 * @throws {SuiteScriptError} AT_LEAST_ONE_EXPRESSION_IS_NEEDED if expressions parameter is empty array
		 * @throws {SuiteScriptError} EXPRESSIONS_MUST_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION when trying to use count distinct aggregation while not defining expressions
		 * @throws {SuiteScriptError} EXPRESSION_MUST_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION when trying to use other than count distinct aggregation while not defining expression
		 * @return {DataMeasure}
		 *
		 * @since 2020.2
		 */
		function createDataMeasure(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createDataMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.aggregation], ['options.aggregation'], 'workbook.createDataMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.aggregation, 'options.aggregation', util.isString)]);
			utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validAggregations, options.aggregation, false), error.Type.INVALID_AGGREGATION, options.aggregation);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.label, 'options.label', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			if (options.expressions)
			{
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.expressions, 'options.expressions', function (expressions){
					return util.isArray(expressions) && utilityFunctions.checkArrayType(expressions, function(expression){
						return utilityFunctions.checkObjectType(expression, "workbook.Expression");
					});
				})]);
				if (options.expressions.length == 0)
					utilityFunctions.throwSuiteScriptError(error.Type.AT_LEAST_ONE_EXPRESSION_IS_NEEDED);
				if (options.expression)
					utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'expression', 'expressions');
			}
			else
			{
				utilityFunctions.checkArgs([options.expression], ['options.expression'], 'workbook.createDataMeasure');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.expression, 'options.expression', function (expr) {
					return utilityFunctions.checkObjectType(expr, "workbook.Expression");
				})]);
			}
			if (options.aggregation == "COUNT_DISTINCT" && !options.expressions)
				utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSIONS_MUST_BE_SPECIFIED_WHEN_USING_COUNT_DISTINCT_AGGREGATION);
			if (options.aggregation != "COUNT_DISTINCT" && !options.expression)
				utilityFunctions.throwSuiteScriptError(error.Type.EXPRESSION_MUST_BE_SPECIFIED_WHEN_USING_OTHER_THAN_COUNT_DISTINCT_AGGREGATION);

			return new DataMeasure(options);
		}

		/**
		 * Creates a CalculatedMeasure
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression} [options.label] label to use
		 * @param {Expression} options.expression - expression for this calculated measure
		 * @return {CalculatedMeasure}
		 *
		 * @since 2021.1
		 */
		function createCalculatedMeasure(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createCalculatedMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.expression], ['options.expression'], 'workbook.createCalculatedMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.expression, 'options.expression', function (expr) {
				return utilityFunctions.checkObjectType(expr, "workbook.Expression");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.label, 'options.label', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			return new CalculatedMeasure(options);
		}

		/**
		 * Creates a chart legend
		 * @governance none
		 * @param {Object} options
		 * @param {Array<ChartAxis>}  options.axes legend axes definition
		 * @param {Section|DataDimension} options.root data to feed the chart from
		 * @param {Array<SortDefinition>} [options.sortDefinitions] Sorting for this legend
		 * @return {Legend}
		 *
		 * @since 2020.2
		 */
		function createLegend(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createLegend');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.root, 'options.root', function (root){
				return utilityFunctions.checkObjectType(root, "workbook.Section") || utilityFunctions.checkObjectType(root, "workbook.DataDimension");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.axes, 'options.axes', function (axes){
				return util.isArray(axes) && utilityFunctions.checkArrayType(axes, function(axis){
					return utilityFunctions.checkObjectType(axis, "workbook.ChartAxis");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sortDefinitions, 'options.sortDefinitions', function (sortDefinitions){
				return util.isArray(sortDefinitions) && utilityFunctions.checkArrayType(sortDefinitions, function(sortDefinition){
					return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
				});
			})]);
			return new Legend(options);
		}

		/**
		 * Creates a SortByMeasure object
		 * @governance none
		 * @param {Object} options
		 * @param {DataMeasure|CalculatedMeasure} options.measure sort by measure
		 * @param {DimensionSelector|DescendantOrSelfNodesSelector|PathSelector|ChildNodesSelector} options.otherAxisSelector selector of this sort
		 * @param {Sort} options.sort - sort object
		 * @return {SortByMeasure}
		 *
		 * @since 2020.2
		 */
		function createSortByMeasure(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createSortByMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.measure], ['options.measure'], 'workbook.createSortByMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.measure, 'options.measure', function (measure){
				return utilityFunctions.checkObjectType(measure, "workbook.DataMeasure") || utilityFunctions.checkObjectType(measure, "workbook.CalculatedMeasure");
			})]);
			utilityFunctions.checkArgs([options.otherAxisSelector], ['options.otherAxisSelector'], 'workbook.createSortByMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.otherAxisSelector, 'options.otherAxisSelector', function (otherAxisSelector){
				return utilityFunctions.checkObjectType(otherAxisSelector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(otherAxisSelector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(otherAxisSelector, "workbook.PathSelector") || utilityFunctions.checkObjectType(otherAxisSelector, "workbook.ChildNodesSelector");
			})]);
			utilityFunctions.checkArgs([options.sort], ['options.sort'], 'workbook.createSortByMeasure');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sort, 'options.sort', function (sort){
				return utilityFunctions.checkObjectType(sort, "workbook.Sort");
			})]);
			return new SortByMeasure(options);
		}

		/**
		 * Creates a PathSelector
		 * @governance none
		 * @param {Object} options
		 * @param {Array<(DescendantOrSelfNodesSelector|DimensionSelector|ChildNodesSelector)>} options.elements
		 * @return {PathSelector}
		 * @throws {SuiteScriptError} NO_ELEMENTS_DEFINED when elements array is empty
		 *
		 * @since 2020.2
		 */
		function createPathSelector(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPathSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.elements], ['options.elements'], 'workbook.createPathSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.elements, 'options.elements', function (elements){
				return util.isArray(elements) && utilityFunctions.checkArrayType(elements, function(element){
					return utilityFunctions.checkObjectType(element, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(element, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(element, "workbook.ChildNodesSelector");
				});
			})]);
			if (options.elements.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_ELEMENTS_DEFINED);
			return new PathSelector(options);
		}

		/**
		 * Creates a pivot
		 * @governance none
		 * @param {Object} options
		 * @param {Array<Expression>} [options.filterExpressions] simple non-aggregated filters
		 * @param {Array<(LimitingFilter|ConditionalFilter)>} [options.aggregationFilters] conditional and limiting filters
		 * @param {string|Expression} options.name name of the pivot
		 * @param {string|Expression} [options.portletName] portlet name of the pivot
		 * @param {string} options.id id of the pivot
		 * @param {PivotAxis} options.rowAxis rowAxis containing sections, data dimensions ...
		 * @param {PivotAxis} options.columnAxis columnAxis containing sections, data dimensions ...
		 * @param {Dataset=} options.dataset Dataset on which is this pivot is based
		 * @param {DatasetLink=} options.datasetLink DatasetLink on which this pivot is based
		 * @param {Array<ReportStyle>} [options.reportStyles] Conditional formatting for this pivot
		 * @return {Pivot}
		 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both dataset and datasetLink are defined
		 * @throws {SuiteScriptError} NEITHER_ARGUMENT_DEFINED if neither dataset nor datasetLink is defined
		 *
		 * @since 2020.2
		 */
		function createPivot(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPivot');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name], ['options.name'], 'workbook.createPivot');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.name, 'options.name', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.portletName, 'options.portletName', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgs([options.id], ['options.id'], 'workbook.createPivot');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'options.id', util.isString)]);
			if (!options.dataset && !options.datasetLink)
				utilityFunctions.throwSuiteScriptError(error.Type.NEITHER_ARGUMENT_DEFINED, 'dataset', 'datasetLink');
			if (options.dataset && options.datasetLink)
				utilityFunctions.throwSuiteScriptError(error.Type.MUTUALLY_EXCLUSIVE_ARGUMENTS, 'dataset', 'datasetLink');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.dataset, 'options.dataset', function (dataset){
				return utilityFunctions.checkObjectType(dataset, "dataset.Dataset");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.datasetLink, 'options.datasetLink', function (datasetLink){
				return utilityFunctions.checkObjectType(datasetLink, "datasetLink.DatasetLink");
			})]);
			utilityFunctions.checkArgs([options.rowAxis], ['options.rowAxis'], 'workbook.createPivot');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rowAxis, 'options.rowAxis', function (rowAxis){
				return utilityFunctions.checkObjectType(rowAxis, "workbook.PivotAxis");
			})]);
			utilityFunctions.checkArgs([options.columnAxis], ['options.columnAxis'], 'workbook.createPivot');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rowAxis, 'options.columnAxis', function (columnAxis){
				return utilityFunctions.checkObjectType(columnAxis, "workbook.PivotAxis");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filterExpressions, 'options.filterExpressions', function (filters){
				return util.isArray(filters) && utilityFunctions.checkArrayType(filters, function(filter){
					return utilityFunctions.checkObjectType(filter, "workbook.Expression");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.aggregationFilters, 'options.aggregationFilters', function (aggregationFilters){
				return util.isArray(aggregationFilters) && utilityFunctions.checkArrayType(aggregationFilters, function(aggregationFilter){
					return utilityFunctions.checkObjectType(aggregationFilter, "workbook.ConditionalFilter") || utilityFunctions.checkObjectType(aggregationFilter, "workbook.LimitingFilter");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.reportStyles, 'options.reportStyles', function (reportStyles){
				return util.isArray(reportStyles) && utilityFunctions.checkArrayType(reportStyles, function(reportStyle){
					return utilityFunctions.checkObjectType(reportStyle, "workbook.ReportStyle");
				});
			})]);
			return new Pivot(options);
		}

		/**
		 * Creates a pivot axis
		 * @governance none
		 * @param {Object} options
		 * @param {Section|DataDimension}  options.root definition of the data
		 * @param {Array<SortDefinition>}  [options.sortDefinitions] sorting definition
		 * @return {PivotAxis}
		 *
		 * @since 2020.2
		 */
		function createPivotAxis(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPivotAxis');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.root], ['options.root'], 'workbook.createPivotAxis');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.root, 'options.root', function (root){
				return utilityFunctions.checkObjectType(root, "workbook.Section") || utilityFunctions.checkObjectType(root, "workbook.DataDimension");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sortDefinitions, 'options.sortDefinitions', function (sortDefinitions){
				return util.isArray(sortDefinitions) && utilityFunctions.checkArrayType(sortDefinitions, function(sortDefinition){
					return utilityFunctions.checkObjectType(sortDefinition, "workbook.SortDefinition");
				});
			})]);
			return new PivotAxis(options);
		}

		/**
		 * Creates a chart series
		 * @governance none
		 * @param {Object} options
		 * @param {Array<Aspect>}  options.aspects - aspects for this series
		 * @return {Series}
		 * @throws {SuiteScriptError} NO_ASPECTS_DEFINED when aspects array is empty
		 *
		 * @since 2020.2
		 */
		function createSeries(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createSeries');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.aspects], ['options.aspects'], 'workbook.createSeries');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.aspects, 'options.aspects', function (aspects){
				return util.isArray(aspects) && utilityFunctions.checkArrayType(aspects, function(aspect){
					return utilityFunctions.checkObjectType(aspect, "workbook.Aspect");
				});
			})]);
			if (options.aspects.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_ASPECTS_DEFINED);
			return new Series(options);
		}


		/**
		 * Creates a Section
		 * @governance none
		 * @param {Object} options
		 * @param {string} [options.totalLine]
		 * @param {Array<(DataDimension|Section|DataMeasure|CalculatedMeasure)>} options.children
		 * @throws {SuiteScriptError} INVALID_TOTAL_LINE when using value outside of TotalLine enum for totalLine
		 * @throws {SuiteScriptError} NO_CHILDREN_DEFINED when children array is empty
		 * @return {Section}
		 *
		 * @since 2020.2
		 */
		function createSection(options)
		{
			if (!options)
				return new Section({});
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createSection');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.children, 'options.children', function (children){
				return util.isArray(children) && utilityFunctions.checkArrayType(children, function(child){
					return utilityFunctions.checkObjectType(child, "workbook.DataDimension") || utilityFunctions.checkObjectType(child, "workbook.Section") || utilityFunctions.checkObjectType(child, "workbook.DataMeasure") || utilityFunctions.checkObjectType(child, "workbook.CalculatedMeasure");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.totalLine, 'options.totalLine', util.isString)]);
			if (options.totalLine)
				utilityFunctions.assertTrue(-1 !== utilityFunctions.arrayIndexOf(validTotalling, options.totalLine, false), error.Type.INVALID_TOTAL_LINE, options.totalLine);
			return new Section(options);
		}

		/**
		 * Creates a Sort object
		 * @param {Object} [options]
		 * @param {boolean} [options.ascending] ascending/descending indicator (defaults to true)
		 * @param {string} [options.locale]  - option for locale specific sorting (validated against query.SortLocale enum)
		 * @param {boolean} [options.nullsLast]  - sort null items last indicator (defaults to the value of ascending parameter)
		 * @param {boolean} [options.caseSensitive]  - case sensitivity indicator
		 * @throws {SuiteScriptError} INVALID_SORT_LOCALE - when using a value outside of query.SortLocale enum for locale parameter
		 * @return {Sort}
		 *
		 * @since 2020.2
		 */
		function createSort(options)
		{
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			if (options == null)
				options = {};
			var locale;
			if (!util.isString(options.locale))
				locale = null;
			else
			{
				queryInternal.validateSortLocale(options.locale);
				locale = options.locale;
			}
			var	ascending = options.ascending == null ? true : !!options.ascending;
			var	nullsLast = options.nullsLast == null ? ascending : !!options.nullsLast;
			var	caseSensitive = !!options.caseSensitive;
			return new Sort({locale: locale, nullsLast: nullsLast, ascending: ascending, caseSensitive: caseSensitive});
		}

		/**
		 * Creates a SortDefinition
		 * @governance none
		 * @param {Object} options
		 * @param {DescendantOrSelfNodesSelector|DimensionSelector|PathSelector|ChildNodesSelector} options.selector  - selector for this sort definition
		 * @param {Array<(MeaureSort|SortByDataDimensionItem)>} options.sortBys  - Particular sort by elements
		 * @throws {SuiteScriptError} NO_SORT_BY_DEFINED - when sortBys array is empty
		 * @return {SortDefinition}
		 *
		 * @since 2020.2
		 */
		function createSortDefinition(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createSortDefinition');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.selector], ['options.selector'], 'workbook.createSortDefinition');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.selector, 'options.selector', function (selector){
				return utilityFunctions.checkObjectType(selector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(selector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(selector, "workbook.PathSelector") || utilityFunctions.checkObjectType(selector, "workbook.ChildNodesSelector");
			})]);
			utilityFunctions.checkArgs([options.sortBys], ['options.sortBys'], 'workbook.createSortDefinition');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sortBys, 'options.sortBys', function (sortBys){
				return util.isArray(sortBys) && utilityFunctions.checkArrayType(sortBys, function(sortBy){
					return utilityFunctions.checkObjectType(sortBy, "workbook.SortByMeasure") || utilityFunctions.checkObjectType(sortBy, "workbook.SortByDataDimensionItem");
				});
			})]);
			if (options.sortBys.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_SORT_BY_DEFINED);
			return new SortDefinition(options);
		}

		/**
		 * Creates a table
		 * @governance none
		 * @param {Object} options
		 * @param {string|Expression} options.name name of the table
		 * @param {string|Expression} [options.portletName] name of the table
		 * @param {string} options.id id of the table view
		 * @param {Dataset} options.dataset Dataset on which is this table view based
		 * @param {Array<TableColumn>} options.columns columns used in this table view
		 * @return {Table}
		 *
		 * @since 2020.2
		 */
		function createTable(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createTable');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name], ['options.name'], 'workbook.createTable');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.name, 'options.name', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.portletName, 'options.portletName', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'options.id', util.isString)]);
			utilityFunctions.checkArgs([options.dataset], ['options.dataset'], 'workbook.createTable');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.dataset, 'options.dataset', function (dataset){
				return utilityFunctions.checkObjectType(dataset, "dataset.Dataset");
			})]);
			utilityFunctions.checkArgs([options.columns], ['options.columns'], 'workbook.createTable');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.columns, 'options.columns', function (columns){
				return util.isArray(columns) && utilityFunctions.checkArrayType(columns, function(column){
					return utilityFunctions.checkObjectType(column, "workbook.TableColumn");
				});
			})]);
			if (options.columns.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_COLUMN_DEFINED);
			return new Table(options);
		}

		/**
		 * Creates a table view column
		 * @governance none
		 * @param {Object} options
		 * @param {TableColumnCondition}  [options.condition] additional condition
		 * @param {number} [options.width] width of the column in pixels
		 * @param {string} options.datasetColumnAlias alias of underlying dataset column
		 * @param {string|Expression} [options.label] label for this column
		 * @param {Sort} options.sort sorting definition for this column
		 * @param {Array<ConditionalFormat>} options.conditionalFormats Conditional formatting for this column
		 * @return {TableColumn}
		 *
		 * @since 2020.2
		 */
		function createTableColumn(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createTableColumn');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.datasetColumnAlias], ['options.datasetColumnAlias'], 'workbook.createTableColumn');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.datasetColumnAlias, 'options.datasetColumnAlias', util.isString)]);
			if (options.condition && !utilityFunctions.checkObjectType(options.condition, "workbook.TableColumnCondition"))
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'condition');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.conditionalFormats, 'options.conditionalFormats', function (conditionalFormats){
				return util.isArray(conditionalFormats) && utilityFunctions.checkArrayType(conditionalFormats, function(conditionalFormat){
					return utilityFunctions.checkObjectType(conditionalFormat, "workbook.ConditionalFormat");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.sort, 'options.sort', function (sort){
				return utilityFunctions.checkObjectType(sort, "workbook.Sort");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fieldContext, 'options.fieldContext', function (fieldContext){
				return utilityFunctions.checkObjectType(fieldContext, "workbook.FieldContext");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.width, 'options.width', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.label, 'options.label', function(val){
				return util.isString(val) || expression.isTranslation(val);
			})]);
			return new TableColumn(options);
		}

		/**
		 * Creates a table column filter
		 * @governance none
		 * @param {Object} options
		 * @param {string}  options.operator operator of this filter
		 * @param {Array<(null|number|string|boolean|Date|Object)>} [options.values] values for this filter
		 * @throws {SuiteScriptError} INVALID_OPERATOR if the operator is not valid
		 * @return {TableColumnFilter}
		 *
		 * @since 2020.2
		 */
		function createTableColumnFilter(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createTableColumnFilter');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.operator], ['options.operator'], 'workbook.createTableColumnFilter');
			queryInternal.validateOperator(options.operator, error.Type.INVALID_OPERATOR);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.values, 'options.values', function (values){
				return util.isArray(values) && utilityFunctions.checkArrayType(values, function(value){
					return value == null || util.isString(value) || util.isBoolean(value) || util.isNumber(value) || util.isDate(value) || utilityFunctions.isObject(value);
				});
			})]);
			query._checkOperatorArity(options.operator, options.values === undefined ? null : options.values);
			return new TableColumnFilter(options);
		}

		/**
		 * Creates a table column condition
		 * @governance none
		 * @param {Object} options
		 * @param {string}  options.operator operator of this filter
		 * @param {Array<TableColumnFilter>} options.filters] filters for this condition
		 * @throws {SuiteScriptError} INVALID_OPERATOR if the operator is not valid
		 * @return {TableColumnCondition}
		 *
		 * @since 2021.1
		 */
		function createTableColumnCondition(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createTableColumnCondition');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.operator], ['options.operator'], 'workbook.createTableColumnCondition');
			if (options.operator != "OR" && options.operator != "AND")
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_OPERATOR, options.operator);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filters, 'options.values', function (values){
				return util.isArray(values) && utilityFunctions.checkArrayType(values, function(value){
					return utilityFunctions.checkObjectType(value, "workbook.TableColumnFilter");
				});
			})]);
			return new TableColumnCondition(options);
		}

		/**
		 * Creates a conditional format rule
		 * @governance none
		 * @param {Object} options
		 * @param {Style}  options.style style to use for this conditional formatting rule
		 * @param {TableColumnFilter} options.filter restriction when such formatting rule should be applied
		 * @return {ConditionalFormatRule}
		 *
		 * @since 2021.1
		 */
		function createConditionalFormatRule(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createConditionalFormatRule');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.filter], ['options.filter'], 'workbook.createConditionalFormatRule');
			utilityFunctions.checkArgs([options.style], ['options.style'], 'workbook.createConditionalFormatRule');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filter, 'options.filter', function (filter){
				return utilityFunctions.checkObjectType(filter, "workbook.TableColumnFilter");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.style, 'options.style', function (style){
				return utilityFunctions.checkObjectType(style, "workbook.Style");
			})]);
			return new ConditionalFormatRule(options);
		}

		/**
		 * Creates a conditional format
		 * @governance none
		 * @param {Object} options
		 * @param {Array<ConditionalFormatRule>} options.rules style to use for this conditional formatting object
		 * @throws {SuiteScriptError} NO_RULE_DEFINED when array rules is empty
		 * @return {ConditionalFormat}
		 *
		 * @since 2021.1
		 */
		function createConditionalFormat(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createConditionalFormat');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rules, 'options.rules', function (rules){
				return util.isArray(rules) && utilityFunctions.checkArrayType(rules, function(rule){
					return utilityFunctions.checkObjectType(rule, "workbook.ConditionalFormatRule");
				});
			})]);
			if (options.rules.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_RULE_DEFINED);
			return new ConditionalFormat(options);
		}

		/**
		 * Creates a report style
		 * @governance none
		 * @param {Object} options
		 * @param {Array<ReportStyleRule>} options.rules rules to apply in this report style
		 * @param {Array<MeasureValueSelector>} options.selectors select where to apply the style
		 * @throws {SuiteScriptError} NO_RULE_DEFINED when array of rules is empty
		 * @throws {SuiteScriptError} NO_SELECTORS_DEFINED when array of selectors is empty
		 * @return {ReportStyle}
		 *
		 * @since 2021.1
		 */
		function createReportStyle(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createReportStyle');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.rules], ['options.rules'], 'workbook.createReportStyle');
			utilityFunctions.checkArgs([options.selectors], ['options.selectors'], 'workbook.createReportStyle');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rules, 'options.rules', function (rules){
				return util.isArray(rules) && utilityFunctions.checkArrayType(rules, function(rule){
					return utilityFunctions.checkObjectType(rule, "workbook.ReportStyleRule");
				});
			})]);
			if (options.rules.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_RULE_DEFINED);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.selectors, 'options.selectors', function (selectors){
				return util.isArray(selectors) && utilityFunctions.checkArrayType(selectors, function(selector){
					return utilityFunctions.checkObjectType(selector, "workbook.MeasureValueSelector");
				});
			})]);
			if (options.selectors.length == 0)
				utilityFunctions.throwSuiteScriptError(error.Type.NO_SELECTORS_DEFINED);
			return new ReportStyle(options);
		}

		/**
		 * Creates a measure value selector
		 * @governance none
		 * @param {Object} options
		 * @param {MeasureSelector} options.measureSelector measures to apply conditional formatting to
		 * @param {DescendantOrSelfNodesSelector|DimensionSelector|PathSelector|ChildNodesSelector} options.rowSelector select row to style
		 * @param {DescendantOrSelfNodesSelector|DimensionSelector|PathSelector|ChildNodesSelector} options.columnSelector select column to style
		 * @return {MeasureValueSelector}
		 *
		 * @since 2021.1
		 */
		function createMeasureValueSelector(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createMeasureValueSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.measureSelector], ['options.measureSelector'], 'workbook.createMeasureValueSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.measureSelector, 'options.measureSelector', function (measureSelector){
				return utilityFunctions.checkObjectType(measureSelector, "workbook.MeasureSelector");
			})]);
			utilityFunctions.checkArgs([options.rowSelector], ['options.rowSelector'], 'workbook.createMeasureValueSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.rowSelector, 'options.rowSelector', function (rowSelector){
				return utilityFunctions.checkObjectType(rowSelector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.PathSelector") || utilityFunctions.checkObjectType(rowSelector, "workbook.ChildNodesSelector");
			})]);
			utilityFunctions.checkArgs([options.columnSelector], ['options.columnSelector'], 'workbook.createMeasureValueSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.columnSelector, 'options.columnSelector', function (columnSelector){
				return utilityFunctions.checkObjectType(columnSelector, "workbook.DescendantOrSelfNodesSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.DimensionSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.PathSelector") || utilityFunctions.checkObjectType(columnSelector, "workbook.ChildNodesSelector");
			})]);
			return new MeasureValueSelector(options);
		}

		/**
		 * Creates a measure selector
		 * @governance none
		 * @param {Object} options
		 * @param {Array<(DataMeasure|CalculatedMeasure)>} options.measures
		 * @throws {SuiteScriptError} NO_MEASURE_DEFINED when array of measures is empty
		 * @return {MeasureSelector}
		 *
		 * @since 2021.1
		 */
		function createMeasureSelector(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createMeasureSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.measures], ['options.measures'], 'workbook.createMeasureSelector');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.measures, 'options.measures', function (measures){
				return util.isArray(measures) && utilityFunctions.checkArrayType(measures, function(measure){
					return utilityFunctions.checkObjectType(measure, "workbook.DataMeasure") || utilityFunctions.checkObjectType(measure, "workbook.CalculatedMeasure");
				});
			})]);
			return new MeasureSelector(options);
		}

		/**
		 * Creates a report style formatting rule
		 * @governance none
		 * @param {Object} options
		 * @param {Style}  options.style style to use for this report style rule
		 * @param {Expression} options.expression restriction when such formatting rule should be applied
		 * @return {ReportStyleRule}
		 *
		 * @since 2021.1
		 */
		function createReportStyleRule(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createReportStyleRule');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.expression], ['options.expression'], 'workbook.createReportStyleRule');
			utilityFunctions.checkArgs([options.style], ['options.style'], 'workbook.createReportStyleRule');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.filter, 'options.expression', function (expression){
				return utilityFunctions.checkObjectType(expression, "workbook.Expression");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.style, 'options.style', function (style){
				return utilityFunctions.checkObjectType(style, "workbook.Style");
			})]);
			return new ReportStyleRule(options);
		}

		/**
		 * Creates a color
		 * @governance none
		 * @param {Object} options
		 * @param {number}  [options.red] red portion of the color
		 * @param {number}  [options.green] green portion of the color
		 * @param {number}  [options.blue] blud portion of the color
		 * @param {number}  [options.alpha] opacity - transparency
		 * @throws {SuiteScriptError} INVALID_COLOR_VALUE if value for any of red|green/blue is either smaller than 0 or greater
		 *     than 255
		 * @throws {SuiteScriptError} INVALID_INVALID_ALPHA_VALUE if value for alpha parameter is either smaller than 0 or greater
		 *     than 1
		 * @return {Color}
		 *
		 * @since 2021.1
		 */
		function createColor(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createColor');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.red, 'options.red', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.green, 'options.green', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.blue, 'options.blue', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.alpha, 'options.alpha', util.isNumber)]);
			if (options.red && (options.red < 0 || options.red > 255))
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, options.red);
			if (options.green && (options.green < 0 || options.green > 255))
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, options.green);
			if (options.blue && (options.blue < 0 || options.blue > 255))
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLOR_VALUE, options.blue);
			if (options.alpha && (options.alpha < 0.0 || options.alpha > 1.0))
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_ALPHA_VALUE, options.alpha);
			return new Color(options);
		}

		/**
		 * Creates a percent-defined background position
		 * @governance none
		 * @param {Object} options
		 * @param {number}  options.percentX percent of the X dimension
		 * @param {number}  options.percentY percent of the Y dimension
		 * @return {PositionPercent}
		 *
		 * @since 2021.1
		 */
		function createPositionPercent(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPositionPercent');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.percentX], ['options.percentX'], 'workbook.createPositionPercent');
			utilityFunctions.checkArgs([options.percentY], ['options.percentY'], 'workbook.createPositionPercent');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.percentX, 'options.percentX', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.percentY, 'options.percentY', util.isNumber)]);
			return new PositionPercent(options);
		}

		/**
		 * Creates a values-defined background position
		 * @governance none
		 * @param {Object} options
		 * @param {string}  options.horizontal horizontal setting
		 * @param {string}  options.vertical vertical setting
		 * @throws {SuiteScriptError} INVALID_POSITION if the value vertical|horizontal position is outside of Position enum
		 * @return {PositionValues}
		 *
		 * @since 2021.1
		 */
		function createPositionValues(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPositionValues');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.horizontal], ['options.horizontal'], 'workbook.createPositionValues');
			utilityFunctions.checkArgs([options.vertical], ['options.vertical'], 'workbook.createPositionValues');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.horizontal, 'options.horizontal', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.vertical, 'options.vertical', util.isString)]);
			if (!POSITIONS[options.horizontal])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_POSITION, options.horizontal);
			if (!POSITIONS[options.vertical])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_POSITION, options.vertical);
			return new PositionValues(options);
		}

		/**
		 * Creates a font size defined by units
		 * @governance none
		 * @param {Object} options
		 * @param {number}  options.size size of the font
		 * @param {string}  options.unit unit of the font size
		 * @throws {SuiteScriptError} INVALID_UNIT when assigned value is outside of Unit enum
		 * @return {FontSize}
		 *
		 * @since 2021.1
		 */
		function createFontSize(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createFontSize');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.size], ['options.size'], 'workbook.createFontSize');
			utilityFunctions.checkArgs([options.unit], ['options.unit'], 'workbook.createFontSize');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.size, 'options.size', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.unit, 'options.unit', util.isString)]);
			if (!UNITS[options.unit])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_UNIT, options.unit);
			return new FontSize(options);
		}

		/**
		 * Creates a background position defined by x/y coordinates and units
		 * @governance none
		 * @param {Object} options
		 * @param {number}  options.x X coordinate
		 * @param {number}  options.y Y coordinate
		 * @param {string}  options.unit units to use for x/y coordinates
		 * @throws {SuiteScriptError} INVALID_POSITION if the value vertical|horizontal position is outside of Position enum
		 * @return {PositionUnits}
		 *
		 * @since 2021.1
		 */
		function createPositionUnits(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createPositionUnits');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.x], ['options.x'], 'workbook.createPositionUnits');
			utilityFunctions.checkArgs([options.y], ['options.y'], 'workbook.createPositionUnits');
			utilityFunctions.checkArgs([options.unit], ['options.unit'], 'workbook.createPositionUnits');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.x, 'options.x', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.y, 'options.y', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.unit, 'options.unit', util.isString)]);
			if (!UNITS[options.unit])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_UNIT, options.unit);
			return new PositionUnits(options);
		}

		/**
		 * Creates a style to be used in conditional formatting
		 * @governance none
		 * @param {Object} options
		 * @param {string} [options.backgroundImage] background image
		 * @param {Color|string} [options.backgroundColor] background color
		 * @param {PositionUnits|PositionValues|PositionPercent} [options.backgroundPosition] background position
		 * @param {string} [options.fontSize] font size
		 * @param {string} [options.fontStyle] font style
		 * @param {string} [options.fontWeight] font weight
		 * @param {string} [options.textAlign] text alignment
		 * @param {Color|string} [options.color] color
		 * @param {Color|string} [options.textDecorationColor] text decoration color
		 * @param {string} [options.textDecorationLine] text decoration line
		 * @param {string} [options.textDecorationStyle] text decoration style
		 * @throws {SuiteScriptError} INVALID_IMAGE if backgroundImage parameter is outside of Image enum
		 * @throws {SuiteScriptError} INVALID_FONT_SIZE if fontSize parameter is outside of FontSize enum
		 * @throws {SuiteScriptError} INVALID_FONT_STYLE if fontStyle parameter is outside of FontStyle enum
		 * @throws {SuiteScriptError} INVALID_FONT_WEIGHT if fontWeight parameter is outside of FontWeight enum
		 * @throws {SuiteScriptError} INVALID_TEXT_ALIGN if textAlign parameter is outside of TextAlign enum
		 * @throws {SuiteScriptError} INVALID_COLOR if backgroundColor, color or textDecorationColor is outside of Color enum
		 *     (while not being color object)
		 * @throws {SuiteScriptError} INVALID_TEXT_DECORATION_LINE if textDecorationLine parameter is outside of TextDecorationLine
		 *     enum
		 * @throws {SuiteScriptError} INVALID_TEXT_DECORATION_STYLE if textDecorationStyle parameter is outside of
		 *     TextDecorationStyle enum
		 * @return {Style}
		 *
		 * @since 2021.1
		 */
		function createStyle(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createStyle');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.backgroundImage, 'options.backgroundImage', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.backgroundColor, 'options.backgroundColor', function(color){
				return util.isString(color) || utilityFunctions.checkObjectType(color, "workbook.Color");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.backgroundPosition, 'options.backgroundPosition', function(position){
				return utilityFunctions.checkObjectType(position, "workbook.PositionValues") || utilityFunctions.checkObjectType(position, "workbook.PositionUnits") || utilityFunctions.checkObjectType(position, "workbook.PositionPercent");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fontSize, 'options.fontSize', function(fontSize){
				return utilityFunctions.checkObjectType(fontSize, "workbook.FontSize") || util.isString(fontSize);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fontStyle, 'options.fontStyle', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.fontStyle, 'options.fontWeight', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.textAlign, 'options.textAlign', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.color, 'options.color', function(color){
				return utilityFunctions.checkObjectType(color, "workbook.Color") || util.isString(color);
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.textDecorationColor, 'options.textDecorationColor', function(color){
				return util.isString(color) || utilityFunctions.checkObjectType(color, "workbook.Color");
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.textDecorationLine, 'options.textDecorationLine', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.textDecorationStyle, 'options.textDecorationStyle', util.isString)]);
			if (options.backgroundImage && !IMAGES[options.backgroundImage])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_IMAGE, options.backgroundImage);
			if (options.fontSize && !FONT_SIZES[options.fontSize] && !(options.fontSize instanceof FontSize))
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FONT_SIZE, options.fontSize);
			if (options.fontStyle && !FONT_STYLES[options.fontStyle])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FONT_STYLE, options.fontStyle);
			if (options.textAlign && !TEXT_ALIGNS[options.textAlign])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_ALIGN, options.textAlign);
			if (util.isString(options.backgroundColor) && !COLORS[options.backgroundColor])
				utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, options.backgroundColor);
			if (util.isString(options.color) && !COLORS[options.color])
				utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, options.color);
			if (util.isString(options.textDecorationColor) && !COLORS[options.textDecorationColor])
				utilityFunctions.throwSuiteScriptError(error.Type.UNSUPPORTED_COLOR, options.textDecorationColor);
			if (options.textDecorationLine && !TEXT_DECORATION_LINES[options.textDecorationLine])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_DECORATION_LINE, options.textDecorationLine);
			if (options.textDecorationStyle && !TEXT_DECORATION_STYLES[options.textDecorationStyle])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEXT_DECORATION_STYLE, options.textDecorationStyle);
			return new Style(options);
		}

		/**
		 * Create a Workbook object
		 * @governance none
		 * @param {Object} options
		 * @param {Array<Pivot>} [options.pivots] Pivots in this workbook
		 * @param {Array<Chart>} [options.charts] Charts in this workbook
		 * @param {Array<Table>} [options.tables] Tables in this workbook
		 * @return {Workbook}
		 *
		 * @since 2020.2
		 */
		function createWorkbook(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.create');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.pivots, 'options.pivots', function (pivots){
				return util.isArray(pivots) && utilityFunctions.checkArrayType(pivots, function(pivot){
					return utilityFunctions.checkObjectType(pivot, "workbook.Pivot");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.charts, 'options.charts', function (charts){
				return util.isArray(charts) && utilityFunctions.checkArrayType(charts, function(chart){
					return utilityFunctions.checkObjectType(chart, "workbook.Chart");
				});
			})]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.tables, 'options.tables', function (tableViews){
				return util.isArray(tableViews) && utilityFunctions.checkArrayType(tableViews, function(tableView){
					return utilityFunctions.checkObjectType(tableView, "workbook.Table");
				});
			})]);
			return new Workbook({pivots: options.pivots, charts: options.charts, tables: options.tables});
		}

		/**
		 * Create translation expression
		 * @param {Object} options
		 * @param {string} {options.key} Key of the translation
		 * @param {string} {options.collection} Collection of the translation
		 * @return {Expression} Expression for the translation
		 *
		 * @since 2021.2
		 */
		function createTranslation(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createTranslation');
			if (!util.isString(options.translationId)) {
				utilityFunctions.checkArgs([options.key], ['options.key'], 'workbook.createTranslation');
				utilityFunctions.checkArgs([options.collection], ['options.collection'], 'workbook.createTranslation');
			}
			return expression.createTranslation(options);
		}

		/**
		 * Creates a Range object
		 * @param {Object} options
		 * @param {string} {options.start} Date or Date time formatted as string
		 * @param {string} {options.end} Date or Date time formatted as string
		 * @return {Range} Range object
		 *
		 * @since 2021.2
		 */
		function createRange(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createRange');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.start], ['options.start'], 'workbook.createRange');
			utilityFunctions.checkArgs([options.end], ['options.end'], 'workbook.createRange');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.start, 'options.start', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.end, 'options.end', util.isString)]);
			return new Range(options);
		}

		/**
		 * Creates a Duration object
		 * @param {Object} options
		 * @param {string} {options.start} Date or Date time formatted as string
		 * @param {string} {options.end} Date or Date time formatted as string
		 * @throws {SuiteScriptError} INVALID_TEMPORAL_UNIT if provided units are outside of TemporalUnit enum
		 * @return {Duration} Duration object
		 *
		 * @since 2021.2
		 */
		function createDuration(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createDuration');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.amount], ['options.amount'], 'workbook.createDuration');
			utilityFunctions.checkArgs([options.units], ['options.units'], 'workbook.createDuration');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.amount, 'options.amount', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.units, 'options.units', util.isString)]);
			if (!expression.TemporalUnit[options.units])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_TEMPORAL_UNIT, options.units);
			return new Duration(options);
		}

		/**
		 * Creates a complex RecordKey object from an object
		 * @param {Object} options Properties of the record key (e. g. {numberkey: 1, stringkey:"a"})
		 * @return {RecordKey} RecordKey object
		 *
		 * @since 2021.2
		 */
		function createComplexRecordKey(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createRecordKey');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', function(obj){
				if (!utilityFunctions.isObject(obj))
					return false;
				var i = 0;
				for (var prop in obj)
				{
					if (!util.isString(prop) || !util.isNumberOrString(obj[prop]))
						return false;
					i++;
				}
				return i > 1;
			})]);
			return new RecordKey(options);
		}

		/**
		 * Creates a RecordKey object
		 * @param {Object} options
		 * @param {string|number} {options.key} string or number key
		 * @return {RecordKey} RecordKey object
		 *
		 * @since 2021.2
		 */
		function createSimpleRecordKey(options)
		{
			var key;
			if (util.isString(options) || util.isNumber(options))
				key = options;
			else if (util.isObject(options))
				key = options.key;
			utilityFunctions.checkArgs([key], ['options.key'], 'workbook.createRecordKey');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(key, 'options.key', util.isNumberOrString)]);
			return new RecordKey({"__key__": key});
		}

		/**
		 * Creates a Currency object
		 * @param {Object} options
		 * @param {number} {options.amount} Currency amount
		 * @param {string} {options.id} Currency id
		 * @throws {SuiteScriptError} INVALID_CURRENCY if provided currency id is outside of Currency enum
		 * @return {Currency} Range object
		 *
		 * @since 2021.2
		 */
		function createCurrency(options)
		{
			utilityFunctions.checkArgs([options], ['options'], 'workbook.createCurrency');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.amount], ['options.amount'], 'workbook.createCurrency');
			utilityFunctions.checkArgs([options.id], ['options.id'], 'workbook.createCurrency');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.amount, 'options.amount', util.isNumber)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.id, 'options.id', util.isString)]);
			if (!expression.Currency[options.id])
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_CURRENCY, options.id);
			return new Currency(options);
		}

		/**
		 * Create pivot storage which can be used to hold results of asynchronous pivot execution
		 * @governance 10 units
		 * @return {number} Id of pivot storage which can be used to retrieve results of asynchronous pivot execution
		 *
		 * @deprecated
		 * @since 2021.2
		 */
		function createPivotStorage()
		{
			var isPromise = utilityFunctions.isPromiseCallback(this);
			var result = invoker(workbookApi, "createPivotStorage", [], isPromise ? this : undefined);
			if (!isPromise)
				return result;
		}

		/**
		 * Asynchronously create pivot storage which can be used to hold results of asynchronous pivot execution
		 * @governance 10 units
		 * @return {Promise<number>} promise to id of pivot storage which can be used to retrieve results of asynchronous pivot execution
		 *
		 * @deprecated
		 * @since 2021.2
		 */
		createPivotStorage.promise = function()
		{
			return utilityFunctions.promiseTo(createPivotStorage);
		};

		/**
		 * Loads pivot results from storage
		 * @governance 10 units
		 * @param {Object} options
		 * @param {number} options.id id of the pivot storage
		 *
		 * @return {Iterator}
		 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE when method is called from browser
		 * @deprecated
		 * @since 2021.2
		 */
		function loadPivotResults(options)
		{
			if (environment.isClientSide())
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_API_USAGE);
			var id = (options && options.hasOwnProperty('id')) ? options.id : options;
			utilityFunctions.checkArgs([id], ['id'], 'workbook.loadPivotResults');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isNumber)]);
			var isPromise = utilityFunctions.isPromiseCallback(this);
			var delegate = invoker(workbookApi, "loadPivotResults", [id], isPromise ? this : undefined);
			if (!isPromise)
				return loadPivotPostProcess({result: delegate});
		}

		/**
		 * Asynchronously loads pivot results from storage
		 * @governance 10 units
		 * @param {Object} options
		 * @param {number} options.id id of the pivot storage

		 * @return {Promise}
		 *
		 * @deprecated
		 * @since 2021.2
		 */
		loadPivotResults.promise = function()
		{
			return utilityFunctions.promiseTo(loadPivotResults, arguments, loadPivotPostProcess);
		};

		return Object.freeze({
			load: loadWorkbook,
			createConstant: expression.createConstant,
			createExpression: expression.create,
			createAspect: createAspect,
			createCategory: createCategory,
			createChart: createChart,
			createChartAxis: createChartAxis,
			createConditionalFilter: createConditionalFilter,
			createDataDimension: createDataDimension,
			createDataDimensionItem: createDataDimensionItem,
			createDimensionSelector: createDimensionSelector,
			createSortByDataDimensionItem: createSortByDataDimensionItem,
			createFieldContext: createFieldContext,
			createLegend: createLegend,
			createLimitingFilter: createLimitingFilter,
			createDataMeasure: createDataMeasure,
			createCalculatedMeasure: createCalculatedMeasure,
			createSortByMeasure: createSortByMeasure,
			createPathSelector: createPathSelector,
			createPivot: createPivot,
			createPivotAxis: createPivotAxis,
			createSection: createSection,
			createSeries: createSeries,
			createSort: createSort,
			createSortDefinition: createSortDefinition,
			createTable: createTable,
			createTableColumn: createTableColumn,
			createTableColumnFilter: createTableColumnFilter,
			createTableColumnCondition: createTableColumnCondition,
			createConditionalFormatRule: createConditionalFormatRule,
			createConditionalFormat: createConditionalFormat,
			createStyle: createStyle,
			createColor: createColor,
			createPositionPercent: createPositionPercent,
			createPositionUnits: createPositionUnits,
			createPositionValues: createPositionValues,
			createFontSize: createFontSize,
			createReportStyle: createReportStyle,
			createReportStyleRule: createReportStyleRule,
			createMeasureSelector: createMeasureSelector,
			createMeasureValueSelector: createMeasureValueSelector,
			createTranslation: createTranslation,
			createRange: createRange,
			createCurrency: createCurrency,
			createDuration: createDuration,
			createComplexRecordKey: createComplexRecordKey,
			createSimpleRecordKey: createSimpleRecordKey,
			create: createWorkbook,
			createPivotStorage: createPivotStorage,
			loadPivotResults: loadPivotResults,
			list: analyticsListing.getListingHandle(workbookApi).list,
			listPaged: analyticsListing.getListingHandle(workbookApi).listPaged,
			DescendantOrSelfNodesSelector: descendantOrSelfNodesSelector,
			ChildNodesSelector: childNodesSelector,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Stacking: STACKING,
			/**
			 * @enum {string}
			 * @readonly
			 */
			ChartType: CHART_TYPE,
			/**
			 * @enum {string}
			 * @readonly
			 */
			AspectType: ASPECTS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			TotalLine: TOTAL_LINE,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Color: COLORS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Image: IMAGES,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Unit: UNITS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Position: POSITIONS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			FontSize: FONT_SIZES,
			/**
			 * @enum {string}
			 * @readonly
			 */
			FontStyle: FONT_STYLES,
			/**
			 * @enum {string}
			 * @readonly
			 */
			FontWeight: FONT_WEIGHTS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			TextAlign: TEXT_ALIGNS,
			/**
			 * @enum {string}
			 * @readonly
			 */
			TextDecorationLine: TEXT_DECORATION_LINES,
			/**
			 * @enum {string}
			 * @readonly
			 */
			TextDecorationStyle: TEXT_DECORATION_STYLES,
			/**
			 * @enum {string}
			 * @readonly
			 */
			Aggregation: AGGREGATION,
			DateTimeProperty: expression.DateTimeProperty,
			DateTimeHierarchy: expression.DateTimeHierarchy,
			ConstantType: expression.ConstantType,
			ExpressionType: expression.Expression,
			ComparisonType: expression.ComparisonType,
			TemporalUnit: expression.TemporalUnit,
			get Currency() {
				return expression.Currency;
			}
		});
	});

/**
 * @private
 */
define('N/restricted/recordApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript notification module
 *
 * @private
 * @module N/notification
 * @suiteScriptVersion 2.x
 *
 */
define('N/notification',['N/utilityFunctions'],function (utilityFunctions) {

	var TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

	function Severity(type)
	{
		/**
		 * @type {number}
		 * @readonly
		 * @throws READ_ONLY_PROPERTY when setting the property is attempted
		 */
		utilityFunctions.addReadOnlyProperty(this, 'value', function ()
		{
			return type;
		});

		/**
		 * @type {string}
		 * @readonly
		 * @throws READ_ONLY_PROPERTY when setting the property is attempted
		 */
		utilityFunctions.addReadOnlyProperty(this, 'label', function ()
		{
			return getLabel(type);
		});

		/**
		 * @param {Object} options
		 * @return {Severity}
		 */
		this.proxy = function (options)
		{
			return this;
		}
	}

	function getLabel(severity)
	{
		/* system default is confirmation */
		var label = 'Confirmation';
		switch(severity)
		{
			case TYPE.INFORMATION:
				label = 'Information';
				break;
			case TYPE.WARNING:
				label = 'Warning';
				break;
			case TYPE.ERROR:
				label = 'Error';
				break;
		}
		return label;
	}

	return Object.freeze({
		Type : TYPE,
		create: function(args)
		{
			return new Severity(args);
		}
	});
});
(function () {
var _NS_define = define;
/**
 * Loader for V2.x scripts
 *
 * @private
 * @module N/scriptLoader
 * @NApiVersion 2.x
 */
define('N/scriptLoader',[], function () {
	var inEmulatedTestEnvironment = typeof globalTestExposures !== 'undefined';

	function getEntryPointRequire(config) {
		var reconfigure = (config != null && config.context != null);
		var configuredRequire = reconfigure ? require.config(config) : require;

		var retrievalId = String.fromCharCode(95, 36, 89, 36);
		_NS_define(retrievalId, ["require"], function (sysRequire) { return sysRequire; });
		configuredRequire([retrievalId], function () {});

		return function entryPointRequire(deps, callback) {
			return configuredRequire([retrievalId], function (systemRequire) {
				return systemRequire(deps, callback);
			});
		};
	}

	function v2ScriptLoader(systemId, moduleObject, loadCallback) {

		var script =  moduleObject.script;

		var rConfig = JSON.parse(script.amdConfig);
		rConfig["context"] = script.scriptInfo;
		if (systemId && !inEmulatedTestEnvironment) {
			rConfig["context"] = String(systemId + ':' + rConfig["context"]);
		}
		// netsuite configuration object
		rConfig._NS = {};
		// add info about media hash code to enable caching of client scripts
		if (script.mediaHashCode) {
			rConfig._NS.mediaHashCode = script.mediaHashCode;
		}
		// add info about last modified time for caching
		if (script.timestamp) {
			rConfig._NS.timestamp = script.timestamp;
		}
		// instruct NsRequire to shield the client scripts from using some of our internal stuff
		rConfig._NS.shieldV2Callback = false;

		rConfig._NS = Object.freeze(rConfig._NS);

		// we need to extend the config with the parent path since this is
		// the only way how to make this work in NEW UI
		// see FormScriptMetadataFactory for cases when the parent path is set
		// TODO: move to _NS config object
		if (script.parentModulePath)
			rConfig["parentModulePath"] = script.parentModulePath;

		var entryPointRequire = getEntryPointRequire(rConfig);

		entryPointRequire([script.scriptInfo], function (handler) {
			moduleObject.load(handler);
			if (util.isFunction(loadCallback)) {
				loadCallback();
			}
		});
	}

	/**
	 * Object describing the client script
	 *
	 * @public
	 * @param {Object} options
	 * @param {Function} options.script - script info for the client script
	 * @param {String} [options.enabled]
	 * @param {Number} [options.localizationScriptLimit]
	 * @constructor
	 */
	function ModuleDescriptor(options) {

		var that = this;

		if (!util.isObject(options) || !options || !util.isObject(options.script))
			throw "Error need init object with script";

		var moduleObject = {
			'script': options.script,
			'handler': null,
			'enabled': false,
			'active': false,
			'loaded': false,
			'locale': undefined,
			'localized': false
		};
		var readonly = ['script', 'locale', 'localized'];
		var internal = ['handler'];

		if (options.script.locale && util.isString(options.script.locale)) {
			var _locale = options.script.locale.split(',');
			if (_locale[0]) {
				moduleObject.locale = _locale;
				moduleObject.localized = true;
			}
		}

		// generate property getters for general use
		Object.getOwnPropertyNames(moduleObject).forEach(function(prop) {
			if (internal.indexOf(prop)!==-1)
				return;
			Object.defineProperty(that, prop, {
				get: function () { return moduleObject[prop] },
				set: function () { throw "Cannot set " + prop; },
				configurable: false
			});
		});
		Object.defineProperty(this, 'triggers', {
			get: function () { return Object.getOwnPropertyNames(moduleObject.handler || {}).filter(function(name) { return util.isFunction(name); }); },
			set: function () { throw "Cannot set triggers"; },
			configurable: false
		});

		this.getTrigger = function getTrigger(trigger) {
			return moduleObject.handler ? moduleObject.handler[trigger] : undefined;
		};
		/**
		 * Check whether module's locale matches the input locale
		 * @param {String|Array} locale locales to match with module's locale
		 * @return {boolean} true iff module is localized and matches at least one of the input locales
		 */
		this.hasLocale = function hasLocale(locale) {
			if (!moduleObject.locale || !locale)
				return false;
			var locales = util.isArray(locale) ? locale : [locale];
			return locales.filter(function (locale) { return moduleObject.locale.indexOf(locale) !== -1 }).length > 0;
		};
		this.enable = function enable() {
			moduleObject.enabled = true;
		};
		this.disable = function disable() {
			moduleObject.enabled = false;
		};
		this.activate = function activate() {
			moduleObject.active = true;
		};
		this.deactivate = function deactivate() {
			// need to clear both active and enabled
			moduleObject.active = false;
			moduleObject.enabled = false;
		};
		this.load = function load(handler) {
			moduleObject.handler = handler;
			moduleObject.loaded = true;
			moduleObject.active = !moduleObject.localized;
		};
		this.update = function update(dataObject) {
			if (!dataObject)
				return;
			Object.getOwnPropertyNames(dataObject).forEach(function (prop) {
				if (readonly.indexOf(prop) === -1 && moduleObject.hasOwnProperty(prop))
					moduleObject[prop] = dataObject[prop];
			});
		};

		this.shouldExecuteTrigger = function shouldExecuteTrigger(locale, trigger)
		{
			if (!moduleObject.enabled)
				return false;
			if (!moduleObject.loaded) {
				console.warn("This state shouldn't happen.  Locale: " + locale + ", module: " + JSON.stringify(that));
				return false;
			}
			var isActive = moduleObject.active;
			var isLocalized = moduleObject.localized;
			var isCorrectLocale = that.hasLocale(locale);
			var shouldExecute = false;
			if  (trigger === "pageInit") {
				shouldExecute = !isLocalized && isActive;
			}
			else if (trigger === "localizationContextEnter") {
				shouldExecute = isLocalized && isCorrectLocale && !isActive; // run for all locale scripts with correct locale
			}
			else if (trigger === "localizationContextExit") {
				shouldExecute = isLocalized && !isCorrectLocale && isActive; // run for all locale scripts with incorrect locale
			}
			else {
				shouldExecute = isActive;
			}
			return shouldExecute;
		};

		this.toJSON = function toJSON() {
			var jsonObj = {};
			Object.getOwnPropertyNames(that).forEach(function(prop) {
				if (!util.isFunction(prop))
					jsonObj[prop] = that[prop];
			});
			return jsonObj;
		};

		Object.freeze(this);
		return this;
	}

	/**
	 * Object holding all clients script handlers to be executed.
	 *
	 * @public
	 * @param {Object} options
	 * @param {Array} options.scriptList
	 * @param {String} [options.systemId]
	 * @param {Number} [options.localizationScriptLimit]
	 * @constructor
	 */
	function ModuleKeeper(options) {
		if (!options || !util.isArray(options.scriptList))
			throw "Invalid argument options: " + options;

		var systemId = options.systemId;
		var localizationScriptLimit = options.localizationScriptLimit;
		var scriptList = options.scriptList;
		var modules = {}; // set of unique modules
		var scriptKeys = []; // array of all script keys in order

		scriptList.forEach(function(script) {
			if (util.isObject(script)) {
				var key = getScriptKey(script);
				scriptKeys.push(key);
				if (!getModuleObject(key)) {
					modules[key] = new ModuleDescriptor({script: script});
				}
			}
		});

		function loadModule(moduleObject, locale, callback) {
			var script = moduleObject.script;
			var wasEnabled = moduleObject.enabled;
			shouldEnableModuleForLocale(moduleObject, locale) ? moduleObject.enable() : moduleObject.disable();
			if (!wasEnabled && moduleObject.enabled) {
				if (isLegacySS(script)) {
					var handler = {};
					if (script.scriptInfo && util.isString(script.scriptInfo))
						handler = JSON.parse(script.scriptInfo);
					if (script.scriptInfo && util.isObject(script.scriptInfo))
						handler = script.scriptInfo;
					moduleObject.load(handler);
				} else {
					if (!moduleObject.loaded)
						v2ScriptLoader(systemId, moduleObject, callback);  // do the actual asynchronous loading
				}
			} else {
				if (!moduleObject.enabled && moduleObject.active)
					throw "This state shouldn't happen.  Locale: " + locale + ", module: " + JSON.stringify(moduleObject);
			}
		}

		function isLegacySS(script)
		{
			return !script.version || script.version === '1.0';
		}

		function shouldEnableModuleForLocale(moduleObject, locale)
		{
			return isWithinLimit(moduleObject.script) && (isLegacySS(moduleObject.script) || !moduleObject.localized || (moduleObject.hasLocale(locale)));
		}

		function isWithinLimit(module)
		{
			if (module.localized)
				return !util.isNumber(localizationScriptLimit) || modules.filter(function (module) { return module.localized && module.enabled; }).length <= localizationScriptLimit;
			return true;
		}

		function doLoadModules(locale, callback)
		{
			scriptKeys.forEach(function(key) {
				loadModule(getModuleObject(key), locale, callback);
			});
		}

		function doLoadModulesPromise(locale) {
			return new Promise(function(resolve, reject) {
				function callback() {
					if (!isLoadingModules(locale))
						resolve();
				}
				try {
					doLoadModules(locale, callback);
					callback();
				} catch (e)
				{
					reject(e);
				}
			});
		}

		function loadModules() {
			doLoadModules();
		}
		loadModules.promise = doLoadModulesPromise.bind(this, null);

		function loadModulesWithLocale(locale) {
			doLoadModules(locale);
		}
		loadModulesWithLocale.promise = doLoadModulesPromise;

		function getScriptKey(script) {
			return util.isString(script) ? script : "" + JSON.stringify(script);
		}

		function getModuleObject(script) {
			return modules[getScriptKey(script)];
		}

		function getOrderedModuleInfos() {
			return scriptKeys.map(function(key) { return getModuleObject(key); }) || [];
		}

		function isLoadingModules(locale) {
			return Object.keys(modules).filter(function (key) {
				return (modules[key].enabled && !modules[key].loaded && (!locale || !modules[key].localized || modules[key].hasLocale(locale)));
			}).length !== 0;
		}

		return Object.freeze({
			loadModules: loadModules,
			loadModulesWithLocale: loadModulesWithLocale,
			getModuleObject: getModuleObject,
			getOrderedModuleInfos: getOrderedModuleInfos,
			isLoadingModules: isLoadingModules
		});
	}

	return {
		getEntryPointRequire: getEntryPointRequire,
		createModuleKeeper : function (options) { return new ModuleKeeper(options); }
	};

});
})();
/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/record/recordEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordEvent',[],function () {
    var EVENT_TYPE = Object.freeze({
        ERROR: 'ERROR',

        UPDATE_ALL: 'UPDATE_ALL',
	    HANDLE_CHANGE_CALL: 'HANDLE_CHANGE_CALL',
        RECORD_INITIALIZED: 'RECORD_INITIALIZED',
        RECORD_SAVABLE: 'RECORD_SAVABLE',
        RECORD_NOT_SAVABLE: 'RECORD_NOT_SAVABLE',

        UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
        UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
	    CREATE_SUBRECORD: 'CREATE_SUBRECORD',
	    UPDATE_SUBRECORD: 'UPDATE_SUBRECORD',
	    REMOVE_SUBRECORD: 'REMOVE_SUBRECORD',
        UPDATE_SUBLIST: 'UPDATE_SUBLIST',
        CREATE_LINE: 'CREATE_LINE',
        UPDATE_LINE: 'UPDATE_LINE',
        INSERT_LINE: 'INSERT_LINE',
        REMOVE_LINE: 'REMOVE_LINE',
	    MOVE_LINE: 'MOVE_LINE',
        SELECT_LINE: 'SELECT_LINE',
        LINE_COMMITTABLE: 'LINE_COMMITTABLE',
        LINE_NOT_COMMITTABLE: 'LINE_NOT_COMMITTABLE',
        UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

        FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
        FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
        FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
        FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
        FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
        FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
        FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

        SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
        SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
        SUBLIST_COLUMN_IS_DISABLED_CHANGE: 'SUBLIST_COLUMN_IS_DISABLED_CHANGE',
        SUBLIST_COLUMN_IS_MANDATORY_CHANGE: 'SUBLIST_COLUMN_IS_MANDATORY_CHANGE',
        SUBLIST_COLUMN_IS_DISPLAY_CHANGE: 'SUBLIST_COLUMN_IS_DISPLAY_CHANGE',
        SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE',

        VALIDATION_FAILED: 'VALIDATION_FAILED',

	    NOTIFY: 'NOTIFY',
	    CONFIRM: 'CONFIRM'
    });

    function isColumnEvent(type)
    {
        return [EVENT_TYPE.SUBLIST_COLUMN_IS_DISABLED_CHANGE,
            EVENT_TYPE.SUBLIST_COLUMN_IS_MANDATORY_CHANGE,
            EVENT_TYPE.SUBLIST_COLUMN_IS_DISPLAY_CHANGE,
            EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE].indexOf(type) > -1;
    }

    return Object.freeze({
        Type : EVENT_TYPE,
	    isColumnEvent: isColumnEvent
    });
});
/**
 * SuiteScript module for routing and storing messages/dialogs
 *
 * @private
 * @module N/msgRouter
 * @suiteScriptVersion 2.x
 */
define(
	'N/msgRouter',['N/nsobject', 'N/utilityFunctions', 'N/restricted/remoteApiBridge', 'N/internal/invoker', 'N/contextSwitch', 'N/currentRecordService'],
	function (nsobject, utilityFunctions, remoteApi, invoker, contextSwitch, currentRecordService)
	{
		function isServerSide() { return typeof document === 'undefined'; }

		/**
		 * Simple object that contains information about the message stored on the record
		 * @param {Object} [options] all information to be stored about the message
		 * @returns {Message}
		 * @constructor
		 */
		function Message (options)
		{
			var TYPE = 'Message';
			var msgInfo = options;

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return msgInfo;
			};
		}
		Object.freeze(Message);

		/**
		 * internal message queue implementation
		 * @returns {MessageQueueImpl}
		 * @constructor
		 */
		function MessageQueueImpl()
		{
			var TYPE = 'msgRouter.MessageQueueImpl';

			/** the actual container where the messages (@see Message) are kept */
			var messageContainer = [];

			this.storeMessage = function (options)
			{
				var msgOptions = {};
				if (!options)
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'options');
				if (!options.hasOwnProperty('source'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'source');
				if (!options.hasOwnProperty('data'))
					utilityFunctions.throwSuiteScriptError('SSS_MISSING_REQD_ARGUMENT', 'data');
				msgOptions.source = options.source;
				msgOptions.data = options.data;
				msgOptions.reply = {value: options.reply || null};
				msgOptions.timestamp = (new Date()).getTime();

				if (isServerSide() && options.source === 'message.Message' && options.forClient === true)
				{
					msgOptions.forClient = options.forClient;
					sendMessageToClient(msgOptions.data);
				}
				messageContainer.push(new Message(msgOptions));
			};

			this.getMessages = function ()
			{
				return messageContainer.slice(0, messageContainer.length);
			};

			var DEFAULT_PROMPT_AUTO_RESPONSE = '';
			var DEFAULT_DIALOG_AUTO_RESPONSE = true;
			var DEFAULT_CONFIRM_AUTO_RESPONSE = true;

			/**
			 * provides an auto-reply for a dialog type specified by options parameter
			 * @param {Object} options
			 * @param {string} options.dialogType can be one of 'prompt', 'dialog', 'confirm'
			 * @param {string} options.dialogOptions this is for the dialog to pass in the buttons defined for the message
			 * @returns {?Object|boolean|string} auto response for the selected dialog type or null
			 */
			this.getAutoResponse = function getAutoResponse(options)
			{
				// TODO: allow to set auto response for a record via the MessageService object
				if (!options || !options.dialogType)
				{
					return null;
				}
				if (options.dialogType === 'prompt')
				{
					return DEFAULT_PROMPT_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'confirm')
				{
					return DEFAULT_CONFIRM_AUTO_RESPONSE;
				}
				else if (options.dialogType === 'dialog')
				{
					if (options.dialogOptions &&
						options.dialogOptions.buttons &&
						options.dialogOptions.buttons.length > 0)
					{
						return options.dialogOptions.buttons[0].value;
					}
					else
						return DEFAULT_DIALOG_AUTO_RESPONSE;
				}
				return null;
			};

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageQueueImpl);

		var defaultQueue = new MessageQueueImpl();
		var isInternal = false;

		/**
		 * a public message queue to be available as a record's property to retrieve all messages stored on the record
		 * @returns {MessageService}
		 * @constructor
		 */
		function MessageService()
		{
			var TYPE = 'Record.MessageService';

			var messageQueue = new MessageQueueImpl();

			function getMessageQueue()
			{
				return messageQueue;
			}

			Object.defineProperty(this, 'getMessageQueue', {
				get: function ()
				{
					if (isInternal)
					{
						return getMessageQueue;
					}
				}
			});

			/**
			 * retrieves all messages from the message queue
			 * @returns {Array<Message>} a list of all messages in the queue
			 */
			this.getMessages = function ()
			{
				return messageQueue.getMessages();
			};

			//TODO: setAutoResponse() method that would allow user to define an auto-response for the record messages

			this.toString = function ()
			{
				return TYPE;
			};

			this.toJSON = function ()
			{
				return {};
			};
		}
		Object.freeze(MessageService);

		/**
		 * provides the currently active MessageQueueImpl instance to store a message into it
		 * @returns {MessageQueueImpl} the active MessageQueueImpl instance, either related to a specific record, or a default one (i.e. id is 0)
		 */
		var getActiveQueue = function getActiveQueue()
		{
			var record = currentRecordService.get();
			if (!record)
			{
				return defaultQueue;
			}
			isInternal = true;
			try
			{
				return record.getMessageService().getMessageQueue();
			}
			finally
			{
				isInternal = false;
			}
		};

		/**
		 * provides a new instance of MessageService to be related to a Record instace
		 * @returns {MessageService}
		 */
		var getMessageServiceInstance = function getMessageServiceInstance()
		{
			return new MessageService();
		};

		// this is here to overload all Javascript native messaging methods
		// so we can also relate them to a record
		(function overloadGlobalAlerts() {
			var global = this;

			function getArgs(args) {
				var _args = [];
				for (var i = 0; i < args.length; i++)
					_args.push(args[i]);
				return _args;
			}

			var gAlert = global.alert;
			global.alert = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.alert', data: {args: getArgs(arguments)}, reply: null};
				if (gAlert) gAlert.apply(null, arguments);
				queue.storeMessage(msg);
			};
			var gPrompt = global.prompt;
			global.prompt = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.prompt', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gPrompt ? gPrompt.apply(null, arguments) : queue.getAutoResponse({dialogType: 'prompt'});
				queue.storeMessage(msg);
				return msg.reply;
			};
			var gConfirm = global.confirm;
			global.confirm = function () {
				var queue = getActiveQueue();
				var msg = {source: 'window.confirm', data: {args: getArgs(arguments)}, reply: null};
				msg.reply = gConfirm ? gConfirm.apply(null, arguments) : queue.getAutoResponse({dialogType: 'confirm'});
				queue.storeMessage(msg);
				return msg.reply;
			};
		})();

		function sendMessageToClient(message)
		{
			if (util.isObject(message))
			{
				var msgJson = JSON.stringify(message);
				invoker(remoteApi, 'sendMessageToClient', [msgJson]);
			}
		}

		var MESSAGE_FIELD = 'custpage__ss_messages_for_client';
		/**
		 * Used to display messges sent from Before Load to the client
		 * @param {Object|string} options - either the JSON string of all messages to be shown or an option object
		 * @param {Object} options.currentRecord - the current record to read the messages from
		 */
		var messageModule;

		function showMessagesFromBeforeLoad(options)
		{
			if (!messageModule)
			{
				//lazy require to avoid circular dependency in define
				require(['N/ui/message'], function(mod) { messageModule = mod; showMessagesFromBeforeLoad(options); });
				return;
			}
			var currentRecord = options && options.currentRecord;
			var messages;
			try {
				if (currentRecord)
					messages = JSON.parse(currentRecord.getValue(MESSAGE_FIELD));
			} catch (e)	{
				return;
			}
			if (messages && Array.isArray(messages.messages))
			{
				messages.messages.forEach(function (msg) {
					if (!msg) return;
					var duration = msg.duration ? msg.duration : undefined;
					messageModule.create(msg).show(duration);
				})
			}
		}

		function getNSUIObject()
		{
			var _NS = typeof NS !== "undefined" ? util.extend({}, NS) : {};
			if (contextSwitch.getRecordSysId()) {
				var cr = currentRecordService.get();
				if (!cr || cr.isCurrentRecord === false) {
					delete _NS.UI;
				}
			}
			return _NS;
		}

		return Object.freeze(
		{
			getActiveQueue : getActiveQueue,
			getNSUIObject: getNSUIObject,
			getMessageServiceInstance : getMessageServiceInstance,
			showMessagesFromBeforeLoad : showMessagesFromBeforeLoad
		});
	}
);
/**
 * SuiteScript Dialog Module (Client Side)
 * Modules within the N/ui namespace allow you to build a custom UI using SuiteScript 2.0. Note that N/ui itself is not a module.
 *
 * @module N/ui/dialog
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/dialog',['N/utilityFunctions', 'N/error', 'N/msgRouter'], function (utilityFunctions, error, msgRouter)
{
    var DEFAULT_BUTTON_LABEL = "OK";
    var DEFAULT_BUTTON_VALUE = true;

    function prepareOptions(options)
    {
        var title = "", message = "";
        if (options !== undefined)
        {
            title = options.hasOwnProperty("title") ? options.title : "";
            message = options.hasOwnProperty("message") ? options.message : "";
        }

        return {title: title, message: message};
    }

	function prepareButtons(options)
	{
		var rawButtons;
		if ((options === undefined) || (options === null) || !options.hasOwnProperty("buttons"))
			rawButtons = [];
		else
			rawButtons = options.buttons;

		if (!util.isArray(rawButtons))
			utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

		if (rawButtons.length === 0)
			rawButtons = [{label: DEFAULT_BUTTON_LABEL, value: DEFAULT_BUTTON_VALUE}];

		return rawButtons;
	}

    function craftButtons(buttonConstructor, options)
    {
    	var buttons = prepareButtons(options);
        var buttonList = [];

        for (var i = 0; i < buttons.length; i++)
        {
            var thisButton = buttons[i];
            if (!thisButton.hasOwnProperty("label") || !thisButton.hasOwnProperty("value"))
                utilityFunctions.throwSuiteScriptError(error.Type.BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE);

            buttonList.push(new buttonConstructor({
                                                           label: thisButton.label,
                                                           value: thisButton.value,
                                                           onClick: function (event) { event.dialog.close(event); }
                                                       }));
        }
        return buttonList;
    }


    function doDialog(options, dialogType)
    {
	    var msg = {source: 'dialog.' + dialogType, data: options, reply: null};
    	var finalOptions = prepareOptions(options);

    	var messageQueue = msgRouter.getActiveQueue();

    	// server side or remote record
	    var NS = msgRouter.getNSUIObject();
    	if (typeof(NS) === 'undefined' ||
		    typeof(NS.UI) === 'undefined' ||
		    typeof(NS.UI.Messaging) === 'undefined') {

		    if (dialogType === 'dialog') {
			    finalOptions.buttons = prepareButtons(options);
		    }
		    msg.reply = messageQueue.getAutoResponse({dialogType: dialogType, dialogOptions: finalOptions});
		    messageQueue.storeMessage(msg);
		    return msg.reply;
		    // TODO: change ret value to promise once its defined on the server so the return type is same as on client
	    }
	    // client side
    	else {
    		var creatorFunction;
		    if (dialogType === 'dialog') {
			    creatorFunction = NS.UI.Messaging.Dialog;
			    finalOptions.buttons = craftButtons(NS.UI.Messaging.Button, options);
		    }
		    else if (dialogType === 'confirm') {
			    creatorFunction = NS.UI.Messaging.Confirm;
		    }
		    else if (dialogType === 'alert') {
			    creatorFunction = NS.UI.Messaging.Alert;
		    }

		    return new Promise(function (resolve, reject) {
			    try {
				    finalOptions.onClose = function (event) {
					    var result = event.button.value;
					    msg.reply = result;
					    messageQueue.storeMessage(msg);
					    resolve(result);
				    };
				    var myDialog = new creatorFunction(finalOptions);
				    myDialog.open();
			    }
			    catch (e) {
				    reject(e);
			    }
		    });
	    }
    }

    function doAlert(options)
    {
        return doDialog(options, 'alert');
    }

    function doConfirm(options)
    {
        return doDialog(options, 'confirm');
    }

    function doCreate(options)
    {
        return doDialog(options, 'dialog');
    }

	/**
	 * @typedef {Object} ButtonOption
	 * @property {*} label The label of the button
	 * @property {*} value The return value of the dialog if the button was clicked
	 */
	//this is a public @typedef and needs a code to be attached to to be stubbed
	function ButtonOptionTypedef(){}

    return Object.freeze({
                             /**
                              * Creates an Alert Dialog with an OK Button.
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The alert dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the alert dialog. This value defaults to an empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *                   The callback will be passed in a response object which contains the value of the button where:
                              *                   OK returns true.
                              *
                              * @since 2016.1
                              */
                             alert: doAlert,
                             /**
                              * Creates an Confirm Dialog with OK and Cancel Button.
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The confirmation dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the confirmation dialog. This value defaults to an empty string.
                              *
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button where:
                              *					 OK returns true and Cancel returns false.
                              *
                              * @since 2016.1
                              */
                             confirm: doConfirm,
                             /**
                              * Creates an Dialog with the specified buttons.
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} [options.title] The dialog title. This value defaults to an empty string.
                              * @param {string} [options.message] The content of the dialog. This value defaults to an empty string.
                              * @param {Array<ButtonOption>} [options.buttons] A list of buttons to include in the dialog. Each item in the button list must be a Javascript Object that contains a label and a value property.
                              * @return {Promise} A Promise object. Pass a function into the then portion to fire a callback when the button is pressed.
                              *					 The callback will be passed in a response object which contains the value of the button.
                              * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options.buttons is specified and is not an array.
                              * @throws {SuiteScriptError} BUTTONS_MUST_INCLUDE_BOTH_A_LABEL_AND_VALUE If options.buttons is specified and one or more items do not have a label and/or value.
                              *
                              * @since 2016.1
                              *
                              */
                             create: doCreate
                         });
});

/**
 * SuiteScript record event enum module
 *
 * @private
 * @module N/eventEmitter
 * @suiteScriptVersion 2.x
 *
 */

/** @typedef {{on: EventEmitterOn, off: EventEmitterOff, emit: EventEmitterEmit}} EventEmitter */
/** @typedef {function({types: Array<string>, listener: EventEmitterListener}): void} EventEmitterOn */
/** @typedef {function({types: Array<string>, listener: EventEmitterListener}): void} EventEmitterOff */
/** @typedef {function(Event): void} EventEmitterEmit */
/** @typedef {function(Event): void} EventEmitterListener */
/** @typedef {{type: string}} Event */

define('N/eventEmitter',['N/utilityFunctions','N/error'],
	function (utilityFunctions, error)
	{

		var currentToken;

		function assertArray(types)
		{
			var isArray = Array.isArray(types);

			if(!isArray)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_ARRAY');
			}
		}

		function assertEventType(validEventTypes, checkEventTypes)
		{
			var invalidEventTypeFound = !!validEventTypes && checkEventTypes.some(function(v){
				return validEventTypes.indexOf(v) === -1;
			});

			if(invalidEventTypeFound)
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_TYPE');
			}
		}

		function assertListener(listener)
		{
			if(typeof listener !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.INVALID_EVENT_LISTENER');
			}
		}

		function assertAsyncAvailable()
		{
			if(typeof setTimeout !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.ASYNC_EVENTS_UNAVAILABLE');
			}
		}

		function asyncTransform(listener)
		{
			return function(event)
			{
				setTimeout(listener.bind(null, event), 0);
			};
		}

		function insulatedTransform(listener)
		{
			return function(event){
				try
				{
					listener(event);
				}
				catch(e)
				{
					if(!!console && !!console.error)
					{
						console.error(e);
					}
				}
			};
		}

		function assertFunction(func)
		{
			if(typeof func !== 'function')
			{
				utilityFunctions.throwSuiteScriptError('error.Type.NOT_A_FUNCTION');
			}
		}

		function createListenerCollection()
		{
			var eventsListeners = {};

			function getEventListeners(eventType)
			{
				var result = eventsListeners[eventType];

				if(!result)
				{
					result = [];
					eventsListeners[eventType] = result;
				}

				return result;
			}

			function add(type, listener)
			{
				var listeners = getEventListeners(type);
				listeners.push(listener);
			}

			function get(type)
			{
				return getEventListeners(type).slice(0);
			}

			function remove(type, listener)
			{
				var listeners = getEventListeners(type);
				var index = 0;
				var count = listeners.length;

				if(!!listener)
				{
					index = listeners.indexOf(listener);
					count = 1;
				}

				if (index != -1) {
					listeners.splice(index, count);
				}
			}

			return Object.freeze({
				add: add,
				get: get,
				remove: remove
			});
		}

		function createEmitter(options)
		{
			var async = !!options && !!options.async;
			var isBlocking = !!options && util.isBoolean(options.blocking) ? options.blocking : async;
			var insulated = !!options && !!options.insulated;
			var eventTypes = !!options && options.eventTypes || null;
			var preProcessor = !!options && options.preProcessor || null;
			var heldEvents = [];
			var heldEventsEmittingFunction = null;
			var eventsListeners = createListenerCollection();

			if(async)
			{
				assertAsyncAvailable();
			}

			function on(options){
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], 'emitter.on');
				assertArray(types);
				assertEventType(eventTypes, types);
				assertListener(listener);

				types.forEach(function(type){
					eventsListeners.add(type, listener);
				});
			}

			function off(options)
			{
				var types = !!options && options.types || null;
				var listener = !!options && options.listener || null;

				utilityFunctions.checkArgs([types], ['types'], 'emitter.off');
				assertArray(types);
				assertEventType(eventTypes, types);

				types.forEach(function(type){
					eventsListeners.remove(type, listener);
				});
			}

			function emitHeldEvents(){
				function emitHeldEventsInternal(){
					if(!!preProcessor)
					{
						heldEvents = preProcessor(heldEvents);
					}

					var errorEvents = [];
					heldEvents.forEach(function (event) {
						if (event.type === "ERROR" && errorEvents.indexOf(event.error) != -1)
							return;
						if (!!event.error)
							errorEvents.push(event.error);
						if (!event.suppressEmit)
							internalEmit(event);
					});
					heldEvents = [];
					heldEventsEmittingFunction = null;
				}

				if (!heldEventsEmittingFunction)
				{
					heldEventsEmittingFunction = emitHeldEventsInternal;
					setTimeout(heldEventsEmittingFunction, 0);
				}
			}

			function internalEmit(event)
			{
				var type = !!event && event.type || null;
				
				eventsListeners.get(type).forEach(function (listener){
					var func = listener;

					func = insulated ? insulatedTransform(func) : func;
					func = async ? asyncTransform(func) : func;

					func(event);
				});
			}

			function emit(event)
			{
				var type = !!event && event.type || null;

				utilityFunctions.checkArgs([event, type], ['event', 'type'], 'emitter.emit');
				assertEventType(eventTypes, [type]);

				if (!!event && event.token == null && currentToken != null)
				{
					event.token = currentToken;
				}

				if(isBlocking)
				{
					heldEvents.push(event);
					emitHeldEvents();
				}
				else
				{
					if(!!preProcessor)
					{
						event = preProcessor([event])[0];
					}

					internalEmit(event);
				}
			}

			return Object.freeze({
				on: on,
				off: off,
				emit: emit
			});
		}

		function callWithToken(token, callback)
		{
			var previousToken = currentToken;

			if (token != null)
			{
				currentToken = token;
			}
			try
			{
				return callback();
			}
			finally
			{
				currentToken = previousToken;
			}
		}

		return Object.freeze({
			create: createEmitter,
			callWithToken: callWithToken
		});
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/recordMessage
 * @suiteScriptVersion 2.x
 */

/**
 * @typedef {Object} RecordMessage
 * @property {RecordMessageNotify} notify
 * @property {RecordMessageConfirm} confirm
 * @property {Array<string>} Type SEVERITY_TYPE
 */

/**
 * @typedef {Object} RecordMessageNotifyOption
 * @property {string} title
 * @property {string=} message defaulted to ""
 * @property {string=} severity defaulted to "CONFIRMATION"
 */

/**
 * @typedef {function(RecordMessageNotifyOption): undefined} RecordMessageNotify
 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT | SSS_INVALID_TYPE_ARG
 */

/**
 * @typedef {Object} RecordMessageConfirmOption
 * @property {string} title
 * @property {string=} message defaulted to ""
 * @property {string=} severity defaulted to "CONFIRMATION"
 * @property {Array<ChoiceInput>} options.choices
 */

/**
 * @typedef {function(RecordMessageConfirmOption, Array<ChoiceInput>): Promise<?>} RecordMessageConfirm
 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT | SSS_INVALID_TYPE_ARG
 */

/**
 * @typedef {Object} ChoiceInput
 * @property {string} label
 * @property {number | string | Date | boolean | Array<number|string|Date> | null} value
 * @property {boolean?} defaultChoice
 */

/**
 * @typedef {Object} ConfirmResponse
 * @property {number | string | Date | boolean | Array<number|string|Date> | null} value
 */

define('N/recordMessage',[
	'N/record/recordEvent',
	'N/utilityFunctions',
	'N/error',
	'N/ui/dialog',
	'N/eventEmitter'
], function (
	recordEvent,
	utilityFunctions,
	error,
	dialog,
	eventEmitter
) {
	/**
	 * @readonly
	 * @enum {string}
	 */
	var SEVERITY_TYPE = Object.freeze({
		CONFIRMATION: 'CONFIRMATION',
		INFORMATION: 'INFORMATION',
		WARNING: 'WARNING',
		ERROR: 'ERROR'
	});

	var LISTENER_TYPE = Object.freeze({
		NONE: 'NONE',
		AUTOCONFIRM: 'AUTOCONFIRM',
		LEGACY: 'LEGACY'
	});

	/**
	 * @param {string} title
	 * @param {string} message
	 * @param {string} severity SEVERITY_TYPE
	 * @constructor
	 */
	function NotifyEvent (title, message, severity) {
		this.type = recordEvent.Type.NOTIFY;
		this.title = title;
		this.message = message;
		this.severity = severity;

		this.proxy = function proxy() {
			return {
				type: this.type,
				title: this.title,
				message: this.message,
				severity: this.severity
			};
		};
	}

	/**
	 * @param {string} label
	 * @param {number | string | Date | boolean | Array<number|string|Date> | null} value
	 * @param {boolean} defaultChoice
	 * @constructor
	 */
	function Choice (label, value, defaultChoice) {
		this.label = label;
		this.value = value;
		this.defaultChoice = defaultChoice;

		this.proxy = function proxy() {
			return {
				label: this.label,
				value: this.value,
				defaultChoice: this.defaultChoice
			};
		};
	}

	/** @typedef {function({value: (number|string|Date|boolean|Array<number|string|Date>|null)}): void} resolveCallback */
	/** @typedef {function({code, error}): void} rejectCallback */

	/**
	 * @param {string} title
	 * @param {string} message
	 * @param {string} severity SEVERITY_TYPE
	 * @param {Array<Choice>} choices
	 * @param {resolveCallback} resolve
	 * @param {rejectCallback} reject
	 * @constructor
	 */
	function ConfirmEvent (title, message, severity, choices, resolve, reject) {
		this.type = recordEvent.Type.CONFIRM;
		this.title = title;
		this.message = message;
		this.severity = severity;
		this.choices = choices;
		this.resolve = resolve;
		this.reject = reject;

		this.proxy = function proxy() {
			return {
				type: this.type,
				title: this.title,
				message: this.message,
				severity: this.severity,
				choices: this.choices,
				resolve: this.resolve,
				reject: this.reject
			};
		};
	}

	/**
	 * @constructor
	 */
	function RecordMessageClassValidator() {
		/**
		 * @param {Object} confirmEvent
		 * @return {boolean}
		 */
		this.isConfirmEvent = function (confirmEvent) {
			return (confirmEvent.constructor && confirmEvent.constructor.name === "ConfirmEvent");
		};

		/**
		 * @param {Object} notifyEvent
		 * @return {boolean}
		 */
		this.isNotifyEvent = function (notifyEvent) {
			return (notifyEvent.constructor && notifyEvent.constructor.name === "NotifyEvent");
		};

		/**
		 * @param {string} severity
		 * @returns {boolean}
		 */
		this.isValidSeverityType = function (severity) {
			return SEVERITY_TYPE.hasOwnProperty(severity);
		};

		/**
		 * @param {string} listenerType
		 * @returns {boolean}
		 */
		this.isValidListenerType = function (listenerType) {
			return LISTENER_TYPE.hasOwnProperty(listenerType);
		};

		/**
		 * Value for choice is one of: number | string | Date | boolean | Array<number|string|Data> | null
		 * @param {*} value
		 * @return {boolean}
		 */
		this.isValidChoiceValue = function (value) {
			if (util.isNumber(value) || util.isString(value) || util.isDate(value) || util.isBoolean(value) || value === null) {
				return true;
			}

			if (util.isArray(value)) {
				if (value.length == 0) {
					return true;
				} else {
					//Check is whole array contain same type of allowad values
					var validationFunction;

					if (util.isNumber(value[0])) {
						validationFunction = util.isNumber;
					}

					if (util.isString(value[0])) {
						validationFunction = util.isString;
					}

					if (util.isDate(value[0])) {
						validationFunction = util.isDate;
					}

					if (!util.isFunction(validationFunction)) {
						return false;
					}

					var isValid = true;
					value.forEach(function(element) {
						if (!validationFunction(element)) {
							isValid = false;
						}
					});

					return isValid;
				}
			}

			return false;
		}
	}

	var recordMessageClassValidator = new RecordMessageClassValidator();

	/**
	 * @param {string} message
	 */
	function log(message) {
		if (typeof console !== 'undefined' && console.log) {
			console.log(message);
		}
	}

	/**
	 * @param {Object} options
	 * @param {EventEmitter?} [options.emitter=EventEmitter]
	 * @param {string} options.listenerType
	 * @return {RecordMessage}
	 */
	function doCreateWithListener(options) {
		utilityFunctions.checkArgs([options], ['options'], 'recordMessage.create');
		utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
		utilityFunctions.checkArgs([options.listenerType], ['options.listenerType'], 'recordMessage.create');
		utilityFunctions.checkArgTypes(
			[utilityFunctions.checkArgObject(options.listenerType, 'options.listenerType', recordMessageClassValidator.isValidListenerType)]
		);

		var emitter = null;

		if (options.emitter) {
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.emitter, 'options.emitter', util.isObject)]);
			utilityFunctions.checkArgs(
				[options.emitter.on, options.emitter.off, options.emitter.emit],
				['options.emitter.on', 'options.emitter.off', 'options.emitter.emit'],
				'recordMessage.create'
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options.emitter.on, 'options.emitter.on', util.isFunction),
				utilityFunctions.checkArgObject(options.emitter.off, 'options.emitter.off', util.isFunction),
				utilityFunctions.checkArgObject(options.emitter.emit, 'options.emitter.emit', util.isFunction)
			]);

			emitter = options.emitter;
		} else {
			emitter = eventEmitter.create({});
		}

		/**
		 * @param {Object} options
		 * @param {string} options.title
		 * @param {string?} options.message
		 * @param {string?} options.severity
		 * @param {string} method
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function validateMessageOptions(options, method) {
			utilityFunctions.checkArgs([options], ['options'], 'messages.' + method);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.title], ['title'], 'messages.' + method);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options.title, 'options.title', util.isString)]);

			if (options.hasOwnProperty("message")) {
				if (!util.isString(options.message)) {
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.message');
				}
			}

			if (options.hasOwnProperty("severity")) {
				if (!recordMessageClassValidator.isValidSeverityType(options.severity)) {
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_TYPE_ARG, 'options.severity');
				}
			}
		}

		/**
		 * @param {Object} options
		 * @param {string} options.label
		 * @param {number | string | Date | boolean | Array<number|string|Date> | null} options.value
		 * @param {boolean?} [options.defaultChoice=false]
		 * @return {Choice}
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function createChoice(options) {
			utilityFunctions.checkArgs([options], ['options.choice'], 'messages.confirm');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.label], ['options.choice.label'], 'messages.confirm');
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options.label, 'options.choice.label', util.isString),
				utilityFunctions.checkArgObject(options.value, 'options.choice.value', recordMessageClassValidator.isValidChoiceValue)
			]);

			var defaultChoice = options.defaultChoice || false;

			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(defaultChoice, 'options.choice.defaultChoice', util.isBoolean)]);

			return new Choice(options.label, options.value, defaultChoice);
		}

		/**
		 * @param {Object} options
		 * @param {Array<ChoiceInput>} options.choices
		 * @return {Array<Choice>}
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 * @throws {SuiteScriptError} CAN_SELECT_ONLY_ONE_DEFAULT_CHOICE
		 */
		function processChoices(options) {
			var choices = [];

			utilityFunctions.assertTrue(options.hasOwnProperty("choices"), error.Type.MISSING_REQD_ARGUMENT, 'options.choices', 'messages.confirm');
			utilityFunctions.assertTrue((options.choices !== null), error.Type.MISSING_REQD_ARGUMENT,'options.choices', 'messages.confirm');
			utilityFunctions.assertTrue(util.isArray(options.choices), error.Type.SSS_INVALID_TYPE_ARG, 'options.choices', 'messages.confirm');

			var countOfDefaultSelected = 0;
			var createdChoice;

			options.choices.forEach(function (choice) {
				createdChoice = createChoice(choice);

				if (createdChoice.defaultChoice) {
					countOfDefaultSelected++;
				}

				choices.push(createdChoice);
			});

			if (countOfDefaultSelected > 1) {
				utilityFunctions.throwSuiteScriptError(error.Type.CAN_SELECT_ONLY_ONE_DEFAULT_CHOICE, 'messages.confirm');
			}

			if (choices.length == 0) {
				choices.push(createChoice({label: 'OK', value: true, defaultChoice: true}));
			} else {
				if (countOfDefaultSelected == 0) {
					choices[0].defaultChoice = true;
				}
			}

			return choices;
		}

		/**
		 * Emit notify event from record emmiter
		 * @param {Object} options
		 * @param {string} options.title
		 * @param {string?} [options.message=""]
		 * @param {string?} [options.severity="CONFIRMATION"]
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function doNotify(options) {
			validateMessageOptions(options, 'notify');

			var message = options.message || "";
			var severity = options.severity || SEVERITY_TYPE.CONFIRMATION;

			emitter.emit(new NotifyEvent(options.title, message, severity));
		}

		/**
		 * Emit confirm event from record emmiter
		 * @param {Object} options
		 * @param {string} options.title
		 * @param {string?} [options.message=""]
		 * @param {string?} [options.severity="CONFIRMATION"]
		 * @param {Array<ChoiceInput>} options.choices
		 * @return {Promise}
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 * @throws {SuiteScriptError} CAN_SELECT_ONLY_ONE_DEFAULT_CHOICE
		 */
		function doConfirm(options) {
			validateMessageOptions(options, 'confirm');

			var message = options.message || "";
			var severity = options.severity || SEVERITY_TYPE.CONFIRMATION;
			var choices = processChoices(options);

			return new Promise(function (resolve, reject) {
				var resolveOrRejectWasCalled = false;

				/**
				 * @param {Object} choice
				 * @param {number | string | Date | boolean | Array<number|string|Date> | null} choice.value
				 */
				function success(choice) {
					if (!resolveOrRejectWasCalled) {
						try {
							utilityFunctions.checkArgs([choice], ['resolved.choice'], 'messages.confirm');
							utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(choice, 'resolved.choice', util.isObject)]);
							utilityFunctions.checkArgsDefined([choice.value], ['resolved.choice.value'], 'messages.confirm');

							resolveOrRejectWasCalled = true;

							resolve(choice);
						} catch (e) {
							failure(e);
						}
					}
				}

				/**
				 * @param {SuiteScriptError} error
				 */
				function failure(error) {
					if (!resolveOrRejectWasCalled) {
						resolveOrRejectWasCalled = true;
						reject(error);
					}
				}

				emitter.emit(new ConfirmEvent(options.title, message, severity, choices, success, failure));
			});
		}

		//register listener
		switch (options.listenerType) {
			case LISTENER_TYPE.AUTOCONFIRM:
				registerAutoconfirmListener(emitter);
				break;
			case LISTENER_TYPE.LEGACY:
				registerLegacyListeners(emitter);
		}

		return Object.freeze({
			notify: doNotify,
			confirm: doConfirm,
			Type: SEVERITY_TYPE
		});
	}
	
	/**
	 * @param {EventEmitter} emitter
	 */
	function registerAutoconfirmListener(emitter) {

		/**
		 * Confirmation of default choice in case event it ConfirmEvent
		 * @param {ConfirmEvent} event
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function confirmBackendListener (event) {
			utilityFunctions.checkArgs([event], ['event'], 'messages.confirm');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(event, 'event', recordMessageClassValidator.isConfirmEvent)]);

			try {
				var resolveWasCalled = false;

				event.choices.forEach(
					/** @param {Choice} choice */
					function (choice) {
						if (choice.defaultChoice) {
							event.resolve({value: choice.value});
							resolveWasCalled = true;
							log("Auto confirm was called with value: " + JSON.stringify({value: choice.value}));
						}
					}
				);

				if (!resolveWasCalled) {
					utilityFunctions.throwSuiteScriptError(error.Type.DEFAULT_CHOICE_IS_MISSING, 'messages.confirm.choices', 'confirmBackendListener');
				}
			} catch (e) {
				event.reject(e);
			}
		}

		emitter.on({
			types: [recordEvent.Type.CONFIRM],
			listener: confirmBackendListener
		});
	}

	/**
	 * @param {EventEmitter} emitter
	 */
	function registerLegacyListeners(emitter) {

		/**
		 * @param {NotifyEvent} event
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function alertClientListener(event) {
			utilityFunctions.checkArgs([event], ['event'], 'messages.confirm');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(event, 'event', recordMessageClassValidator.isNotifyEvent)]);

			dialog.alert({
				title: event.title,
				message: event.message
			});
		}

		/**
		 * @param {ConfirmEvent} event
		 *
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT
		 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG
		 */
		function confirmClientListener(event) {
			utilityFunctions.checkArgs([event], ['event'], 'messages.confirm');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(event, 'event', recordMessageClassValidator.isConfirmEvent)]);

			dialog.create({
				title: event.title,
				message: event.message,
				buttons: event.choices
			}).then(function (value) {
				event.resolve({value: value});
			}, function (error) {
				event.reject(error);
			});
		}

		emitter.on({
			types: [recordEvent.Type.NOTIFY],
			listener: alertClientListener
		});
		emitter.on({
			types: [recordEvent.Type.CONFIRM],
			listener: confirmClientListener
		});
	}

	return Object.freeze({
		createWithListener: doCreateWithListener,
		Type : LISTENER_TYPE
	});
});
/**
 * SuiteScript record macro module
 *
 * @private
 * @module N/macro
 * @suiteScriptVersion 2.x
 */
define(
	'N/macro',['N/utilityFunctions', 'N/error', 'N/environment', 'N/notification', 'N/runtime', 'N/contextSwitch', 'N/scriptLoader', 'N/recordMessage'],
	function (utilityFunctions, error, environment, notification, runtime, contextSwitch, scriptLoader, recordMessage)
	{
		function isServerSide() {
			return (typeof(document) === 'undefined');
		}

		function isJavaCall() {
			return (typeof(_java_call) !== 'undefined' && !!_java_call);
		}

		var getCachedMetadata = (function() {

			var macroMetadataCache = [];

			return function getCachedMetadata(options)
			{
				options = options || {};
				var macroMetadata = [];
				var rawRecord = options.rawRecord;
				if (rawRecord && rawRecord.hasOwnProperty('type') && rawRecord.hasOwnProperty('toString'))
				{
					var cacheKey;
					var isReadOnly = !isServerSide() && (rawRecord.hasOwnProperty('getIsReadOnlyRecord') ? rawRecord.getIsReadOnlyRecord() : !rawRecord.isDynamic);
					// view mode record has different macros that edit mode record
					if (rawRecord.type)
						cacheKey = rawRecord.type + (isReadOnly ? "_readOnly" : "");

					if (!macroMetadataCache[cacheKey])
					{
						if (rawRecord && rawRecord.getMacroMetadata)
							macroMetadata = rawRecord.getMacroMetadata() || [];

						if (cacheKey)
							macroMetadataCache[cacheKey] = macroMetadata;
					}
					else
					{
						macroMetadata = macroMetadataCache[cacheKey] || [];
					}

				}

				var macroList = [];
				macroMetadata.forEach(
					function(metadata)
					{
						var macro = {
							// basic info for the user
							id: metadata.id,
							'package': metadata['package'],
							label: metadata.label,
							description: metadata.description,
							attributes: metadata.attributes
						};
						if (!options.limited) {
							// all props for internal use
							for(var data in metadata)
								macro[data] = metadata[data];
						}
						macroList.push(macro);
					});
				return macroList;
			}
		})();

		function getMacroMetadata(options)
		{
			return getCachedMetadata(options).filter(
				function (macro)
				{
					return (macro.id === options.id
						&& macro['package'] === options['package']);
				})[0];
		}

		function getMacros()
		{
			var rawRecord = this;
			var record = rawRecord.proxy({scriptId: undefined});
			var Macros = {};
			getCachedMetadata({rawRecord: rawRecord}).forEach(
				function (macroDef)	{
					var macro = getMacroObject(macroDef, record);
					if (!macro['package'])
						Macros[macro.id] = macro;
					else {
						if (Macros[macro['package']] === undefined) {
							Macros[macro['package']] = {};
						}
						Macros[macro['package']][macro.id] = macro;
					}
				});
			return Object.freeze(Macros);
		}

		function getMacro(options)
		{
			var rawRecord = this;
			var record = rawRecord.proxy({scriptId: undefined});
			var id, pckgId;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
			}
			pckgId = pckgId || '';

			utilityFunctions.checkArgsPresent([id], ['id'], 'Record.getMacro');
			utilityFunctions.assertTrue(util.isString(id), error.Type.SSS_INVALID_TYPE_ARG, 'id');
			utilityFunctions.assertTrue(util.isString(pckgId), error.Type.SSS_INVALID_TYPE_ARG, 'package');

			var macroDef = getMacroMetadata({'id': id, 'package': pckgId, limited: true, rawRecord: rawRecord});

			if (!macroDef)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);

			return getMacroObject(macroDef, record);
		}

		function getMacroObject(macroDefinition, record) {

			var Macro = function Macro(params)
			{
				return record.executeMacro({'id': macroDefinition.id, 'package': macroDefinition['package'], 'params': params});
			};
			Macro.execute = function MacroExecute(params)
			{
				return record.executeMacro({'id': macroDefinition.id, 'package': macroDefinition['package'], 'params': params});
			};
			Macro.promise = function MacroExecutePromise(params)
			{
				return record.executeMacro.promise({
					'id': macroDefinition.id,
					'package': macroDefinition['package'],
					'params': params
				});
			};
			Macro.execute.promise = Macro.promise;

			var jsonDescription = {};

			// add metadata
			for (var attr in macroDefinition)
			{
				if (macroDefinition.hasOwnProperty(attr))
				{
					Macro[attr] = macroDefinition[attr];

					if (!!Macro[attr])
						jsonDescription[attr] = Macro[attr];
				}
			}

			Macro.toJSON = function() {
				return jsonDescription;
			};

			Macro.toString = function() {
				return 'Macro: ' + JSON.stringify(Macro.toJSON());
			};

			Object.defineProperty(Macro, 'proxy', {value: function () { return Macro; }});

			return Object.freeze(Macro);
		}

		function getExecuteMacroArgs(options)
		{
			var id, pckgId, params;
			if (options !== undefined && options !== null)
			{
				id = options.id;
				pckgId = options['package'];
				params = options.params;
			}
			if (id === undefined)
				id = null;
			pckgId = pckgId || '';
			if (params === undefined)
				params = null;

			return [id, pckgId, params];
		}

		function clientExecuteMacro(options, callback)
		{
			var rawRecord = this;
			var proxiedRecord = rawRecord.proxy({scriptId: undefined});

			var args = getExecuteMacroArgs(options);
			var id = args[0];
			var pckgId = args[1];
			var params = args[2];

			utilityFunctions.checkArgsPresent([id], ['id'], 'Record.executeMacro');
			utilityFunctions.assertTrue(util.isString(id), error.Type.SSS_INVALID_TYPE_ARG, 'id');
			utilityFunctions.assertTrue(util.isString(pckgId), error.Type.SSS_INVALID_TYPE_ARG, 'package');

			var macroDef = getMacroMetadata({'id': id, 'package': pckgId, rawRecord: rawRecord});
			if (!macroDef)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);


			/**
			 * Creation of _recordMessage (instead of getting it from record) is temporary solution.
			 * Remove it when new UI/ NSX will implement handling of NOTICE and CONFIRM events.
			 *
			 * @type {RecordMessage}
			 */
			var _recordMessage = recordMessage.createWithListener({
				listenerType: rawRecord.isCurrentRecord ? recordMessage.Type.LEGACY : recordMessage.Type.AUTOCONFIRM
			});

 			var notifications = [];
 			var requisites =
		    {
		    	currentRecord: proxiedRecord,
		    	params: params,
		    	scriptingContext: rawRecord.getScriptingContext(),
		    	store: rawRecord.getStatefulStoreProxyProvider({}).proxy(macroDef.modulePath),
			    messages: {
				    /**
				     * Emit notify event from record emmiter and add notification to return object
				     * @see RecordMessage#doNotify
				     */
				    notify: function (options)
				    {
					    _recordMessage.notify(options);

					    var title = options.title;
					    var message = options.message || "";
					    var severity = getNotificationSeveritybyRecordMessageSeverity(options.severity, _recordMessage);

					    notifications.push({title: title, message: message, severity: severity});
				    },
				    confirm: _recordMessage.confirm,
				    Type: _recordMessage.Type
			    }
		    };

			function getResult(response)
			{
				if (response != null && !util.isObject(response))
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Object');

				return {
					notifications: notifications,
					response: response || {}
				}
			}

			var entryPointRequire = scriptLoader.getEntryPointRequire(isServerSide() || (rawRecord.toString() === "DomCurrentRecord") ? null : {'context': rawRecord.getSystemId()});
			var modulePath = macroDef.modulePath;
			var functionName = macroDef.id;
			if (callback)
			{
				var macroHasPromise = false;
				entryPointRequire([modulePath], function (mod)
				{
					var requirePromise = new Promise(function (requireResolve, requireReject)
					{
						try
						{
							var macroFunc = mod[functionName];
							if (macroFunc && typeof(macroFunc.promise) === 'function')
							{
								macroFunc = macroFunc.promise;
								macroHasPromise = true;
							}
							if (typeof(macroFunc) === 'function')
								requireResolve(macroFunc);
							else
								requireReject(error.create(error.Type.SSS_INVALID_MACRO_ID));
						}
						catch (e)
						{
							utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
						}
					});
					requirePromise.then(function (macroFunc) {
						var response = macroFunc.apply(this, [requisites]);
						if (response instanceof Promise)
						{
							response.then(getResult).then(callback, callback.bind(null, undefined));
						}
						else
						{
							if (macroHasPromise)
								utilityFunctions.throwSuiteScriptError(error.Type.INVALID_RETURN_TYPE_EXPECTED_1, 'Promise');
							else
								callback(getResult(response));
						}
					})['catch'](function (macroErr) {
						callback(undefined, macroErr);
					});
				});
			}
			else
			{
				var macroFunc;
				wasSync = require.isSync();
				require.forceSync(true);
				try
				{
					entryPointRequire([modulePath], function (mod)
					{
						macroFunc = mod[functionName];
					});
				}
				finally
				{
					require.forceSync(wasSync);
				}
				if (typeof(macroFunc) === 'function')
				{
					var response = macroFunc.apply(this, [requisites]);
				}
				else
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_MACRO_ID, id);
				}
				return getResult(response);
			}
		}

		function processServerResult(callback, result, exception)
		{
			if (exception === undefined)
			{
				result = JSON.parse(result);
				if (!callback)
					return result;
				else
					return callback(result);
			}
			else
			{
				if (!callback)
					throw exception;
				else
					return callback(undefined, exception);
			}
		}

		function serverExecuteMacro(options, callback)
		{
			var recordObject = this;
			var result, exception;
			try
			{
				result = recordObject.invokeMacro(getExecuteMacroArgs(options), callback && processServerResult.bind(null, callback));
			}
			catch (e)
			{
				exception = e;
			}
			return processServerResult(callback && (function () {}), result, exception);
		}

		var doExecuteMacro = function() { return (isServerSide() && !isJavaCall()) ? serverExecuteMacro.apply(this, arguments) : clientExecuteMacro.apply(this, arguments) };

		var executeMacro = function executeMacro(options) {
			return contextSwitch.execute({record: this}, doExecuteMacro.bind(this, options, null/*callback*/));
		};

		executeMacro.promise = function executeMacroPromise(options) {
			var rawRecord = this;
			return new Promise(
				function (resolve, reject) {
					var callback = function callback(result, exception) {
						if (exception === undefined) {
							resolve(result);
						} else {
							reject(exception);
						}
					};

					return contextSwitch.execute({record: rawRecord}, doExecuteMacro.bind(rawRecord, options, callback));
				}
			);
		};

		/**
		 * @param {string} recordMessageSeverityType
		 * @param {RecordMessage} recordMessage
		 * @returns {Severity}
		 */
		function getNotificationSeveritybyRecordMessageSeverity(recordMessageSeverityType, recordMessage)
		{
			var type;

			switch (recordMessageSeverityType)
			{
				case recordMessage.Type.CONFIRMATION:
					type = notification.Type.CONFIRMATION;
					break;
				case recordMessage.Type.INFORMATION:
					type = notification.Type.INFORMATION;
					break;
				case recordMessage.Type.WARNING:
					type = notification.Type.WARNING;
					break;
				case recordMessage.Type.ERROR:
					type = notification.Type.ERROR;
					break;
				default:
					type = notification.Type.CONFIRMATION;
			}

			return notification.create(type);
		}

		return Object.freeze(
		{
			getMacros: getMacros,
			getMacro: getMacro,
			executeMacro : executeMacro
		});

	}
);

/**
 * SuiteScript proxy module.
 *
 * @private
 * @module N/record/proxy
 * @NApiVersion 2.x
 */
define('N/record/proxy',['N/utilityFunctions', 'N/error'], function (utilityFunctions, error) {
	var isObject = utilityFunctions.isObject;
	var isPlainObject = util.isObject;
	var isArray = util.isArray;
	var isFunction = util.isFunction;
	var isDate = util.isDate;
	var isError = util.isError;
	var isThenable = utilityFunctions.isThenable;

	if (typeof WeakMap === 'undefined') {
		var weakMapSerial = 1;
		var weakMapConstructor = function ProxyWeakMap() {
			var property = '$SuiteScript$proxy$' + weakMapSerial;
			weakMapSerial++;
			var allowGet = false;

			this.has = function has(key) {
				return Object.prototype.hasOwnProperty.call(key, property);
			};

			this.get = function get(key) {
				if (!Object.prototype.hasOwnProperty.call(key, property)) {
					return undefined;
				}
				allowGet = true;
				try {
					return key[property];
				} finally {
					allowGet = false;
				}
			};

			this.set = function set(key, value) {
				Object.defineProperty(key, property, {
					get: function get() {
						return allowGet ? value : undefined;
					},
					enumerable: false,
					configurable: true
				});
			}
		};
	} else {
		weakMapConstructor = WeakMap;
	}

	var unwrapForwardCaches = Object.create(null);
	var unwrapReverseCache = new weakMapConstructor();

	function wrap(target, targetThis, proxyOptions) {
		var proxy;

		if (!isObject(target)
			|| isDate(target)
			|| isError(target)
			|| (target.constructor && target.constructor.name === 'SuiteScriptError')) {
			proxy = target;
		} else if ('proxy' in target && isFunction(target.proxy)) {
			proxy = target.proxy(proxyOptions);
		} else if (unwrapReverseCache.has(target)) {
			proxy = unwrapReverseCache.get(target);
		} else if (isThenable(target)) {
			proxy = target.then(function (value) {
				return wrap(value, undefined, proxyOptions);
			});
		} else if (isArray(target)) {
			proxy = Array.prototype.map.call(target, function (value) {
				return wrap(value, undefined, proxyOptions);
			});
		} else if (isPlainObject(target)) {
			proxy = {};
			var keys = Object.getOwnPropertyNames(target);
			for (var i in keys) {
				if (keys.hasOwnProperty(i)) {
					var key = keys[i];
					proxy[key] = wrap(target[key], undefined, proxyOptions);
				}
			}
		} else if (isFunction(target)) {
			if (proxyOptions.isAsync && isFunction(target.promise)) {
				target = target.promise;
			}
			var proxyOptionsArgumentIndex = 'proxyOptionsArgIndex' in target ? target.proxyOptionsArgIndex : -1;
			proxy = utilityFunctions.wraps(target, function () {
				if (targetThis && targetThis.isAbandoned && targetThis.isAbandoned()) {
					utilityFunctions.throwSuiteScriptError(error.Type.OPERATION_IS_NOT_ALLOWED);
				}
				if (arguments.length === 1 && isPlainObject(arguments[0])) {
					var proxyArguments = [{}];
					var keys = Object.getOwnPropertyNames(arguments[0]);
					for (var i in keys) {
						if (keys.hasOwnProperty(i)) {
							var key = keys[i];
							proxyArguments[0][key] = unwrap(arguments[0][key], undefined, proxyOptions);
						}
					}
				} else {
					proxyArguments = Array.prototype.map.call(arguments, function (argument) {
						return unwrap(argument, undefined, proxyOptions);
					});
				}
				if (proxyOptionsArgumentIndex >= proxyArguments.length) {
					proxyArguments.length = proxyOptionsArgumentIndex + 1;
				}
				if (proxyOptionsArgumentIndex >= 0) {
					proxyArguments[proxyOptionsArgumentIndex] = proxyOptions;
				}
				return wrap(target.apply(targetThis, proxyArguments), undefined, proxyOptions);
			});
			if (isFunction(target.promise) && target.promise !== target) {
				proxy.promise = wrap(target.promise, targetThis, proxyOptions);
			}
		} else {
			throw new TypeError("Cannot wrap " + (target.constructor ? (target.constructor.name + " ") : "") + target);
		}

		return proxy;
	}

	function unwrap(target, targetThis, proxyOptions) {
		var cacheKey = [
			proxyOptions.isReadOnly,
			proxyOptions.isInteractive,
			proxyOptions.isAsync,
			proxyOptions.scriptId,
			proxyOptions.bundleId
		].join();
		var unwrapForwardCache = unwrapForwardCaches[cacheKey] || (unwrapForwardCaches[cacheKey] = new weakMapConstructor());
		var proxy;

		if (!isObject(target)
			|| isDate(target)
			|| isError(target)
			|| (target.constructor && target.constructor.name === 'SuiteScriptError')) {
			proxy = target;
		} else if (unwrapForwardCache.has(target)) {
			proxy = unwrapForwardCache.get(target);
		} else if (isFunction(target)) {
			proxy = utilityFunctions.wraps(target, function () {
				var proxyArguments = wrap(Array.prototype.slice.call(arguments), undefined, proxyOptions);
				return unwrap(target.apply(targetThis, proxyArguments), undefined, proxyOptions);
			});

			unwrapForwardCache.set(target, proxy);
			unwrapReverseCache.set(proxy, target);
		} else {
			proxy = target;
		}

		return proxy;
	}

	function initialize(target, record, handler) {
		var cache = {};

		return function proxy(options) {
			var proxyOptions = {
				isReadOnly: record.isReadOnly,
				isInteractive: record.isInteractive,
				isAsync: record.isAsync,
				scriptId: record.scriptId,
				bundleId: record.bundleId
			}
			if (options) {
				util.extend(proxyOptions, options);
			}
			Object.freeze(proxyOptions);

			if ((proxyOptions.isInteractive && !record.isInteractive) || (!proxyOptions.isAsync && record.isAsync)) {
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			}

			var cacheKey = [
				proxyOptions.isReadOnly,
				proxyOptions.isInteractive,
				proxyOptions.isAsync,
				proxyOptions.scriptId,
				proxyOptions.bundleId
			].join();

			if (!(cacheKey in cache)) {
				var proxy = Object.create(Object.getPrototypeOf(target));
				var keys = Object.getOwnPropertyNames(target);
				keys.forEach(function (key) {
					var propertyDescriptor = Object.getOwnPropertyDescriptor(target, key);
					if (('value' in propertyDescriptor || 'writable' in propertyDescriptor) && propertyDescriptor.configurable) {
						var lazyPropertyDescriptor = propertyDescriptor;
						var value = propertyDescriptor.value;
						propertyDescriptor = {};
						propertyDescriptor.get = function get() {
							lazyPropertyDescriptor.value = wrap(value, target, proxyOptions);
							Object.defineProperty(this, key, lazyPropertyDescriptor);
							return lazyPropertyDescriptor.value;
						};
						if (lazyPropertyDescriptor.writable) {
							propertyDescriptor.set = function set(value) {
								lazyPropertyDescriptor.value = value;
								Object.defineProperty(this, key, lazyPropertyDescriptor);
							};
						}
						propertyDescriptor.configurable = lazyPropertyDescriptor.configurable;
						propertyDescriptor.enumerable = lazyPropertyDescriptor.enumerable;
					} else {
						if ('value' in propertyDescriptor) {
							propertyDescriptor.value = wrap(propertyDescriptor.value, target, proxyOptions);
						}
						if ('get' in propertyDescriptor) {
							propertyDescriptor.get = wrap(propertyDescriptor.get, target, proxyOptions);
						}
						if ('set' in propertyDescriptor) {
							propertyDescriptor.set = wrap(propertyDescriptor.set, target, proxyOptions);
						}
					}
					Object.defineProperty(proxy, key, propertyDescriptor);
				});

				cache[cacheKey] = handler(proxy, proxyOptions);
			}

			return cache[cacheKey];
		};
	}

	return Object.freeze({
		initialize: initialize
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordConstants
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordConstants',[],
	function ()
	{
		var RECORD_MODE = Object.freeze({
			DYNAMIC_RECORD: 'dynamic record',
			DEFERRED_DYNAMIC_RECORD: 'standard record',
			READ_ONLY_RECORD: 'read-only record'
		});

		var SUBRECORD_MODE = Object.freeze({
			DYNAMIC_SUBRECORD: 'dynamic subrecord',
			DEFERRED_DYNAMIC_SUBRECORD: 'standard subrecord',
			READ_ONLY_SUBRECORD: 'read-only subrecord'
		});

		var CURRENT_RECORD_MODE = Object.freeze({
			CURRENT_RECORD: 'current record',
			READ_ONLY_CURRENT_RECORD: 'read-only current record'
		});

		var CURRENT_SUBRECORD_MODE = Object.freeze({
			CURRENT_SUBRECORD: 'current subrecord',
			READ_ONLY_CURRENT_SUBRECORD: 'read-only current subrecord'
		});

		var ALL_RECORD_PROXY_NAMES = Object.freeze([
			RECORD_MODE.DYNAMIC_RECORD,
			RECORD_MODE.DEFERRED_DYNAMIC_RECORD,
			RECORD_MODE.READ_ONLY_RECORD,
			SUBRECORD_MODE.DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD,
			SUBRECORD_MODE.READ_ONLY_SUBRECORD,
			CURRENT_RECORD_MODE.CURRENT_RECORD,
			CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD,
			CURRENT_SUBRECORD_MODE.CURRENT_SUBRECORD,
			CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD
		]);

		var LINE_MODE = Object.freeze({
			DYNAMIC_LINE: 'dynamic record sublist line',
			DEFERRED_DYNAMIC_LINE: 'standard record sublist line',
			READ_ONLY_LINE: 'read-only record sublist line'
		});

		var RECORD_UNDERLYING_IMPL_NAME = Object.freeze({
			CLIENT_DYNAMIC_RECORD:      'recordDefinition.Record',	        // recordDefinition.js (both record & subrecord)
			DOM_CURRENT_RECORD:         'DomCurrentRecord',			        // domCurrentRecord.js (V1 client record)
			DOM_CURRENT_SUBRECORD:      'DomCurrentSubrecord',		        // currentSubrecord.js (V1 client subrecord)
			SERVER_DYNAMIC_RECORD:      'RecordImpl',				        // serverRecordService.js (java RecordImpl object)
			SERVER_DYNAMIC_SUBRECORD:   'SubrecordImpl'				        // serverRecordService.js (java SubrecordImpl object)
		});

		var ALL_RECORD_UNDERLYING_IMPL_NAMES = Object.freeze([
			RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_RECORD,
			RECORD_UNDERLYING_IMPL_NAME.SERVER_DYNAMIC_SUBRECORD
		]);

		return Object.freeze({
			RECORD_MODE: RECORD_MODE,
			SUBRECORD_MODE: SUBRECORD_MODE,
			CURRENT_RECORD_MODE: CURRENT_RECORD_MODE,
			CURRENT_SUBRECORD_MODE: CURRENT_SUBRECORD_MODE,
			ALL_RECORD_PROXY_NAMES: ALL_RECORD_PROXY_NAMES,
			LINE_MODE: LINE_MODE,
			RECORD_UNDERLYING_IMPL_NAME: RECORD_UNDERLYING_IMPL_NAME,
			ALL_RECORD_UNDERLYING_IMPL_NAMES: ALL_RECORD_UNDERLYING_IMPL_NAMES
		});
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/dynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error'],
	function (nsobject, constants, utilityFunctions, error)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {RawRecord} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {DynamicRecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicRecord(delegate)
		{
			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @function DynamicRecord#getMacros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @function DynamicRecord#getMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @function DynamicRecord#executeMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro;

			/**
			 * same as excuteMacro but returns a Promise
			 * @function DynamicRecord#executeMacro.promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */

			/**
			 * The id of the record
			 * @name DynamicRecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the record
			 * @name DynamicRecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name DynamicRecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * return true if the record is read-only
			 * @name DynamicRecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name DynamicRecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @function DynamicRecord#getMessageService
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DynamicRecord#save
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			if (delegate.save) {
				this.save = delegate.save;
			}

			/**
			 * same as save but returns a Promise
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DynamicRecord#save.promise
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */

			/**
			 * JSON.stringify() implementation.
			 * @function DynamicRecord#toJSON
			 * @returns {Object}
			 */
			if (delegate.toJSON) {
				this.toJSON = delegate.toJSON;
			}

			/**
			 * Returns the object type name (DynamicRecord)
			 * @returns {string}
			 */
			this.toString = delegate.isCurrentRecord
				? function () { return constants.CURRENT_RECORD_MODE.CURRENT_RECORD; }
				: function () { return constants.RECORD_MODE.DYNAMIC_RECORD; };

			/**
			 * remove body field data
			 * @function DynamicRecord#removeField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			if (delegate.removeField) {
				this.removeField = delegate.removeField;
			}

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function DynamicRecord#getFields
			 * @returns {Array<string>}
			 */
			if (delegate.getFields) {
				this.getFields = delegate.getFields;
			}

			/**
			 * returns the specified sublist
			 * @function DynamicRecord#getSublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @function DynamicRecord#getSublists
			 * @returns {Array<string>}
			 */
			if (delegate.getSublists) {
				this.getSublists = delegate.getSublists;
			}

			/**
			 * return array of names of all fields in a sublist
			 * @function DynamicRecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array<string>}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			if (delegate.getSublistFields) {
				this.getSublistFields = delegate.getSublistFields;
			}

			/**
			 * return value of the field
			 * @function DynamicRecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @function DynamicRecord#setValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = delegate.setValue;

			/**
			 * get value of the field in text representation
			 * @function DynamicRecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 * @function DynamicRecord#setText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = delegate.setText;

			/**
			 * return field object from record
			 * @function DynamicRecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function DynamicRecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function DynamicRecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @function DynamicRecord#insertLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = delegate.insertLine;

			/**
			 * remove a sublist line
			 * @function DynamicRecord#removeLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = delegate.removeLine;

			/**
			 * Move one line to desired location.
			 * You can address both lines either by Line Instance IDs or both by Indexes.
			 * Order of all other lines is preserved.
			 * Line indexes between original and final position are shifted by one.
			 * @function DynamicRecord#moveLine
			 * @param {Object|string} options (sublistId)
			 * @param {string} options.sublistId
			 * @param {number} options.from (0-based index)
			 * @param {number} options.to (0-based index)
			 * @param {string} options.fromInstanceId (line instance ID)
			 * @param {string} options.toInstanceId (line instance ID)
			 * @param {number} from (0-based index)
			 * @param {number} to (0-based index)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, from or to is missing
			 * @throws {SuiteScriptError} SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES if machine doesn't support line moving
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line indexes are invalid
			 */
			if (!delegate.isNSE) {
				this.moveLine = delegate.moveLine;
			}

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function DynamicRecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * cancel the current selected line
			 * @function DynamicRecord#cancelLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.cancelLine = delegate.cancelLine;
			}

			/**
			 * commit the current selected line
			 * @function DynamicRecord#commitLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.commitLine = delegate.commitLine;
			}

			/**
			 * select line
			 * @function DynamicRecord#selectLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.selectLine = delegate.selectLine;
			}

			/**
			 * select a new line at the end of sublist
			 * @function DynamicRecord#selectNewLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.selectNewLine = delegate.selectNewLine;
			}

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @function DynamicRecord#getCurrentSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistValue = delegate.getCurrentSublistValue;
			}

			/**
			 * return value of a sublist field
			 * @function DynamicRecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			if (delegate.isCoreScript) {
				this.setSublistValue = delegate.setSublistValue;
				this.getLineInstanceIds = delegate.getLineInstanceIds;
			}

			/**
			 * set the value for field in the current selected line
			 * @function DynamicRecord#setCurrentSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			if (!delegate.isNSE) {
				this.setCurrentSublistValue = delegate.setCurrentSublistValue;
			}

			/**
			 * return the value for field in the current selected line by text representation
			 * @function DynamicRecord#getCurrentSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistText = delegate.getCurrentSublistText;
			}

			/**
			 * return value of a sublist field in text representation
			 * @function DynamicRecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * set the value for field in the current selected line by text representation
			 * @function DynamicRecord#setCurrentSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.setCurrentSublistText = delegate.setCurrentSublistText;
			}

			/**
			 * return the line number of current selected line
			 * @function DynamicRecord#getCurrentSublistIndex
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistIndex = delegate.getCurrentSublistIndex;
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @function DynamicRecord#hasSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function DynamicRecord#getSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DynamicSubrecord} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = delegate.getSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function DynamicRecord#getSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */

			/**
			 * remove the subrecord for the associated field
			 * @function DynamicRecord#removeSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DynamicRecord}
			 */
			this.removeSubrecord = delegate.removeSubrecord;

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @function DynamicRecord#hasSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @returns {boolean}
			 */
			if (!delegate.isNSE) {
				this.hasSublistSubrecord = delegate.hasSublistSubrecord;
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @function DynamicRecord#hasCurrentSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.hasCurrentSublistSubrecord = delegate.hasCurrentSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @function DynamicRecord#getCurrentSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {DynamicSubrecord} [requested subrecord]
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistSubrecord = delegate.getCurrentSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @function DynamicRecord#getCurrentSublistSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @restriction only available in dynamic record
			 */

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @function DynamicRecord#removeCurrentSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {DynamicRecord}
			 * @restriction only available in dynamic record
			 */
			if (!delegate.isNSE) {
				this.removeCurrentSublistSubrecord = delegate.removeCurrentSublistSubrecord;
			}

			/**
			 * return field object from record's sublist current line
			 * @function DynamicRecord#getCurrentSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 */
			if (delegate.getCurrentSublistField && !delegate.isNSE) {
				this.getCurrentSublistField = delegate.getCurrentSublistField;
			}

			/**
			 * set the value for the associated header in the matrix
			 * @function DynamicRecord#setMatrixHeaderValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {DynamicRecord}
			 */
			this.setMatrixHeaderValue = delegate.setMatrixHeaderValue;

			/**
			 * get the value for the associated header in the matrix
			 * @function DynamicRecord#getMatrixHeaderValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * get the value for the associated field in the matrix
			 * @function DynamicRecord#getMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * set the value for the associated field in the matrix
			 * @function DynamicRecord#setMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {DynamicRecord}
			 */
			this.setMatrixSublistValue = delegate.setMatrixSublistValue;

			/**
			 * set the value for the line currently selected in the matrix
			 * @function DynamicRecord#setCurrentMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @returns {DynamicRecord}
			 */
			this.setCurrentMatrixSublistValue = delegate.setCurrentMatrixSublistValue;

			/**
			 * get the value for the line currently selected in the matrix
			 * @function DynamicRecord#getCurrentMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 * @restriction only available in dynamic record
			 */
			this.getCurrentMatrixSublistValue = delegate.getCurrentMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @function DynamicRecord#getMatrixHeaderField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @function DynamicRecord#getMatrixSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @function DynamicRecord#findMatrixSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @function DynamicRecord#getMatrixHeaderCount
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/**
			 * Notes about the callback passed to on() and off():
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @typedef {function(Event): void} eventCallback
			 */

			/**
			 * Start listening to events
			 * @function DynamicRecord#on
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {DynamicRecord} same record
			 */
			if (delegate.on) {
				this.on = delegate.on;
			}

			/**
			 * Stop listening to events
			 * @function DynamicRecord#off
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {DynamicRecord} same record
			 */
			if (delegate.off) {
				this.off = delegate.off;
			}

			/**
			 * Call restricted method.
			 * @function DynamicRecord#callRestrictedMethod
			 * @param {Object} options
			 * @param {Object} options.token  token required for access to restricted methods
			 * @param {string} options.methodName  name of the method to invoke
			 * @param {Array} options.args  (optional) arguments to pass to the method
			 */
			if (delegate.isInteractive) {
				this.callRestrictedMethod = delegate.callRestrictedMethod;
			}

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer) {
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;
			}

			/**
			 * return true if record is being seen in interactive mode.
			 * @name DynamicRecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			/**
			 * copy the current line of the sublist to the new line
			 * @function DynamicRecord#copyLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicRecord | Line}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
			 */
			if (!delegate.isNSE && delegate.isInteractive) {
				this.copyLine = delegate.copyLine;
			}

			/**
			 * get query url and parameters
			 * @name DynamicRecord#query
			 * @type {Object}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'query', function () { return delegate.query; });
			}

			/**
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DynamicRecord#saveAndFetch
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {Object} contains id of submitted record
			 */
			if (delegate.isInteractive) {
				Object.defineProperty(this, 'saveAndFetch', {
					value: delegate.saveAndFetch,
					writable: true,
					configurable: true
				});
			}

			/**
			 * same as saveAndFetch but returns a Promise
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DynamicRecord#saveAndFetch.promise
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {Object} contains id of submitted record
			 */

			/**
			 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
			 * @function DynamicRecord#addNewLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} the Line object that was created.
			 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {error.SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			if (delegate.isInteractive) {
				this.addNewLine = delegate.addNewLine;
			}

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DynamicRecord.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicRecord);

		return DynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/dynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define('N/record/proxy/dynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * Dynamic Record interface (with the interactive API)
		 * @param {RawRecord} delegate
		 * @returns {DynamicSubrecord} (proxied record.Record)
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @constructor
		 * @since 2015.2
		 */
		function DynamicSubrecord(delegate)
		{
			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name DynamicSubrecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name DynamicSubrecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * return true if the record is read-only
			 * @name DynamicSubrecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name DynamicSubrecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @function DynamicSubrecord#getMessageService
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @function DynamicSubrecord#getMacros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @function DynamicSubrecord#getMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @function DynamicSubrecord#executeMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro;

			/**
			 * same as excuteMacro but returns a Promise
			 * @function DynamicSubrecord#executeMacro.promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */

			/**
			 * return true if record is a dynamic record
			 * @name DynamicSubrecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * JSON.stringify() implementation.
			 * @function DynamicSubrecord#toJSON
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (record.DynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function () { return constants.SUBRECORD_MODE.DYNAMIC_SUBRECORD; };

			/**
			 * remove body field data
			 * @function DynamicSubrecord#removeField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = delegate.removeField;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function DynamicSubrecord#getFields
			 * @returns {Array}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @function DynamicSubrecord#getSublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [sublist, or null if sublist not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @function DynamicSubrecord#getSublists
			 * @returns {Array}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @function DynamicSubrecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @function DynamicSubrecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @function DynamicSubrecord#setValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = delegate.setValue;

			/**
			 * get value of the field in text representation
			 * @function DynamicSubrecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 * @function DynamicSubrecord#setText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = delegate.setText;

			/**
			 * return field object from record
			 * @function DynamicSubrecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function DynamicSubrecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function DynamicSubrecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @function DynamicSubrecord#insertLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = delegate.insertLine;

			/**
			 * remove a sublist line
			 * @function DynamicSubrecord#removeLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = delegate.removeLine;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function DynamicSubrecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * cancel the current selected line
			 * @function DynamicSubrecord#cancelLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 */
			if (!delegate.isNSE) {
				this.cancelLine = delegate.cancelLine;
			}

			/**
			 * commit the current selected line
			 * @function DynamicSubrecord#commitLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			if (!delegate.isNSE) {
				this.commitLine = delegate.commitLine;
			}

			/**
			 * select line
			 * @function DynamicSubrecord#selectLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 */
			if (!delegate.isNSE) {
				this.selectLine = delegate.selectLine;
			}

			/**
			 * select a new line at the end of sublist
			 * @function DynamicSubrecord#selectNewLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 */
			if (!delegate.isNSE) {
				this.selectNewLine = delegate.selectNewLine;
			}

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @function DynamicSubrecord#getCurrentSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistValue = delegate.getCurrentSublistValue;
			}

			/**
			 * return value of a sublist field
			 * @function DynamicSubrecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			/**
			 * set the value for field in the current selected line
			 * @function DynamicSubrecord#setCurrentSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			if (!delegate.isNSE) {
				this.setCurrentSublistValue = delegate.setCurrentSublistValue;
			}

			/**
			 * return the value for field in the current selected line by text representation
			 * @function DynamicSubrecord#getCurrentSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistText = delegate.getCurrentSublistText;
			}

			/**
			 * return value of a sublist field in text representation?
			 * @function DynamicSubrecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}?
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id or line number
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * set the value for field in the current selected line by text representation
			 * @function DynamicSubrecord#setCurrentSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD if user tries to edit readonly sublist field
			 */
			if (!delegate.isNSE) {
				this.setCurrentSublistText = delegate.setCurrentSublistText;
			}

			/**
			 * return the line number of current selected line
			 * @function DynamicSubrecord#getCurrentSublistIndex
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistIndex = delegate.getCurrentSublistIndex;
			}

			/**
			 * return field object from current selected line
			 * @function DynamicSubrecord#getCurrentSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @returns {Field} [field, or null if not found]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 */
			if (!delegate.isNSE) {
				this.getCurrentSublistField = delegate.getCurrentSublistField;
			}

			/**
			 * validate the subrecord
			 * @function DynamicSubrecord#validate
			 * @returns {DynamicSubrecord}
			 */
			this.validate = delegate.validate;

			/**
			 * commit the subrecord
			 * @function DynamicSubrecord#commit
			 * @returns {DynamicSubrecord}
			 */
			this.commit = delegate.commit;

			/**
			 * cancel the subrecord
			 * @function DynamicSubrecord#cancel
			 * @returns {DynamicSubrecord}
			 */
			this.cancel = delegate.cancel;

			/**
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @typedef {function(Event): void} eventCallback
			 */

			/**
			 * Start listening to events
			 * @function DynamicSubrecord#on
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {DynamicSubrecord} record
			 */
			this.on = delegate.on;

			/**
			 * Stop listening to events
			 * @function DynamicSubrecord#off
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @returns {DynamicSubrecord} record
			 */
			this.off = delegate.off;

			/**
			 * copy the current line of the sublist to the new line
			 * @function DynamicSubrecord#copyLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {DynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
			 */
			if (!delegate.isNSE && delegate.isInteractive) {
				this.copyLine = delegate.copyLine;
			}

			/**
			 * return form metadata for the subrecord.
			 * @name DynamicSubrecord#formMetadata
			 * @type {Object}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'formMetadata', function () { return delegate.formMetadata; });
			}

			/**
			 * return true if record is being seen in interactive mode.
			 * @name DynamicSubrecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			/**
			 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
			 * @function DynamicSubrecord#addNewLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} the Line object that was created.
			 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {error.SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			if (delegate.isInteractive) {
				this.addNewLine = delegate.addNewLine;
			}

			/**
			 * same as commitLine, but returns a Promise
			 * @function DynamicSubrecord#commitLine.promise
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Object} a promise with the record object
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicSubrecord);

		return DynamicSubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error'],
	function (nsobject, constants, utilityFunctions, error)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {RawRecord} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = This should NEVER be true because it's not supported for current record to be deferred-dynamic.
		 * @returns {DeferredDynamicRecord} (proxied record.Record)
		 * @constructor
		 */
		function DeferredDynamicRecord(delegate)
		{
			/* Nothing should ever try to wrap the current record as deferred dynamic, because it is an unsupported case that should never occur. */
			if (delegate.isCurrentRecord)
				utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
			/**
			 * The id of the record
			 * @name DeferredDynamicRecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the record
			 * @name DeferredDynamicRecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name DeferredDynamicRecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * return true if the record is read-only
			 * @name DeferredDynamicRecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name DeferredDynamicRecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @function DeferredDynamicRecord#getMessageService
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DeferredDynamicRecord#save
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */
			this.save = delegate.save;

			/**
			 * same as save but returns a Promise
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DeferredDynamicRecord#save.promise
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {number} id of submitted record
			 */

			/**
			 * JSON.stringify() implementation.
			 * @function DeferredDynamicRecord#toJSON
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicRecord)
			 * @returns {string}
			 */
			this.toString = function () { return constants.RECORD_MODE.DEFERRED_DYNAMIC_RECORD; };

			/**
			 * remove body field data
			 * @function DeferredDynamicRecord#removeField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = delegate.removeField;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function DeferredDynamicRecord#getFields
			 * @returns {Array<string>}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @function DeferredDynamicRecord#getSublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @function DeferredDynamicRecord#getSublists
			 * @returns {Array<string>}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @function DeferredDynamicRecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array<string>}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @function DeferredDynamicRecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @function DeferredDynamicRecord#setValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setValue = delegate.setValue;

			/**
			 * get value of the field in text representation
			 * @function DeferredDynamicRecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @function DeferredDynamicRecord#setText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.setText = delegate.setText;

			/**
			 * return field object from record
			 * @function DeferredDynamicRecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function DeferredDynamicRecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function DeferredDynamicRecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @function DeferredDynamicRecord#insertLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = delegate.insertLine;

			/**
			 * remove a sublist line
			 * @function DeferredDynamicRecord#removeLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = delegate.removeLine;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function DeferredDynamicRecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @function DeferredDynamicRecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			/**
			 * set the value of a sublist field
			 * @function DeferredDynamicRecord#setSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			if (!delegate.isNSE) {
				this.setSublistValue = delegate.setSublistValue;
			}

			/**
			 * return value of a sublist field in text representation
			 * @function DeferredDynamicRecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * set the value of a sublist field in text representation
			 * @function DeferredDynamicRecord#setSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {DeferredDynamicRecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			if (!delegate.isNSE) {
				this.setSublistText = delegate.setSublistText;
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @function DeferredDynamicRecord#hasSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function DeferredDynamicRecord#getSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DeferredDynamicSubrecord} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = delegate.getSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function DeferredDynamicRecord#getSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */

			/**
			 * remove the subrecord for the associated field
			 * @function DeferredDynamicRecord#removeSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DeferredDynamicRecord}
			 */
			this.removeSubrecord = delegate.removeSubrecord;

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @function DeferredDynamicRecord#hasSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			if (!delegate.isNSE) {
				this.hasSublistSubrecord = delegate.hasSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @function DeferredDynamicRecord#getSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {DeferredDynamicSubrecord} [requested subrecord]
			 */
			if (!delegate.isNSE) {
				this.getSublistSubrecord = delegate.getSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @function DeferredDynamicRecord#getSublistSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */

			/**
			 * remove the subrecord for the associated sublist field
			 * @function DeferredDynamicRecord#removeSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {DeferredDynamicRecord}
			 */
			if (!delegate.isNSE) {
				this.removeSublistSubrecord = delegate.removeSublistSubrecord;
			}

			/**
			 * set the value for the associated header in the matrix
			 * @function DeferredDynamicRecord#setMatrixHeaderValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {DeferredDynamicRecord}
			 */
			this.setMatrixHeaderValue = delegate.setMatrixHeaderValue;

			/**
			 * get the value for the associated header in the matrix
			 * @function DeferredDynamicRecord#getMatrixHeaderValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * set the value for the associated field in the matrix
			 * @function DeferredDynamicRecord#setMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {DeferredDynamicRecord}
			 */
			this.setMatrixSublistValue = delegate.setMatrixSublistValue;

			/**
			 * get the value for the associated field in the matrix
			 * @function DeferredDynamicRecord#getMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @function DeferredDynamicRecord#getMatrixHeaderField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @function DeferredDynamicRecord#getMatrixSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @function DeferredDynamicRecord#findMatrixSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @function DeferredDynamicRecord#getMatrixHeaderCount
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/* This is added server-side only. It comes from server implementation of N/record/recordService */
			if (delegate._addToTemplateRenderer) {
				this._addToTemplateRenderer = delegate._addToTemplateRenderer;
			}

			/**
			 * return true if record is being seen in interactive mode.
			 * @name DeferredDynamicRecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			/**
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DeferredDynamicRecord#saveAndFetch
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {Object} contains id of submitted record
			 */
			if (delegate.isInteractive) {
				Object.defineProperty(this, 'saveAndFetch', {
					value: delegate.saveAndFetch,
					writable: true,
					configurable: true
				});
			}

			/**
			 * same as saveAndFetch but returns a Promise
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @function DeferredDynamicRecord#saveAndFetch.promise
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @returns {Object} contains id of submitted record
			 */

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DeferredDynamicRecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicRecord);

		return DeferredDynamicRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/deferredDynamicSubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/deferredDynamicSubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {RawRecord} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @returns {DeferredDynamicSubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function DeferredDynamicSubrecord(delegate)
		{
			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name DeferredDynamicSubrecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name DeferredDynamicSubrecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name DeferredDynamicSubrecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * return true if the record is read-only
			 * @name DeferredDynamicSubrecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name DeferredDynamicSubrecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @function DeferredDynamicSubrecord#getMessageService
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @function DeferredDynamicSubrecord#toJSON
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (DeferredDynamicSubrecord)
			 * @returns {string}
			 */
			this.toString = function () { return constants.SUBRECORD_MODE.DEFERRED_DYNAMIC_SUBRECORD; };

			/**
			 * remove body field data
			 * @function DeferredDynamicSubrecord#removeField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.removeField = delegate.removeField;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function DeferredDynamicSubrecord#getFields
			 * @returns {Array}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @function DeferredDynamicSubrecord#getSublists
			 * @returns {Array}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @function DeferredDynamicSubrecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @function DeferredDynamicSubrecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * set value of the field
			 * @function DeferredDynamicSubrecord#setValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setValue = delegate.setValue;

			/**
			 * get value of the field in text representation
			 * @function DeferredDynamicSubrecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * set value of the field by text representation
			 *
			 * @function DeferredDynamicSubrecord#setText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @param {string} options.text
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.setText = delegate.setText;

			/**
			 * return field object from record
			 * @function DeferredDynamicSubrecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function DeferredDynamicSubrecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function DeferredDynamicSubrecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * insert a sublist line
			 * @function DeferredDynamicSubrecord#insertLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.insertLine = delegate.insertLine;

			/**
			 * remove a sublist line
			 * @function DeferredDynamicSubrecord#removeLine
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not editable
			 */
			this.removeLine = delegate.removeLine;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function DeferredDynamicSubrecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @function DeferredDynamicSubrecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			/**
			 * set the value of a sublist field
			 * @function DeferredDynamicSubrecord#setSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {number|Date|string|Array} options.value
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			if (!delegate.isNSE) {
				this.setSublistValue = delegate.setSublistValue;
			}

			/**
			 * return value of a sublist field in text representation
			 * @function DeferredDynamicSubrecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * set the value of a sublist field in text representation
			 * @function DeferredDynamicSubrecord#setSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @returns {DeferredDynamicSubrecord}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 */
			if (!delegate.isNSE) {
				this.setSublistText = delegate.setSublistText;
			}

			/**
			 * return true if record is being seen in interactive mode.
			 * @name DeferredDynamicSubrecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		DeferredDynamicSubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicSubrecord);

		return DeferredDynamicSubrecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlyRecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlyRecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions', 'N/error'],
	function (nsobject, constants, utilityFunctions, error)
	{
		/**
		 * ReadOnly Record interface (with the interactive API)
		 * @param {RawRecord} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentRecord = (optional) true if we are proxy-wrapping to create a current record object.
		 * @returns {ReadOnlyRecord} (proxied record.Record)
		 * @constructor
		 * @since 2016.2
		 */
		function ReadOnlyRecord(delegate)
		{
			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @function ReadOnlyRecord#getMacros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @function ReadOnlyRecord#getMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro (@see Macro) specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @function ReadOnlyRecord#executeMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro;

			/**
			 * same as excuteMacro but returns a Promise
			 * @function ReadOnlyRecord#executeMacro.promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */

			/**
			 * The id of the record
			 * @name ReadOnlyRecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the record
			 * @name ReadOnlyRecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * return true if record is a dynamic record
			 * @name ReadOnlyRecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * return true if the record is read-only
			 * @name ReadOnlyRecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name ReadOnlyRecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * Object to retrieve all messages stored on the record via the getMessages method
			 * @name MessageService
			 * @class
			 */

			/**
			 * provides record's MessageService object
			 * @function ReadOnlyRecord#getMessageService
			 * @returns {MessageService} record's MessageService instance
			 */
			this.getMessageService = delegate.getMessageService;

			/**
			 * JSON.stringify() implementation.
			 * @function ReadOnlyRecord#toJSON
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlyRecord)
			 * @returns {string}
			 */
			this.toString = delegate.isCurrentRecord
				? function () { return constants.CURRENT_RECORD_MODE.READ_ONLY_CURRENT_RECORD; }
				: function () { return constants.RECORD_MODE.READ_ONLY_RECORD; };

			/**
			 * Object corresponding to a record action. It contains the necessary action information
			 * and can be executed (both synchronously and asynchronously using Action.promise).
			 * @name Action
			 * @function
			 * @param {Object} params
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 */

			/**
			 * Provides available record actions for this record instance.
			 * @function ReadOnlyRecord#getActions
			 * @returns {Object} a set of actions (@see Action) defined on the record type indexed by action ID
			 */
			this.getActions = delegate.getActions;

			/**
			 * Returns an executable record action for this record instance.
			 * @function ReadOnlyRecord#getAction
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @returns {?Action} record action executor for action specified by options
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.getAction = delegate.getAction;

			/**
			 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
			 * @function ReadOnlyRecord#executeAction
			 * @param {Object} options
			 * @param {String} options.id action ID
			 * @param {Object} [options.params] action arguments
			 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the response property
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeAction = delegate.executeAction;

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function ReadOnlyRecord#getFields
			 * @returns {Array<string>}
			 */
			this.getFields = delegate.getFields;

			/**
			 * returns the specified sublist
			 * @function ReadOnlyRecord#getSublist
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Sublist} [requested sublist]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublist = delegate.getSublist;

			/**
			 * return array of names of all sublists
			 * @function ReadOnlyRecord#getSublists
			 * @returns {Array<string>}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @function ReadOnlyRecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @function ReadOnlyRecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @function ReadOnlyRecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @function ReadOnlyRecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function ReadOnlyRecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function ReadOnlyRecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function ReadOnlyRecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @function ReadOnlyRecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			/**
			 * return value of a sublist field in text representation
			 * @function ReadOnlyRecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @function ReadOnlyRecord#hasSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {boolean}
			 */
			this.hasSubrecord = delegate.hasSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function ReadOnlyRecord#getSubrecord
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {ReadOnlySubrecord} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */
			this.getSubrecord = delegate.getSubrecord;

			/**
			 * get the subrecord for the associated field
			 * @function ReadOnlyRecord#getSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Record} [requested subrecord]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 */

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @function ReadOnlyRecord#hasSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {boolean}
			 */
			if (!delegate.isNSE) {
				this.hasSublistSubrecord = delegate.hasSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @function ReadOnlyRecord#getSublistSubrecord
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {ReadOnlySubrecord} [requested subrecord]
			 */
			if (!delegate.isNSE) {
				this.getSublistSubrecord = delegate.getSublistSubrecord;
			}

			/**
			 * get the subrecord for the associated sublist field
			 * @function ReadOnlyRecord#getSublistSubrecord.promise
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {Record} [requested subrecord]
			 */

			/**
			 * get the value for the associated header in the matrix
			 * @function ReadOnlyRecord#getMatrixHeaderValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixHeaderValue = delegate.getMatrixHeaderValue;

			/**
			 * get the value for the associated field in the matrix
			 * @function ReadOnlyRecord#getMatrixSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.line - the line number for the field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number|Date|string}
			 */
			this.getMatrixSublistValue = delegate.getMatrixSublistValue;

			/**
			 * get the field for the specified header in the matrix
			 * @function ReadOnlyRecord#getMatrixHeaderField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixHeaderField = delegate.getMatrixHeaderField;

			/**
			 * get the field for the specified sublist in the matrix
			 * @function ReadOnlyRecord#getMatrixSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {number} options.line - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {Field} [requested field]
			 */
			this.getMatrixSublistField = delegate.getMatrixSublistField;

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @function ReadOnlyRecord#findMatrixSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.value - the column number for the field
			 * @param {number} options.column - the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.findMatrixSublistLineWithValue = delegate.findMatrixSublistLineWithValue;

			/**
			 * returns the number of columns for the specified matrix.
			 * @function ReadOnlyRecord#getMatrixHeaderCount
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @returns {number}
			 */
			this.getMatrixHeaderCount = delegate.getMatrixHeaderCount;

			/**
			 * return true if record is being seen in interactive mode.
			 * @name ReadOnlyRecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			/**
			 * get query url and parameters
			 * @name ReadOnlyRecord#query
			 * @type {Object}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				Object.defineProperty(this, 'query', {
					value: delegate.query,
					writable: true,
					configurable: true
				});
			}

			/**
			 * Call restricted method.
			 * @function ReadOnlyRecord#callRestrictedMethod
			 * @param {Object} options
			 * @param {Object} options.token  token required for access to restricted methods
			 * @param {string} options.methodName  name of the method to invoke
			 * @param {Array} options.args  (optional) arguments to pass to the method
			 */
			if (delegate.isInteractive) {
				this.callRestrictedMethod = delegate.callRestrictedMethod;
			}

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		ReadOnlyRecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyRecord);

		return ReadOnlyRecord;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/readOnlySubrecord
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/proxy/readOnlySubrecord',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * Deferred Dynamic Record interface (with the interactive API)
		 * @param {RawRecord} delegate = underlying implementation of record, to be wrapped
		 * @param {boolean} isInteractive = true to create this record proxy wraper with the interactive API
		 * @param {boolean} isCurrentSubrecord = (optional) true if we are proxy-wrapping to create subrecord for a current record object.
		 * @returns {ReadOnlySubrecord} (proxied record.Record)
		 * @constructor
		 * @since 2015.2
		 */
		function ReadOnlySubrecord(delegate)
		{
			/**
			 * The id of the subrecord (always null for subrecords)
			 * @name ReadOnlySubrecord#id
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'id', function () { return delegate.id; });

			/**
			 * The type of the subrecord (always null for subrecords)
			 * @name ReadOnlySubrecord#type
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'type', function () { return delegate.type; });

			/**
			 * contains necessary macro information, performs macro operation (specified by getMacro)
			 * and returns result; the Macro.promise returns a Promise
			 * @name Macro
			 * @function
			 * @param {Object} [params]
			 * @returns {Object} [macro result]
			 */

			/**
			 * provides available macros
			 * @function ReadOnlySubrecord#getMacros
			 * @returns {Object} a set of macros (@see Macro) defined on the record indexed by macroId
			 */
			this.getMacros = delegate.getMacros;

			/**
			 * provides a macro to execute
			 * @function ReadOnlySubrecord#getMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @returns {?Macro} [executor function for macro specified by options, or null if not found]
			 */
			this.getMacro = delegate.getMacro;

			/**
			 * performs macro operation and returns result
			 * @function ReadOnlySubrecord#executeMacro
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */
			this.executeMacro = delegate.executeMacro;

			/**
			 * same as excuteMacro but returns a Promise
			 * @function ReadOnlySubrecord#executeMacro.promise
			 * @param {Object} options
			 * @param {String} options.id macro id
			 * @param {String} [options.package] macro package
			 * @param {Object} [options.params] macro arguments
			 * @returns {Object} [macro result, or null]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
			 */

			/**
			 * return true if record is a dynamic record
			 * @name ReadOnlySubrecord#isDynamic
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isDynamic', function () { return delegate.isDynamic; });

			/**
			 * return true if the record is read-only
			 * @name ReadOnlySubrecord#isReadOnly
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isReadOnly', function () { return delegate.isReadOnly; });

			/**
			 * return true if the record is newly created
			 * @name ReadOnlySubrecord#isNew
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'isNew', function () { return delegate.isNew; });

			/**
			 * JSON.stringify() implementation.
			 * @function ReadOnlySubrecord#toJSON
			 * @returns {Object}
			 */
			this.toJSON = delegate.toJSON;

			/**
			 * Returns the object type name (ReadOnlySubrecord)
			 * @returns {string}
			 */
			this.toString = delegate.isCurrentRecord
				? function () { return constants.CURRENT_SUBRECORD_MODE.READ_ONLY_CURRENT_SUBRECORD; }
				: function () { return constants.SUBRECORD_MODE.READ_ONLY_SUBRECORD; };

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @function ReadOnlySubrecord#getFields
			 * @returns {Array<string>}
			 */
			this.getFields = delegate.getFields;

			/**
			 * return array of names of all sublists
			 * @function ReadOnlySubrecord#getSublists
			 * @returns {Array<string>}
			 */
			this.getSublists = delegate.getSublists;

			/**
			 * return array of names of all fields in a sublist
			 * @function ReadOnlySubrecord#getSublistFields
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {Array<string>}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 */
			this.getSublistFields = delegate.getSublistFields;

			/**
			 * return value of the field
			 * @function ReadOnlySubrecord#getValue
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = delegate.getValue;

			/**
			 * get value of the field in text representation
			 * @function ReadOnlySubrecord#getText
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setText
			 */
			this.getText = delegate.getText;

			/**
			 * return field object from record
			 * @function ReadOnlySubrecord#getField
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 */
			this.getField = delegate.getField;

			/**
			 * return field object from record's sublist
			 * @function ReadOnlySubrecord#getSublistField
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {boolean} options.line
			 * @returns {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 */
			if (!delegate.isNSE) {
				this.getSublistField = delegate.getSublistField;
			}

			/**
			 * return line count of sublist
			 * @function ReadOnlySubrecord#getLineCount
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @returns {number}
			 */
			this.getLineCount = delegate.getLineCount;

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @function ReadOnlySubrecord#findSublistLineWithValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number|Date|string|Array|boolean} options.value
			 * @returns {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing or undefined
			 */
			this.findSublistLineWithValue = delegate.findSublistLineWithValue;

			/**
			 * return value of a sublist field
			 * @function ReadOnlySubrecord#getSublistValue
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {number|Date|string|Array|boolean}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistValue = delegate.getSublistValue;
			}

			/**
			 * return value of a sublist field in text representation
			 * @function ReadOnlySubrecord#getSublistText
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 */
			if (!delegate.isNSE) {
				this.getSublistText = delegate.getSublistText;
			}

			/**
			 * return form metadata for the subrecord.
			 * @name ReadOnlySubrecord#formMetadata
			 * @type {Object}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				this.formMetadata = delegate.formMetadata;
			}

			/**
			 * return true if record is being seen in interactive mode.
			 * @name ReadOnlySubrecord#isInteractive
			 * @type {boolean}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			if (delegate.isInteractive) {
				utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isInteractive', function () { return delegate.isInteractive; });
			}

			if (delegate.isInteractive) {
				this.getLine = delegate.getLine;
			}

			if (delegate.isInteractive) {
				this.getLines = delegate.getLines;
			}

			if (delegate.isInteractive) {
				this.getLinesIterator = delegate.getLinesIterator;
			}

			return this;
		}

		ReadOnlySubrecord.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlySubrecord);

		return ReadOnlySubrecord;
	});

/**
 * Totaling Module
 *
 * WARNING: This module is targeted as a NSX effort and only have partial function in NSN.
 * Currently this module only support Async functions that can be used in client side. Execution of Async JavaScript code on server side is not supported.
 *
 * @module N/totaling
 * @suiteScriptVersion 2.x
 *
 */

define('N/totaling',[], function () {

	function iterablePromises(promises) {
		return Promise.all(promises)
			.then(function(results){
				if(results.length !== promises.length){
					return iterablePromises(promises);
				}
				return results;
			});
	}

	var nodeTypes = {
		SUBLIST: "sublist",
		FIELD: "field",
		VIRTUAL: "virtual",
		VALUE: "value"
	};
	var operationTypes = {
		REMOVE: "remove",
		COMMIT: "commit",
		MACHINESOURCING: "machinesourcing",
		SETSUBLISTVALUE: "setSublistValue"
	};

	function needFullCalc(dataMap, nodes, originalArg) {
		if(!originalArg.lineInstanceId){
			return true;
		}
		var result = false;
		(nodes || []).forEach(function (node) {
			result = result || !hasRawAggregation(dataMap, node);
		});
		return result;
	}

	function getLineInstanceId(currentRecord, sublistId, lineIndex){
		var instanceId = currentRecord.getSublistValue(sublistId, "_id", lineIndex);
			return instanceId || lineIndex;
	}

	function getNode(nodes, nodeId) {
		if (nodes[nodeId]) {
			return nodes[nodeId];
		}
		else {
			throw "Node " + nodeId + " does not exist";
		}
	}

	function getSublistNodes(sourceMap, nodes, sublistId) {
		if (sourceMap.sublists[sublistId]) {
			var nodeIds = sourceMap.sublists[sublistId];
			return (nodeIds || []).map(function (nodeId) {return getNode(nodes, nodeId);});
		}
		else {
			throw "Sublist " + sublistId + " does not exist.";
		}
	}

	function getSingleContribution(dataMap, node, id) {
		var result = (dataMap.contributions[node.id] || {})[id];
		return util.isString(result) ? JSON.parse(result) : result;
	}

	function setContribution(dataMap, node, id, value, qualifies) {
		var data = {value: value, qualifies: !!qualifies};
		dataMap.contributions[node.id] = dataMap.contributions[node.id] || {};
		dataMap.contributions[node.id][id] = data;
	}

	function clearSingleContribution(dataMap, node, id) {
		delete (dataMap.contributions[node.id] || {})[id];
	}

	function hasRawAggregation(dataMap,  node) {
		return dataMap.rawAggregations[node.id] !== undefined;
	}

	function getRawAggregation(dataMap, node) {
		return dataMap.rawAggregations[node.id];
	}

	function setRawAggregation(dataMap, node, value) {
		dataMap.rawAggregations[node.id] = value;
	}

	function clearRawAggregation(dataMap, node) {
		delete dataMap.rawAggregations[node.id];
	}

	function clearRawAggregations(dataMap, nodes) {
		(nodes || []).forEach(function (node) {
			clearRawAggregation(dataMap, node);
		});
	}

	function getBodyFieldValues(currentRecord, nodes) {
		var fieldValues = {};
		Object.keys(nodes || []).forEach(function (node) {
			(nodes[node].fields.body || []).reduce(function (vals, fieldId) {
				if (!vals.hasOwnProperty(fieldId)) {
					vals[fieldId] = currentRecord.getValue(fieldId);
				}
				return vals;
			}, fieldValues);
		});
		return fieldValues;
	}

	function getSublistFieldValues(currentRecord, nodes, sublistId, lineIndex) {
		var sublistValues = {};
		Object.keys(nodes || []).forEach(function (node) {
			(nodes[node].fields.sublist || []).reduce(function (vals, fieldId) {
				if (!vals.hasOwnProperty(fieldId)) {
					vals[fieldId] = currentRecord.getSublistValue(sublistId, fieldId, lineIndex);
				}
				return vals;
			}, sublistValues);
		});
		return sublistValues;
	}

	function prepareMapperInput(node, sublistValues, fieldValues){
		var result = {
			nodeId: node.id,
			sourceId: null,
			values: {}
		};
		(node.fields.sublist || []).forEach(function (fieldId) {
			result.values[fieldId] = sublistValues[fieldId];
		});
		(node.fields.body || []).forEach(function (fieldId) {
			result.values[fieldId] = fieldValues[fieldId];
		});
		return result;
	}

	function extend(target, source) {
		Array.prototype.push.apply(target || [], source || []);
		return target;
	}

	function processTarget(dataMap, node, targetNode){
		var sourceObj = targetNode.sources.filter(function (source) {return source.id === node.id})[0];
		if (sourceObj) {
			clearSingleContribution(dataMap, targetNode, node.id);
			clearRawAggregation(dataMap, targetNode);
		}
		else {
			throw "Mismatching happens between node " + node.id + " and node " + targetNode.id;
		}
	}

	function rawAggregationChange(node, options){
		return getRawAggregation(options.dataMap, node)!== options.preRawAggregation[node.id];
	}

	function asyncProcessTargets(node, options) {
		var nodes = options.totalingMap.nodes;
		var dataMap = options.dataMap;
		var targetPromises = [];

		if(rawAggregationChange(node, options)) {
			(node.targets || []).forEach(function targetProcess(target) {
				var targetNode = getNode(nodes, target.id);
				processTarget(dataMap, node, targetNode);
				var targetPromise = nodeAsyncProcess(targetNode, options);
				targetPromises.push(targetPromise);
			});
		}
		return targetPromises;
	}

	function asyncAggregation(currentRecord, dataMap, sublistId, nodes, aggregatePromises){
		var lineCount = currentRecord.getLineCount(sublistId);
		(nodes || []).forEach(function(node){
			var contributions = [];
			for(var i=0; i<lineCount; i++){
				var lineInstanceId = getLineInstanceId(currentRecord, sublistId, i);
				var contribution = getSingleContribution(dataMap, node, lineInstanceId);
				if(contribution.qualifies){
					contributions.push(contribution.value);
				}
			}
			var aggregatePromise = new Promise(function(resolve) {
				contributions
					.reduce(function (prePromise, contribution) {
						return prePromise.then(function (result) {
							return getAggregator(node)({
								currentAggregation: result.aggregation,
								contribution: contribution
							});
						});
					}, Promise.resolve({}))
					.then(function(result) {
						setRawAggregation(dataMap, node, result.aggregation);
						resolve();
					});
			});
			aggregatePromises.push(aggregatePromise);
		});
	}

	function asyncAddLineHandler(currentRecord, dataMap, sublistNodes, sublistId, lineIndex) {
		return asyncCalculateSingleLineContributions(currentRecord, dataMap, sublistNodes, sublistId, lineIndex, true);
	}

	function checkDefaultAggregatorLineChange(dataMap, nodes, lineInstanceId, nodesWithDefaultAggregator, nodesWithCustomAggregator){
		nodes.forEach(function (node) {
			if (!util.isFunction(node.aggregator)) {
				var previousRawAggregation = getRawAggregation(dataMap, node);
				var previousContribution = getSingleContribution(dataMap, node, lineInstanceId);
				if (previousRawAggregation != null && previousContribution) {
					if (previousContribution.qualifies) {
						setRawAggregation(dataMap, node, previousRawAggregation - previousContribution.value);
					}
					nodesWithDefaultAggregator.push(node);
				}
				else {
					nodesWithCustomAggregator.push(node);
				}
			}
			else {
				nodesWithCustomAggregator.push(node);
			}
			clearSingleContribution(dataMap, node, lineInstanceId);
		});
		clearRawAggregations(dataMap, nodesWithCustomAggregator);
	}

	function asyncChangeLineHandler(currentRecord, dataMap, sublistNodes, sublistId, lineIndex) {
		var bodyFields = getBodyFieldValues(currentRecord, sublistNodes);
		var sublistFields = getSublistFieldValues(currentRecord, sublistNodes, sublistId, lineIndex);
		var changeLinePromises = [];
		var nodesWithDefaultAggregator = [];
		var nodesWithCustomAggregator = [];
		var instanceId = getLineInstanceId(currentRecord, sublistId, lineIndex);
		return new Promise(function(resolve){
			if (sublistNodes && sublistNodes.length) {
				checkDefaultAggregatorLineChange(dataMap, sublistNodes, instanceId, nodesWithDefaultAggregator, nodesWithCustomAggregator);

				changeLinePromises.push(asyncCalculateSingleLineContributions(currentRecord, dataMap, nodesWithDefaultAggregator, sublistId, lineIndex, true, sublistFields, bodyFields));
				changeLinePromises.push(asyncCalculateSingleLineContributions(currentRecord, dataMap, nodesWithCustomAggregator, sublistId, lineIndex, false, sublistFields, bodyFields));

				var aggregatePromises = [];
				Promise.all(changeLinePromises)
					.then(function(){
						asyncAggregation(currentRecord, dataMap, sublistId, nodesWithCustomAggregator, aggregatePromises);
					})
					.then(function() {
						return Promise.all(aggregatePromises);
					})
					.then(function(){
						resolve();
					})
			}
			else{
				resolve();
			}
		});
	}

	function checkDefaultAggregatorLineRemove(dataMap, nodes, lineInstanceId, nodesWithDefaultAggregator, nodesWithCustomAggregator){
		(nodes || []).forEach(function (node) {
			if (!util.isFunction(node.aggregator)) {
				var removedData = getSingleContribution(dataMap, node, lineInstanceId);
				var previousRawAggregation = getRawAggregation(dataMap, node);
				if (previousRawAggregation != null && removedData) {
					if (removedData.qualifies) {
						setRawAggregation(dataMap, node, previousRawAggregation - removedData.value);
					}
					nodesWithDefaultAggregator.push(node);
				}
				else {
					nodesWithCustomAggregator.push(node);
				}
			}
			else {
				nodesWithCustomAggregator.push(node);
			}
			clearSingleContribution(dataMap, node, lineInstanceId);
		});
		clearRawAggregations(dataMap, nodesWithCustomAggregator);
	}

	function asyncRemoveLineHandler(currentRecord, dataMap, sublistNodes, sublistId, lineInstanceId) {
		var nodesWithDefaultAggregator = [];
		var nodesWithCustomAggregator = [];
		return new Promise(function(resolve) {
			checkDefaultAggregatorLineRemove(dataMap, sublistNodes, lineInstanceId, nodesWithDefaultAggregator, nodesWithCustomAggregator);
			var aggregatePromises = [];
			asyncAggregation(currentRecord, dataMap, sublistId, nodesWithCustomAggregator, aggregatePromises);
			Promise.all(aggregatePromises)
				.then(function(){
					resolve();
				});
		});
	}

	function init(options){
		var currentOptions = {
			totalingMap : options.totalingMap,
			originalSublistId : options.sublistId,
			originalFieldId : options.fieldId,
			originalArgs : options.originalArgs || [],
			currentRecord : options.currentRecord
		};

		options.totalingMap.dataMap = options.totalingMap.dataMap || {};

		currentOptions.dataMap = options.totalingMap.dataMap; //JSON.parse(JSON.stringify(options.totalingMap.dataMap || {}));
		currentOptions.dataMap.contributions = currentOptions.dataMap.contributions || {};
		currentOptions.dataMap.rawAggregations = currentOptions.dataMap.rawAggregations || {};
		currentOptions.preRawAggregation = JSON.parse(JSON.stringify(currentOptions.dataMap.rawAggregations));

		//clean processed history
		currentOptions.nodePromises = [];

		return currentOptions;
	}

	function asyncCalculateSingleLineContributions(currentRecord, dataMap, nodes, sublistId, lineIndex, runAggregate, sublistValues, fieldValues){
		return new Promise(function(resolve){
			var sublistValues = sublistValues || getSublistFieldValues(currentRecord, nodes, sublistId, lineIndex);
			var fieldValues = fieldValues || getBodyFieldValues(currentRecord, nodes);
			var instanceId = getLineInstanceId(currentRecord, sublistId, lineIndex);
			var lineContributions = {};
			var promises = [];
			(nodes || []).forEach(function (node) {
				var inputSublist = prepareMapperInput(node, sublistValues, fieldValues);
				var promise = new Promise(function(resolve){
					var qualifierResult;
					getQualifier(node)(inputSublist)
						.then(function(result){
							qualifierResult = (result || {}).isQualified;
							if(qualifierResult === true){
								return getMapper(node)(inputSublist);
							}
							else{
								return Promise.resolve();
							}
						})
						.then(function(result){
							var lineContribution = (result || {}).contribution;
							lineContributions[node.id] = lineContribution;
							setContribution(dataMap, node, instanceId, lineContribution, qualifierResult);
							if(runAggregate){
								return getAggregator(node)({
									currentAggregation: getRawAggregation(dataMap, node),
									contribution: lineContribution
								});
							}
							else{
								return Promise.resolve({});
							}
						})
						.then(function(result){
							if(runAggregate){
								setRawAggregation(dataMap, node, result.aggregation);
							}
							resolve();
						})
				});
				promises.push(promise);
			});
			Promise.all(promises)
				.then(function(){
					resolve(lineContributions);
				});
		});
	}

	function sublistAsyncProcess(sublistId, options) {
		var sourceMap = options.totalingMap.sourceMap;
		var nodes = options.totalingMap.nodes;
		var dataMap = options.dataMap;
		var currentRecord = options.currentRecord;
		var nodePromises = options.nodePromises;
		var originalArg = options.originalArgs[0];
		var sublistNodes = getSublistNodes(sourceMap, nodes, sublistId);
		if (!sublistNodes.length)
			return Promise.resolve("There is no node in sublist " + sublistId);
		return new Promise(function(resolve, reject){
			if (needFullCalc(dataMap, sublistNodes, originalArg)) {
				var lineCount = currentRecord.getLineCount(sublistId);
				if (lineCount === 0) {
					(sublistNodes || []).forEach(function (node) {
						setRawAggregation(dataMap, node, 0);
						extend(nodePromises, asyncProcessTargets(node, options));
					});
					resolve("sublist {" + sublistId + "} process finished ===> no line exists");
				}
				else {
					var fieldValues = getBodyFieldValues(currentRecord, sublistNodes);
					//calculate all contributions
					var lineContributionsPromises = [];
					for (var i = 0; i < lineCount; i++) {
						lineContributionsPromises.push(asyncCalculateSingleLineContributions(currentRecord, dataMap, sublistNodes, sublistId, i, false, null, fieldValues));
					}
					//run aggregators
					var aggregatePromises = [];
					Promise.all(lineContributionsPromises)
						.then(function (results) {
							(sublistNodes || []).forEach(function (node) {
								var aggregatePromise = new Promise(function (resolve) {
									results.map(function (result) {return result[node.id];})
										.reduce(function (prePromise, contribution) {
											return prePromise.then(function (result) {
												return getAggregator(node)({
													currentAggregation: result.aggregation,
													contribution: contribution
												});
											});
										}, Promise.resolve({}))
										.then(function (result) {
											setRawAggregation(dataMap, node, result.aggregation);
											resolve();
										});
								});
								aggregatePromises.push(aggregatePromise);
							});
						})
						.then(function () {
							return Promise.all(aggregatePromises);
						})
						.then(function () {
							//process targets
							(sublistNodes || []).forEach(function (node) {
								extend(nodePromises, asyncProcessTargets(node, options));
							});
							resolve("sublist {" + sublistId + "} process finished ===> fullCalculation");
						});
				}
			}
			else if (sublistId !== options.originalSublistId) {
				reject("This should never happen");
			}
			else if (originalArg.operation === operationTypes.COMMIT) {
				var sublistOperations = {add: [], change: []};
				(sublistNodes || []).forEach(function (node) {
					!getSingleContribution(dataMap, node, originalArg.lineInstanceId) ? sublistOperations.add.push(node) : sublistOperations.change.push(node);
				});
				var lineCommitPromises = [];
				lineCommitPromises.push(asyncAddLineHandler(currentRecord, dataMap, sublistOperations.add, sublistId, originalArg.lineIndex));
				lineCommitPromises.push(asyncChangeLineHandler(currentRecord, dataMap, sublistOperations.change, sublistId, originalArg.lineIndex));

				Promise.all(lineCommitPromises)
					.then(function(){
						(sublistNodes || []).forEach(function (node) {
							extend(nodePromises, asyncProcessTargets(node, options));
						});
						resolve("sublist {" + sublistId + "} process finished ===> lineCommit with nodes: " + JSON.stringify(sublistOperations));
					})
			}
			else if (originalArg.operation === operationTypes.REMOVE) {
				asyncRemoveLineHandler(currentRecord, dataMap, sublistNodes, sublistId, originalArg.lineInstanceId)
					.then(function(){
						(sublistNodes || []).forEach(function (node) {
							extend(nodePromises, asyncProcessTargets(node, options));
						});
						resolve("sublist {" + sublistId + "} process finished ===> lineRemove");
					});
			}
			else if (originalArg.operation === operationTypes.SETSUBLISTVALUE) {
				asyncChangeLineHandler(currentRecord, dataMap, sublistNodes, sublistId, originalArg.lineIndex)
					.then(function(){
						(sublistNodes || []).forEach(function (node) {
							extend(nodePromises, asyncProcessTargets(node, options));
						});
						resolve("sublist {" + sublistId + "} process finished ===> setSublistValue");
					});
			}
		});
	}

	function nodeAsyncProcess(node, options){
		var nodes = options.totalingMap.nodes;
		var dataMap = options.dataMap;
		var nodePromises = options.nodePromises;
		var currentRecord = options.currentRecord;

		if (node.isSource) {
			throw "Virtual node or field node should be a leaf node.";
		}
		return new Promise(function(resolve){
			var needWait = false;
			var needWaitList = [];
			(node.sources || []).forEach(function (source) {
				var sourceNode = getNode(nodes, source.id);
				if (!hasRawAggregation(dataMap, sourceNode)) {
					nodePromises.push((sourceNode.type === nodeTypes.SUBLIST) ?
						sublistAsyncProcess(sourceNode.sublistId, options) : nodeAsyncProcess(sourceNode, options));
					needWait = true;
					needWaitList.push(sourceNode.id);
				}
			});
			if (needWait === true) {
				resolve("node {" + node.id + "} is not ready for process because sources [" + needWaitList + "] are not ready.");
			}
			var inputGeneral = {
				nodeId: node.id,
				sourceId: undefined,
				values: {}
			};
			var modifierPromises = [];
			(node.sources || []).forEach(function (source) {
				var sourceNode = getNode(nodes, source.id);
				var contributor = getRawAggregation(dataMap, sourceNode);
				var modifierPromise = new Promise(function(resolve){
					var modifiers = [];
					//get modifiers in source.targets
					var targetObj = sourceNode.targets.filter(function (target) {return target.id === node.id;})[0];
					if (targetObj) {
						extend(modifiers, (targetObj.modifiers || []));
					}
					//get modifiers in node.sources
					extend(modifiers, (source.modifiers || []));
					(modifiers || [])
						.reduce(function(prePromise, modifier){
							return prePromise.then(function(result){
								contributor = result.result;
								var inputModifier = {currentRecord: currentRecord, value: contributor};
								return modifier(inputModifier)
							});
						}, Promise.resolve({result: contributor}))
						.then(function(result){
							contributor = result.result;
							inputGeneral.values[source.id] = contributor;
							resolve();
						});
				});
				modifierPromises.push(modifierPromise);
			});
			var mapperPromises = [];
			Promise.all(modifierPromises)
				.then(function(){
					(node.sources || []).forEach(function sourceProcess(source) {
						var inputGeneralClone = JSON.parse(JSON.stringify(inputGeneral));
						inputGeneralClone.sourceId = source.id;
						var mapperPromise = new Promise(function(resolve){
							var qualifierResult;
							getQualifier(node)(inputGeneralClone)
								.then(function(result){
									qualifierResult = (result || {}).isQualified;
									if(qualifierResult === true){
										return getMapper(node)(inputGeneralClone);
									}
									else{
										return Promise.resolve();
									}
								})
								.then(function(result){
									var contributionGeneral = (result || {}).contribution;
									setContribution(dataMap, node, source.id, contributionGeneral, qualifierResult);
									resolve(contributionGeneral);
								})
						});
						mapperPromises.push(mapperPromise);
					});
				})
				.then(function(){
					return Promise.all(mapperPromises);
				})
				.then(function(results){
					(results || [])
						.reduce(function(prePromise, contribution){
							return prePromise.then(function(result){
								return getAggregator(node)({ currentAggregation: result.aggregation, contribution: contribution })
							});
						}, Promise.resolve({}))
						.then(function(result){
							setRawAggregation(dataMap, node, result.aggregation);
							if (node.type === nodeTypes.FIELD) {
								if (!node.isTarget) {
									throw "Field node should be a root node.";
								}
								if (node.fields.body.length === 0) {
									throw "Field node should have target body field id.";
								}
								(node.fields.body || []).forEach(function (fieldId) {
									currentRecord.setValue(fieldId, getRawAggregation(dataMap, node), true);
								});
							}
							else {
								extend(nodePromises, asyncProcessTargets(node, options));
							}
							resolve("node {" + node.id + "} process finished with result " + getRawAggregation(dataMap, node));
						});
				});
		});
	}

	function calcAsyncTotaling(options) {

		var totalingOptions = init(options);

		var dataMap = totalingOptions.dataMap;
		var nodePromises = totalingOptions.nodePromises;
		var sourceMap = options.totalingMap.sourceMap;
		var nodes = options.totalingMap.nodes;
		var originalArg = options.originalArgs[0];

		if (originalArg.operation === operationTypes.MACHINESOURCING) {
			if (!originalArg.sublists) {
				throw "machine sourcing opration missing sublists";
			}
			(originalArg.sublists || []).forEach(function (sublistId) {
				(sourceMap.sublists[sublistId] || []).forEach(function (nodeId) {
					clearRawAggregation(dataMap, getNode(nodes, nodeId));
				});
				nodePromises.push(sublistAsyncProcess(sublistId, totalingOptions));
			});
		}
		else {
			nodePromises.push(sublistAsyncProcess(options.sublistId, totalingOptions));
		}
		return iterablePromises(nodePromises);
	}

	var asyncDefaults = {
		qualifier: function defaultAsyncQualifier() {
			return Promise.resolve({isQualified: true});
		},
		mapper: function defaultAsyncMapper(options) {
			return new Promise(function(resolve, reject){
				var id = options.sourceId || Object.keys(options.values || [])[0];
				resolve({contribution: options.values[id]});
			});
		},
		aggregator: function asyncSummation(options) {
			return new Promise(function(resolve) {
				var aggregation = options.currentAggregation === undefined ? 0 : options.currentAggregation;
				if (util.isNumber(options.contribution) && !isNaN(options.contribution)) {
					resolve({aggregation: aggregation + options.contribution});
				} else {
					resolve({aggregation: aggregation});
				}
			});
		}
	};

	function getQualifier(node) {
		return util.isFunction(node.qualifier) ? node.qualifier : asyncDefaults.qualifier;
	}

	function getMapper(node) {
		return util.isFunction(node.mapper) ? node.mapper : asyncDefaults.mapper;
	}

	function getAggregator(node) {
		return util.isFunction(node.aggregator) ? node.aggregator : asyncDefaults.aggregator;
	}

	return Object.freeze({
		calcTotaling: function () {
			return calcAsyncTotaling.apply(this, arguments);
		}
	});
});
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript module
 *
 * @private
 * @module N/util/recordScripting
 * @suiteScriptVersion 2.x
 */
define('N/util/recordScripting',['N/error', 'N/utilityFunctions', 'N/util', 'N/scriptLoader', 'N/totaling', 'N/resultObject'],
	function (error, utilityFunctions, util, scriptLoader, totaling, resultObject) {

		/**
		 * Record Scripting Event Handler object for scripting defined in static JS file(s)
		 * @param {Object} options
		 *        {Array} options.handlerModules the list of various event handler modules defined for the record
		 *        {String} options.context the require context name in which the scripting should be evaluated
		 *        {Function} [options.scope] the closure function that should be used to evaluate the event handler files
		 *        {boolean} [options.isNSE]
		 *        {Object} [options.scriptingContext] the object containing dynamic context for the record scripting
		 *        {Object} [options.totalingContext] the object containing information for totaling evaluation
		 */
		function RecordScriptingHandler(options, isAyncConstructed) {

			options = options || {};
			var eventHandlerModules = options.handlerModules || [];
			var scriptingContext = options.scriptingContext || {};
			var totalingContext = options.totalingContext || {};
			var eventMap = {};
			var context = options.context;
			var statefulStoreProvider = options.statefulStoreProvider || function() {};
			var scope = options.scope || null;
			var isNSE = options.isNSE;
			var that = this;
			var initializeThenable;

			function getKey(sublistName, fieldName, eventName) {
				var key = String(String(sublistName || null).toLowerCase() + ':' + String(fieldName || null).toLowerCase() + ':' + String(eventName || null));
				return key;
			}

			function addEvent(sublistName, fieldName, eventName, handler, event) {
				if (util.isFunction(event)) {
					var key = getKey(sublistName, fieldName, eventName);
					if (!eventMap[key]) eventMap[key] = [];
					eventMap[key].push({ handler: handler, event: event });
				}
			}

			var totalingBuilder = (function Totaling() {

				function throwError(message) {
					throw message;
				}

				function getHash(input) {
					var hash = 0, i, chr;
					for (i = 0; i < input.length; i++) {
						chr   = input.charCodeAt(i);
						hash  = ((hash << 5) - hash) + chr;
						hash |= 0; // Convert to 32bit integer
					}
					return hash;
				}

				function getElementId(node) {
					if (node.id) {
						return node.id;
					}
					if (node.fields.sublist && node.fields.sublist.length && node.sublistId) {
						return '@'+node.sublistId+'#'+node.fields.sublist.join('.') + ((node.fields.body && node.fields.body.length) ? '~'+node.fields.body.join('.') : '');
					}
					if (node.fields.body && node.fields.body.length) {
						return '@#~'+node.fields.body.join('.');
					}
					throwError('Unknown Node Type: '+JSON.stringify(node));
				}

				var REFERENCE_TYPES = {
					sources: 'sources',
					targets: 'targets'
				};

				var NODE_TYPES = {
					sublist: 'sublist',
					field: 'field',
					value: 'value',
					virtual: 'virtual'
				};

				function getElementType(node) {
					if (node.sublistId) return NODE_TYPES.sublist;
					if (node.fields.body && node.fields.body.length) return NODE_TYPES.field;
					if (node.value) return NODE_TYPES.value;
					// TODO: add more node types
					return node.type || NODE_TYPES.virtual;
				}
				function getElementModifiers(element) {
					var modifiers = [];
					if (util.isFunction(element.modifier))
						modifiers.push(element.modifier);
					modifiers = util.isArray(element.modifiers) ? element.modifiers.filter(function(modifier) {return util.isFunction(modifier);}) : modifiers;
					delete element.modifiers;
					delete element.modifier;
					return modifiers;
				}
				function getElementFields(element) {
					var fields = util.extend({sublist: [], body:[], nodes:[]}, util.isObject(element.fields) ? element.fields : {});

					if (util.isString(element.sublistId)) {
						if (util.isArray(element.sources)) {
							element.sources.forEach(function (source) {
								if (util.isString(source) && fields.sublist.indexOf(source) < 0)
									fields.sublist.push(source);
							})
						}
						delete element.sources;
					}
					if (util.isString(element.fieldId)) {
						var fldType = element.sublistId ? 'sublist' : 'body';
						if (fields[fldType].indexOf(element.fieldId) < 0) {
							fields[fldType].push(element.fieldId);
						}
					}
					delete element.fieldId;

					if (util.isArray(element.sources)) {
						element.sources.forEach(function (source) {
							var nodeId = util.isString(source) || source.id;
							if (nodeId && fields.nodes.indexOf(nodeId) < 0)
								fields.nodes.push(source.id || source);
						})
					}

					return fields;
				}
				function fixReferences(elementList) {
					var references = [];
					elementList.forEach(function(element) {
						if (!element || !(util.isString(element) || util.isObject(element)))
							return;
						element = util.isString(element) ? {id: element} : element;
						element.fields = getElementFields(element);
						element.id = getElementId(element);
						element.type = getElementType(element);
						var modifiers = getElementModifiers(element);
						if (modifiers && modifiers.length > 0)
							element.modifiers = modifiers;
						references.push(element);
					});
					return references;
				}

				function isAutoId(id) {
					return (id || '').indexOf('@') === 0;
				}

				function isLeafNode(node) {
					return !!node.type && node.type !== NODE_TYPES.virtual;
				}

				function isLeafType(node, refType) {
					return isLeafNode(node) && !!node[otherRefType(refType)];
				}

				function updateNodeProps(node) {
					node.fields = getElementFields(node);
					node.id = getElementId(node);
					node.type = getElementType(node);
					node.isSource = isLeafType(node, REFERENCE_TYPES.sources);
					node.isTarget = isLeafType(node, REFERENCE_TYPES.targets);
					return node;
				}

				function buildNewNode(node, nodeId, handlerName, referenceType, referenceElement) {
					var definition = util.extend({handler: handlerName}, node);
					definition = util.extend(definition, referenceElement || {});
					definition.id = nodeId;
					if (util.isArray(node.targets)) {
						definition.targets = fixReferences(node.targets);
					}
					if (util.isArray(node.sources) && !definition.sublistId) {
						definition.sources = fixReferences(node.sources);
					}
					definition = updateNodeProps(definition);
					delete definition.modifiers;
					return definition;
				}

				function getNodeReferenceById(node, referenceType, id) {
					return node[referenceType] && node[referenceType].filter(function (element) { return element.id === id; })[0];
				}

				function transferReferenceToNode(nodeToUpdate, baseNode, baseReferenceNode, referenceType) {
					if (!getNodeReferenceById(nodeToUpdate, referenceType, baseNode.id)) {
						nodeToUpdate[referenceType] = (nodeToUpdate[referenceType] || []);
						nodeToUpdate[referenceType].push(fixReferences([{id: baseNode.id}])[0]);
					}
					updateNodeProps(nodeToUpdate);
					// cleanup reference node
					Object.keys(baseReferenceNode).forEach(function (k) {
						if (k !== 'modifiers') delete baseReferenceNode[k];
					});
					baseReferenceNode.id = nodeToUpdate.id;
					baseReferenceNode.type = nodeToUpdate.type;
				}

				var totalingMap = {
					nodes: {},
					dataMap: {},
					sourceMap: {sublists: {}, fields: {}, others: {}}
				};

				function collectTotalingDefinitions(totalingMap, totalingDefinition, handlerName, sublistId) {
					(Object.keys(totalingDefinition) || []).forEach(function (nodeName) {
						if (!totalingDefinition[nodeName] || !util.isObject(totalingDefinition[nodeName]))
							return;
						var node = totalingDefinition[nodeName];
						if (node.id && node.id !== nodeName) {
							throwError('Node id mismatch: '+ nodeName + ' != ' + node.id);
						}
						if (nodeName === 'sublists') {
							(Object.keys(node) || []).forEach(function (sublistId) {
								collectTotalingDefinitions(totalingMap, node[sublistId], handlerName, sublistId);
							});
						}
						else {
							var nodeObject = buildNewNode(node, nodeName, handlerName, REFERENCE_TYPES.sources, sublistId ? {sublistId: sublistId} : {});
							if (totalingMap.nodes[nodeName] && typeof console !== 'undefined') {
								console.warn('Totaling node "' + nodeName + '" defined in "' + totalingMap.nodes[nodeName].handler + '" redefined in "' + handlerName + '"');
							}
							totalingMap.nodes[nodeName] = nodeObject;
						}
					});
				}
				this.collectTotalingDefinitions = collectTotalingDefinitions.bind(this, totalingMap);

				function otherRefType(referenceType) {
					if (referenceType === REFERENCE_TYPES.sources) return REFERENCE_TYPES.targets;
					if (referenceType === REFERENCE_TYPES.targets) return REFERENCE_TYPES.sources;
				}

				function expandReference(node, referenceNode, referenceType, totalingMap, additionalNodes) {
					if (!util.isObject(referenceNode)) {
						return;
					}
					//var id = referenceType === REFERENCE_TYPES.sources && isLeafType(node, referenceType) ? referenceNode.id + '>' + node.id : referenceNode.id;
					var id = referenceType === REFERENCE_TYPES.sources && isLeafNode(referenceNode) && isAutoId(referenceNode.id) ? referenceNode.id + '>' + node.id : referenceNode.id;

					var baseNode = totalingMap.nodes[id] || additionalNodes[id];
					if (!baseNode) {
						baseNode = buildNewNode(referenceNode, id, node.handler, referenceType, referenceNode);
						additionalNodes[id] = baseNode;
						expandNode(baseNode, referenceType, totalingMap, additionalNodes);
					}
					transferReferenceToNode(baseNode, node, referenceNode, otherRefType(referenceType));
				}

				function expandNode(node, referenceType, totalingMap, additionalNodes) {
					(node[referenceType] || []).forEach(function (referenceNode) {
						expandReference(node, referenceNode, referenceType, totalingMap, additionalNodes);
					});
				}

				function validateNode(node) {
					if (node.isSource
						&& ((node.sources && node.sources.length > 0) || node.isTarget)) {
						throwError('Invalid Node Definition (node cannot be both source and target): '+JSON.stringify(node));
					}
				}

				function buildTotaling(totalingMap) {

					function processNodeReferences(totalingMap) {
						var additionalNodes = {};
						(Object.keys(totalingMap.nodes) || []).forEach(function (nodeName) {
							expandNode(totalingMap.nodes[nodeName], REFERENCE_TYPES.sources, totalingMap, additionalNodes);
							expandNode(totalingMap.nodes[nodeName], REFERENCE_TYPES.targets, totalingMap, additionalNodes);
						});
						util.extend(totalingMap.nodes, additionalNodes);
					}

					function buildAndVerifySourceMap(totalingMap) {
						var sourceMap = totalingMap.sourceMap;
						Object.keys(totalingMap.nodes).forEach(function (nodeName) {
							var node = totalingMap.nodes[nodeName];
							validateNode(node);
							if (node.isSource) {
								if (node.type  === NODE_TYPES.sublist) {
									sourceMap.sublists[node.sublistId] = sourceMap.sublists[node.sublistId] || [];
									sourceMap.sublists[node.sublistId].push(node.id);
								} else if (node.type === NODE_TYPES.field) {
									node.fields.body.forEach(function(fieldId) {
										sourceMap.fields[fieldId] = sourceMap.fields[fieldId] || [];
										sourceMap.fields[fieldId].push(node.id);
									});
								} else {
									sourceMap.others[node.id] = sourceMap.others[node.id] || [];
									sourceMap.others[node.id].push(node.id);
								}
							}
						});
					}

					function addEvents(totalingMap) {
						if (Object.keys(totalingMap.sourceMap.sublists).length) {
							addEvent(null, null, '_syncsublists_', 'totaling', callTotaling.bind(null, {totalingMap: totalingMap}));
						}
						Object.keys(totalingMap.sourceMap.sublists).forEach(function(sublistId) {
							var totalingOptions = {totalingMap: totalingMap, sources: totalingMap.sourceMap.sublists[sublistId].map(function (id) { return totalingMap.nodes[id]; })};
							// temporary for testing
							if (totalingContext.isOldUI) {
								addEvent(sublistId, null, 'lineCommit', 'totaling', callTotaling.bind(null, totalingOptions));
								addEvent(sublistId, null, 'postDeleteLine', 'totaling', callTotaling.bind(null, totalingOptions));
							} else {
								addEvent(sublistId, null, '_sync_'+sublistId, 'totaling', callTotaling.bind(null, totalingOptions));
								(totalingMap.sourceMap.sublists[sublistId] || []).forEach(function(nodeId) {
									(((totalingMap.nodes[nodeId] || {}).fields || {}).sublist || []).forEach(function (fieldId) {
										addEvent(sublistId, fieldId, '_sync_'+sublistId+'_'+fieldId, 'totaling', callTotaling.bind(null, totalingOptions));
									});
								});
							}
						});
						Object.keys(totalingMap.sourceMap.fields).forEach(function(fieldId) {
							var totalingOptions = {totalingMap: totalingMap, sources: totalingMap.sourceMap.fields[fieldId].map(function (id) { return totalingMap.nodes[id]; })};
							// temporary for testing
							addEvent(null, fieldId, '_syncfield_'+fieldId, 'totaling', callTotaling.bind(null, totalingOptions));
						});
					}

					function callTotaling(totalingObject, eventObject) {
						if (eventObject.originalArgs && eventObject.originalArgs[0]) {
							if (typeof nlapiSetLineItemValue !== "undefined" && !eventObject.originalArgs[0].setSublistValue)
								eventObject.originalArgs[0].setSublistValue = function(sublistId, fieldId, line, value) { return nlapiSetLineItemValue(sublistId, fieldId, line != null ? line+1 : line, value); };
						}
						if (totalingObject.totalingMap) {
							if (eventObject.originalArgs  && util.isArray((eventObject.originalArgs[0] || {}).sublists)) {
								var applicableSouces = [];

								totalingObject.sources = (eventObject.originalArgs[0]).sublists.forEach(function(sublistId) {
									Array.prototype.push.apply(applicableSouces, (totalingObject.totalingMap.sourceMap.sublists[sublistId] || []).map(function (id) { return totalingObject.totalingMap.nodes[id]; }));
								});
								if (applicableSouces.length > 0) {
									totaling.calcTotaling(util.extend({sources: applicableSouces, totalingMap: totalingObject.totalingMap}, eventObject))
								}
							}
							else {
								totaling.calcTotaling(util.extend({sources: totalingObject.sources, totalingMap: totalingObject.totalingMap}, eventObject))
							}
						}
					}

					processNodeReferences(totalingMap);
					buildAndVerifySourceMap(totalingMap);
					addEvents(totalingMap);
				}
				this.buildTotaling = buildTotaling.bind(this, totalingMap);

				function getTotalingMap() {
					return totalingMap;
				}
				this.getTotalingMap = getTotalingMap;

				return this;
			})();

			function handleError(e) {
				var err = e;
				if (e instanceof Error) {
					if (e.userFacing !== undefined && e.userFacing !== null) {
						err = error.create({name: e.name, message: e.message, cause: e, userFacing: e.userFacing});
					} else {
						err = error.create({name: e.name, message: e.message, cause: e});
					}
				}
				throw err;
			}

			var runEvent = utilityFunctions.thenableFunction(function runEvent(args) {
				var key = getKey(args.sublistId, args.fieldId, args.eventName);
				var results = [];
				var listeners = eventMap[key];
				return resultObject.create(function () {
					if (listeners) {
						return utilityFunctions.forEachThenable(listeners, function (listener) {
							var event = listener.event;
							args.store = statefulStoreProvider(listener.handler, {isReadOnly: event.name.indexOf('validate') >= 0});
							return resultObject.create(function () {
								var currResult = event(args);
								if (isNSE) {
									if (!utilityFunctions.isThenable(currResult)) {
										throw new TypeError("require('" + listener.handler + "')"
											+ (args.sublistId ? ".sublists." + args.sublistId : "")
											+ (args.fieldId ? ".fields." + args.fieldId : "")
											+ "." + args.eventName + "()"
											+ " must return a promise");
									}
								} else {
									if (utilityFunctions.isThenable(currResult)) {
										throw new TypeError("require('" + listener.handler + "')"
											+ (args.sublistId ? ".sublists." + args.sublistId : "")
											+ (args.fieldId ? ".fields." + args.fieldId : "")
											+ "." + args.eventName + "()"
											+ " must not return a promise");
									}
								}
								return currResult;
							}).then(function (currResult) {
								results.push({handler: listener.handler, result: currResult})
							})['catch'](function (e) {
								handleError(e);
							});
						});
					}
				}).then(function () {
					return results;
				});
			});

			var initializeHandlers = utilityFunctions.thenableFunction(function initializeHandlers()
			{
				// do not include current record reference to avoid misusing this as pre-pageInit call
				return runEvent.thenable({
					eventName: 'setupHandler',
					scriptingContext: scriptingContext
				});
			});

			/**
			 * Run the event handler defined in static javascript file and return merged result
			 * @param {Object} options object with all arguments for the event execution
			 * @return {array} list of all event results that were executed in format {handler : string, result : Object }
			 */
			this.runStaticEvent = utilityFunctions.thenableFunction(function runStaticEvent(options) {
				var args = util.extend(options || {}, {scriptingContext: scriptingContext});
				return runEvent.thenable(args);
			});

			this.hasStaticEvent = function hasStaticEvent(options) {
				var args = options || {};
				var key = getKey(args.sublistId, args.fieldId, args.eventName);
				return !!eventMap[key];
			};
			
			function parseEventHandlers(handlerName, recordScriptImpl) {
				var sublists = (recordScriptImpl.sublists || {});
				(Object.keys(sublists) || []).forEach(function (sublistName) {
					var fieldsOrEvents = recordScriptImpl.sublists[sublistName] || {};
					var sublistFields = fieldsOrEvents.fields || {};
					(Object.keys(sublistFields) || []).forEach(function (fieldName) {
						var field = sublistFields[fieldName] || {};
						(Object.keys(field) || []).forEach(function (eventName) {
							addEvent(sublistName, fieldName, eventName, handlerName, field[eventName]);
						});
					});
					(Object.keys(fieldsOrEvents) || []).forEach(function (eventName) {
						addEvent(sublistName, null, eventName, handlerName, fieldsOrEvents[eventName]);
					});
				});
				var fields = recordScriptImpl.fields || {};
				(Object.keys(fields) || []).forEach(function (fieldName) {
					var field = fields[fieldName] || {};
					(Object.keys(field) || []).forEach(function (eventName) {
						addEvent(null, fieldName, eventName, handlerName, field[eventName]);
					});
				});
				totalingBuilder.collectTotalingDefinitions(recordScriptImpl.totaling || {}, handlerName);
				var eventNames = Object.keys(recordScriptImpl) || {};
				eventNames.forEach(function (eventName) {
					addEvent(null, null, eventName, handlerName, recordScriptImpl[eventName]);
				});
			}

			function getScriptModuleHash(eventHandlerModule) {
				if (util.isObject(eventHandlerModule)) {
					if (eventHandlerModule.hash) {
						return eventHandlerModule.hash;
					}
				}
			}
			function getScriptModuleName(eventHandlerModule) {
				if (util.isObject(eventHandlerModule)) {
					return eventHandlerModule.name;
				}
				return eventHandlerModule;
			}
			function isBundleModule(eventHandlerModule) {
				if (util.isObject(eventHandlerModule)) {
					return eventHandlerModule.forRequire;
				}
				return false;
			}

			function getBundleModuleHashedNames(eventHandlerModules) {
				var bundles = eventHandlerModules.filter(isBundleModule);
				if (bundles.length === 0)
					bundles.push(eventHandlerModules[0]);
				return bundles.map(function(eventHandlerModule) {
					var moduleHash = getScriptModuleHash(eventHandlerModule);
					var bundleModuleName = getScriptModuleName(eventHandlerModule);
					return bundleModuleName + (moduleHash ? "." + moduleHash : "");
				})
			}

			(function constructor() {
				initializeThenable = resultObject.create(function () {
					if (eventHandlerModules.length > 0) {
						var asyncRequire = isNSE || (isAyncConstructed && typeof Promise !== "undefined");
						var thenableConstructor = asyncRequire ? Promise : resultObject;
						if (!asyncRequire) {
							var wasSync = require.isSync();
							require.forceSync(true);
						}
						var entryPointRequire = scriptLoader.getEntryPointRequire({'context': context, _closure: scope});
						return resultObject.create(function () {
							return new thenableConstructor(function (resolve) {
								// Need to require the bundle modules beforehand since they contain everything so we don't have to go to server again for the rest of the files
                                entryPointRequire(getBundleModuleHashedNames(eventHandlerModules), resolve);
							});
						}).then(function () {
							// Due to the setting in JSON File, eventHandlerModules should be executed in reverse order. The last event handler module should be executed first
							return utilityFunctions.forEachThenable(eventHandlerModules.slice().reverse(), function (handler) {
								var handlerName = getScriptModuleName(handler);
								return new thenableConstructor(function (resolve) {
									entryPointRequire([handlerName], function (recordScriptExport) {
										if (recordScriptExport && (recordScriptExport.__esModule || recordScriptExport.createEventHandler)) {
											resolve(utilityFunctions.forEachThenable(Object.keys(recordScriptExport), function (k) {
												return resultObject.create(function () {
													if (k === 'createEventHandler' && util.isFunction(recordScriptExport[k])) {
														return recordScriptExport.createEventHandler();
													}
													else if (util.isFunction(recordScriptExport[k].createEventHandler)) {
														return recordScriptExport[k].createEventHandler();
													}
													return null;
												}).then(function (handler) {
													if (handler != null) {
														parseEventHandlers(k === 'createEventHandler' ? handlerName : handlerName + '.' + k, handler);
													}
												});
											}));
										} else {
											throw new Error("Unsupported event handler " + handlerName);
											resolve();
										}
									});
								});
							});
						})['finally'](function () {
							if (!asyncRequire) {
								require.forceSync(wasSync);
							}
						}).then(function () {
							totalingBuilder.buildTotaling();
							// call setupHandler methods of all registered event handlers
							return initializeHandlers.thenable();
						});
					}
				}).then(function () {
					return that;
				});
			})();

			this.ensureInitialized = function ensureInitialized() {
				return initializeThenable;
			}
		}

		var create = utilityFunctions.thenableFunction(function (options, isAsync)
		{
			return new RecordScriptingHandler(options, isAsync).ensureInitialized();
		}, {isAsyncArgIndex: 1});

		return {
			create: create
		};
	}
);

/**
 * SuiteScript module
 * This file is an alias for NLSqlInjectionDetector - NLSqlInjectionDetector.getFirstIllegalMatch(null)
 *
 * @private
 * @module N/util/sqlInjectionFilter
 * @suiteScriptVersion 2.x
 */
define('N/util/sqlInjectionFilter',["N/internal/invoker", 'N/restricted/remoteApiBridge'],
	function(invoker, apiBridge){
		/* imports */
		/**
		 * @alias SELECT_STRING (NLSqlInjectionDetector.java)
		 */
		var SQL_SELECT_STRING_REGEX = /select[ ].+from[ ]?[^ ,]*[ ,]+((all)?(trandoc|tranline|trancard|entity|custjob|emaillogin|emailpassword|emailpasswordhistory|emailpasswordnewhistory)|([a-zA-Z_0-9]*)?@SIGNUPDB_0|([a-zA-Z_0-9]*)?@SANDBOX_SIGNUPDB_0|pwdresetanswers|v\$|source\$|dbms_|all_|dba_|user_|java\$|nl_)/i;

		/**
		 * utility function that values field value against SQL injection regex. Logs error if match is found
		 * @param {*} fieldId - field name
		 * @param {*} toValidate - value in field
		 */
		function validateSqlInjection(fieldId, toValidate)
		{
			if(isNonEmptyString(toValidate))
			{
				var matches = SQL_SELECT_STRING_REGEX.exec(toValidate.replace(/\s/g,' '));
				if(matches != null && matches.length > 1 && matches[1].trim().length > 0)
					logSQLInjectionError(fieldId, toValidate, matches[1]);
			}
		}

		function logSQLInjectionError(fieldId, toValidate, firstCaptureGroup)
		{
			invoker(apiBridge, 'logSQLInjectionError', [fieldId, toValidate, firstCaptureGroup]);
		}

		function isNonEmptyString(toValidate)
		{
			return (util.isString(toValidate) && toValidate.length > 0);
		}

		/* assign util.sqlInjectionFilter package */
		return Object.freeze({
			validateSqlInjection: validateSqlInjection
		});
	}
);

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * Encode and decode record data types for transfer between Java and JavaScript.
 *
 * @module N/record/recordDataEncoding
 * @private
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/recordDataEncoding',['N/util', 'N/utilityFunctions', "N/error", 'N/util/date'],
	function (util, utilityFunctions, error, dateUtil){
		var MIN_INT = -0x80000000;
		var MAX_INT = 0x7fffffff;

		function marshal(type, value, useNewTypes) {
			if (useNewTypes) {
				return marshalWithNewTypes(type, value);
			} else {
				return marshalWithOldTypes(type, value);
			}
		}

		function marshalWithNewTypes(type, value) {
			checkNewTypesDefined();
			var MIN_LONG = BigInt(-1) << BigInt(63);
			var MAX_LONG = (BigInt(1) << BigInt(63)) - BigInt(1);
			var res;
			if (value === null || value === undefined) {
				if (type === "boolean") {
					return "false";
				}
				return null;
			}

			switch (type) {
				case "boolean":
				case "checkbox":
				case "radio":
					assertType(value, type, "boolean",  util.isBoolean);
					res = String(value);
					break;
				case "text":
				case "longtext":
				case "email":
				case "emails":
				case "ccnumber":
				case "address":
				case "textarea":
				case "richtext":
				case "url":
				case "identifier":
				case "identifieranycase":
				case "phone":
				case "password":
					assertType(value, type, "string", util.isString);
					res = String(value);
					break;
				case "posinteger":
				case "integer":
					assertType(value, type, "number", util.isNumber);
					assertThat(value, type, function (o) {return !Number.isNaN(o) && (o) >= MIN_INT && (o) <= MAX_INT;});
					res = String(parseInt(value));
					break;
				case "long":
					assertType(value, type, "bigint", util.isBigInt);
					assertThat(value, type, function (o) {return o >= MIN_LONG && (o) <= MAX_LONG;});
					res = value.toString();
					break;
				case "float":
				case "posfloat":
				case "nonnegfloat":
				case "bigdecimal":
				case "percent":
				case "rate":
				case "currency":
				case "currency2":
				case "poscurrency":
				case "nonnegcurrency":
					assertType(value, type, "number", util.isNumber);
					res = String(value);
					break;
				case "datetime":
				case "datetimetz":
					assertType(value, type, "Temporal.Instant", function (o) { return o instanceof Temporal.Instant; });
					res = value.toString();
					break;
				case "duration":
				case "time":
				case "timetrack":
					assertType(value, type, "Temporal.Duration", function (o) { return o instanceof Temporal.Duration; });
					assertThat(value, type, function (o) {return !(o.years !== 0 || o.months !== 0 || o.weeks !== 0);});
					assertThat(value, type, function(o) {
						const sec = BigInt(o.days) * BigInt(86400) + BigInt(o.hours) * BigInt(3600) + BigInt(o.minutes) * BigInt(60) + BigInt(o.seconds);
						return sec >= MIN_LONG && sec <= MAX_LONG;
					});
					res = value.toString();
					break;
				case "timeofday":
					assertType(value, type, "Temporal.PlainTime", function (o) { return o instanceof Temporal.PlainTime; });
					res = value.toString();
					break;
				case "date":
					assertType(value, type, "Temporal.PlainDate", function (o) { return o instanceof Temporal.PlainDate; });
					res = value.toString();
					break;
				case "mmyydate":
				case "ccexpdate":
				case "ccvalidfrom":
					assertType(value, type, "Temporal.PlainYearMonth", function (o) { return o instanceof Temporal.PlainYearMonth; });
					res = value.toString();
					break;
				case "multiselect":
					assertType(value, type, "array", Array.isArray);
					res = value.map(function (identity) {return String(identity);});
					break;
				case "select":
				case "summary":
					res = String(value);
					break;
				default:
					if (typeof console !== "undefined" && typeof console.warn === "function") {
						console.warn("Unsupported field type: " + type);
					}
					res = value;
			}
			return res;
		}

		function marshalWithOldTypes(type, value) {
			var res;
			if (value === null || value === undefined) {
				if (type === "boolean") {
					return "false";
				}
				return null;
			}
			switch (type) {
				case "boolean":
				case "checkbox":
				case "radio":
					assertType(value, type, "boolean", util.isBoolean);
					res = String(value);
					break;
				case "text":
				case "longtext":
				case "email":
				case "emails":
				case "ccnumber":
				case "address":
				case "textarea":
				case "richtext":
				case "url":
				case "identifier":
				case "identifieranycase":
				case "phone":
				case "password":
					assertType(value, type, "string", util.isString);
					res = String(value);
					break;
				case "posinteger":
				case "integer":
					assertType(value, type, "number", util.isNumber);
					assertThat(value, type, function(o) {return !Number.isNaN(o) && (o) >= MIN_INT && (o) <= MAX_INT;});
					res = String(parseInt(value));
					break;
				case "long":
				case "float":
				case "posfloat":
				case "nonnegfloat":
				case "bigdecimal":
				case "percent":
				case "rate":
				case "currency":
				case "currency2":
				case "poscurrency":
				case "nonnegcurrency":
					assertType(value, type, "number", util.isNumber);
					res = value.toString();
					break;
				case "datetime":
				case "datetimetz":
					assertType(value, type, "Date", util.isDate);
					res = value.toISOString();
					break;
				case "duration":
				case "timetrack":
				case "time":
					assertType(value, type, "number", util.isNumber);
					if (isNaN(value) || utilityFunctions.isValEmpty(value))
						return value;
					var hours = value;
					var isNeg = false;
					if (value < 0)
					{
						isNeg = true;
						hours *= -1
					}

					var days = 0;
					var hrs = Math.floor((hours*60+0.5)/60);
					var mins = Math.floor((hours-hrs)*60+0.5);
					var sign = isNeg ? "-" : "";
					if (hrs > 23) {
						days = Math.floor(hrs / 24);
						hrs %= 24;
						if (mins > 0) {
							res = sign + "P" + days + "DT" + hrs + "H" + mins + "M";
						} else if (hrs > 0 && mins === 0) {
							res = sign + "P" + days + "DT" + hrs + "H";
						} else {
							res = sign + "P" + days + "D";
						}
					} else {
						if (mins > 0) {
							res = sign + "PT" + hrs + "H" + mins + "M";
						} else {
							res = sign + "PT" + hrs + "H";
						}
					}
					res = String(res);
					break;
				case "timeofday":
					assertType(value, type, "Date", util.isDate);
					var hrs = value.getHours();
					var mins = value.getMinutes();
					var secs = value.getSeconds();
					res = String((hrs > 9 ? hrs : "0" + hrs) + ":" + (mins > 9 ? mins : "0" + mins) + ":" + (secs > 9 ? secs : "0" + secs));
					break;
				case "date":
					assertType(value, type, "Date", util.isDate);
					var year = value.getFullYear();
					var month = value.getMonth() + 1;
					var day = value.getDate();
					res = String(year + "-" + (month > 9 ? month : "0" + month) + "-" + (day > 9 ? day : "0" + day));
					break;
				case "mmyydate":
				case "ccexpdate":
				case "ccvalidfrom":
					assertType(value, type, "Date", util.isDate);
					var year = value.getFullYear();
					var month = value.getMonth() + 1;
					res = String(year + "-" + (month > 9 ? month : "0" + month));
					break;
				case "multiselect":
					assertType(value, type, "array", Array.isArray);
					res = value.map(function (identity) {return String(identity);});
					break;
				case "select":
				case "summary":
					res = String(value);
					break;
				default:
					if (typeof console !== "undefined" && typeof console.warn === "function") {
						console.warn("Unsupported field type: " + type);
					}
					res = value;
				}
			return res;
		}


		function unmarshal(type, value, useNewTypes) {
			if (useNewTypes) {
				return unmarshalWithNewTypes(type, value);
			} else {
				return unmarshalWithOldTypes(type, value);
			}
		}

		function unmarshalWithNewTypes(type, value) {
			checkNewTypesDefined();
			var res;
			if (value === null || value === undefined) {
				return null;
			}
			switch (type) {
				case "boolean":
				case "checkbox":
				case "radio":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function(o) {return o === "true" || o === "false";});
					res = value === "true";
					break;
				case "text":
				case "longtext":
				case "email":
				case "emails":
				case "ccnumber":
				case "address":
				case "textarea":
				case "richtext":
				case "url":
				case "identifier":
				case "identifieranycase":
				case "phone":
				case "password":
					assertType(value, type, "string", util.isString);
					res = String(value);
					break;
				case "posinteger":
				case "integer":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function(o) {return !isNaN(o);});
					res = parseInt(value);
					break;
				case "long":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function(o) {return !isNaN(o);});
					res = BigInt(value);
					break;
				case "float":
				case "posfloat":
				case "nonnegfloat":
				case "bigdecimal":
				case "percent":
				case "rate":
				case "currency":
				case "currency2":
				case "poscurrency":
				case "nonnegcurrency":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function (o) { return o === "NaN" || !isNaN(o);});
					res = parseFloat(value);
					break;
				case "datetime":
				case "datetimetz":
					assertType(value, type, "string", util.isString);
					res = Temporal.Instant.from(value);
					break;
				case "duration":
				case "timetrack":
				case "time":
					assertType(value, type, "string", util.isString);
					res = Temporal.Duration.from(value);
					break;
				case "timeofday":
					assertType(value, type, "string", util.isString);
					res = Temporal.PlainTime.from(value);
					break;
				case "date":
					assertType(value, type, "string", util.isString);
					res = Temporal.PlainDate.from(value);
					break;
				case "mmyydate":
				case "ccexpdate":
				case "ccvalidfrom":
					assertType(value, type, "string", util.isString);
					res = Temporal.PlainYearMonth.from(value);
					break;
				case "multiselect":
					assertType(value, type, "array", Array.isArray);
					break;
				case "select":
				case "summary":
					res = value;
					break;
				default:
					if (typeof console !== "undefined" && typeof console.warn === "function") {
						console.warn("Unsupported field type: " + type);
					}
					res = value;
			}
			return res;
		}

		function unmarshalWithOldTypes(type, value) {
			var res;
			if (value === null || value === undefined) {
				return null;
			}
			switch (type) {
				case "boolean":
				case "checkbox":
				case "radio":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function (o) { return o === "true" || o === "false";});
					res = value === "true";
					break;
				case "text":
				case "longtext":
				case "email":
				case "emails":
				case "ccnumber":
				case "address":
				case "textarea":
				case "richtext":
				case "url":
				case "identifier":
				case "identifieranycase":
				case "phone":
				case "password":
					assertType(value, type, "string", util.isString);
					res = String(value);
					break;
				case "posinteger":
				case "integer":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function(o) {return !isNaN(o);});
					res = parseInt(value);
					break;
				case "long":
				case "float":
				case "posfloat":
				case "nonnegfloat":
				case "bigdecimal":
				case "percent":
				case "rate":
				case "currency":
				case "currency2":
				case "poscurrency":
				case "nonnegcurrency":
					assertType(value, type, "string", util.isString);
					assertThat(value, type, function(o) {return o === "NaN" || !isNaN(o);});
					res = parseFloat(value);
					break;
				case "datetime":
				case "datetimetz":
					assertType(value, type, "string", util.isString);
					res = new Date(value);
					break;
				case "duration":
				case "timetrack":
				case "time":
					assertType(value, type, "string", util.isString);
					var strValue = String(value);
					var days = 0;
					var hrs = 0;
					var mins = 0;
					if (strValue.lastIndexOf("D") > -1)
					{
						days = parseInt(strValue.substring(strValue.lastIndexOf("P") + 1, strValue.lastIndexOf("D")));
						if (strValue.lastIndexOf("H") > -1) {
							hrs = parseInt(strValue.substring(strValue.lastIndexOf("T") + 1, strValue.lastIndexOf("H")));
						}
						if (strValue.lastIndexOf("M") > -1) {
							mins = parseInt(strValue.substring(strValue.lastIndexOf("H") + 1, strValue.lastIndexOf("M")));
						}
					}
					else
					{
						days = 0;
						hrs = parseInt(strValue.substring(strValue.lastIndexOf("T") + 1, strValue.lastIndexOf("H")));
						if (strValue.lastIndexOf("M") > -1) {
							mins = parseInt(strValue.substring(strValue.lastIndexOf("H") + 1, strValue.lastIndexOf("M")));
						}
					}
					res = strValue.startsWith("-") ? - (days * 24 + hrs + mins * 60) : (days * 24 + hrs + mins * 60);
					break;
				case "timeofday":
					assertType(value, type, "string", util.isString);
					res = new Date(0);
					var splitTime = value.split(":");
					res.setHours(parseInt(splitTime[0]), parseInt(splitTime[1]), parseInt(splitTime[2]));
					break;
				case "date":
					assertType(value, type, "string", util.isString);
					var splitDate = value.split("-");
					res = new Date(parseInt(splitDate[0]), parseInt(splitDate[1]) - 1, parseInt(splitDate[2]));
					break;
				case "mmyydate":
				case "ccexpdate":
				case "ccvalidfrom":
					assertType(value, type, "string", util.isString);
					res = new Date(0);
					var splitMMYY = value.split("-");
					res.setFullYear(parseInt(splitMMYY[0]), parseInt(splitMMYY[1]) - 1)
					break;
				case "multiselect":
					assertType(value, type, "array", Array.isArray);
					break;
				case "select":
				case "summary":
					res = value;
					break;
				default:
					if (typeof console !== "undefined" && typeof console.warn === "function") {
						console.warn("Unsupported field type: " + type);
					}
					res = value;
			}
			return res;
		}

		function serialize(type, value, useNewTypes){
			var marshalledValue = marshal(type, value, useNewTypes);
			return JSON.stringify(marshalledValue);
		}

		function deserialize(type, serializedValue, useNewTypes){
			var marshalledValue = JSON.parse(serializedValue, useNewTypes);
			return unmarshal(type, marshalledValue);
		}

		function assertType (value, fieldType, expected, validationFn){
			if (!validationFn(value))
				throw ("Invalid value type for a " + fieldType.toUpperCase() + " field, expected: " + expected + ", actual: " + typeof value);
		}

		function assertThat(value, fieldType, validationFn){
			if (!validationFn(value))
				throw "Invalid value for a " + fieldType.toUpperCase() + " field";
		}

		function checkNewTypesDefined() {
			if (typeof Temporal === "undefined" || typeof BigInt === "undefined") {
				utilityFunctions.throwSuiteScriptError(error.Type.NEW_TYPES_NOT_DEFINED);
			}
		}

		return Object.freeze({
			marshal: marshal,
			unmarshal: unmarshal,
			serialize: serialize,
			deserialize: deserialize,
		});
	}
);

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * @module N/record/parameterMarshaler
 * @suiteScriptVersion 2.x
 */

define(
	'N/record/parameterMarshaler',['N/util', 'N/record/recordDataEncoding', 'N/fieldTypeConstants'],
	function (util, recordDataEncoding, fieldTypeConstants){
		var Type = fieldTypeConstants.Type;
		function marshal(o)
		{
			var res, type, useNewTypes;
			if (o == null) { // null or undefined
				return {t: String(o)};
			} else if (util.isArray(o)) {
				type = "array";
				res = o.map(marshal);
			} else if (util.isObject(o)) {  // plain objects only
				type = "object";
				res = {};
				for (var key in o) {
					res[key] = marshal(o[key]);
				}
			} else if (util.isNumber(o)) {
				type = Type.FLOAT;
			} else if (util.isBigInt(o)) {
				type = Type.LONG;
				useNewTypes = true;
			} else if (util.isBoolean(o)) {
				type = "boolean";
			} else if (util.isString(o)) {
				type = Type.TEXT;
			} else if (util.isDate(o)) {
				type = Type.DATE;
			} else if (typeof Temporal !== "undefined" && o instanceof Temporal.Duration) {
				type = Type.TIMETRACK;
				useNewTypes = true;
			} else if (typeof Temporal !== "undefined" && o instanceof Temporal.Instant) {
				type = Type.DATETIME;
				useNewTypes = true;
			} else if (typeof Temporal !== "undefined" && o instanceof Temporal.PlainTime) {
				type = Type.TIMEOFDAY;
				useNewTypes = true;
			} else if (typeof Temporal !== "undefined" && o instanceof Temporal.PlainDate) {
				type = Type.DATE;
				useNewTypes = true;
			} else if (typeof Temporal !== "undefined" && o instanceof Temporal.PlainYearMonth) {
				type = Type.MMYYDATE;
				useNewTypes = true;
			} else {
				throw "Unsupported parameter type";
			}
			if (res === undefined) {
				res = recordDataEncoding.marshal(type, o, useNewTypes);
			}
			return {t: type, v: res};
		}

		function serialize(o)
		{
			return JSON.stringify(marshal(o));
		}

		function unmarshal(marshaled, useNewTypes)
		{
			var type = marshaled.t;
			var value = marshaled.v;
			var res;
			switch (type) {
				case "array":
					res = value.map(function(v) {
						return unmarshal(v, useNewTypes);
					});
					break;
				case "object":
					res = {};
					for (var key in value) {
						res[key] = unmarshal(value[key], useNewTypes);
					}
					break;
				case "null":
					res = null;
					break;
				case "undefined":
					res = undefined;
					break;
				default:
					res = recordDataEncoding.unmarshal(type, value, useNewTypes);
			}
			return res;
		}

		function deserialize(o, useNewTypes)
		{
			return unmarshal(JSON.parse(o), useNewTypes);
		}

		return Object.freeze({
			marshal: marshal,
			unmarshal: unmarshal,
			serialize: serialize,
			deserialize: deserialize,
		});
	}
);

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordUtilityFunctions',['N/internal/invoker', 'N/utilityFunctions', 'N/error', 'N/restricted/remoteApiBridge',
		'N/util/sqlInjectionFilter', 'N/util/formatter', 'N/fieldTypeConstants', 'N/record/parameterMarshaler'],
	function(invoker, utilityFunctions, error, clientScriptHandler,
	         sqlInjectionFilter, formatter, fieldTypeConstants, parameterMarshaler)
	{
	    var undef = undefined;

		var statefulStore = "_statefulstore";

	    var MACHINE_TYPE = {
	            INLINE_EDIT: 'inlineeditor'
        };

	    var EDIT_MACHINE_TYPE = [MACHINE_TYPE.INLINE_EDIT];
	    function isEditMachine(sublist)
	    {
	        return EDIT_MACHINE_TYPE.indexOf(sublist.type) > -1;
	    }

	    function handleOverloadingMethodsForSingleArgument(options, key, errorMessageFillerValue)
	    {
	        var argument = options !== undef && options !== null && !util.isString(options) ? options[key] : options;
	        utilityFunctions.checkArgs([argument], [key], errorMessageFillerValue);

	        return argument;
	    }

	    function emptyIfNullOrUndefined(value)
	    {
	        if(value === null || value === undefined)
	            return "";
	        else
	            return value;
	    }

	    function assertValidSublistOperation(isValid)
	    {
	        if(!isValid)
	            utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
	    }

	    function formatValueToArrayType(value)
	    {
	        if(!value && value !== 0 && value !== '')
	            return value;
	        else
	        {
	            if(typeof value === 'string' && value.indexOf(String.fromCharCode(5)) !== -1)
	                value = value.split(String.fromCharCode(5));

	            // Empty value represents the value is not set, hence return empty array
	            return util.isArray(value) ? value : (!utilityFunctions.isValEmpty(value)) ? [value] : [];
	        }
	    }
	    function formatArrayToStringType(value)
	    {
	        if(util.isArray(value))
	            return value.join(String.fromCharCode(5));
	        else
	            return String(value);
	    }

	    function validateAgainstSqlInjection(fieldId, value)
	    {
		    sqlInjectionFilter.validateSqlInjection(fieldId, value);
	    }

	    /**
	     * utility function to apply function to each property of the object, the function takes 2 argument one is the key and
	     * second one is the value
	     * @param {Object} obj
	     * @param {Function} f function to process each property of the object, first argument will be property key and second
	     *     argument will be the entry
	     */
	    function forEachProperty(obj, f)
	    {
	        for(var pKey in obj)
	        {
	            if(obj.hasOwnProperty(pKey))
	            {
	                f(pKey, obj[pKey]);
	            }
	        }
	    }

	    function executeRecordGetterFunctionsForInstance(sublistId, fieldId, lineInstanceId, isCommitted, bodyFieldFunction, sublistFieldFunction)
	    {
	        var toRet = null;
	        if (!!sublistId)
	        {
	            toRet = sublistFieldFunction(sublistId, fieldId, lineInstanceId, isCommitted);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function executeRecordGetterFunctions(sublistId, fieldId, line, bodyFieldFunction, sublistFieldFunction, currentSublistFieldFunctions)
	    {
	        var toRet = null;
	        if (sublistId)
	        {
	            if (line >= 0)
	                toRet = sublistFieldFunction(sublistId, fieldId, line);
	            else
	                toRet = currentSublistFieldFunctions(sublistId, fieldId);
	        }
	        else
	        {
	            toRet = bodyFieldFunction(fieldId);
	        }
	        return toRet;
	    }

	    function matchRecordFieldValueSchema(obj)
	    {
	        return util.isObject(obj) && obj.hasOwnProperty('value') && obj.hasOwnProperty('legacyStringValue');
	    }

	    function transformRawValueToFieldValueSchema(obj, cacher, fieldMetadata)
	    {
	    	var doNotFormat = fieldMetadata && fieldMetadata.doNotFormat;
	    	var fieldValue;
	    	if (util.isArray(obj))
		    {
		    	obj = obj.map(function (item)
			    {
			    	if (util.isObject(item) && item.hasOwnProperty('id') && item.hasOwnProperty('text'))
				    {
				    	cacher(item.id, utilityFunctions.unescape(item.text));
				    	return item.id;
				    }
				    else
				    {
				    	return doNotFormat ? item : utilityFunctions.unescape(item);
				    }
			    });
		    	fieldValue = {value: undefined, legacyStringValue: obj.join(String.fromCharCode(5))};
		    }
	        else if(/* select schema */ util.isObject(obj) && obj.hasOwnProperty('id') && obj.hasOwnProperty('text'))
	        {
	            fieldValue = {value: undefined, legacyStringValue: obj.id };
	            cacher(obj.id, utilityFunctions.unescape(obj.text));
	        }
	        else
	            fieldValue = {value: undefined, legacyStringValue: doNotFormat ? obj : utilityFunctions.unescape(obj)};
	        return fieldValue;
	    }

	    function validateRecordFieldValueSchema(val)
	    {
	        if (!matchRecordFieldValueSchema(val) && val !== null && val !== undefined)
	        {
	            utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
	        }
	    }

	    function clone(receiver, contributor)
	    {
	        for (var key in contributor)
	            if (contributor.hasOwnProperty(key))
	            {
	                var value = contributor[key];
	                if(util.isDate(contributor[key]))
	                {
	                    value = new Date(value);
	                }
	                else if(util.isArray(value))
	                {
	                    value = value.map(function(v){
	                        return v;
	                    })
	                }

	                receiver[key] = value;
	            }
	        return receiver;
	    }

	    function getZeroBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index > 0 ? index - 1 : index;
	    }

	    function getOneBasedIndex(index)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        return index >= 0 ? index + 1 : index;
	    }

		function validateAndGetZeroBasedIndex(index, method, indexUpperLimit)
		{
			if (isNaN(index) || index == null)
				return index;
			else
				index = parseInt(index, 10);

			if (index < 1 || (indexUpperLimit != null && index > indexUpperLimit))
			{
				throw error.create({name: error.Type.INVALID_SUBLIST_OPERATION, message: method});
			}
			else
			{
				return index - 1;
			}
		}

	    function validateAndGetOneBasedIndex(index, method, indexUpperLimit)
	    {
	        if (isNaN(index))
	            return index;
	        else
	            index = parseInt(index, 10);

	        if (index < 0 || (indexUpperLimit !== undefined && index >= indexUpperLimit))
	        {
	            throw error.create({name: error.Type.INVALID_SUBLIST_OPERATION, message: method});
	        }
	        else
	        {
	            return index + 1;
	        }
	    }

	    function getClientSlavingResultFromMetadata(clientSlavingMetadata, masterValue, getClientSlavingMetadata)
	    {
	        //TODO refactor into client slaving metadata
	        var slaveResults = {fields: []};

	        for(var slaveFieldId in clientSlavingMetadata)
	        {
	            var clientSlavingResult = clientSlavingMetadata[slaveFieldId];
	            var result = { isClientSlaving: true };
	            result.name = clientSlavingResult.name;
	            if(clientSlavingResult.machine)
	                result.machine = clientSlavingResult.machine;
	            if(clientSlavingResult.firechange || getClientSlavingMetadata(result.machine, result.name) !== null)
	                result.firechange = true;
	            if(clientSlavingResult.condition)
	                result.condition = clientSlavingResult.condition;
	            if(clientSlavingResult.nooverride)
	                result.nooverride = clientSlavingResult.nooverride;

	            if(clientSlavingResult.values)
	                result.value = clientSlavingResult.values["_"+masterValue] || "";

	            if(clientSlavingResult.options && util.isArray(clientSlavingResult.options))
	            {
	                result.options = [];
	                var selectOptions = clientSlavingResult.options;

	                for(var i = 0; i < selectOptions.length; i++)
	                {
	                    if(!!selectOptions[i].isSelected)
	                        result.value = selectOptions[i].value;
	                    result.options.push([selectOptions[i].value, selectOptions[i].text]);
	                }
	            }

	            slaveResults.fields.push(result);
	        }

	        return slaveResults;
	    }

		function parseValue(isValidField, fieldLevelMetadata, value, skipPercentage, ignoreUserPrefs)
		{
			var parsedValue;

			if (fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.CHECKBOX && value === '')
			{
				parsedValue = false;
			}
			else if (!isValidField || (!value && value !== false && value !== 0 && value !== ''))
			{
				parsedValue = value;
			}
			else if (fieldLevelMetadata && fieldLevelMetadata.isTypeMultiSelect)
			{
				parsedValue = formatValueToArrayType(value).map(function (val) { return String(val); });
			}
			else if (fieldLevelMetadata && fieldLevelMetadata.isTypeSelect)
			{
				parsedValue = String(value);
			}
			else if (fieldLevelMetadata)
			{
				parsedValue = formatter.parse(value, fieldLevelMetadata.type, fieldLevelMetadata.isNumeric,
					fieldLevelMetadata.isCurrency, fieldLevelMetadata.fieldTypeForValidation,
					undefined, skipPercentage, ignoreUserPrefs);
			}

			return parsedValue;
		}

		var no_op_function = utilityFunctions.thenableFunction(function () {});

		/**
		 * @param {Object} source field container
		 * @param {String} fieldId
		 * @param {boolean} isNSE
		 * @returns {string|Number|Boolean|Date|Array|null}
		 */
	    function getFieldValue(source, fieldId, isNSE)
	    {
		    var fieldValue = isNSE ? null : "";

		    if (util.isObject(source[fieldId]))
		    {
			    if (!!source[fieldId].value || source[fieldId].value === "" || source[fieldId].value === 0 || source[fieldId].value === false)
			    {
				    fieldValue = source[fieldId].value;
			    }
			    else
			    {
				    if (isNSE)
					    fieldValue = source[fieldId].legacyStringValue === undefined ? null : source[fieldId].legacyStringValue
				    else
					    fieldValue = emptyIfNullOrUndefined(source[fieldId].legacyStringValue);
			    }
		    }

		    return fieldValue;
	    }

		function formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, fieldType) {
			var fieldType = fieldType || null;
			var formattedValue = null;

			if (!value && value !== "" && value !== 0 && !util.isBoolean(value)) {
				formattedValue = "";
			}
			else if (fieldType === fieldTypeConstants.Type.MULTISELECT && util.isArray(value)) {
				formattedValue = value.join(String.fromCharCode(5));
			}
			else if (fieldType === fieldTypeConstants.Type.MULTISELECT || fieldType === null) {
				formattedValue = String(value);
			}
			return formattedValue;
		}

		function needsToBeFormattedForLegacySave(fieldType, value)
		{
			return util.isDate(value) || util.isBoolean(value) ||
				fieldType === fieldTypeConstants.Type.TIME || fieldType === fieldTypeConstants.Type.TIMETRACK;
		}

		function formatValueForLegacySyntheticRequest(fieldType, value) {
			var formattedValue = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, fieldType);
			if (formattedValue === null || formattedValue === undefined) {
				if (needsToBeFormattedForLegacySave(fieldType, value)) {
					formattedValue = formatter.format(value, fieldType);
					return formattedValue ? String(formattedValue) : formattedValue;
				}
				else {
					return String(value);
				}
			}
			return formattedValue;
		}

		/**
		 * X type of a parameted as listted in [object X]
		 * @param o
		 * @return {string}
		 */
		function getType(o){ return Object.prototype.toString.call(o).slice(8,-1)};

		/**
		 * @typedef {function(*, *): -1|0|1|NaN} comparator
		 * @typedef {function(*, *, comparator|comparatorWithNesting): -1|0|1|NaN} comparatorWithNesting
		 */

		/**
		 *
		 * @type {comparator}
		 */
		var recordFieldComparator = getComparator(arraySetCompare);
		/**
		 *
		 * @type {comparator}
		 */
		var genericValueComparator = getComparator(arrayCompare);

		/**
		 * equality check used on record field values - arrays are treated as sets
		 * @param {*} a
		 * @param {*} b
		 * @return {boolean}
		 */
		function recordEquals(a, b) {
			return recordCompare(a, b) === 0;
		}

		/**
		 * equality check used on any values - arrays are treated as arrays
		 * @param {*} a
		 * @param {*} b
		 * @return {boolean}
		 */
		function genericEquals(a, b) {
			return genericCompare(a, b) === 0;
		}

		/**
		 * compares record field values - arrays are treated as sets
		 * @param {*} a
		 * @param {*} b
		 * @return {-1|0|1|NaN}
		 */
		function recordCompare(a, b) {
			return recordFieldComparator(a, b);
		}

		/**
		 * compares values generically - arrays are treated as arrays, plain objects are compared as primitives
		 * @param {*} a
		 * @param {*} b
		 * @return {-1|0|1|NaN}
		 */
		function genericCompare(a, b) {
			return genericValueComparator(a, b);
		}

		/**
		 * configures comparator
		 * @param {comparatorWithNesting} arrayComparator
		 * @return {comparator}
		 */
		function getComparator(arrayComparator) {
			/**
			 * compares values based on configuration
			 * @param {*} a
			 * @param {*} b
			 * @return {-1|0|1|NaN}
			 */
			return function (a, b) {
				// identical operands are equal
				if (a === b) {
					return 0;
				}
				// null and undefined are equal
				if (a == null && b == null) {
					return 0;
				}
				// sort nulls before non-nulls
				if (a == null) {
					return -1;
				}
				if (b == null) {
					return 1;
				}
				// both operands must be of the same type, otherwise they are not equal
				if (typeof a !== typeof b) {
					return NaN;
				}
				// try to compare using LHS compare function first
				try {
					return getObjectComparator(a, arrayComparator)(a, b);
				}
				catch (e){
					// continue
				}
				// try to compare using RHS compare function second
				try {
					return -getObjectComparator(b, arrayComparator)(b, a);
				}
				catch (e){
					// continue
				}
				// give up
				return NaN;
			}
		}

		/**
		 * compares complex values based on configuration
		 * @param {Object} arg
		 * @param {comparatorWithNesting} arrayComparator
		 * @return {comparator}
		 */
		function getObjectComparator(arg, arrayComparator) {
			if (arg.constructor && util.isFunction(arg.constructor.compare)) {
				// if the operand has a "compare" static method, use it
				return arg.constructor.compare;
			}
			else if (util.isFunction(arg.equals)) {
				// if the operand has an "equals" method, use it
				return objectCompare;
			}
			else {
				var argType = getType(arg);
				if (argType === "Array") {
					// if the operand is an array, compare using array comparison
					return function (a, b){ return arrayComparator(a, b, getComparator(arrayComparator))};
				}
				else if (argType === "Object") {
					if (util.isObject(arg)) {
						return function (a, b){
							if (!util.isObject(b)) {
								return (a === b ? 0 : NaN)
							}
							return plainObjectCompare(a, b, getComparator(arrayComparator))
						};
					}
					// for any other objects that are not plain, do the reference comparison
					return function (a, b){ return (a === b ? 0 : NaN) };
				}
				else {
					// otherwise convert to primitive value and
					return primitiveValueCompare;
				}
			}
		}

		/**
		 * compares objects that implement equals, isLessThan, or isGreaterThan
		 * @param {Object} a
		 * @param {*} b
		 * @return {-1|0|1|NaN}
		 */
		function objectCompare(a, b) {
			if (a.equals(b)) {
				return 0;
			}
			else if (util.isFunction(a.isLessThan) && a.isLessThan(b)) {
				return -1;
			}
			else if (util.isFunction(a.isGreaterThan) && a.isGreaterThan(b)) {
				return 1;
			}
			else {
				return NaN;
			}
		}

		/**
		 * compares arrays as sets, i.e. arrays of different lenght with duplicite values or
		 * arrays with identical values on different indexes are considered to be equal
		 * this satisfies the multiselect value contract where the array is considered to be a set
		 * TODO: consider changing the internal implementation of multiselect field to be a Set to avoid this kind of comparison
		 * @param {*[]} a
		 * @param {*[]} b
		 * @param {comparator} comparator - array's values comparator
		 * @return {0|NaN}
		 */
		function arraySetCompare(a, b, comparator) {
			if (!util.isArray(b)) {
				throw new TypeError("other operand must be an array");
			}
			var bFound = new Array(b.length);
			// check that for every element in a there is an equal element in b
			for (var i = 0; i < a.length; i++) {
				var found = false;
				for (var j = 0; j < b.length; j++) {
					if (comparator(a[i], b[j]) === 0) {
						bFound[j] = true;
						found = true;
						break;
					}
				}
				if (!found) {
					return NaN;
				}
			}
			// check that for every element in b there is an equal element in a
			for (var j = 0; j < b.length; j++) {
				if (bFound[j]) {
					continue;
				}
				var found = false;
				for (var i = 0; i < a.length; i++) {
					if (comparator(a[i], b[j]) === 0) {
						found = true;
						break;
					}
				}
				if (!found) {
					return NaN;
				}
			}
			return 0;
		}

		/**
		 * compares arrays based on their sizes and indexed values
		 * @param {*[]} a
		 * @param {*[]} b
		 * @param {comparator} comparator - array's values comparator
		 * @return {0|NaN}
		 */
		function arrayCompare(a, b, comparator) {
			if (!util.isArray(b)) {
				throw new TypeError("other operand must be an array");
			}
			if (a.length === b.length) {
				for (var i = 0; i < a.length; i++) {
					if (comparator(a[i], b[i]) !== 0) {
						return NaN;
					}
				}
				return 0;
			}
			return NaN;
		}

		/**
		 * compares plain objects by their keys and values
		 * @param {{}} a
		 * @param {{}} b
		 * @param {comparator} comparator - object's keys comparator
		 * @return {0|NaN}
		 */
		function plainObjectCompare(a, b, comparator) {
			// for plain object getKeys and getOwnPropertyNames should give the same results
			var aKeys = Object.getOwnPropertyNames(a);
			var bKeys =  Object.getOwnPropertyNames(b);
			if (aKeys.length === bKeys.length) {
				for (var i = 0; i < aKeys.length; i++) {
					var key = aKeys[i];
					if (comparator(a[key], b[key]) !== 0) {
						return NaN;
					}
				}
				return 0;
			}
			return NaN;
		}

		/**
		 * compares values as primitives
		 * @param {*} a
		 * @param {*} b
		 * @return {-1|0|1|NaN}
		 */
		function primitiveValueCompare(a, b) {
			var lte = a <= b;
			var gte = a >= b;
			// can't use ==, because it doesn't convert the operands to primitive values when both are objects
			if (lte && gte) {
				// this condition is true when a and b are null, same Date, [], {}, other non-simple objects
				// but those were mostly filtered out by previous conditions
				return 0;
			}
			else if (lte && !gte) {
				return -1;
			}
			else if (gte) {
				return 1;
			}
			else {
				return NaN;
			}
		}

		/**
		 * @typedef {{proxy(handler: string): StatefulStore}} RawStatefulStore
		 */

		/**
		 * @param statefulStores
		 * @param {Object} proxyOptions
		 * @returns {RawStatefulStore}
		 */
		function getStatefulStoreProxyProvider(statefulStores, proxyOptions)
		{
			return new (function RawStatefulStore(statefulStores, proxyOptions)
			{
				this.proxy = function(handler) {
					statefulStores[handler] = statefulStores[handler] || {};
					const proxy = {};
					if (proxyOptions.isReadOnly) {
						proxy.set = function () { throw new Error("Storage is read-only in validation hooks!"); }
					}
					else if (proxyOptions.invoker) {
						proxy.set = function set(key, value) {
							if (value === undefined)
								proxyOptions.invoker('removeStoreValue', [handler, key]);
							else
								proxyOptions.invoker('setStoreValue', [handler, key, parameterMarshaler.serialize(value)]);
						}
					}
					else {
						proxy.set = function set(key, value) {
							if (value === undefined)
								delete statefulStores[handler][key];
							else
								statefulStores[handler][key] = parameterMarshaler.marshal(value);
						}
					}

					if (proxyOptions.invoker) {
						proxy.get = function get(key) {
							const val = proxyOptions.invoker('getStoreValue', [handler, key]);
							return val ? parameterMarshaler.deserialize(val, false) : val;
						}
					}
					else {
						proxy.get = function get(key) {
							const val = statefulStores[handler][key];
							return val ? parameterMarshaler.unmarshal(val, false) : val;
						}
					}
					return proxy;
				}
			})(statefulStores, proxyOptions);
		}

	    return {
		    formatValueForLegacySyntheticRequest: formatValueForLegacySyntheticRequest,
	        clone: clone,
	        no_op_function: no_op_function,
	        isEditMachine: isEditMachine,
	        executeRecordGetterFunctions: executeRecordGetterFunctions,
	        executeRecordGetterFunctionsForInstance: executeRecordGetterFunctionsForInstance,
	        forEachProperty: forEachProperty,
	        handleOverloadingMethodsForSingleArgument: handleOverloadingMethodsForSingleArgument,
	        emptyIfNullOrUndefined: emptyIfNullOrUndefined,
	        assertValidSublistOperation: assertValidSublistOperation,
	        formatValueToArrayType: formatValueToArrayType,
	        formatArrayToStringType: formatArrayToStringType,
	        validateAgainstSqlInjection: validateAgainstSqlInjection,
	        validateRecordFieldValueSchema: validateRecordFieldValueSchema,
	        matchRecordFieldValueSchema: matchRecordFieldValueSchema,
	        getZeroBasedIndex: getZeroBasedIndex,
	        getOneBasedIndex: getOneBasedIndex,
		    validateAndGetZeroBasedIndex: validateAndGetZeroBasedIndex,
	        validateAndGetOneBasedIndex: validateAndGetOneBasedIndex,
	        getClientSlavingResultFromMetadata: getClientSlavingResultFromMetadata,
	        transformRawValueToFieldValueSchema: transformRawValueToFieldValueSchema,
		    parseValue: parseValue,
		    getFieldValue: getFieldValue,
		    genericEquals: genericEquals,
		    genericCompare: genericCompare,
		    recordEquals: recordEquals,
		    recordCompare: recordCompare,
		    arraySetCompare: arraySetCompare,
		    STATEFUL_STORE: statefulStore,
		    getStatefulStoreProxyProvider: getStatefulStoreProxyProvider
	    };
	});
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript module
 *
 * @private
 * @module N/util/callRecordScript
 * @suiteScriptVersion 2.x
 */
define('N/util/callRecordScript',['N/util/recordScripting', 'N/utilityFunctions', 'N/contextSwitch', 'N/record/recordUtilityFunctions', 'N/resultObject'],
	function (recordScriptingModule, utilityFunctions, contextSwitch, recordUtil, resultObject)
	{
		var CoreScriptTag = "_C0R3$CR1PT_";

		/**
		 * @param {Object} options
		 * @param {Array} options.handlerModules
		 * @param {Object} [options.context]
		 * @param {Object} [options.scope]
		 * @param {boolean} [options.isNSE]
		 * @param {boolean} [options.isAyncConstructed]
		 * @param {Object} [options.scriptingContext]
		 * @param {function} [options.statefulStoreProvider]
		 */
		var create = utilityFunctions.thenableFunction(function create(options, isAsync) {
			var opts = options || {};
			var isNSE = opts.isNSE;
			utilityFunctions.checkArgs([opts.handlerModules], ["options.handlerModules"], "callRecordScript.create");

			var scriptingHandler;

			function mergeInternalScriptResults(options, results) {
				var mergedResult = { valid: true, fields: [], messages: [], results: [] };
				for(var i = 0; i < results.length; i++) {
					var currResult = results[i].result;
					if (utilityFunctions.isObject(currResult) && currResult.hasOwnProperty('valid')) {
						mergedResult.results.push(results[i]);
						mergedResult.valid = mergedResult.valid && !!currResult.valid;
						Array.prototype.push.apply(mergedResult.fields, currResult.fields);
						Array.prototype.push.apply(mergedResult.messages, currResult.messages);
					} else {
						mergedResult.results.push(results[i]);
						mergedResult.valid = mergedResult.valid && !!currResult;
					}
				}
				if (!mergedResult.messages.length)
					delete(mergedResult.messages);
				if (!mergedResult.fields.length)
					delete(mergedResult.fields);
				return mergedResult;
			}

			function organizeRecordScriptingArgs(rawCurrentRecord, rawCurrentLine, isInteractive, args) {

				var organizedArgs = {};
				organizedArgs.eventName = args.eventName;
				organizedArgs.fieldId = args.fieldId;
				organizedArgs.sublistId = args.sublistId;
				organizedArgs.originalArgs = args.arguments;
				organizedArgs.messages = rawCurrentRecord.getRecordMessage();

				var proxyOptions = { isInteractive: isInteractive, scriptId: CoreScriptTag };
				organizedArgs.currentRecord = rawCurrentRecord.proxy(proxyOptions);
				if (rawCurrentLine) {
					organizedArgs.currentLine = rawCurrentLine.proxy(proxyOptions);
				}

				if (args.arguments &&
					args.arguments.length > 0 &&
					args.sublistId &&
					["onChange", "validate", "postDeleteLine", "lineCommit"].indexOf(args.eventName) > -1) {
					organizedArgs.line =  recordUtil.getZeroBasedIndex(args.arguments[0]); // original arguments are 1-based
				}

				if (args.sublistId && args.line != null)
					organizedArgs.line = args.line;
				if (args.sublistId && args.lineInstanceId != null)
					organizedArgs.lineInstanceId = args.lineInstanceId;

				if ("validate" === args.eventName) {
					if (args.valueObject && 'newValue' in args.valueObject)
						organizedArgs.newValue = args.valueObject.newValue;
					if (args.valueObject && 'currentValue' in args.valueObject)
						organizedArgs.currentValue = args.valueObject.currentValue;

					// TODO: re-proxy the record and line as read only for NSE
				}

				return organizedArgs;
			}

			/**
			 * Call 2.0 record owner event handlers and merge with legacy result.
			 *
			 * @param {Object} options
			 * @param {string} options.eventName
			 * @param {string} [options.fieldId]
			 * @param {string|Array<string>} [options.sublistId] - sublist id or a list of all sublist ids on the record in case of
			 *     saveRecord event
			 * @param {string} [options.lineInstanceId] -id of a line object
			 * @param {{currentValue: (Object|null), newValue: (Object|null)}=} [options.valueObject] - value object for validation
			 *     events
			 * @param {Array} [options.arguments] - the arguments from the initial caller of callRecordScript
			 *                                      -   options.arguments[0] - linenum, options.arguments[1] - origLineData
			 *                                      -   when options.eventName === lineCommit: the initial caller is
			 *     postprocessline and the arguments are (linenum, origLineData)
			 *                                      -   when options.eventName === postDeleteLine: the initial caller is
			 *     postdeleteline and the arguments are (linenum + 1, origLineData)
			 * @param {boolean} [options.legacyScript] - the result of legacy event handlers, it is false if the legacy validation
			 *     exists and failed
			 * @return {Object} extended validation object including all partial results
			 */
			var callRecordScript = utilityFunctions.thenableFunction(function callRecordScript(options) {
				var rawCurrentRecord = this;
				var isInteractive = rawCurrentRecord.isNSE && rawCurrentRecord.isInteractive;
				var results = [];
				if (options && options.hasOwnProperty('legacyScript')) {
					results.push({handler: 'legacyHandler', result: options.legacyScript});
				}
				return resultObject.create(function () {
					if (scriptingHandler && options.eventName) {
						// organize arguments based on event type
						var args = options;
						var argsArray = [];
						if (args.eventName !== "save") {
							if (scriptingHandler.hasStaticEvent(args)) {
								argsArray.push(args);
							}
						} else {
							var sublists = args.sublistId || [];
							// The executing sequence of 2.0 save event handler: save on record -> save on sublist
							sublists = [null].concat(sublists);
							for (var i = 0; i < sublists.length; i++) {
								args.sublistId =  sublists[i];
								if (scriptingHandler.hasStaticEvent(args)) {
									argsArray.push(util.extend({}, args));
								}
							}
						}
						if (argsArray.length > 0) {
							return contextSwitch.execute({scriptInfo: {}}, function () {
								return utilityFunctions.forEachThenable(argsArray, function (args) {
									return resultObject.create(function () {
										if (isInteractive && args.sublistId && args.lineInstanceId) {
											return rawCurrentRecord.getLine.thenable({
												sublistId: args.sublistId,
												lineInstanceId: args.lineInstanceId
											});
										}
									})['catch'](function () {
										return null;
									}).then(function (rawCurrentLine) {
										return scriptingHandler.runStaticEvent.thenable(organizeRecordScriptingArgs(rawCurrentRecord, rawCurrentLine, isInteractive, args));
									}).then(function (returnResult) {
										Array.prototype.push.apply(results, returnResult);
									});
								});
							});
						}
					}
				}).then(function ()
				{
					return mergeInternalScriptResults(options, results);
				});
			});

			callRecordScript.thenable.thenable = callRecordScript.thenable;

			return recordScriptingModule.create.thenable(opts, isAsync).then(function (recordScripting)
			{
				scriptingHandler = recordScripting;
				return isNSE ? callRecordScript.thenable : callRecordScript;
			});
		}, {isAsyncArgIndex: 1});

		return {
			create: create,

			CORE_SCRIPT_TAG: CoreScriptTag
		}
	});

/**
 * SuiteScript record definition base module
 *
 * @private
 * @module N/record/recordDefinitionBase
 * @NApiVersion 2.x
 */
define('N/record/recordDefinitionBase',[
	'N/action',
	'N/macro',
	'N/msgRouter',
	'N/utilityFunctions',
	'N/record/proxy',
	'N/record/proxy/dynamicRecord',
	'N/record/proxy/dynamicSubrecord',
	'N/record/proxy/deferredDynamicRecord',
	'N/record/proxy/deferredDynamicSubrecord',
	'N/record/proxy/readOnlyRecord',
	'N/record/proxy/readOnlySubrecord',
	'N/util/callRecordScript',
	'N/internal/invoker',
	'N/restricted/scriptDeploymentContext'
], function (
	action,
	macro,
	msgRouter,
	utilityFunctions,
	proxy,
	DynamicRecord,
	DynamicSubrecord,
	DeferredDynamicRecord,
	DeferredDynamicSubrecord,
	ReadOnlyRecord,
	ReadOnlySubrecord,
	callRecordScript,
	invoker,
	scriptDeploymentContext
) {
	function noMethodWrapper(method) {
		return method;
	}

	/**
	 * Primary object used to encapsulate a record object.
	 *
	 * @alias RawRecord
	 *
	 * @return {RawRecord}
	 */
	function RecordBase(options) {
		var that = this;
		var recordOptions = options.recordOptions;
		var methodWrapper = options.methodWrapper || noMethodWrapper;

		/**
		 * The recordType of the record
		 * @name RawRecord#type
		 * @type {string}
		 * @readonly
		 *
		 * @since 2015.2
		 */

		/**
		 */
		this.isSubrecord = !!recordOptions.isSubrecord;

		this.isNSE = false;

		/**
		 * The record id
		 * @name RawRecord#id
		 * @type {?number}
		 * @readonly
		 *
		 * @since 2015.2
		 */

		/**
		 * retun tru if the record is newly created
		 * @type {boolean}
		 * @readonly
		 */

		/**
		 * True if the record is dynamicRecord
		 * @name RawRecord#isDynamic
		 * @type {boolean}
		 * @readonly
		 *
		 * @since 2015.2
		 */

		/**
		 * return true if the record is read-only
		 * @type {boolean}
		 * @readonly
		 */

		/**
		 */
		this.isCurrentRecord = !!recordOptions.isCurrentRecord;

		this.isInteractive = false;

		this.isAsync = false;

		Object.defineProperty(this, 'scriptId', {
			get: function get() {
				return invoker(scriptDeploymentContext, 'getScriptId');
			},
			configurable: true,
			enumerable: true
		});

		Object.defineProperty(this, 'bundleId', {
			get: function get() {
				return (invoker(scriptDeploymentContext, 'getBundleIds') || []).join(',') || undefined;
			},
			configurable: true,
			enumerable: true
		});

		var messageService;
		this.getMessageService = function getMessageService() {
			if (!messageService) {
				messageService = msgRouter.getMessageServiceInstance();
			}
			return messageService;
		};

		/**
		 * contains necessary macro information, performs macro operation (specified by getMacro)
		 * and returns result; the Macro.promise returns a Promise
		 * @name Macro
		 * @function
		 * @param {Object} [params]
		 * @returns {Object} [macro result]
		 */

		/**
		 * provides available macros
		 * @return {Object} a set of macros (@see Macro) defined on the record indexed by macroId
		 */
		this.getMacros = methodWrapper(utilityFunctions.wraps(macro.getMacros, macro.getMacros.bind(this)));

		/**
		 *
		 * provides a macro to execute
		 * @param {Object} options
		 * @param {String} options.id macro id
		 * @param {String} [options.package] macro package
		 * @return {?Macro} [executor function for macro specified by options, or null if not found]
		 */
		this.getMacro = methodWrapper(utilityFunctions.wraps(macro.getMacro, macro.getMacro.bind(this)));

		/**
		 * performs macro operation and returns result
		 * executeMacro.promise returns a Promise
		 * @param {Object} options
		 * @param {String} options.id macro id
		 * @param {String} [options.package] macro package
		 * @param {Object} [options.params] macro arguments
		 * @return {Object} [macro result]
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
		 */
		this.executeMacro = methodWrapper(utilityFunctions.wraps(macro.executeMacro, macro.executeMacro.bind(this)));

		this.executeMacro.promise = methodWrapper(utilityFunctions.wraps(macro.executeMacro.promise, macro.executeMacro.promise.bind(this)));

		/**
		 * Executes record action and returns its result. Record ID and type is automatically taken from this record instance.
		 * @param {Object} options
		 * @param {String} options.id action ID
		 * @param {Object} [options.params] action arguments
		 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the
		 *     response property
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
		 */
		this.executeAction = methodWrapper(utilityFunctions.wraps(action.execute, action.execute.bind(this)));

		this.executeAction.promise = methodWrapper(utilityFunctions.wraps(action.execute.promise, action.execute.promise.bind(this)));

		/**
		 * Provides available record actions for this record instance.
		 * @returns {Object} a set of actions (@see Action) defined on the record indexed by action ID
		 */
		this.getActions = methodWrapper(utilityFunctions.wraps(action.find, action.find.bind(this)));
		this.getActions.promise = methodWrapper(utilityFunctions.wraps(action.find.promise, action.find.promise.bind(this)));

		/**
		 * Object corresponding to a record action. It contains the necessary action information
		 * and can be executed (both synchronously and asynchronously using Action.promise).
		 * @name Action
		 * @function
		 * @param {Object} params
		 * @returns {Object} action result; the actual return value returned by the action implementation is stored in the
		 *     response property
		 */

		/**
		 * Returns an executable record action for this record instance.
		 * @param {Object} options
		 * @param {String} options.id action ID
		 * @returns {?Action} record action executor for action specified by options
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.id is missing or undefined
		 */
		this.getAction = methodWrapper(utilityFunctions.wraps(action.get, action.get.bind(this)));

		this.getAction.promise = methodWrapper(utilityFunctions.wraps(action.get.promise, action.get.promise.bind(this)));

		/* --- Proxy cache mechanism setup --- */

		this.proxy = proxy.initialize(this, this, function (proxy, proxyOptions) {
			var proxyOverride = {};

			proxyOverride.isInteractive = proxyOptions.isInteractive;
			proxyOverride.isAsync = proxyOptions.isAsync;
			proxyOverride.isCoreScript = proxyOptions.scriptId === callRecordScript.CORE_SCRIPT_TAG;

			if (that.isSubrecord) {
				proxyOverride.type = null;
				proxyOverride.id = null;
			}

			if (that.isReadOnly || proxyOptions.isReadOnly) {
				var constructor = that.isSubrecord ? ReadOnlySubrecord : ReadOnlyRecord;
				proxyOverride.isDynamic = false;
				proxyOverride.isReadOnly = true;
			} else if (that.isDynamic) {
				constructor = that.isSubrecord ? DynamicSubrecord : DynamicRecord;
			} else {
				constructor = that.isSubrecord ? DeferredDynamicSubrecord : DeferredDynamicRecord;
			}

			for (var key in proxy) {
				if (Object.prototype.hasOwnProperty.call(proxy, key) && !Object.prototype.hasOwnProperty.call(proxyOverride, key)) {
					Object.defineProperty(proxyOverride, key, Object.getOwnPropertyDescriptor(proxy, key));
				}
			}

			return new constructor(proxyOverride);
		});

		/* --- End of proxy cache mechanism --- */
	}

	return RecordBase;
});

/**
 * SuiteScript module
 *
 * This is the localization context implementation for both legacy DOM current record and dynamic record
 *
 * @private
 * @module N/localeContext
 * @NApiVersion 2.x
 */
define('N/localeContext',['N/localization'], function(localizationService) {

	function LocaleContextHandler(options) {
		if (!options || !options.hasOwnProperty('recordType'))
			throw "Invalid argument options: " + options;
		var recordType = options.recordType;
		var localeObject = (util.isString(options.defaultLocale) ? JSON.parse(options.defaultLocale) : options.defaultLocale) || {};
		var activeLocale = null;
		var targetLocale = null;
		var loadScriptsForLocale;
		var localizationContextEnter;
		var localizationContextExit;
		var initialized = false;
		var fields = localeObject.fields || [];  //body fields
		var sublists = localeObject.sublists || [];  //sublists
		var pendingChangeCalls = [];

		// initialize target locale to default
		setTargetLocale(localeObject.country || null);

		/**
		 * Function to initialize the callbacks needed to perform the context change.
		 * Each of the callback is expected to return a promise
		 *
		 * @public
		 * @param {Object} options
		 * @param {Function} options.localizationContextEnter
		 * @param {Function} options.localizationContextExit
		 * @param {Function} options.loadScriptsForLocale
		 */
		function setupCallbacks(options) {
			if (!options
				|| !util.isFunction(options.localizationContextEnter)
				|| !util.isFunction(options.localizationContextExit)
				|| !util.isFunction(options.loadScriptsForLocale))
			{
				throw "Invalid argument options: " + options;
			}
			if (!initialized) {
				loadScriptsForLocale = options.loadScriptsForLocale;
				localizationContextEnter = options.localizationContextEnter;
				localizationContextExit = options.localizationContextExit;
				initialized = true;
			}
		}

		function getActiveLocale() { return activeLocale || null; }

		function clearActiveLocale() { activeLocale = null; }

		function getTargetLocale() { return targetLocale || null; }

		function setTargetLocale(locale) {
			if (locale != null && !(util.isString(locale) || util.isArray(locale)))
				throw "Invalid argument locale: " + locale;
			if (util.isString(locale))
				targetLocale = locale.split(',');
			else if (util.isArray(locale))
				targetLocale = locale.length > 0 ? locale : null;
			else
				targetLocale = locale;
			if (!targetLocale || !targetLocale.length)
				targetLocale = null;
		}

		function syncActiveLocale() { activeLocale = targetLocale; }

		function getLocaleFields() { return fields.slice(); }

		function shouldCheckForLocaleChange(sublistId, fieldId) {
			return !sublistId && fields.indexOf(fieldId) > -1;
		}

		function localizedScriptLimit() {
			return localeObject.limit || null;
		}

		function getSignificantFieldValueMap(getter)
		{
			// so far we expect only body fields to drive context
			return (fields || []).reduce(function(result, fieldId) {
				result[fieldId] = getter(fieldId); return result;
			}, {});
		}

		function valuesFromSublistGetter(sublistId, lineCountGetter, lineValueGetter)
		{
			var sublistField = sublistId.split('.');
			var sublist = sublistField[0];
			var field = sublistField[1];
			var values = [];
			var lineCount = lineCountGetter({sublistId: sublist});
			for (var line = 0; line < lineCount; line++) {
				values.push(lineValueGetter({sublistId: sublist, fieldId: field, line: line}));
			}
			return values;
		};

		/**
		 * Function to check whether the locale should be changed or not.
		 * Once the new locale is decided the localization context change is triggered.
		 * Currently only body fields can trigger context change.
		 *
		 * @public
		 * @param {Object} options
		 * @param {String} options.fieldId
		 * @param {String} [options.sublistId]
		 * @param {Function} options.valueGetter
		 * @param {Function} options.lineCountGetter
		 * @param {Function} options.lineValueGetter
		 */
		function checkLocaleAndTriggerContextChange(options)
		{
			if (!options || !options.fieldId || !util.isFunction(options.valueGetter))
				throw "Invalid arguments options: " + options;

			if (!shouldCheckForLocaleChange(options.sublistId, options.fieldId)) {
				return;
			}

			function onSuccess(result) {
				pendingChangeCalls.pop();
				if (pendingChangeCalls.length === 0 && result !== getTargetLocale()) {
					setTargetLocale(result);
					_localizationContextChange();
				}
			}
			function onError(error) {
				pendingChangeCalls = [];
				throw error;
			}

			var fieldValues = getSignificantFieldValueMap(options.valueGetter);
			var fieldValuesFromSublist = {};
			for (var i = 0; i < sublists.length; i++) {
				// Only submachine.subsidiary sublist on custromer or vendor or lead or prospect record type can be checked for changes.
				// The reason is potencial performence issue on bigger sublists
				if ((recordType == 'customer' || recordType == 'vendor' || recordType == 'lead' || recordType == 'prospect') && sublists[i] == 'submachine.subsidiary') {
					fieldValuesFromSublist[sublists[i]] = valuesFromSublistGetter(sublists[i], options.lineCountGetter, options.lineValueGetter);
				}
			}
			pendingChangeCalls.push(Object.assign(fieldValues, fieldValuesFromSublist));
			localizationService.getContext.promise(recordType, Object.assign(fieldValues, fieldValuesFromSublist)).then(onSuccess, onError);
		}

		function _localizationContextChange() {
			var targetLocale = getTargetLocale();
			if (getActiveLocale() === targetLocale || !localizationContextExit)
				return; // nothing to do

			localizationContextExit(targetLocale).then(function exitCurrentLocale(result) {
				if (result && result.executed) {
					clearActiveLocale(); // no locale should be active after exit
					loadScriptsForLocale(targetLocale).then(function reloadScriptsForNewLocale(result) {
						localizationContextEnter(targetLocale).then(function enterNewLocale(result) {
							if (result && result.executed && targetLocale === getTargetLocale())
							{
								// we're done here
								syncActiveLocale();
							}
							else
							{
								// enter didn't finish correctly or locale changed so start over
								triggerLocalizationContextChange();
							}
						});
					});
				}
				else
				{
					// exit didn't finish correctly or locale changed so start over
					triggerLocalizationContextChange();
				}
			});
		}

		/**
		 * Triggers the localizationContextExit and localizationContextEnter
		 * in case target locale differs from actual.  To be called after pageInit.
		 *
		 * @public
		 */
		function triggerLocalizationContextChange() {
			if (typeof setTimeout !== "undefined")
				setTimeout(_localizationContextChange, 0);
			else
				_localizationContextChange();
		}

		return ({
			getActiveLocale: getActiveLocale,
			getTargetLocale: getTargetLocale,
			getLocaleFields: getLocaleFields,
			checkLocaleAndTriggerContextChange: checkLocaleAndTriggerContextChange,
			setupCallbacks: setupCallbacks,
			triggerLocalizationContextChange: triggerLocalizationContextChange,
			localizedScriptLimit: localizedScriptLimit
		});
	}

	return {
		createLocaleContext: function (options) { return new LocaleContextHandler(options); }
	}
});

/**
 * SuiteScript client record definition base module
 *
 * @private
 * @module N/record/clientRecordDefinitionBase
 * @NApiVersion 2.x
 */
define('N/record/clientRecordDefinitionBase',[
	'N/record/recordDefinitionBase',
	'N/localeContext',
	'N/utilityFunctions',
	'N/error'
], function (
	recordDefinitionBase,
	localeContext,
	utilityFunctions,
	error
) {

	/**
	 * Primary object used to encapsulate a record object.
	 *
	 * @alias RawRecord
	 *
	 * @return {RawRecord}
	 */
	function ClientRecordBase(options, isAsyncConstructed) {
		recordDefinitionBase.call(this, options);

		var recordOptions = options.recordOptions;

		this.type = recordOptions.type;
		this.isNSE = !!recordOptions.isNSE;
		this.id = recordOptions.id ? parseInt(recordOptions.id, 10) : null;
		this.isNew = this.id == null || this.id < 0;
		this.isDynamic = !!recordOptions.isDynamic;
		this.isReadOnly = !!recordOptions.isReadOnly;
		this.isAsync = this.isNSE;

		if ((this.isDynamic && this.isReadOnly) || (this.isAsync && !isAsyncConstructed)) {
			utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
		}

		var localeContextInstance = localeContext.createLocaleContext({
			recordType: this.type,
			defaultLocale: options.defaultLocale
		});

		this.getLocaleContext = function getLocaleContext()
		{
			return localeContextInstance;
		};

		this.getDynamicData = function getDynamicData()
		{
			return options.dynamicData;
		};

		this.isCanaryOn = function isCanaryOn(canaryName)
		{
			if (options.dynamicData && options.dynamicData.hasOwnProperty("_canary")) {
				return !!options.dynamicData._canary[canaryName];
			}
			return false;
		};

	}

	return ClientRecordBase;
});

/**
 * Field Definition module
 * Will create the appropriate Field Object given the desired attributes.
 *
 * @private
 * @module N/fieldDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldDefinition',['N/internal/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'], function(invoker, utilityFunctions, nsobject, error) {



    var FIELD_CATEGORY = {
        CURRENT_BODY: 'currentBody',
        CURRENT_SUBLIST: 'currentSublist',
        DYNAMIC_BODY: 'dynamicBody',
        DYNAMIC_SUBLIST: 'dynamicSublist',
        DEFERRED_DYNAMIC_BODY: 'deferredDynamicBody',
        DEFERRED_DYNAMIC_SUBLIST: 'deferredDynamicSublist',
        DEFERRED_DYNAMIC_CURRENT_BODY: 'deferredDynamicCurrentBody',
        DEFERRED_DYNAMIC_CURRENT_SUBLIST: 'deferredDynamicCurrentSublist',
        READ_ONLY_BODY: 'readOnlyRecordBody',
        READ_ONLY_SUBLIST: 'readOnlyRecordSublist'
    };
	/**
	 *
	 * @param {object} options
	 * @param {boolean} options.isDynamic
	 * @param {boolean} options.isReadOnly
	 * @param {boolean} options.isSublistField
	 * @returns {Category}
	 */
    FIELD_CATEGORY.getInstance = function getFieldCategoryInstance(options){
        var category;
        if(!!options.isDynamic)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DYNAMIC_SUBLIST : FIELD_CATEGORY.DYNAMIC_BODY;
        }
        else if(!!options.isReadOnly)
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.READ_ONLY_SUBLIST : FIELD_CATEGORY.READ_ONLY_BODY;
        }
        else
        {
            category = !!options.isSublistField ? FIELD_CATEGORY.DEFERRED_DYNAMIC_SUBLIST : FIELD_CATEGORY.DEFERRED_DYNAMIC_BODY;
        }
        return category;
    };
    FIELD_CATEGORY = utilityFunctions.freezeObjectIfPossible(FIELD_CATEGORY);

    var FIELD_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            LABEL: "label",
                                            TYPE: "type",
                                            SUBLIST_ID: "sublistId",
                                            SELECT_OPTION_PROP: "selectOptionProp",
                                            IS_MANDATORY: "isMandatory",
                                            IS_DISABLED: "isDisabled",
                                            IS_POPUP: "isPopup",
                                            IS_DISPLAY: "isDisplay",
                                            IS_VISIBLE: "isVisible",
                                            IS_READ_ONLY: "isReadOnly",
											TO_JSON: "toJSON",
											TO_STRING: "toString"
                                         });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

	/**
	 *
	 * @param {RawField|CurrentRecordField} delegate
	 * @param {FieldPermissions} permissions
	 * @returns {Field}
	 * @constructor
	 */
    function Field(delegate, permissions)
    {
        function authorizeThenWrite(accessLevel, setFunction, errorMsg)
        {
            if (accessLevel === ACCESS_LEVEL.READ_WRITE)
            {
                setFunction();
            }
            else
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, errorMsg );
            }
        }

        function noAction() { }

        if (permissions[FIELD_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the id of the field
             * @name Field#id
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return delegate.id;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.ID], noAction, "Field.id");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.LABEL] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the label of the field
             * @name Field#label
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'label', {
                get: function ()
                {
                    return delegate.label;
                },
                set: function (label)
                {
                            var setFunction = function ()
                            {
                                        delegate.label = label;
                                      };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.LABEL], setFunction, "Field.label");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the field
             * @name Field#type
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'type', {
                get: function ()
                {
                    return delegate.type;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.TYPE], noAction, "Field.type");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SUBLIST_ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the sublist id of the field
             * @name Field#sublistId
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'sublistId', {
                get: function ()
                {
                    return delegate.sublistId;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.SUBLIST_ID], noAction, "Field.sublistId");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.SELECT_OPTION_PROP] > ACCESS_LEVEL.NONE)
        {
	        /**
	         * Return select options for this field
	         * @returns {{value:string, text:string, isSelected:boolean?}}
	         */
            this.getSelectOptions = delegate.getSelectOptions;
	        /**
	         * Add select a select option to the field
             * @param {object} options
	         * @param {string} options.value
	         * @param {string} options.text
	         * @param {boolean} [options.isSelected]
	         */
	        this.insertSelectOption = delegate.insertSelectOption;
	        /**
	         * Remove select option of a given value from the field
	         * @param {object} options
	         * @param {string} options.value
	         */
	        this.removeSelectOption = delegate.removeSelectOption;
        }
        if (permissions[FIELD_PROPERTIES.IS_MANDATORY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is mandatory or not.
             * @name Field#isMandatory
             * @type {boolean}
             * @since 2015.2
             */
            Object.defineProperty(this, 'isMandatory', {
                get: function ()
                {
                    return delegate.isMandatory;
                },
                set: function (required)
                {
                            var setFunction = function ()
                            {
                                            if (!util.isBoolean(required))
                                                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isMandatory",'boolean' );

                                            delegate.isMandatory = required;
                                        };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_MANDATORY], setFunction, "Field.isMandatory");
                },
                enumerable: true,
                configurable: false
            });
        }
        // ==== Current Record (UI) specific properties
        if (permissions[FIELD_PROPERTIES.IS_DISABLED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is disabled
             * @name Field#isDisabled
             * @type {boolean}
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisabled', {
                get: function ()
                {
                    return delegate.isDisabled;
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                        if (!util.isBoolean(val))
                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisabled",'boolean' );

                        delegate.isDisabled = val;
                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISABLED], setFunction, "Field.isDisabled");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_POPUP] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is a popup
             * @name Field#isPopup
             * @type {boolean}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, 'isPopup', {
                get: function ()
                {
                    return delegate.isPopup;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_POPUP], noAction, "Field.isPopup");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is displayed (when false, there is no space reserved on the UI for this field, unlike
             * visible)
             * @name Field#isDisplay
             * @type {boolean}
             * @since 2015.2
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return delegate.isDisplay;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isDisplay",'boolean' );
                                        delegate.isDisplay = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_DISPLAY], setFunction, "Field.isDisplay");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_VISIBLE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is visible (when false, the space is still reserved on the UI for this field, unlike
             * display)
             * @name Field#isVisible
             * @type {boolean}
             * @since 2015.2
             */
            Object.defineProperty(this, 'isVisible', {
                get: function ()
                {
                    return delegate.isVisible;
                },
                set: function (show)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(show))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isVisible",'boolean' );
                                        delegate.isVisible = show;
                                    };
                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_VISIBLE], setFunction, "Field.isVisible");
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[FIELD_PROPERTIES.IS_READ_ONLY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether the field is readOnly
             * @name Field#isReadOnly
             * @type {boolean}
             * @since 2015.2
             */
            Object.defineProperty(this, 'isReadOnly', {
                get: function ()
                {
                    return delegate.isReadOnly
                },
                set: function (val)
                {
                            var setFunction = function ()
                            {
                                        if (!util.isBoolean(val))
                                            utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, "Field.isReadOnly",'boolean' );
                                        delegate.isReadOnly = val;
                                    };

                    authorizeThenWrite(permissions[FIELD_PROPERTIES.IS_READ_ONLY], setFunction, "Field.isReadOnly");
                },
                enumerable: true,
                configurable: false
            });
        }

		if (permissions[FIELD_PROPERTIES.TO_JSON] > ACCESS_LEVEL.NONE)
		{
			this.toJSON = delegate.toJSON;
		}

		if (permissions[FIELD_PROPERTIES.TO_STRING] > ACCESS_LEVEL.NONE)
		{
			this.toString = delegate.toString;
		}
    }

    Field.prototype = nsobject.getNewInstance();
    Object.freeze(Field);

    return Object.freeze({
	    /** @enum {string} */
	    Category: FIELD_CATEGORY,
	    /** @enum {string} */
		Property: FIELD_PROPERTIES,
	    /** @enum {number} */
		Access: ACCESS_LEVEL,

	    /**
	     *
	     * @param {RawField|CurrentRecordField} delegate
	     * @param {FieldPermissions} permissions
	     * @returns {Field}
	     */
		create: function (delegate, permissions)
		{
			return !delegate ? null : Object.freeze(new Field(delegate, permissions));
		}
	});
});
/**
 *
 * @private
 * @module N/fieldPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/fieldPermissions',['N/metadata/fieldDefinition'], function(fieldDef) {

	/** @typedef {object} FieldPermissions */

    var dynamicBody = {};
    dynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    dynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    dynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    dynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
	dynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var dynamicSublist = {};
    dynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    dynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    dynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
	dynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	dynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicBody = {};
    deferredDynamicBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicSublist = {};
    deferredDynamicSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.NONE;
    deferredDynamicSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentBody = {};
    currentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    currentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    currentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
	currentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var currentSublist = {};
    currentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    currentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    currentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
	currentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentBody = {};
    deferredDynamicCurrentBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var deferredDynamicCurrentSublist = {};
    deferredDynamicCurrentSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_WRITE;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    deferredDynamicCurrentSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordBody = {};
    readOnlyRecordBody[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordBody[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordBody[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var readOnlyRecordSublist = {};
    readOnlyRecordSublist[fieldDef.Property.ID]                 = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TYPE]               = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.LABEL]              = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SUBLIST_ID]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.SELECT_OPTION_PROP] = fieldDef.Access.NONE;
    readOnlyRecordSublist[fieldDef.Property.IS_MANDATORY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISABLED]        = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_POPUP]           = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_DISPLAY]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_VISIBLE]         = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.IS_READ_ONLY]       = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_JSON]            = fieldDef.Access.READ_ONLY;
    readOnlyRecordSublist[fieldDef.Property.TO_STRING]          = fieldDef.Access.READ_ONLY;

    var masterPermission = {};
    masterPermission[fieldDef.Category.CURRENT_BODY]                     = currentBody;
    masterPermission[fieldDef.Category.CURRENT_SUBLIST]                  = currentSublist;
    masterPermission[fieldDef.Category.DYNAMIC_BODY]                     = dynamicBody;
    masterPermission[fieldDef.Category.DYNAMIC_SUBLIST]                  = dynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_BODY]            = deferredDynamicBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST]         = deferredDynamicSublist;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY]    = deferredDynamicCurrentBody;
    masterPermission[fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST] = deferredDynamicCurrentSublist;
    masterPermission[fieldDef.Category.READ_ONLY_BODY] = readOnlyRecordBody;
    masterPermission[fieldDef.Category.READ_ONLY_SUBLIST] = readOnlyRecordSublist;

    var convertToCurrentVersion = {};
    convertToCurrentVersion[fieldDef.Category.CURRENT_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.CURRENT_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_BODY] = fieldDef.Category.CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DYNAMIC_SUBLIST] = fieldDef.Category.CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_BODY] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_BODY;
    convertToCurrentVersion[fieldDef.Category.DEFERRED_DYNAMIC_SUBLIST] = fieldDef.Category.DEFERRED_DYNAMIC_CURRENT_SUBLIST;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_BODY] = fieldDef.Category.READ_ONLY_BODY;
    convertToCurrentVersion[fieldDef.Category.READ_ONLY_SUBLIST] = fieldDef.Category.READ_ONLY_SUBLIST;


	/**
	 *
	 * @param {Category} type
	 * @param {boolean} isCurrent
	 * @returns {FieldPermissions}
	 */
    function getPermission(type, isCurrent)
    {
        var trueType = isCurrent ? convertToCurrentVersion[type] : type;
        return masterPermission[trueType];
    }

	return Object.freeze({
		getPermissions: getPermission
	});
});
/**
 * @module N/record/fieldBase
 * @private
 * @suiteScriptVersion 2.x
 */
define('N/record/fieldBase',[
	'N/record/proxy',
	'N/record/recordConstants',
	'N/metadata/fieldDefinition',
	'N/metadata/fieldPermissions'
], function (
	proxy,
	recordConstants,
	fieldDefinition,
	fieldPermissions
) {
	function FieldBase(record) {
		var that = this;

		this.proxy = proxy.initialize(this, record, function (proxy, proxyOptions) {
			if (
				record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD ||
				record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD
			) {
				var category = that.sublistId ? fieldDefinition.Category.CURRENT_SUBLIST : fieldDefinition.Category.CURRENT_BODY;
			} else {
				category = fieldDefinition.Category.getInstance({
					isSublistField: !!that.sublistId,
					isDynamic: record.isDynamic,
					isReadOnly: record.isReadOnly || proxyOptions.isReadOnly
				});
			}

			return fieldDefinition.create(proxy, fieldPermissions.getPermissions(category, record.isCurrentRecord));
		});
	}

	return FieldBase;
});

/**
 * SuiteScript metadata module
 *
 * @private
 * @module N/field
 * @NApiVersion 2.x
 *
 */
define('N/field',['N/error', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/eventEmitter', 'N/runtime', 'N/resultObject', 'N/record/fieldBase', 'N/fieldTypeConstants'],
        function (error, nsobject, invoker, utilityFunctions, eventEmitter, runtime, resultObject, fieldBase, fieldTypeConstants)
{
	/**
	 * @typedef {Object} ServerRecordField
	 * @see com.netledger.app.common.scripting.version2.record.FieldInterface
	 */

    /**
     * @alias RawField
     *
     * @param {RecordField|ServerRecordField} delegate
     * @protected
     * @returns {RawField}
     * @constructor
     */
    function Field(delegate, record)
    {
        /**
         * Return label of the field
         * @name RawField#label
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return invoker(delegate, 'getLabel');
            },
            set: function (val)
            {
                invoker(delegate, 'setLabel', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name RawField#id
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                        return invoker(delegate, 'getName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.id');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Disabled state of the field
         * @name RawField#isDisabled
         * @type {boolean}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisabled');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisabled', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Display state of the field
         * @name RawField#isDisplay
         * @type {boolean}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
                    get: function ()
                    {
                        return invoker(delegate, 'isDisplay');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setDisplay', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Mandatory state of the field
         * @name RawField#isMandatory
         * @type {boolean}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
                    get: function ()
                    {
                        return invoker(delegate, 'isMandatory');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setMandatory', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Read Only state of the field
         * @name RawField#isReadOnly
         * @type {boolean}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
                    get: function ()
                    {
                        return invoker(delegate, 'isReadOnly');
            },
                    set: function (val)
                    {
                        invoker(delegate, 'setReadOnly', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Visible state of the field
         * @name RawField#isVisible
         * @type {boolean}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return invoker(delegate, 'isVisible');
            },
            set: function (val)
            {
                invoker(delegate, 'setVisible', [val]);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name RawField#type
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return invoker(delegate, 'getType');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.type');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return the sublistId of the field
         * @name RawField#sublistId
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return invoker(delegate, 'getSublistName');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.sublistId');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns if the field is a popup
         * @name RawField#isPopup
         * @type {boolean}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return invoker(delegate, 'isPopup');
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'field.Field.isPopup');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns a list of available options on a select field. This API can be used on both standard and custom select fields.
         * Only the first 1,000 available options will be returned by this API.
         *
         * @param {Object} options
         * @param {string} options.filter
         * @param {string} options.operator Supported operators are contains | is | startswith. If not specified, defaults to the
         *     contains operator.
         * @return {Array}
         *
         */
        var getSelectOptions = utilityFunctions.thenableFunction(function getSelectOptions(options, filteroperator, isAsync)
        {
            var filter = options;
            if (utilityFunctions.isObject(options))
            {
                filter = options.filter;
                filteroperator = options.operator;
            }
            var sOptions = [];
            return resultObject.create(function ()
            {
                return (isAsync ? invoker.promise : invoker)(delegate, 'getSelectOptions', [filter || null, filteroperator || null]);
            }).then(function (optionObjects)
            {
                for (var i in optionObjects)
	            {
                    if (!optionObjects.hasOwnProperty(i))
	                    continue;
                    sOptions[sOptions.length] = {
                        'value': optionObjects[i].getId(),
                        'text': optionObjects[i].getText()
                    };
	            }
	            return sOptions;
            });
        }, {
			isAsyncArgIndex: 2
        });

        if (fieldTypeConstants.isSelectTypeOrRadio(this.type))
            this.getSelectOptions = getSelectOptions;

        function checkUpdateSelectOptions()
        {
	        var scriptId = runtime.getCurrentScript().id;
	        if (scriptId != null && scriptId !== 'internal' && !invoker(delegate, 'canExternalUpdateSelectOptions'))
	        	utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE);
	        if (invoker(delegate, 'isPopup'))
		        utilityFunctions.throwSuiteScriptError(error.Type.SSS_NOT_YET_SUPPORTED, "update popup select options");
        }

        var insertSelectOption = utilityFunctions.thenableFunction(function insertSelectOption(options, text, isAsync)
        {
            var value,
                selected = false,
                that = this,
                undef = undefined,
                eventToken;

            if (text !== undef)
            {
                value = options;
            }
            else if (options !== undef && options !== null)
            {
                value = options.value;
                text = options.text;
                selected = options.isSelected || false;
	            eventToken = options._eventToken;
            }

            return eventEmitter.callWithToken(eventToken, function ()
            {
	            checkUpdateSelectOptions();
	            utilityFunctions.checkArgsPresent([value, text], ['value', 'text'], 'Field.insertSelectOption');
	            return (isAsync ? invoker.promise : invoker)(delegate, 'insertSelectOption', [String(value), text, selected]);
            });
        }, {
			isAsyncArgIndex: 2
        });

        var removeSelectOption = utilityFunctions.thenableFunction(function removeSelectOption(options, isAsync)
        {
            var undef = undefined,
                that = this,
                value,
                eventToken;

            if (options !== undef && options !== null && options.value !== undef)
            {
            	value = options.value;
            	eventToken = options._eventToken;
            }
            else
            {
            	value = options;
            }

	        return eventEmitter.callWithToken(eventToken, function ()
	        {
		        checkUpdateSelectOptions();
		        utilityFunctions.checkArgsDefined([value], ['value'], 'Field.removeSelectOption');
		        return (isAsync ? invoker.promise : invoker)(delegate, 'removeSelectOption', [value]);
	        });
        }, {
			isAsyncArgIndex: 1
        });

        if (fieldTypeConstants.isSelectType(this.type)) {
            this.insertSelectOption = insertSelectOption;
            this.removeSelectOption = removeSelectOption;
        }
        // Functions for debugger
        /**
         * get JSON format of the object
         * @return {{id: *, label: *, type: *}}
         *
         */
        this.toJSON = function toJSON()
        {
            return {
                        'id': this.id,
                        'label': this.label,
                        'type': this.type
            };
        };

        /**
         * @return {string}
         *
         */
        this.toString = function toString()
        {
            return "Field";
        };

        fieldBase.call(this, record);
    }

    Field.prototype = nsobject.getNewInstance();

    return Object.freeze({
	    /**
	     *
	     * @param {RecordField|ServerRecordField} f
	     * @returns {RawField}
	     */
        create: function create(f, record)
        {
            try
            {
                return Object.freeze(new Field(f, record));
            }
            catch (e)
            {
                throw error.create(e);
            }
        }
    });

});
/**
 * SuiteScript field level metadata event module
 *
 * @private
 * @module N/record/fieldLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadataEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(type, fieldLevelMetadata)
	{
		return {
			type: type,
			fieldLevelMetadata: fieldLevelMetadata
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function emit(emitter, fieldLevelMetadata, type, oldValue, newValue)
	{
		emitter.emit(addFieldValues(getEvent(type, fieldLevelMetadata), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldLevelMetadata',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/record/fieldLevelMetadataEvent', 'N/eventEmitter', 'N/fieldTypeConstants'],
       function(recordUtil, utilityFunctions, fieldLevelMetadataEvent, eventEmitter, fieldTypeConstants){


	       /**
	        * @typedef {Object} FieldMetadataObject
	        * @property {string} name
	        * @property {string} label
	        * @property {string} type
	        * @property {boolean} isPopup
	        * @property {boolean} autosuggestSupportsContains
	        * @property {boolean} hasStaticOptions
	        * @property {OptionObject[]} [supplementedOptions]
	        * @property {boolean} hasBlankString
	        * @property {string} [blankString]
	        * @property {boolean} doNotFormat
	        * @property {string} [subrecordType]
	        * @property {string} [subrecordIdField]
	        * @property {Object<string,string>} [subrecordCompatibilityMap] - key/value map of strings
	        * @property {SubrecordInitialParameter[]} [subrecordInitialParameters]
	        * @property {FieldStateMetadataObject} [fieldState]
	        * @property {OptionMasterField[]} [optionMastersAndAuxFields]
	        * @property {boolean} isNumeric
	        * @property {boolean} isCurrency
	        * @property {number} maxLength
	        * @property {number} minValue
	        * @property {number} maxValue
	        * @property {string} validationTypeField
	        * @property {Object<string, Object<string,string>>} [radioSet]
	        * @property {string} [subrecordIdField]
	        * @property {boolean} [isMachineHeaderField]
	        * @property {SlavingMetadata} [clientSlavingMetadata]
	        * @property {SlavingMetadata} [slavingMetadata]
	        * @property {FieldScript} [fieldScript]
	        */

	       /**
	        * @typedef {Object<string, *>} SlavingMetadata
	        */
	       /**
	        * @typedef {{validatefield?: string, fieldChange?: string, canCreateSubrecord?: string}} FieldScript
	        */
	       /**
	        * @typedef {{fieldName:string, sublistName:string?}} OptionMasterField
	        */
	       /**
	        * @typedef {{param:string, path:string, mandatory:boolean}} SubrecordInitialParameter
	        */
	       /**
	        * @typedef {{id:string, text:string}} OptionObject
	        */

	       /**
	        * @typedef {Object} FieldStateMetadataObject
	        * @property {string} name not in payload from server, added in FieldLevelMetadata constructor
	        * @property {string} label not in payload from server, added in FieldLevelMetadata constructor
	        * @property {boolean} isMandatory
	        * @property {boolean} isDefaultMandatory
	        * @property {boolean} isHidden
	        * @property {boolean} isDisabled
	        * @property {boolean} isReadOnly
	        * @property {boolean} isDefaultReadOnly not in payload from server, added in FieldLevelMetadata constructor
	        * @property {boolean} noSlaving
	        * @property {boolean} isVisible
	        * @property {boolean} isDisplay
	        */

	       /**
            * object hold the field metadata of record
            * @alias FieldLevelMetadata
	        *
            * @param {FieldMetadataObject} metadata
            * @returns {FieldLevelMetadata}
            * @constructor
            */
           function FieldLevelMetadata(metadata)
           {
               var that = this;
               var label = utilityFunctions.unescape(metadata.label);

               var defaultFieldStates = {};
               if (metadata.hasOwnProperty('fieldState'))
               {
	               defaultFieldStates = util.extend({
		               name: metadata.name,
		               label: label,
		               isDefaultReadOnly: metadata.fieldState.isReadOnly
	               }, metadata.fieldState);
               }

               var emitter = eventEmitter.create();
               var sortableFields = [fieldTypeConstants.Type.TEXT,
		           fieldTypeConstants.Type.TEXTAREA,
		           fieldTypeConstants.Type.EMAIL,
		           fieldTypeConstants.Type.DOCUMENT,
		           fieldTypeConstants.Type.INTEGER,
		           fieldTypeConstants.Type.POSINTEGER,
		           fieldTypeConstants.Type.FLOAT,
		           fieldTypeConstants.Type.POSFLOAT,
		           fieldTypeConstants.Type.NONNEGFLOAT,
		           fieldTypeConstants.Type.RATE,
		           fieldTypeConstants.Type.RATEHIGHPRECISION,
		           fieldTypeConstants.Type.PERCENT,
		           fieldTypeConstants.Type.CURRENCY,
		           fieldTypeConstants.Type.CURRENCY2,
		           fieldTypeConstants.Type.PHONE,
		           fieldTypeConstants.Type.SELECT,
		           fieldTypeConstants.Type.CHECKBOX,
		           fieldTypeConstants.Type.TIME,
		           fieldTypeConstants.Type.TIMETRACK,
		           fieldTypeConstants.Type.DATE,
		           fieldTypeConstants.Type.MMYYDATE,
		           fieldTypeConstants.Type.DATETIME,
		           fieldTypeConstants.Type.DATETIMETZ,
		           fieldTypeConstants.Type.TIMEOFDAY];

	           /**
	            * field's label
	            * @name FieldLevelMetadata#label
	            * @type {string}
	            */
               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (val)
                   {
                       var oldValue = label;
                       label = val;
                       var newValue = label;
                       fieldLevelMetadataEvent.emit(emitter, that, fieldLevelMetadataEvent.Type.LABEL_CHANGE, oldValue, newValue);
                   },
                   enumerable: true,
                   configurable: false
               });

               function getName() { return metadata.name; }
	           /**
	            * Return name of the field
	            * @name FieldLevelMetadata#name
	            * @type {string}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
               utilityFunctions.addReadOnlyProperty(that, 'name', getName);

               function getType() { return metadata.type; }
	           /**
	            * Return type of the field
	            * @name FieldLevelMetadata#type
	            * @type {string}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'type', getType);

	           function isFieldMultiSelect() { return metadata.type === fieldTypeConstants.Type.MULTISELECT; }
	           /**
	            * Return true if the field is a multi-select field type
	            * @name FieldLevelMetadata#isTypeMultiSelect
	            * @type {boolean}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeMultiSelect', isFieldMultiSelect);

	           function isFieldSelectType(){ return fieldTypeConstants.isSelectType(metadata.type); }
	           /**
	            * Return true if the field is a select type
	            * @name FieldLevelMetadata#isTypeSelect
	            * @type {boolean}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeSelect', isFieldSelectType);


	           function isFieldRadioType(){ return metadata.type === fieldTypeConstants.Type.RADIO; }
	           /**
	            * Return true if the field is a radio type
	            * @name FieldLevelMetadata#isTypeRadio
	            * @type {boolean}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isTypeRadio', isFieldRadioType);

	           function isSortable() { return sortableFields.indexOf(metadata.type) > -1; }
	           /**
	            * Returns whether or not the field is sortable via getLines API
	            * @name FieldLevelMetadata#isSortable
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isSortable', isSortable);

	           function getRadioSet() { return metadata.radioSet || null; }
               /**
                * @name FieldLevelMetadata#radioSet
                * @type {Object<string, Object<string,string>>}
                * @readonly
                */
	           utilityFunctions.addReadOnlyProperty(that, 'radioSet', getRadioSet);

               function isPopup() { return metadata.isPopup || false; }
	           /**
	            * @name FieldLevelMetadata#isPopup
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isPopup', isPopup);

               function hasStaticOptions() { return metadata.hasStaticOptions || false; }
	           /**
	            * @name FieldLevelMetadata#hasStaticOptions
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'hasStaticOptions', hasStaticOptions);

	           function getSupplementedOptions() { return metadata.supplementedOptions || null; }
	           /**
	            * @name FieldLevelMetadata#supplementedOptions
	            * @type {Array<OptionObject>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'supplementedOptions', getSupplementedOptions);

               function isMachineHeaderField() { return metadata.isMachineHeaderField || false; }
	           /**
	            * @name FieldLevelMetadata#isMachineHeaderField
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isMachineHeaderField', isMachineHeaderField);

               function getMaxLength() { return metadata.maxLength; }
	           /**
	            * @name FieldLevelMetadata#maxLength
	            * @type {number}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'maxLength', getMaxLength);

               function isNumeric() { return metadata.isNumeric; }
	           /**
	            * @name FieldLevelMetadata#isNumeric
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isNumeric', isNumeric);

               function isCurrency() { return metadata.isCurrency; }
	           /**
	            * @name FieldLevelMetadata#isCurrency
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'isCurrency', isCurrency);

               function hasBlankString() { return metadata.hasBlankString; }
	           /**
	            * @name FieldLevelMetadata#hasBlankString
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'hasBlankString', hasBlankString);

               function getBlankString() {
                   return metadata.blankString;
               }
	           /**
	            * @name FieldLevelMetadata#blankString
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'blankString', getBlankString);

	           function doNotFormat() { return metadata.doNotFormat === true; }
	           /**
	            * @name FieldLevelMetadata#doNotFormat
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'doNotFormat', doNotFormat);

               function hasMinValue() { return metadata.hasOwnProperty("minValue"); }
	           /**
	            * @name FieldLevelMetadata#hasMinValue
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'hasMinValue', hasMinValue);

               function getMinValue() { return metadata.minValue; }
	           /**
	            * @name FieldLevelMetadata#minValue
	            * @type {number}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'minValue', getMinValue);

               function hasMaxValue() { return metadata.hasOwnProperty("maxValue"); }
	           /**
	            * @name FieldLevelMetadata#hasMaxValue
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'hasMaxValue', hasMaxValue);

               function getMaxValue() { return metadata.maxValue; }
	           /**
	            * @name FieldLevelMetadata#maxValue
	            * @type {number}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'maxValue', getMaxValue);


               function getValidationFieldType() { return metadata.validationTypeField; }
	           /**
	            * field type for validation logic
	            * @name FieldLevelMetadata#fieldTypeForValidation
	            * @type {string}
	            * @readonly
	            * @throws READ_ONLY when setting the property is attempted
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'fieldTypeForValidation', getValidationFieldType);

               function getDefaultFieldState() { return util.extend({}, defaultFieldStates); }
	           /**
	            * @name FieldLevelMetadata#defaultFieldState
	            * @type {FieldStateMetadataObject}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'defaultFieldState', getDefaultFieldState);

               function getSlavingMetadata() { return metadata.hasOwnProperty('slavingMetadata') ? metadata.slavingMetadata : null; }
	           /**
	            * @name FieldLevelMetadata#slavingMetadata
	            * @type {SlavingMetadata}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'slavingMetadata', getSlavingMetadata);

               function getClientSlavingMetadata() { return metadata.clientSlavingMetadata; }
	           /**
	            * @name FieldLevelMetadata#clientSlavingMetadata
	            * @type {SlavingMetadata}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'clientSlavingMetadata', getClientSlavingMetadata);

               function getFieldScripts(){ return metadata.fieldScript; }
	           /**
	            * @name FieldLevelMetadata#fieldScripts
	            * @type {FieldScript}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'fieldScripts', getFieldScripts);

               function getFieldScript(scriptType)
               {
                   if(metadata.hasOwnProperty('fieldScript') && metadata['fieldScript'].hasOwnProperty(scriptType))
                       return metadata['fieldScript'][scriptType];
                   else
                       return null;
               }
               this.getFieldScript = getFieldScript;

               function getOptionMastersAndAuxFields() { return metadata.optionMastersAndAuxFields; /* array */ }
	           /**
	            * @name FieldLevelMetadata#optionMastersAndAuxFields
	            * @type {Array<OptionMasterField>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'optionMastersAndAuxFields', getOptionMastersAndAuxFields);

               function getSubrecordType()
               {
                   return (metadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && metadata.hasOwnProperty('subrecordType')) ? metadata.subrecordType : null;
               }
	           /**
	            * @name FieldLevelMetadata#subrecordType
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordType', getSubrecordType);


               function getSubrecordIdField()
               {
                   return (metadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && metadata.hasOwnProperty('subrecordIdField')) ? metadata.subrecordIdField : null;
               }
	           /**
	            * @name FieldLevelMetadata#subrecordIdField
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordIdField', getSubrecordIdField);


               function getSubrecordCompatibilityMap()
               {
                   return (metadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && metadata.hasOwnProperty('subrecordCompatibilityMap')) ? metadata.subrecordCompatibilityMap : null;
               }
	           /**
	            * @name FieldLevelMetadata#subrecordCompatibilityMap
	            * @type {Object<string,string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordCompatibilityMap', getSubrecordCompatibilityMap);


               function getSubrecordInitialParameters()
               {
                   return (metadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && metadata.hasOwnProperty('subrecordInitialParameters')) ? metadata.subrecordInitialParameters: null;
               }
	           /**
	            * @name FieldLevelMetadata#subrecordInitialParameters
	            * @type {Array<SubrecordInitialParameter>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(that, 'subrecordInitialParameters', getSubrecordInitialParameters);

               this.on = emitter.on;
               this.off = emitter.off;

               function toJSON()
               {
                   var copy = util.extend({}, metadata);
                   return copy;
               }

               return this;
           }
           Object.freeze(FieldLevelMetadata);


           return {
               /**
                * return a new instance of field level metadata object
                * @param {FieldMetadataObject} options
                * @returns {FieldLevelMetadata}
                */
               create: function create(options) {
                   return new FieldLevelMetadata(options);
               }
           };
       });
/**
 * SuiteScript sublist metadata event module
 *
 * @private
 * @module N/record/sublistLevelMetadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadataEvent',['N/record/fieldLevelMetadataEvent'], function(fieldLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	var translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(sublistLevelMetadata, translateFieldLevelMetadataEventTypeToSublistLevelMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;
		if(fieldLevelMetadataEvent.oldValue !== undefined){ event.oldValue = fieldLevelMetadataEvent.oldValue; }
		if(fieldLevelMetadataEvent.newValue !== undefined){ event.newValue = fieldLevelMetadataEvent.newValue; }

		return event;
	}

	function getEvent(sublistLevelMetadata, type)
	{
		return {
			type: type,
			sublistLevelMetadata: sublistLevelMetadata
		};
	}

	function emit(emitter, sublistState, type)
	{
		emitter.emit(getEvent(sublistState, type));
	}

	function forwardFieldLevelMetadataEvent(emitter, sublistLevelMetadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToSublistLevelMetadataEvent(sublistLevelMetadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, sublistLevelMetadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, sublistLevelMetadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLevelMetadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLevelMetadata',['N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/sublistLevelMetadataEvent', 'N/eventEmitter'],
       function(utilityFunctions, recordUtil, sublistLevelMetadataEvent, eventEmitter){

	       /**
	        * @typedef {Object} SublistMetadataObject
	        * @property {string} name
	        * @property {string} type
	        * @property {boolean} isRecalcDeferred
	        * @property {boolean} isScriptableMachine
	        * @property {boolean} isEditable
	        * @property {string} nlobjSublistType
	        * @property {boolean} displayOnly
	        * @property {Object<string, string>} defaultValues
	        * @property {boolean} allowMoveLines
	        * @property {boolean} [isMultilineEditable]
	        * @property {Array<string>} [sortedFields]
	        * @property {Array<string>} [backwardCompatibleFields]
	        * @property {{validateline:string?, validateinsert:string?, validatedelete:string?, lineinit:string?,
	        *     linecommit:string?, recalc:string?, postdeleteline:string? }[]} [sublistScript]
	        * @property {DefaultSublistState} sublistState
	        * @property {Object<string, FieldMetadataObject>} fieldMetadata
	        * @property {Array<string>} noCopyFields
	        */

	       /**
	        * @typedef {{allowAddlines:boolean, isDisplay:boolean, isHidden:boolean}} DefaultSublistState
	        */

	       /**
            * object hold the sublist metadata of record
            *
            * @param {Object} options
            * @param {SublistMetadataObject} options.sublistMetadataObj
            * @param {Object<string,FieldLevelMetadata>} options.fieldMetadatas fieldLevelMetadata collection, key is fieldId
            * @returns {SublistLevelMetadata}
            * @constructor
            */
           function SublistLevelMetadata(options)
           {
               var that = this;
               var sublistMetadataObj = options.sublistMetadataObj;
               var fieldMetadata = options.fieldMetadatas;

               var name = sublistMetadataObj.name;
               var type = sublistMetadataObj.type; /* machine type: edit|list|search|subtab */
               var nlobjSublistType = sublistMetadataObj.nlobjSublistType; /* sublist type: inlineeditor|editor|staticlist|list */
               var isScriptableMachine = sublistMetadataObj.isScriptableMachine;
               var isSublistEditable = sublistMetadataObj.isEditable;
               var sortedFields = sublistMetadataObj.sortedFields || [];
               var noCopyFields = sublistMetadataObj.noCopyFields || [];
               var backwardCompatibleFields = sublistMetadataObj.backwardCompatibleFields;
               var scripts = sublistMetadataObj.sublistScript || {};
               var defaultValues = {};
	           recordUtil.forEachProperty(sublistMetadataObj.defaultValues || {}, function(fld, value) {
		           defaultValues[fld] = utilityFunctions.unescape(value);
	           });
	           var isSublistDisplayOnly = sublistMetadataObj.displayOnly || false;
	           var isSublistMultilineEditable = sublistMetadataObj.isMultilineEditable || false;
	           var isAllowedToMoveLines = sublistMetadataObj.allowMoveLines || false;

               var emitter = eventEmitter.create();
	           recordUtil.forEachProperty(fieldMetadata, function(fieldId, metadata) {
                   sublistLevelMetadataEvent.forwardFieldLevelMetadataEvents(emitter, that, metadata);
               });

               function getName() { return name }
               /**
                * @name SublistLevelMetadata#name
                * @type {string}
                * @readonly
                */
	           utilityFunctions.addReadOnlyProperty(this, 'name', getName);

               function getType() { return type }
	           /**
	            * @name SublistLevelMetadata#type
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getSortedFields() { return sortedFields; }
	           /**
	            * @name SublistLevelMetadata#sortedFields
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getNoCopyFields() { return noCopyFields; }
	           /**
	            * @name SublistLevelMetadata#noCopyFields
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'noCopyFields', getNoCopyFields);

               function getBackwardCompatibilityFieldNamesForSubrecord() { return backwardCompatibleFields; }
	           /**
	            * @name SublistLevelMetadata#backwardCompatibilityFieldNamesForSubrecord
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'backwardCompatibilityFieldNamesForSubrecord', getBackwardCompatibilityFieldNamesForSubrecord);

               function getNlobjSublistConstructorType() { return nlobjSublistType; }
	           /**
	            * @name SublistLevelMetadata#nlobjSublistConstructorType
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'nlobjSublistConstructorType', getNlobjSublistConstructorType);

               function getIsScriptableMachine(){
                   return isScriptableMachine;
               }
	           /**
	            * @name SublistLevelMetadata#isScriptableMachine
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'isScriptableMachine', getIsScriptableMachine);

               function getIsSublistEditable(){
                   return isSublistEditable;
               }
	           /**
	            * @name SublistLevelMetadata#isEditable
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'isEditable', getIsSublistEditable);

	           function getIsAllowedToMoveLines(){
		           return isAllowedToMoveLines;
	           }
	           /**
	            * @name SublistLevelMetadata#isAllowedToMoveLines
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'isAllowedToMoveLines', getIsAllowedToMoveLines);

	           /**
	            *
	            * @param {*} scriptingTrigger
	            * @returns {string}
	            */
               function getSublistScripts(scriptingTrigger)
               {
                   /*
                    * list of scriptingTrigger:
                    * validatelines
                    * validateinsert
                    * validatedelete
                    * lineinit
                    * linecommit
                    * postdeleteline
                    * recalc
                    */
                   var result = null;

                   if(scriptingTrigger === undefined)
                   {
                       result = scripts;
                   }
                   else if(scripts.hasOwnProperty(scriptingTrigger))
                   {
                       result = scripts[scriptingTrigger];
                   }

                   return result;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue()
               {
                   return util.extend({}, defaultValues);
               }
	           /**
	            * @name SublistLevelMetadata#defaultValue
	            * @type {Object<string, string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'defaultValue', getSublistDefaultValue);

               function getDefaultSublistState()
               {
                   return util.extend({}, sublistMetadataObj.sublistState);
               }
	           /**
	            * @name SublistLevelMetadata#defaultState
	            * @type {DefaultSublistState}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'defaultState', getDefaultSublistState);

               function getFieldMetadatas()
               {
                   return fieldMetadata
               }
	           /**
	            * @name SublistLevelMetadata#fieldMetadata
	            * @type {Object<string,FieldLevelMetadata>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'fieldMetadata', getFieldMetadatas);

               function getFieldMetadata(fieldId)
               {
                   return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
               }
               this.getFieldMetadata = getFieldMetadata;

               function isRecalcDeferred()
               {
                   return sublistMetadataObj.isRecalcDeferred;
               }
	           /**
	            * @name SublistLevelMetadata#isRecalcDeferred
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'isRecalcDeferred', isRecalcDeferred);

               function isDisplayOnly()
               {
                   return isSublistDisplayOnly;
               }
	           /**
	            * @name SublistLevelMetadata#displayOnly
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'displayOnly', isDisplayOnly);

	           function isMultilineEditable()
	           {
		           return isSublistMultilineEditable;
	           }
	           /**
	            * @name SublistLevelMetadata#isMultilineEditable
	            * @type {boolean}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'isMultilineEditable', isMultilineEditable);

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }
           Object.freeze(SublistLevelMetadata);

           return {
               /**
                * return a new instance of sublist level metadata object
                * @param {Object} options
                * @param {SublistMetadataObject} options.sublistMetadataObj
                * @param {Object<string,FieldLevelMetadata>} options.fieldMetadatas fieldLevelMetadata collection, key is fieldId
                * @returns {SublistLevelMetadata}
                */
               create: function create(options) {
                   return new SublistLevelMetadata(options);
               }
           };
       });
/**
 * SuiteScript metadata event module
 *
 * @private
 * @module N/record/metadataEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadataEvent',['N/record/fieldLevelMetadataEvent', 'N/record/sublistLevelMetadataEvent'], function(fieldLevelMetadataEvent, sublistLevelMetadataEvent)
{
	var EVENT_TYPE = Object.freeze({
		FIELD_METADATA_LABEL_CHANGE: 'FIELD_METADATA_LABEL_CHANGE'
	});

	function getEvent(metadata, type)
	{
		return {
			type: type,
			metadata: metadata
		};
	}

	var translateFieldLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldLevelMetadataEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent)
	{
		return addFieldLevelMetadataEventDetails(getEvent(metadata, translateFieldLevelMetadataEventTypeToMetadataEventType(fieldLevelMetadataEvent.type)), fieldLevelMetadataEvent);
	}

	function addFieldLevelMetadataEventDetails(event, fieldLevelMetadataEvent)
	{
		event.fieldId = fieldLevelMetadataEvent.fieldLevelMetadata.name;

		return event;
	}

	function forwardFieldLevelMetadataEvent(emitter, metadata, fieldLevelMetadataEvent)
	{
		emitter.emit(translateFieldLevelMetadataEventToMetadataEvent(metadata, fieldLevelMetadataEvent));
	}

	function forwardFieldLevelMetadataEvents(emitter, metadata, fieldLevelMetadata)
	{
		var forward = forwardFieldLevelMetadataEvent.bind(null, emitter, metadata);

		fieldLevelMetadata.on({
			types: [
				fieldLevelMetadataEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistLevelMetadataEventTypeToMetadataEventType = (function(){
		var eventTranslations = {};

		eventTranslations[sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.FIELD_METADATA_LABEL_CHANGE;

		return function(sublistLevelMetadataEventType){
			return eventTranslations[sublistLevelMetadataEventType];
		}
	}());

	function translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent)
	{
		return addSublistLevelMetadataEventDetails(getEvent(metadata, translateSublistLevelMetadataEventTypeToMetadataEventType(sublistLevelMetadataEvent.type)), sublistLevelMetadataEvent);
	}

	function addSublistLevelMetadataEventDetails(event, sublistLevelMetadataEvent)
	{
		event.sublistId = sublistLevelMetadataEvent.sublistLevelMetadata.name;
		event.fieldId = sublistLevelMetadataEvent.fieldId;
		if(sublistLevelMetadataEvent.oldValue !== undefined){ event.oldValue = sublistLevelMetadataEvent.oldValue; }
		if(sublistLevelMetadataEvent.newValue !== undefined){ event.newValue = sublistLevelMetadataEvent.newValue; }

		return event;
	}

	function forwardSublistLevelMetadataEvent(emitter, metadata, sublistLevelMetadataEvent)
	{
		emitter.emit(translateSublistLevelMetadataEventToMetadataEvent(metadata, sublistLevelMetadataEvent));
	}

	function forwardSublistLevelMetadataEvents(emitter, metadata, sublistLevelMetadata)
	{
		var forward = forwardSublistLevelMetadataEvent.bind(null, emitter, metadata);

		sublistLevelMetadata.on({
			types: [
				sublistLevelMetadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function emit(emitter, metadata, type)
	{
		emitter.emit(getEvent(metadata, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldLevelMetadataEvents: forwardFieldLevelMetadataEvents,
		forwardSublistLevelMetadataEvents: forwardSublistLevelMetadataEvents
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/metadata
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/metadata',['N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/fieldLevelMetadata','N/record/sublistLevelMetadata', 'N/record/metadataEvent', 'N/eventEmitter', 'N/fieldTypeConstants'],
       function(utilityFunctions, recordUtil, fieldLevelMetadata, sublistLevelMetadata, metadataEvent, eventEmitter, fieldTypeConstants){

	       /**
	        * @typedef {Object} RecordMetadataObject
	        * @property {*} queryUrl
	        * @property {{country:string[], fields:string[], limit:number}} defaultLocale
	        * @property {string} dynamicData - JSON
	        * @property {string} type
	        * @property {Object.<string, FieldMetadataObject>} fieldMetadata
	        * @property {Object.<string, SublistMetadataObject>} sublists
	        * @property {string} libraryScript
	        * @property {string} staticScript
	        * @property {string} uiFormScript
	        * @property {string[]} sortedFields
	        * @property {string[]} sortedSublists
	        * @property {string} workflowScript
	        *
	        * @see RecordMetadataTransformer.java
	        */

	       /**
	        * object holding the metadata of a record
	        *
	        * @param {RecordMetadataObject} metadataObj
	        * @returns {Metadata}
	        * @constructor
	        */
           function Metadata(metadataObj)
           {
               var that = this;
               var type, queryUrl, sortedFields, sortedSublists, libraryScript, staticScript, uiFormScript, workflowScript;
               var fieldIds, sublistIds, sublistFieldIds, fieldMetadata, sublistMetadata;

               var emitter = eventEmitter.create();

               (function constructor(metadataObj){
                   type = metadataObj.type;
                   queryUrl = metadataObj.queryUrl;
                   sortedFields = metadataObj.sortedFields;
                   sortedSublists = metadataObj.sortedSublists;
                   /* Record Scripting Variables */
                   libraryScript = metadataObj.libraryScript;
                   staticScript = metadataObj.staticScript;
                   uiFormScript = metadataObj.uiFormScript;
                   workflowScript = metadataObj.workflowScript;

                   fieldIds = [];
                   sublistIds = [];
                   sublistFieldIds = {};
                   fieldMetadata = {};
                   sublistMetadata = {};
                   (function setFieldMetadata(fieldLevelMetadataObjs){
                       recordUtil.forEachProperty(fieldLevelMetadataObjs, function(fieldId, metadataJSON)
                       {
                           fieldIds[fieldIds.length] = fieldId;
                       });

                       utilityFunctions.freezeObjectIfPossible(fieldIds);
                   })(metadataObj.fieldMetadata);

                   (function setSublistFieldMetadata(sublistLevelMetadataObjs){

                       recordUtil.forEachProperty(sublistLevelMetadataObjs, function(sublistId, sublistLevelMetadataObj){
                           sublistIds[sublistIds.length] = sublistId;

                           var fieldmetadataJSON = sublistLevelMetadataObj.fieldMetadata;
                           var fieldLevelMetadatas = {};
                           sublistFieldIds[sublistId] = [];

                           recordUtil.forEachProperty(fieldmetadataJSON, function(fieldId, metadataJSON)
                           {
                               sublistFieldIds[sublistId].push(fieldId);
                               fieldLevelMetadatas[fieldId] = fieldLevelMetadata.create(metadataJSON);
                           });

                           var metadata = sublistLevelMetadata.create({sublistMetadataObj: sublistLevelMetadataObj, fieldMetadatas: fieldLevelMetadatas});
                           metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                           sublistMetadata[sublistId] = metadata;
                       });

                       utilityFunctions.freezeObjectIfPossible(sublistIds);
                   }) (metadataObj.sublists);


               })(metadataObj);

               function getType() { return type; }
	           /**
	            * @name Metadata#type
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'type', getType);

               function getQueryUrl() { return queryUrl; }
	           /**
	            * @name Metadata#queryUrl
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'queryUrl', getQueryUrl);

               function getLibraryScript() { return libraryScript; }
	           /**
	            * @name Metadata#libraryScript
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'libraryScript', getLibraryScript);

               function getStaticScript() { return staticScript; }
	           /**
	            * @name Metadata#staticScript
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'staticScript', getStaticScript);

               function getUIFormScript() { return uiFormScript; }
	           /**
	            * @name Metadata#uiFormScript
	            * @type {string}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'uiFormScript', getUIFormScript);

               function getWorkflowScript() { return workflowScript; }
	           /**
	            * @name Metadata#workflowScript
	            * @type {string}
	            * @readonly
	            */
               utilityFunctions.addReadOnlyProperty(this, 'workflowScript', getWorkflowScript);

               function getNoCopyFields() { return sortedFields; }
	           /**
	            * @name Metadata#noCopyFields
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'noCopyFields', getNoCopyFields);

               function getSortedFields() { return sortedFields; }
	           /**
	            * @name Metadata#sortedFields
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'sortedFields', getSortedFields);

               function getSortedSublists() { return sortedSublists; }
	           /**
	            * @name Metadata#sortedSublists
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'sortedSublists', getSortedSublists);

               function getAllFieldNames() { return fieldIds; }
	           /**
	            * @name Metadata#fieldIds
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'fieldIds', getAllFieldNames);

               function isValidField(fieldId)
               {
                   return getAllFieldNames().indexOf(fieldId) > -1;
               }
               this.isValidField = isValidField;

               function getAllSubrecordFields()
               {
                   return getAllFieldNames().filter(function(v, i, a){
                       var fieldId = v;
                       return getFieldMetadata(null, fieldId) && getFieldMetadata(null, fieldId).type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE;
                   });
               }
	           /**
	            * @name Metadata#subrecordFieldIds
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'subrecordFieldIds', getAllSubrecordFields);

               function getSublistFieldMetadata(sublistId, fieldId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId].getFieldMetadata(fieldId) : null;
               }

	           /**
	            * get field Metadata
	            * @param {string|null} sublistId
	            * @param {string} fieldId
	            * @returns {FieldLevelMetadata}
	            */
               function getFieldMetadata(sublistId, fieldId)
               {
                   if(sublistId)
                       return getSublistFieldMetadata(sublistId, fieldId);

                   var metadata = null;
                   if(fieldMetadata.hasOwnProperty(fieldId))
                       metadata = fieldMetadata[fieldId];
                   else if(metadataObj.fieldMetadata.hasOwnProperty(fieldId))
                   {
                       metadata = fieldLevelMetadata.create(metadataObj.fieldMetadata[fieldId]);
                       metadataEvent.forwardSublistLevelMetadataEvents(emitter, that, metadata);
                       fieldMetadata[fieldId] = metadata;
                   }

                   return metadata;
               }
               this.getFieldMetadata = getFieldMetadata;

               function isValidSublist(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId);
               }
               this.isValidSublist = isValidSublist;

	           /**
	            * return sublist level metadata
	            * @param {string} sublistId
	            * @returns {SublistLevelMetadata|null}
	            */
               function getSublistMetadata(sublistId)
               {
                   return sublistMetadata.hasOwnProperty(sublistId) ? sublistMetadata[sublistId] : null;
               }
               this.getSublistMetadata = getSublistMetadata;

	           /**
	            *
	            * @param {*} sublistId
	            * @returns {string|null}
	            */
               function getSublistType(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.type : null;
               }
               this.getSublistType = getSublistType;

               function getSublists() { return sublistIds; }
	           /**
	            * @name Metadata#sublistIds
	            * @type {Array<string>}
	            * @readonly
	            */
	           utilityFunctions.addReadOnlyProperty(this, 'sublistIds', getSublists);

               function isValidSublistField(sublistId, fieldId)
               {
                   var sublistfields = getAllSublistFields(sublistId);
                   return (sublistfields != null && sublistfields.indexOf(fieldId) > -1);
               }
               this.isValidSublistField = isValidSublistField;

               function getAllSublistFields(sublistId)
               {
                   return sublistFieldIds[sublistId] || [];
               }
               this.getAllSublistFields = getAllSublistFields;

               function getAllSublistSubrecordFields(sublistId)
               {
                   var sublistFields = sublistFieldIds[sublistId] || [];

                   sublistFields = sublistFields.filter(function(v, i, a){
                       var fieldId = v;

                       return getSublistFieldMetadata(sublistId, fieldId) &&
                              getSublistFieldMetadata(sublistId, fieldId).type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE;
                   });

                   return sublistFields;
               }
               this.getAllSublistSubrecordFields = getAllSublistSubrecordFields;

               function getSublistScripts(sublistName, scriptingTrigger)
               {
                   var metadata = getSublistMetadata(sublistName);
                   return (metadata) ? metadata.getSublistScripts(scriptingTrigger) : null;
               }
               this.getSublistScripts = getSublistScripts;

               function getSublistDefaultValue(sublistId)
               {
                   var metadata = getSublistMetadata(sublistId);
                   return (metadata) ? metadata.defaultValue : {};
               }
               this.getSublistDefaultValue = getSublistDefaultValue;

               function toJSON()
               {
                   return metadataObj;
               }

               function clone()
               {
                   return new Metadata(toJSON());
               }
               this.clone = clone;

               this.on = emitter.on;
               this.off = emitter.off;

               return this;
           }

           return {
               /**
                * return a new instance of Metadata
                * @param {RecordMetadataObject} metadataObj
                * @returns {Metadata}
                */
               create: function(metadataObj) { return new Metadata(metadataObj); },
               /**
                * return true if object is an instance of Metadata
                * @param {*} obj
                * @returns {boolean}
                */
               isInstance: function(obj) { return obj instanceof Metadata; }
           };
       });
/**
 * SuiteScript field state event module
 *
 * @private
 * @module N/record/fieldStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/fieldStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			PARENT_STATE_CHANGE: 'PARENT_STATE_CHANGE',
			USE_TEXT_API_CHANGE: 'USE_TEXT_API_CHANGE',
			IS_PARSED_CHANGE: 'IS_PARSED_CHANGE',
			IS_MANDATORY_CHANGE: 'IS_MANDATORY_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			IS_DISABLED_CHANGE: 'IS_DISABLED_CHANGE',
			IS_VISIBLE_CHANGE: 'IS_VISIBLE_CHANGE',
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_READ_ONLY_CHANGE: 'IS_READ_ONLY_CHANGE',
			IGNORE_SLAVING_CHANGE: 'IGNORE_SLAVING_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			LABEL_CHANGE: 'LABEL_CHANGE'
		});

	function getEvent(fieldState, type)
	{
		return {
			type: type,
			fieldState: fieldState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function emit(emitter, fieldState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(fieldState, type), oldValue, newValue));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/fieldState
 * @suiteScriptVersion 2.x
 */
define('N/record/fieldState',['N/record/fieldStateEvent', 'N/eventEmitter', 'N/utilityFunctions', 'N/error'], function (fieldStateEvent, eventEmitter, utilityFunctions, error){

	var TBI = 'TBI'; // to be initialized

	/**
     * field state for record
	 * @alias FieldState
	 *
     * @param {Object} options
     * @param {RecordStateController|SublistLineState} options.parentState parent state
     * @param {SublistState} options.parentSublistState parent sublist state
     * @param {FieldStateMetadataObject} options.fieldState
     *
     * @returns {FieldState}
     * @constructor
     * @protected
     *
     */
    function FieldState(options)
    {
        var that = this;
        var parentState = options.parentState != null ? options.parentState : TBI;
        var parentSublistState = options.parentSublistState;
        var fs = options.fieldState;
        var id = fs.name || '';
        var label = fs.label || '';
        var shouldUseTextApi = false;
        var isParsed = fs && !!(fs.isParsed);

	    var isFieldMandatory = !!fs.isMandatory;               // is this field mandatory (required)
	    var defaultMandatory = !!fs.isDefaultMandatory;        // is this field mandatory by default (required)
	    var isFieldHidden = !!fs.isHidden;                     // is this field hidden (i.e. not visible or editable to user in the UI)
	    var isFieldDisabled = !!fs.isDisabled;                 // is this field disabled (i.e. uneditable by user in UI).
	    var isFieldReadOnly = !!fs.isReadOnly;                 // is a fundamentally read-only field
	    var defaultReadOnly = !!fs.isDefaultReadOnly;          // is a fundamentally read-only field by default
	    var ignoreSlaving = !!fs.noSlaving;                    // if true then slaving is disabled when during fieldChange execution
	    var isFieldChanged = !!fs.isChanged;                   // if true then this field was set/changed by the user
	    var isFieldVisible = !!fs.isVisible && !isFieldHidden; // if true then this field should be made visible in the user interface
	    var isFieldDisplay = !!fs.isDisplay && !isFieldHidden; // if false then this field should be removed from the user interface

        var emitter = eventEmitter.create();

        /**
         * parentSublistState
         * @name FieldState#parentSublistState
         * @type {SublistState|RecordStateController}
         */
        Object.defineProperty(this, 'parentSublistState', {
            get: function ()
            {
                return parentSublistState;
            },
            enumerable: true,
            configurable: false
        });
        /**
         * parentState
         * @name FieldState#parentState
         * @type {SublistLineState|RecordStateController}
         */
        Object.defineProperty(this, 'parentState', {
            get: function ()
            {
                return parentState;
            },
            set: function (state)
            {
                if(parentState !== state)
                {
                    var oldParentState = parentState;
                	parentState = state;
                    if (oldParentState !== TBI)
                        fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.PARENT_STATE_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * useTextApi
         *
         * @name FieldState#useTextApi
         * @type {boolean}
         */
        Object.defineProperty(this, 'useTextApi', {
            get: function ()
            {
                return shouldUseTextApi;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (shouldUseTextApi !== val))
                {
                    var oldValue = shouldUseTextApi;
                    shouldUseTextApi = val;
                    var newValue = shouldUseTextApi;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.USE_TEXT_API_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isParsed
         *
         * @name FieldState#isParsed
         * @type {boolean}
         */
        Object.defineProperty(this, 'isParsed', {
            get: function ()
            {
                return isParsed;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isParsed !== val))
                {
                    var oldValue = isParsed;
                    isParsed = val;
                    var newValue = isParsed;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_PARSED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isMandatory
         *
         * @name FieldState#isMandatory
         * @type {boolean}
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return isFieldMandatory;
            },
            set: function (val) {
                if (util.isBoolean(val) && (isFieldMandatory !== val))
                {
                    var oldValue = isFieldMandatory;
                    isFieldMandatory = val;
                    var newValue = isFieldMandatory;

                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_MANDATORY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * isDefaultMandatory
         *
         * @name FieldState#isDefaultMandatory
         * @type {boolean}
         * @readonly
         */
        Object.defineProperty(this, 'isDefaultMandatory', {
            get: function ()
            {
                return defaultMandatory;
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isHidden
         *
         * @name FieldState#isHidden
         * @type {boolean}
         */
        Object.defineProperty(this, 'isHidden', {
            get: function ()
            {
                return isFieldHidden;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldHidden !== val))
                {
                    var oldValue = isFieldHidden;
                    isFieldHidden = val;
                    var newValue = isFieldHidden;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisabled
         *
         * @name FieldState#isDisabled
         * @type {boolean}
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return isFieldDisabled;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisabled !== val))
                {
                    var oldValue = isFieldDisabled;
                    isFieldDisabled = val;
                    var newValue = isFieldDisabled;

                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISABLED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isVisible
         *
         * @name FieldState#isVisible
         * @type {boolean}
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return isFieldVisible;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldVisible !== val))
                {
                    var oldValue = isFieldVisible;
                    isFieldVisible = val;
                    var newValue = isFieldVisible;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_VISIBLE_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isDisplay
         *
         * @name FieldState#isDisplay
         * @type {boolean}
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return isFieldDisplay;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldDisplay !== val))
                {
                    var oldValue = isFieldDisplay;
                    isFieldDisplay = val;
                    var newValue = isFieldDisplay;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isReadOnly
         *
         * @name FieldState#isReadOnly
         * @type {boolean}
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return isFieldReadOnly;
            },
            set: function (val)
            {
            	if (parentState && parentState.getIsNSERecord() && defaultReadOnly)
	            {
		            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly');
	            }
                else if (util.isBoolean(val) && (isFieldReadOnly !== val))
                {
                    var oldValue = isFieldReadOnly;
                    isFieldReadOnly = val;
                    var newValue = isFieldReadOnly;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_READ_ONLY_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
	    /**
	     * isDefaultReadOnly
	     *
	     * @name FieldState#isDefaultReadOnly
	     * @type {boolean}
	     */
	    Object.defineProperty(this, 'isDefaultReadOnly', {
		    get: function ()
		    {
			    return defaultReadOnly;
		    },
		    enumerable: true,
		    configurable: false
	    });
        /**
         * ignoreSlaving
         *
         * @name FieldState#ignoreSlaving
         * @type {boolean}
         */
        Object.defineProperty(this, 'ignoreSlaving', {
            get: function ()
            {
                return ignoreSlaving;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (ignoreSlaving !== val))
                {
                    var oldValue = ignoreSlaving;
                    ignoreSlaving = val;
                    var newValue = ignoreSlaving;
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IGNORE_SLAVING_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name FieldState#isChanged
         * @type {boolean}
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isFieldChanged;
            },
            set: function (val)
            {
                if (util.isBoolean(val) && (isFieldChanged !== val))
                {
                    var oldValue = isFieldChanged;
                    isFieldChanged = val;
                    var newValue = isFieldChanged;
                    if(val === true && parentState)
                    {
                        parentState.isChanged = val;
                    }
                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * label
         *
         * @name FieldState#label
         * @type {string}
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return label;
            },
            set: function (val)
            {
                if(label !== val)
                {
                    var oldValue = label;
                    label = val;
                    var newValue = label;

                    if (parentSublistState != null) {
	                    if (parentSublistState.getColumnProperty(id, 'label') !== newValue)
		                    parentSublistState.setColumnProperty(id, 'label', newValue);
                    }
					else {
	                    fieldStateEvent.emit(emitter, that, fieldStateEvent.Type.LABEL_CHANGE, oldValue, newValue);
                    }
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * id
         * @name FieldState#id
         * @type {string}
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return id;
            },
            set: function (val)
            {
                // TODO: remove ???
                id = val;
            },
            enumerable: true,
            configurable: false
        });
        
        this.on = emitter.on;
        this.off = emitter.off;
        
        return this;
    }
    Object.freeze(FieldState);


    return Object.freeze({
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {Object} options
                              * @param {RecordStateController|string} [options.parentState]
                              * @param {SublistState} options.parentSublistState
                              * @param {Object} options.fieldState
                              *
                              * @returns {FieldState}
                              */
                             create: function (options) {
                                 return new FieldState(options);
                             },
                             /**
                              * clone the fieldState object
                              *
                              * @param {FieldState} fieldState
                              * @param {RecordStateController|SublistLineState?} parentState
                              * @param {object?} fieldStateOverrides
                              * @returns {FieldState}
                              */
                             clone: function (fieldState, parentState, fieldStateOverrides)
                             {
                                 return new FieldState({
                                     parentState: parentState || fieldState.parentState,
                                     parentSublistState: fieldState.parentSublistState,
                                     fieldState: util.extend({
                                             name: fieldState.id,
                                             label: fieldState.label,
                                             isMandatory: fieldState.isMandatory,
                                             isDefaultMandatory: fieldState.isDefaultMandatory,
                                             isHidden: fieldState.isHidden,
                                             isDisabled: fieldState.isDisabled,
                                             isReadOnly: fieldState.isReadOnly,
                                             isDefaultReadOnly: fieldState.isDefaultReadOnly,
                                             noSlaving: fieldState.ignoreSlaving,
                                             isChanged: fieldState.isChanged,
                                             isVisible: fieldState.isVisible,
                                             isDisplay: fieldState.isDisplay,
                                             isParsed: fieldState.isParsed
                                         }, fieldStateOverrides || {})
                                 });
                             },
                             /**
                              * create a new instance of fieldState
                              *
                              * @param {object} options
                              * @param {RecordStateController|SublistLineState} [options.parentState]
                              * @param {SublistState?} options.parentSublistState
                              * @param {FieldLevelMetadata} options.metadata
                              *
                              * @returns {FieldState}
                              */
                             createBasedOnFieldLevelMetadata: function(options){
                                 var parentState = options.parentState;
                                 var parentSublistState = options.parentSublistState;
                                 var metadata = options.metadata;
                                 return new FieldState({
                                     parentState: parentState,
                                     fieldState: metadata.defaultFieldState,
                                     parentSublistState: parentSublistState
                                 });
                             }
                         })
});
/**
 * SuiteScript sublist line state event module
 *
 * @private
 * @module N/record/sublistLineStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineStateEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			LINE_NUM_CHANGE: 'LINE_NUM_CHANGE',
			IS_INSERTED_CHANGE: 'IS_INSERTED_CHANGE',
			FIELD_STATE_ADDED: 'FIELD_STATE_ADDED',
			FIELD_STATE_REMOVED: 'FIELD_STATE_REMOVED'
		});

	function getEvent(sublistLineState, type)
	{
		return {
			type: type,
			sublistLineState: sublistLineState
		};
	}

	function emit(emitter, sublistLineState, type)
	{
		emitter.emit(getEvent(sublistLineState, type));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit
	});
});
/**
 * SuiteScript recordstate module
 *
 * @private
 * @module N/record/sublistLineState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineState',['N/utilityFunctions', 'N/record/fieldState', 'N/record/sublistLineStateEvent', 'N/eventEmitter'], function(utilityFunctions, fieldState, sublistLineStateEvent, eventEmitter)
{
    /**
     * line state for record sublist
     *
     * @param {Object} options
     * @param {Function} options.fieldStatesProvider field states for the line
     * @param {Number} [options.line=-1]
     * @param {string} options.lineInstanceId
     * @param {SublistState} options.parentState
     *
     * @return {SublistLineState}
     * @constructor
     */
    function SublistLineState(options)
    {
        var that = this;
        var fieldStates = options.fieldStatesProvider(that);
        var originalLine = options.line || options.line === 0 ? options.line : -1;
	    var originalLineInstanceId = options.lineInstanceId;
        var isInsertedLine = false;
        var emitter = eventEmitter.create();
        var parentState = options.parentState;

	    /**
	     * @name SublistLineState#getIsNSERecord
	     * @function
	     * @return boolean
	     */
	    this.getIsNSERecord = function() { return parentState.getIsNSERecord(); };

        /**
         * lineNum line number from db
         *
         * @name SublistLineState#lineNum
         * @type {number}
         */
        Object.defineProperty(this, 'lineNum', {
            get: function ()
            {
                return originalLine;
            },
            set: function (line)
            {
                if(originalLine !== line)
                {
                    originalLine = line;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.LINE_NUM_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
	    /**
	     * lineInstanceId
	     *
	     * @name SublistLineState#lineInstanceId
	     * @type {number}
	     */
	    Object.defineProperty(this, 'lineInstanceId', {
		    get: function ()
		    {
			    return originalLineInstanceId;
		    },
		    set: function (lineInstanceId)
		    {
			    if(originalLineInstanceId !== lineInstanceId)
			    {
				    originalLineInstanceId = lineInstanceId;
				    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.LINE_NUM_CHANGE);
			    }
		    },
		    enumerable: true,
		    configurable: false
	    });
        /**
         * isInserted
         *
         * @name SublistLineState#isInserted
         * @type {boolean}
         */
        Object.defineProperty(this, 'isInserted', {
            get: function ()
            {
                return isInsertedLine;
            },
            set: function (val)
            {
                if(isInsertedLine !== val)
                {
                    isInsertedLine = val;
                    sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.IS_INSERTED_CHANGE);
                }
            },
            enumerable: true,
            configurable: false
        });
        /**
         * isChanged
         *
         * @name SublistLineState#isChanged
         * @type {boolean}
         * @readonly
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                for(var fieldId in fieldStates)
                {
                    if(fieldStates.hasOwnProperty(fieldId) && fieldStates[fieldId].isChanged)
                        return true;
                }
                return false;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * has the fieldState for field
         *
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasFieldState(fieldId)
        {
            return fieldStates.hasOwnProperty(fieldId);
        }
        this.hasFieldState = hasFieldState;

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
            {
                delete fieldStates[fieldId];
                sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_REMOVED);
            }
        }
        this.removeFieldState = removeFieldState;

        /**
         * return the fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @returns {FieldState}
         */
        function getFieldState(fieldId)
        {
            return fieldStates[fieldId];
        }
        this.getFieldState = getFieldState;

        /**
         * add new fieldState object for fieldId in the current line
         *
         * @param {string} fieldId
         * @param {FieldState} state
         * @returns {FieldState}
         */
        function addFieldState(fieldId, state)
        {
            fieldStates[fieldId] = state;
            sublistLineStateEvent.emit(emitter, that, sublistLineStateEvent.Type.FIELD_STATE_ADDED);
        }
        this.addFieldState = addFieldState;

	    /**
	     * return all field states of this line
	     * @returns {Array<FieldState>}
	     */
	    function getAllFields()
	    {
		    var arr = [];
		    for(var f in fieldStates)
			    if(fieldStates.hasOwnProperty(f))
				    arr.push(f);
		    return arr;
	    }
	    this.getAllFields = getAllFields;

        /**
         * clone the fieldState object in the current line
         *
         * @returns {object} collection of cloned fieldState from current line
         */
        function getClonedFieldStates(targetParentState)
        {
            var returnFieldStates = {};
            for(var fieldId in fieldStates)
            {
                if(fieldStates.hasOwnProperty(fieldId))
	                returnFieldStates[fieldId] = fieldState.clone(fieldStates[fieldId], targetParentState, {isParsed: false});
            }
            return returnFieldStates;
        }
        this.getClonedFieldStates = getClonedFieldStates;

	    function getMandatoryFields(useDefaultState)
	    {
		    var result = [];
		    for (var fieldId in fieldStates)
		    {
			    if (fieldStates.hasOwnProperty(fieldId))
			    {
				    var fs = fieldStates[fieldId];
				    if (useDefaultState ? fs.isDefaultMandatory : fs.isMandatory)
					    result.push(fieldId);
			    }
		    }
		    return result;
	    }
	    this.getMandatoryFields = getMandatoryFields;

        this.on = emitter.on;
        this.off = emitter.off;

        return this;
    }
    utilityFunctions.freezeObjectIfPossible(SublistLineState);

    return Object.freeze({
                             /**
                              * create a new instance of sublist line state
                              *
                              * @param {Object} options
                              * @param {Function} options.fieldStatesProvider
                              * @param {Number} options.line
                              * @param {string} options.lineInstanceId
                              * @param {SublistState} options.parentState
                              *
                              * @return {SublistLineState}
                              */
                             create: function (options)
                             {
                                 return new SublistLineState(options);
                             }
                         });
});
/**
 * SuiteScript sublist state event module
 *
 * @private
 * @module N/record/sublistStateEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistStateEvent',['N/record/fieldStateEvent'], function(fieldStateEvent)
{
	var EVENT_TYPE = Object.freeze({
			IS_DISPLAY_CHANGE: 'IS_DISPLAY_CHANGE',
			IS_CHANGED_CHANGE: 'IS_CHANGED_CHANGE',
			IS_HIDDEN_CHANGE: 'IS_HIDDEN_CHANGE',
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',
			COLUMN_IS_DISABLED_CHANGE: 'COLUMN_IS_DISABLED_CHANGE',
			COLUMN_IS_MANDATORY_CHANGE: 'COLUMN_IS_MANDATORY_CHANGE',
			COLUMN_IS_DISPLAY_CHANGE: 'COLUMN_IS_DISPLAY_CHANGE,',
			COLUMN_LABEL_CHANGE: 'COLUMN_LABEL_CHANGE'
		});

	var translateFieldStateEventTypeToSublistStateEventType = (function(){
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function(fieldStateEventType){
			return eventTranslations[fieldStateEventType];
		}
	}());

	function translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(sublistState, translateFieldStateEventTypeToSublistStateEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		var lineFieldStateLocation = event.sublistState.findLineForFieldState(fieldStateEvent.fieldState);
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		event.line = lineFieldStateLocation.line;
		event.lineId = lineFieldStateLocation.lineId;
		event.useLineBuffer = lineFieldStateLocation.useLineBuffer;

		return event;
	}

	function getEvent(sublistState, type)
	{
		return {
			type: type,
			sublistState: sublistState
		};
	}

	function addValues(event, oldValue, newValue)
	{
		if(oldValue !== undefined){ event.oldValue = oldValue; }
		if(newValue !== undefined){ event.newValue = newValue; }

		return event;
	}

	function forwardColumnEvent(emitter, sublistState, type, column, oldValue, newValue)
	{
		var event = getEvent(sublistState, type);
		event.fieldId = column;
		emitter.emit(addValues(event, oldValue, newValue));
	}

	function emit(emitter, sublistState, type, oldValue, newValue)
	{
		emitter.emit(addValues(getEvent(sublistState, type), oldValue, newValue));
	}

	function forwardFieldStateEvent(emitter, sublistState, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToSublistStateEvent(sublistState, fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, sublistState, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter, sublistState);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		forwardFieldStateEvents: forwardFieldStateEvents,
		forwardColumnEvent: forwardColumnEvent
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistState
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistState',['N/utilityFunctions', 'N/error', 'N/record/fieldState', 'N/record/sublistLineState', 'N/record/sublistStateEvent', 'N/eventEmitter'],
       function(utilityFunctions, error, fieldState, sublistLineState, sublistStateEvent, eventEmitter){

	       /**
	        * returns {SublistController}
	        * @constructor
	        */
           function SublistController()
           {
               var that = this;
               var sublist = {};

               function lineInstanceIdExists(lineInstanceId)
               {
                   return sublist.hasOwnProperty(lineInstanceId);
               }

               function getLineInstanceIds()
               {
                   return Object.keys(sublist);
               }
               this.getLineInstanceIds = getLineInstanceIds;

               function has(lineInstanceId)
               {
                   var result = false;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = !!sublist[lineInstanceId];
                   }

                   return result;
               }
               this.has = has;

	           /**
	            *
	            * @param {string} lineInstanceId
	            * @returns {SublistLineState}
	            */
               function get(lineInstanceId)
               {
                   var result = null;
                   var hasLineInstanceId = lineInstanceIdExists(lineInstanceId);

                   if(hasLineInstanceId)
                   {
                       result = sublist[lineInstanceId];
                   }

                   return result;
               }
               this.get = get;

               function put(lineInstanceId, value)
               {
                   var previousValue = get(lineInstanceId);
                   sublist[lineInstanceId] = value;
                   return previousValue;
               }
               this.put = put;

               function remove(lineInstanceId)
               {
                   var removedValue = get(lineInstanceId);
                   delete sublist[lineInstanceId];
                   return removedValue;
               }
               this.remove = remove;

	           function getMandatoryFields(lineId, useDefaultState)
	           {
	           	   var result = [];
		           if (sublist.hasOwnProperty(lineId))
		           {
			           var line = sublist[lineId];
			           result = line.getMandatoryFields(useDefaultState);
		           }
		           return result;
	           }
	           this.getMandatoryFields = getMandatoryFields;
           }

        /**
         * sublist state for record sublist
         *
         * @param {Object} options
         * @param {string} options.id sublist name
         * @param {RecordStateController} options.parentState
         * @param {Object} options.sublistStateObj
         * @param {boolean} options.sublistStateObj.allowAddlines
         * @param {boolean} options.sublistStateObj.isDisplay
         * @param {boolean?} options.isMultilineEditable
         * @param {Function} options.getModelController
         * @param {Object} options.fieldMetadata group of field metadata with field id as key
         *
         * @return {SublistState}
         * @constructor
         */
        function SublistState(options)
        {
            var that = this;
            var id = options.id;
            var parentState = options.parentState;
            var sublistStateObj = options.sublistStateObj;
            var fieldMetadata = options.fieldMetadata;
            var getModelController = options.getModelController;
            var lineStatePrototype = {};
            var columnProperties = {};

            var lines = new SublistController();
            var lineBuffers = new SublistController();

            var allowsNewLine = sublistStateObj.allowAddlines || false;
            var isSublistChanged = false;
            var isSublistHidden = sublistStateObj.isHidden;
	        var isSublistDisplay = sublistStateObj.isDisplay && !isSublistHidden;
            var isSublistMultilineEditable = options.isMultilineEditable;

            var emitter = eventEmitter.create();

	        /**
	         * @name SublistState#getIsNSERecord
	         * @function
	         * @return boolean
	         */
	        this.getIsNSERecord = function() { return parentState.getIsNSERecord(); };

	        /**
	         * set column property
	         * @param {string} column
	         * @param {string} property
	         * @param {*} newValue
	         */
            function setColumnProperty(column, property, newValue)
            {
                var fieldMeta = getFieldLevelMetadata(column);
                if (!!fieldMeta && fieldMeta.defaultFieldState.hasOwnProperty(property))
                {
                    if (!columnProperties.hasOwnProperty(column))
	                    columnProperties[column] = fieldMeta.defaultFieldState;

	                var oldValue = columnProperties[column][property];
                    if (oldValue !== newValue) {
	                    columnProperties[column][property] = newValue;
	                    switch (property) {
		                    case 'isDisabled':
			                    sublistStateEvent.forwardColumnEvent(emitter, that, sublistStateEvent.Type.COLUMN_IS_DISABLED_CHANGE, column, oldValue, newValue);
			                    break;
		                    case 'isMandatory':
			                    sublistStateEvent.forwardColumnEvent(emitter, that, sublistStateEvent.Type.COLUMN_IS_MANDATORY_CHANGE, column, oldValue, newValue);
			                    break;
		                    case 'isDisplay':
			                    sublistStateEvent.forwardColumnEvent(emitter, that, sublistStateEvent.Type.COLUMN_IS_DISPLAY_CHANGE, column, oldValue, newValue);
			                    break;
		                    case 'label':
			                    sublistStateEvent.forwardColumnEvent(emitter, that, sublistStateEvent.Type.COLUMN_LABEL_CHANGE, column, oldValue, newValue);
			                    break;
	                    }
                    }
                    changeFieldStatesByColumn(column, property, newValue)
                }
            }
            this.setColumnProperty = setColumnProperty;

            function changeFieldStatesByColumn(fieldId, property, newValue)
            {
                var sublistLines = getSublistlines(true);
                sublistLines.getLineInstanceIds().forEach(function (lineId) {
                    var fs = sublistLines.get(lineId).getFieldState(fieldId);
                    fs[property] = newValue;
                });
                sublistLines = getSublistlines(false);
                sublistLines.getLineInstanceIds().forEach(function (lineId) {
                    var fs = sublistLines.get(lineId).getFieldState(fieldId);
                    fs[property] = newValue;
                });
            }

	        /**
	         *
	         * @param {string} fieldId
	         * @param {string} property
	         * @returns {string|boolean}
	         */
            function getColumnProperty(fieldId, property)
            {
                if (columnProperties.hasOwnProperty(fieldId))
                {
                    if (columnProperties[fieldId].hasOwnProperty(property))
                        return columnProperties[fieldId][property];
                }
                var fieldMeta = getFieldLevelMetadata(fieldId);
                if (!!fieldMeta)
                    return fieldMeta.defaultFieldState[property] ;
            }
            this.getColumnProperty = getColumnProperty;

            function checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId)
            {
            	return !allowsNewLine && !getModelController().isSublistLineInstanceIdValid(id, lineInstanceId, true);
            }

	        /**
	         * get controller for buffer or committed lines
	         * @param {*} isCommitted
	         * @returns {SublistController}
	         */
            function getSublistlines(isCommitted)
            {
                return isCommitted ? lines : lineBuffers;
            }

	        /**
	         * find line for field state
	         * @param {FieldState} fs
	         * @returns {{useLineBuffer: (boolean|null), line: (number|null), lineId: (string|null)}}
	         */
            function findLineForFieldState(fs)
            {
                var result = {
                        useLineBuffer: null,
		                lineId: null,
                        line: null
                    };
                var fieldId = fs.id;
                var parentState = fs.parentState;
                var modelController = getModelController();

                var lineInstanceId = parentState && parentState.lineInstanceId || null;
                var lineInstanceIds = null;
                var sublistLineState = null;
                var found = false;

                if(!found)
                {
                    lineInstanceIds = lineInstanceId ? [lineInstanceId] : lineBuffers.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lineBuffers.get(lineInstanceId);
                        if (!!sublistLineState && sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fs)
                        {
                            found = true;
                            result.useLineBuffer = true;
	                        result.lineId = lineInstanceId;
                            result.line = modelController.getSublistLineIndexForInstance(id, lineInstanceId, !result.useLineBuffer);
                            break;
                        }
                    }
                }

                if(!found)
                {
                    lineInstanceIds = lineInstanceId ? [lineInstanceId] : lines.getLineInstanceIds();
                    for (var i = 0; i < lineInstanceIds.length; i++)
                    {
                        lineInstanceId = lineInstanceIds[i];
                        sublistLineState = lines.get(lineInstanceId);
                        if (!!sublistLineState && sublistLineState.hasFieldState(fieldId) && sublistLineState.getFieldState(fieldId) === fs)
                        {
                            found = true;
                            result.useLineBuffer = false;
                            result.lineId = lineInstanceId;
                            result.line = modelController.getSublistLineIndexForInstance(id, lineInstanceId, !result.useLineBuffer);
                            break;
                        }
                    }
                }

                return result;
            }
            this.findLineForFieldState = findLineForFieldState;

            (function constructor(fieldMetadata){
                lineStatePrototype = {};
                for(var fieldId in fieldMetadata)
                {
                    if(fieldMetadata.hasOwnProperty(fieldId))
                        lineStatePrototype[fieldId] = fieldMetadata[fieldId].defaultFieldState;
                }
            }(fieldMetadata));


            /**
             * name of sublist
             * @name SublistState#id
             * @readonly
             * @type {string}
             */
            Object.defineProperty(this, 'id', {
                get: function ()
                {
                    return id;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is allowed to add line
             * @name SublistState#allowsNewLine
             * @type {boolean}
             * @readonly
             */
            Object.defineProperty(this, 'allowsNewLine', {
                get: function ()
                {
                    return allowsNewLine;
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is on display
             * @name SublistState#isDisplay
             * @type {boolean}
             */
            Object.defineProperty(this, 'isDisplay', {
                get: function ()
                {
                    return isSublistDisplay;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistDisplay !== val) && !isSublistHidden)
                    {
                        var oldValue = isSublistDisplay;
                        isSublistDisplay = val;
                        var newValue = isSublistDisplay;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_DISPLAY_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is changed
             * @name SublistState#isChanged
             * @type {boolean}
             */
            Object.defineProperty(this, 'isChanged', {
                get: function ()
                {
                    return isSublistChanged;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistChanged !== val))
                    {
                        var oldValue = isSublistChanged;
                        isSublistChanged = val;
                        var newValue = isSublistChanged;
                        if(val === true && parentState)
                            parentState.isChanged = true;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_CHANGED_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });
            /**
             * return true if sublist is hidden
             * @name SublistState#isHidden
             * @type {boolean}
             */
            Object.defineProperty(this, 'isHidden', {
                get: function ()
                {
                    return isSublistHidden;
                },
                set: function (val)
                {
                    if(util.isBoolean(val) && (isSublistHidden !== val))
                    {
                        var oldValue = isSublistHidden;
                        isSublistHidden = val;
                        var newValue = isSublistHidden;
                        sublistStateEvent.emit(emitter, that, sublistStateEvent.Type.IS_HIDDEN_CHANGE, oldValue, newValue);
                    }
                },
                enumerable: true,
                configurable: false
            });

	        /**
	         * Return true if sublist has multi-line buffer feature enabled.
	         * @name SublistState#isMultilineEditable
	         * @readonly
	         * @type {boolean}
	         */
	        utilityFunctions.addReadOnlyNonEnumerableProperty(this, 'isMultilineEditable', function () { return isSublistMultilineEditable || that.getIsNSERecord(); });

            function getFieldLevelMetadata(fieldId)
            {
                return fieldMetadata.hasOwnProperty(fieldId) ? fieldMetadata[fieldId] : null;
            }

            function getOrCreateFieldState(fieldId, lineInstanceId, isCommitted)
            {
            	var fs = null;
            	var sublistlineState = getOrCreateLineState(lineInstanceId, isCommitted);

				// check if field already exists and return
            	if (sublistlineState.hasFieldState(fieldId))
	            {
	            	return sublistlineState.getFieldState(fieldId);
	            }
				// check if field exists on committed line and clone it if so
	            if(!isCommitted && getSublistlines(true).has(lineInstanceId))
	            {
		            var committedLineState = getSublistlines(true).get(lineInstanceId);
		            if (committedLineState.hasFieldState(fieldId))
		            {
			            fs = fieldState.clone(committedLineState.getFieldState(fieldId), sublistlineState, {isParsed: false});
		            }
	            }
	            // create field from metadata or just by name
	            if (!fs)
	            {
	                var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
	                if(fieldLevelMetadata)
	                {
	                    fs = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata, parentState: sublistlineState, parentSublistState: that});
	                }
	                else
	                {
	                    var fsObj = {name: fieldId, label: fieldId};
	                    addField(fieldId, fsObj);
	                    fs = fieldState.create({fieldState: fsObj, parentState: sublistlineState, parentSublistState: that});
	                }
                }
                sublistStateEvent.forwardFieldStateEvents(emitter, that, fs);
	            sublistlineState.addFieldState(fieldId, fs);

                return fs;
            }

            /**
             * add field state for virtual field and apply to all rows
             * @param {String} fieldId
             * @param {Object} state
             */
            function addField(fieldId, state)
            {
                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
	                var thisLine = lineBuffers.get(lineInstanceId);
                    var fs = fieldState.create({fieldState: {name: fieldId, label: fieldId}, parentState: thisLine, parentSublistState: that});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fs);
                    thisLine.addFieldState(fieldId, fs);
                });

                lines.getLineInstanceIds().forEach(function(lineInstanceId){
	                var thisLine = lines.get(lineInstanceId);
                    var fs = fieldState.create({fieldState: {name: fieldId, label: fieldId}, parentState: thisLine, parentSublistState: that});
                    sublistStateEvent.forwardFieldStateEvents(emitter, that, fs);
	                thisLine.addFieldState(fieldId, fs);
                });

                lineStatePrototype[fieldId] = state;
            }

	        /**
	         * remove field state from sublist line state
	         * @param {string} fieldId
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         */
            function removeFieldStateForInstance(fieldId, lineInstanceId, isCommitted)
            {
                var sublistlineState = getSublistlines(isCommitted).get(lineInstanceId);
                if(!!sublistlineState)
                {
                    sublistlineState.removeFieldState(fieldId);
                }
            }
            this.removeFieldStateForInstance = removeFieldStateForInstance;

	        /**
	         * return the field state in a line
	         * @param {string} fieldId
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         * @returns {FieldState}
	         */
            function getFieldStateForInstance(fieldId, lineInstanceId, isCommitted)
            {
                validateLineInstanceId(lineInstanceId, isCommitted);
				return getOrCreateFieldState(fieldId, lineInstanceId, isCommitted);
            }
            this.getFieldStateForInstance = getFieldStateForInstance;


	        /**
	         * Get information about probable update of buffer
	         * When buffer is updated we need invalidate model controller caches for fields.
	         * Right now we don't have a way how to pass this information.
	         * Note: This need to be checked only for case when we touched uncommited lines.
	         * @param {string} lineInstanceId
	         * @param {bollean} isCommitted
	         * @return {false|boolean}
	         */
			function willCallOfGetFieldStateForInstanceCauseUpdateOfBuffer(lineInstanceId, isCommitted)
			{
				validateLineInstanceId(lineInstanceId, isCommitted);
				return !isCommitted && !getSublistlines(isCommitted).has(lineInstanceId) && getSublistlines(!isCommitted).has(lineInstanceId);
			}
			this.willCallOfGetFieldStateForInstanceCauseUpdateOfBuffer = willCallOfGetFieldStateForInstanceCauseUpdateOfBuffer;

			function validateLineInstanceId(lineInstanceId, isCommitted)
			{
				var modelController = getModelController();

				var isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted);
				if (!isLineInstanceValid && !isCommitted)
				{
					isLineInstanceValid = modelController.isSublistLineInstanceIdValid(id, lineInstanceId, true);
				}

				if (!isLineInstanceValid)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
				}
			}

            function getOrCreateLineState(lineInstanceId, isCommitted)
            {
	            var sublistLines = getSublistlines(isCommitted);
	            if(!sublistLines.has(lineInstanceId))
	            {
		            if (!isCommitted && getSublistlines(!isCommitted).has(lineInstanceId))
		            {
			            resetBufferLineStateForInstance(lineInstanceId);
		            }
		            else
		            {
			            insertLineForInstance(lineInstanceId, isCommitted);
		            }
	            }
            	return sublistLines.get(lineInstanceId);
            }

            function getLineStatePropotype()
            {
                var prototype = {};
                for(var fieldId in lineStatePrototype)
                {
                    if(lineStatePrototype.hasOwnProperty(fieldId))
                        prototype[fieldId] = util.extend({}, lineStatePrototype[fieldId]);
                    if (!!columnProperties[fieldId]){
	                    prototype[fieldId] = util.extend(prototype[fieldId], columnProperties[fieldId]);
                    }
                }

                return prototype;
            }

			function getLinePrototypeFieldStates(newParentState)
			{
				var linePrototype = getLineStatePropotype();
				return Object.keys(linePrototype).reduce(function(result, fieldId) {
					result[fieldId] = fieldState.create({fieldState: linePrototype[fieldId], parentState: newParentState, parentSublistState: that});
					return result;
				}, {});
			}

            function createClonedLineStateForInstance(lineInstanceId, isCommitted)
            {
                var sublistlineStateClone = null;
                var modelController = getModelController();

                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted))
                {
                    var sublistlines = getSublistlines(isCommitted);

                    if(sublistlines.has(lineInstanceId))
                    {
                        var sublistlineState = sublistlines.get(lineInstanceId);

                        sublistlineStateClone = sublistLineState.create({
	                        fieldStatesProvider: function(targetLineState) { return doForwardFieldStateEvents(sublistlineState.getClonedFieldStates(targetLineState)); } ,
                            line: sublistlineState.lineNum,
	                        lineInstanceId : lineInstanceId,
	                        parentState: that
                        });

                        sublistlineStateClone.isInserted = sublistlineState.isInserted;
                        sublistlineStateClone.isChanged = sublistlineState.isChanged;
                    }
                    else
                    {
                        sublistlineStateClone = sublistLineState.create({
	                        fieldStatesProvider: function(targetLineState) { return doForwardFieldStateEvents(getLinePrototypeFieldStates(targetLineState)); },
                            line: modelController.getSublistLineIndexForInstance(id, lineInstanceId),
	                        lineInstanceId : lineInstanceId,
	                        parentState: that
                        });
                    }
                }

                return sublistlineStateClone;
            }

            function doForwardFieldStateEvents(fieldStates)
            {
	            Object.keys(fieldStates).forEach(function(fieldId) {
		            sublistStateEvent.forwardFieldStateEvents(emitter, that, fieldStates[fieldId]);
	            });
	            return fieldStates;
            }

            /**
             * initiate the line states by record data
             */
            function init()
            {
                var modelController = getModelController();
                lines.getLineInstanceIds().forEach(function(lineInstanceId){
                    lines.remove(lineInstanceId);
                });
                lineBuffers.getLineInstanceIds().forEach(function(lineInstanceId){
                    lineBuffers.remove(lineInstanceId);
                });

                modelController.getSublistLineInstanceIds(id, true).forEach(function(lineInstanceId)
                {
	                var lineIndex = modelController.getSublistLineIndexForInstance(id, lineInstanceId);
                    var linestate = sublistLineState.create({
	                    fieldStatesProvider: function(targetLineState) { return doForwardFieldStateEvents(getLinePrototypeFieldStates(targetLineState)); },
	                    line: lineIndex,
	                    lineInstanceId: lineInstanceId,
	                    parentState: that
                    });

                    lines.put(lineInstanceId, linestate);
                });
            }
            this.init = init;

            /**
             * return all the field names
             * @returns {Array<String>} fieldnames
             */
            function getAllFields()
            {
            	return Object.keys(lineStatePrototype);
            }
            this.getAllFields = getAllFields;

	        /**
	         *
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         * @returns {Array<string>}
	         */
            function getAllLineFieldsForInstance(lineInstanceId, isCommitted)
            {
                var result = null,
                    sublistlineState = getSublistlines(isCommitted).get(lineInstanceId);

                if(!!sublistlineState && !!sublistlineState.getAllFields)
                {
                    result = sublistlineState.getAllFields();
                }

                return result;
            }
            this.getAllLineFieldsForInstance = getAllLineFieldsForInstance;

	        /**
	         * remove sublist line state for instance
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         */
            function removeSublistLineState(lineInstanceId, isCommitted)
            {
                getSublistlines(isCommitted).remove(lineInstanceId);
            }
            this.removeSublistLineState = removeSublistLineState;

	        /**
	         * update buffered line state
	         * @param {string} lineInstanceId
	         * @return {boolean} was updated
	         */
			function updateBufferLineStateForInstance(lineInstanceId)
	        {
				if(!isSublistMultilineEditable || !getSublistlines(false).has(lineInstanceId))
				{
					resetBufferLineStateForInstance(lineInstanceId);
					return true;
				}

				return false;
			}
	        this.updateBufferLineStateForInstance = updateBufferLineStateForInstance;

	        /**
             * reload a line state buffer by for givent instanceId
             * @param {string} lineInstanceId
             */
            function resetBufferLineStateForInstance(lineInstanceId)
            {
                removeBufferLineForInstance(lineInstanceId);
                var sublistlineState = createClonedLineStateForInstance(lineInstanceId, true);
                if(!sublistlineState)
                {
                    sublistlineState = createClonedLineStateForInstance(lineInstanceId, false);
                }

                getSublistlines(false).put(lineInstanceId, sublistlineState);
            }

	        /**
	         * clone line state
	         * @param {string} sourceLineInstanceId
	         * @param {boolean} isSourceCommitted
	         * @param {string} targetLineInstanceId
	         */
            function cloneLineStateToLineCopy(sourceLineInstanceId, isSourceCommitted, targetLineInstanceId)
            {
	            var line = getModelController().getSublistLineIndexForInstance(id, targetLineInstanceId, false);
	            var sublistlineState = createClonedLineStateForInstance(sourceLineInstanceId, isSourceCommitted);
	            sublistlineState.lineNum = line; // TODO: include in the cloning method
	            sublistlineState.lineInstanceId = targetLineInstanceId; // TODO: include in the cloning method

	            getSublistlines(false).put(targetLineInstanceId, sublistlineState);
            }
            this.cloneLineStateToLineCopy = cloneLineStateToLineCopy;

            /**
             * commit the current line state buffer to actual line state
             * @param {string} lineInstanceId
             */
            function commitLineForInstance(lineInstanceId)
            {
                if(lineBuffers.has(lineInstanceId))
                {
                    var sublistlineState = lineBuffers.remove(lineInstanceId);
                    sublistlineState.isInserted = false;
                    lines.put(lineInstanceId, sublistlineState);
                    that.isChanged = true;
                }
            }
            this.commitLineForInstance = commitLineForInstance;

            /**
             * insert a new LineState
             * @param {string} lineInstanceId of inserted line
             * @param {boolean} isCommitted buffered or committed line state
             */
            function insertLineForInstance(lineInstanceId, isCommitted)
            {
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                var modelController = getModelController();
                if(modelController.isSublistLineInstanceIdValid(id, lineInstanceId, isCommitted))
                {
                    var sublistlineState = sublistLineState.create({
	                    fieldStatesProvider: function(targetLineState) { return doForwardFieldStateEvents(getLinePrototypeFieldStates(targetLineState)); },
	                    line : -1,
	                    lineInstanceId : lineInstanceId,
	                    parentState: that
                    });
                    sublistlineState.isInserted = true;
                    getSublistlines(isCommitted).put(lineInstanceId, sublistlineState);
                }
            }
            this.insertLineForInstance = insertLineForInstance;

	        /**
	         * return true if line is inserted
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         * @returns {boolean}
	         */
            function isLineInsertedForInstance(lineInstanceId, isCommitted)
            {
                var result = false;
                var sublistlines = getSublistlines(isCommitted);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isInserted;
                }

                return result;
            }
            this.isLineInsertedForInstance = isLineInsertedForInstance;

	        /**
	         * remove buffered line state
	         * @param {string} lineInstanceId
	         */
	        function removeBufferLineForInstance(lineInstanceId)
	        {
		        if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
			        utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

		        getSublistlines(false).remove(lineInstanceId);
	        }

	        /**
	         * remove both committed and buffered line states
	         * @param {string} lineInstanceId
	         */
            function removeLineForInstance(lineInstanceId)
            {
                if (checkIfMachineDoesNotAllowsChangeForInstance(lineInstanceId))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);

                getSublistlines(false).remove(lineInstanceId);
	            getSublistlines(true).remove(lineInstanceId);
            }
            this.removeLineForInstance = removeLineForInstance;

            /**
             * return true if line is removed
             * @param {string} lineInstanceId
             * @param {boolean} isCommitted
             * @returns {boolean}
             */
            function isLineRemovedForInstance(lineInstanceId, isCommitted)
            {
            	var sublistLines = getSublistlines(isCommitted);
                return !sublistLines.has(lineInstanceId) /* || sublistLines.get(lineInstanceId).lineNum < 0 */; // TODO: validate this condition
            }
            this.isLineRemovedForInstance = isLineRemovedForInstance;

	        /**
	         * return true if line is changed
	         * @param {string} lineInstanceId
	         * @param {boolean} isCommitted
	         * @returns {boolean}
	         */
            function isLineChangedForInstance(lineInstanceId, isCommitted)
            {
                var result = false;
                var sublistlines = getSublistlines(isCommitted);

                if(sublistlines.has(lineInstanceId))
                {
                    var sublistlineState = sublistlines.get(lineInstanceId);
                    result = sublistlineState.isChanged;
                }

                return result;
            }
            this.isLineChangedForInstance = isLineChangedForInstance;

            /**
             * return the instanceId of committed or buffered lines
             * @param {boolean} isCommitted
             * @return {Array<string>}
             */
            function getLineInstanceIds(isCommitted)
            {
                return (isCommitted ? lines : lineBuffers).getLineInstanceIds();
            }
            this.getLineInstanceIds = getLineInstanceIds;

	        function getMandatoryFields(lineId, isCommitted, useDefaultState)
	        {
		        return (isCommitted ? lines : lineBuffers).getMandatoryFields(lineId, useDefaultState);
	        }
	        this.getMandatoryFields = getMandatoryFields;

            this.on = emitter.on;
            this.off = emitter.off;

            return this;
        }
        Object.freeze(SublistState);

        return Object.freeze({
                                /**
                                 * create a new instance of sublist state
                                 *
                                 * @param {Object} options
                                 * @param {String} options.id
                                 * @param {Object} options.sublistStateObj
                                 * @param {RecordStateController} options.parentState
                                 * @param {Object} options.fieldMetadata
                                 * @param {boolean?} options.isMultilineEditable
                                 * @param {Function} options.getModelController
                                 *
                                 * @return {SublistState}
                                 */
                                create: function (options) { return new SublistState(options); }
                            });
});

/**
 * SuiteScript record state controller event module
 *
 * @private
 * @module N/record/recordStateControllerEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateControllerEvent',['N/record/fieldStateEvent', 'N/record/sublistStateEvent'], function(fieldStateEvent, sublistStateEvent) {
	var EVENT_TYPE = Object.freeze({
			FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
			FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
			FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
			FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
			FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
			FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
			FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',
			SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
			SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
			SUBLIST_COLUMN_IS_DISABLED_CHANGE: 'SUBLIST_COLUMN_IS_DISABLED_CHANGE',
			SUBLIST_COLUMN_IS_MANDATORY_CHANGE: 'SUBLIST_COLUMN_IS_MANDATORY_CHANGE',
			SUBLIST_COLUMN_IS_DISPLAY_CHANGE: 'SUBLIST_COLUMN_IS_DISPLAY_CHANGE',
			SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE'
		});

	function getEvent(type)
	{
		return {
			type: type
		}
	}

	var translateFieldStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[fieldStateEvent.Type.IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[fieldStateEvent.Type.IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[fieldStateEvent.Type.LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addFieldStateEventDetails(event, fieldStateEvent)
	{
		event.fieldId = fieldStateEvent.fieldState.id;
		if(fieldStateEvent.oldValue !== undefined){ event.oldValue = fieldStateEvent.oldValue; }
		if(fieldStateEvent.newValue !== undefined){ event.newValue = fieldStateEvent.newValue; }
		return event;
	}

	function translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent)
	{
		return addFieldStateEventDetails(getEvent(translateFieldStateEventTypeToRecordControllerEventType(fieldStateEvent.type)), fieldStateEvent);
	}

	function forwardFieldStateEvent(emitter, fieldStateEvent)
	{
		emitter.emit(translateFieldStateEventToRecordControllerStateEvent(fieldStateEvent));
	}

	function forwardFieldStateEvents(emitter, fieldState)
	{
		var forward = forwardFieldStateEvent.bind(null, emitter);

		fieldState.on({
			types: [
				fieldStateEvent.Type.IS_MANDATORY_CHANGE,
				fieldStateEvent.Type.IS_HIDDEN_CHANGE,
				fieldStateEvent.Type.IS_DISABLED_CHANGE,
				fieldStateEvent.Type.IS_VISIBLE_CHANGE,
				fieldStateEvent.Type.IS_DISPLAY_CHANGE,
				fieldStateEvent.Type.IS_READ_ONLY_CHANGE,
				fieldStateEvent.Type.LABEL_CHANGE
			],
			listener: forward
		});
	}

	var translateSublistStateEventTypeToRecordControllerEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistStateEvent.Type.IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[sublistStateEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;
		eventTranslations[sublistStateEvent.Type.COLUMN_IS_DISABLED_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_DISABLED_CHANGE;
		eventTranslations[sublistStateEvent.Type.COLUMN_IS_MANDATORY_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_MANDATORY_CHANGE;
		eventTranslations[sublistStateEvent.Type.COLUMN_IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_DISPLAY_CHANGE;
		eventTranslations[sublistStateEvent.Type.COLUMN_LABEL_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistStateEventDetails(event, sublistStateEvent)
	{
		event.sublistId = sublistStateEvent.sublistState.id;
		if(sublistStateEvent.hasOwnProperty('fieldId'))
		{
			event.line = sublistStateEvent.line;
			event.lineId = sublistStateEvent.lineId;
			event.useLineBuffer = sublistStateEvent.useLineBuffer;
			event.fieldId = sublistStateEvent.fieldId;
		}
		if(sublistStateEvent.oldValue !== undefined){ event.oldValue = sublistStateEvent.oldValue; }
		if(sublistStateEvent.newValue !== undefined){ event.newValue = sublistStateEvent.newValue; }

		return event;
	}

	function translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent)
	{
		return addSublistStateEventDetails(getEvent(translateSublistStateEventTypeToRecordControllerEventType(sublistStateEvent.type)), sublistStateEvent);
	}

	function forwardSublistStateEvent(emitter, sublistStateEvent)
	{
		emitter.emit(translateSublistStateEventToRecordControllerStateEvent(sublistStateEvent));
	}

	function forwardSublistStateEvents(emitter, sublistState)
	{
		var forward = forwardSublistStateEvent.bind(null, emitter);

		sublistState.on({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.COLUMN_LABEL_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistStateEvents(sublistState)
	{
		sublistState.off({
			types: [
				sublistStateEvent.Type.IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				sublistStateEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				sublistStateEvent.Type.FIELD_LABEL_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_DISABLED_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_MANDATORY_CHANGE,
				sublistStateEvent.Type.COLUMN_IS_DISPLAY_CHANGE,
				sublistStateEvent.Type.COLUMN_LABEL_CHANGE
			]
		})
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		forwardFieldStateEvents: forwardFieldStateEvents,
		forwardSublistStateEvents: forwardSublistStateEvents,
		unforwardSublistStateEvents: unforwardSublistStateEvents
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordStateController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordStateController',['N/record/fieldState', 'N/record/sublistState', 'N/record/recordStateControllerEvent', 'N/eventEmitter'], function(fieldState, sublistState, recordStateControllerEvent, eventEmitter){

   function createSublistState(sublistId, parentState, sublistMetadata, getModelController)
   {
      var state = sublistState.create({
            id: sublistId,
            parentState: parentState,
            sublistStateObj: sublistMetadata.defaultState,
            fieldMetadata: sublistMetadata.fieldMetadata,
            getModelController: getModelController,
	        isMultilineEditable: sublistMetadata.isMultilineEditable
         });
      state.init();

      return state;
   }

    /**
     * record state controller
     * @param {Object} options
     * @param {Metadata} options.metadata
     * @param {Function} options.getModelController
     * @param {Function} options.getIsNSERecord
     * @constructor
     */
    function RecordStateController(options)
    {
        var that = this;
        var metadata = options.metadata;
        var getModelController = options.getModelController;
        var getIsNSERecord = options.getIsNSERecord;
        var isChanged = false;
        var emitter = eventEmitter.create();

        var fieldStates = {};
        var sublistStates = {};

        (function constructor(metadata, getModelController){
            var sublists = metadata.sublistIds;
            sublists.forEach(function(sublistId){
                var sublistMetadata = metadata.getSublistMetadata(sublistId);
                if(sublistMetadata)
                {
                   var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
                   recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
                    sublistStates[sublistId] = sublist;
                }
            });
        })(metadata, getModelController);

	    /**
	     * @name RecordStateController#getIsNSERecord
	     * @function
	     * @return boolean
	     */
        this.getIsNSERecord = function() { return getIsNSERecord(); };

        /**
         * is record changed by any operations
         * @name RecordStateController#isChanged
         * @type {boolean}
         */
        Object.defineProperty(this, 'isChanged', {
            get: function ()
            {
                return isChanged;
            },
            set: function (val)
            {
                if(util.isBoolean(val))
                    isChanged = val;
            },
            enumerable: true,
            configurable: false
        });

        function createNewFieldState(fieldId)
        {
            var state;
            var fieldLevelMetadata = metadata.getFieldMetadata(undefined, fieldId);
            if(fieldLevelMetadata)
            {
                state = fieldState.createBasedOnFieldLevelMetadata({metadata: fieldLevelMetadata, parentState: that});
            }
            else
            {
               state = fieldState.create({parentState: that, fieldState: {name: fieldId, label: fieldId}});
            }
           recordStateControllerEvent.forwardFieldStateEvents(emitter, state);

            return state;
        }

        /**
         * remove field state
         * @param {string} fieldId
         */
        function removeFieldState(fieldId)
        {
            if(fieldStates.hasOwnProperty(fieldId))
                delete fieldStates[fieldId];
        }
        this.removeFieldState = removeFieldState;

        /**
         * return field state for record field
         * @param {string} fieldId
         * @return {FieldState}
         */
        function getFieldState(fieldId)
        {
            var state;
            if(fieldStates.hasOwnProperty(fieldId))
                state = fieldStates[fieldId];
            else
            {
                state = createNewFieldState(fieldId);
                fieldStates[fieldId] = state;
            }

            return state;
        }
        this.getFieldState = getFieldState;

        /**
         * return the sublist state of record sublist
         * @param {string} sublistId
         * @returns {SublistState}
         */
        function getSublistState(sublistId)
        {
            var state = null;
            if(sublistStates.hasOwnProperty(sublistId))
                state = sublistStates[sublistId];

            return state;
        }
        this.getSublistState = getSublistState;

	    /**
	     * add the sublist state for record sublist
	     * @param {string} sublistId
	     * @param {Function} getModelController callback returning the model controller reference
	     */
        function addSublist(sublistId, getModelController)
        {
            removeSublist(sublistId);
            var sublistMetadata = metadata.getSublistMetadata(sublistId);
           var sublist = createSublistState(sublistId, that, sublistMetadata, getModelController);
           recordStateControllerEvent.forwardSublistStateEvents(emitter, sublist);
            sublistStates[sublistId] = sublist;
        }
        this.addSublist = addSublist;

	    /**
	     * remove the sublist state of record sublist
	     * @param {string} sublistId
	     */
        function removeSublist(sublistId)
        {
            var sublist = sublistStates[sublistId];
            if(!!sublist)
            {
                delete sublistStates[sublistId];
                recordStateControllerEvent.unforwardSublistStateEvents(emitter, sublist);
            }
        }

	    /**
	     * return all body field states of a record
	     * @returns {Array<string>}
	     */
        function getAllFields()
        {
            var arr = [];
            for(var f in fieldStates)
                if(fieldStates.hasOwnProperty(f))
                    arr.push(f);
            return arr;
        }
        this.getAllFields = getAllFields;

	    /**
	     * return all sublist ids a record
	     * @returns {Array<string>}
	     */
        function getAllSublists()
        {
            var arr = [];
            for(var sublistId in sublistStates)
                if(sublistStates.hasOwnProperty(sublistId))
                    arr.push(sublistId);
            return arr;
        }
        this.getAllSublists = getAllSublists;

      this.on = emitter.on;
      this.off = emitter.off;
    }

    return {
        /**
         * @function
         * return a new instance of RecordStateController
         * @param {Object} options
         * @returns {RecordStateController}
         */
        create: function(options) { return new RecordStateController(options); },
        /**
         * return true if object is an instance of FieldStates
         * @param {*} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof RecordStateController; }
    };
});
/**
 * SuiteScript field util module
 *
 * @private
 * @module N/fieldUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/fieldUtil',["N/utilityFunctions"],
	function(utilityFunctions)
	{
		var CUSTPAGE_PREFIX = 'custpage';

		function isPrefixedWithCustPage(fieldName)
		{
			return (!utilityFunctions.isValEmpty(fieldName)) && (fieldName.indexOf(CUSTPAGE_PREFIX) === 0)
		}

		return {
					isPrefixedWithCustPage: isPrefixedWithCustPage,
			   };
	});
/**
 * SuiteScript module
 *
 * @private
 * @module N/util/validator
 * @suiteScriptVersion 2.x
 */
define(
	'N/util/validator',['N/util/date','N/error','N/format','N/fieldTypeConstants','N/utilityFunctions', 'N/FieldValidationHelper'],
	function (DateUtil, error, format, fieldTypeConstants, utilityFunctions, FieldValidationHelper){

		// For Email Validation  
		var TLD_PATTERN = "zw|zuerich|zone|zm|zippo|zip|zero|zara|zappos|za|yun|yt|youtube|you|yokohama|yoga|yodobashi|ye|yandex|yamaxun|yahoo|yachts|xyz|xxx|xperia|xn--zfr164b|xn--ygbi2ammx|xn--yfro4i67o|xn--y9a3aq|xn--xkc2dl3a5ee0h|xn--xkc2al3hye2a|xn--xhq521b|xn--wgbl6a|xn--wgbh1c|xn--w4rs40l|xn--w4r85el8fhu5dnra|xn--vuq861b|xn--vhquv|xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--unup4y|xn--tiq49xqyj|xn--tckwe|xn--t60b56a|xn--ses554g|xn--s9brj9c|xn--rovu88b|xn--rhqv96g|xn--qxam|xn--qcka1pmc|xn--q9jyb4c|xn--pssy2u|xn--pgbs0dh|xn--pbt977c|xn--p1ai|xn--p1acf|xn--ogbpf8fl|xn--o3cw4h|xn--nyqy26a|xn--nqv7fs00ema|xn--nqv7f|xn--node|xn--ngbe9e0a|xn--ngbc5azd|xn--mxtq1m|xn--mk1bu44c|xn--mix891f|xn--mgbx4cd0ab|xn--mgbtx2b|xn--mgbt3dhd|xn--mgbpl2fh|xn--mgbi4ecexp|xn--mgberp4a5d4ar|xn--mgbca7dzdo|xn--mgbc0a9azcg|xn--mgbbh1a71e|xn--mgbb9fbpob|xn--mgbayh7gpa|xn--mgbab2bd|xn--mgbaam7a8h|xn--mgba7c0bbn0a|xn--mgba3a4f16a|xn--mgba3a3ejt|xn--mgb9awbf|xn--lgbbat1ad8j|xn--l1acc|xn--kput3i|xn--kpu716f|xn--kpry57d|xn--kprw13d|xn--kcrx77d1x4a|xn--jvr189m|xn--jlq61u9w7b|xn--j6w193g|xn--j1amh|xn--j1aef|xn--io0a7i|xn--imr513n|xn--i1b6b1a6a2e|xn--hxt814e|xn--h2brj9c|xn--gk3at1e|xn--gecrj9c|xn--gckr3f0f|xn--g2xx48c|xn--fzys8d69uvgm|xn--fzc2c9e2c|xn--fpcrj9c3d|xn--flw351e|xn--fjq720a|xn--fiqz9s|xn--fiqs8s|xn--fiq64b|xn--fiq228c5hs|xn--fhbei|xn--fct429k|xn--estv75g|xn--efvy88h|xn--eckvdtc9d|xn--e1a4c|xn--d1alf|xn--d1acj3b|xn--czru2d|xn--czrs0t|xn--czr694b|xn--co-pka|xn--clchc0ea0b2g2a9gcd|xn--cg4bki|xn--cck2b3b|xn--c2br7g|xn--c1avg|xn--bck1b9a5dre4c|xn--b4w605ferd|xn--9krt00a|xn--9et52u|xn--9dbq2a|xn--90ais|xn--90ae|xn--90a3ac|xn--8y0a063a|xn--80aswg|xn--80asehdb|xn--80aqecdr1a|xn--80ao21a|xn--80adxhks|xn--6qq986b3xl|xn--6frz82g|xn--5tzm5g|xn--5su34j936bgsg|xn--55qx5d|xn--55qw42g|xn--54b7fta0cc|xn--4gbrim|xn--45q11c|xn--45brj9c|xn--42c2d9a|xn--3pxu8k|xn--3oq18vl8pn36a|xn--3e0b707e|xn--3ds443g|xn--3bst00m|xn--30rr7y|xn--1qqw23a|xn--1ck2e1b|xn--11b4c3d|xin|xihuan|xfinity|xerox|xbox|wtf|wtc|ws|wow|world|works|work|woodside|wolterskluwer|wme|winners|wine|windows|win|williamhill|wiki|wien|whoswho|wf|weir|weibo|wedding|wed|website|weber|webcam|weatherchannel|weather|watches|watch|warman|wanggou|wang|walter|walmart|wales|vuelos|vu|voyage|voto|voting|vote|volvo|volkswagen|vodka|vn|vlaanderen|vivo|viva|vistaprint|vista|vision|visa|virgin|vip|vin|villas|viking|vig|video|viajes|vi|vg|vet|versicherung|verisign|ventures|vegas|ve|vc|vanguard|vana|vacations|va|uz|uy|us|ups|uol|uno|university|unicom|uk|ug|uconnect|ubs|ubank|ua|tz|tw|tvs|tv|tushu|tunes|tui|tube|tt|trv|trust|travelersinsurance|travelers|travelchannel|travel|training|trading|trade|tr|toys|toyota|town|tours|total|toshiba|toray|top|tools|tokyo|today|to|tn|tmall|tm|tl|tkmaxx|tk|tjx|tjmaxx|tj|tirol|tires|tips|tiffany|tienda|tickets|tiaa|theatre|theater|thd|th|tg|tf|teva|tennis|temasek|telefonica|telecity|tel|technology|tech|team|tdk|td|tci|tc|taxi|tax|tattoo|tatar|tatamotors|target|taobao|talk|taipei|tab|sz|systems|symantec|sydney|sy|sx|swiss|swiftcover|swatch|sv|suzuki|surgery|surf|support|supply|supplies|sucks|su|style|study|studio|stream|store|storage|stockholm|stcgroup|stc|statoil|statefarm|statebank|starhub|star|staples|stada|st|srt|srl|sr|spreadbetting|spot|spiegel|space|soy|sony|song|solutions|solar|sohu|software|softbank|social|soccer|so|sncf|sn|smile|smart|sm|sling|sl|skype|sky|skin|ski|sk|sj|site|singles|sina|silk|si|shriram|showtime|show|shouji|shopping|shop|shoes|shiksha|shia|shell|shaw|sharp|shangrila|sh|sg|sfr|sexy|sex|sew|seven|ses|services|sener|select|seek|security|secure|seat|se|sd|scot|scor|scjohnson|science|schwarz|schule|school|scholarships|schmidt|schaeffler|scb|sca|sc|sbs|sbi|sb|saxo|save|sas|sarl|sapo|sap|sanofi|sandvikcoromant|sandvik|samsung|samsclub|salon|sale|sakura|safety|safe|saarland|sa|ryukyu|rwe|rw|run|ruhr|ru|rsvp|rs|room|rogers|rodeo|rocks|rocher|ro|rmit|rip|rio|ril|rightathome|ricoh|richardli|rich|rexroth|reviews|review|restaurant|rest|republican|report|repair|rentals|rent|ren|reliance|reit|reisen|reise|rehab|redumbrella|redstone|red|recipes|realty|realtor|realestate|read|re|raid|radio|racing|qvc|quest|quebec|qpon|qa|py|pwc|pw|pub|pt|ps|prudential|pru|protection|property|properties|promo|progressive|prof|productions|prod|pro|prime|press|praxi|pramerica|pr|post|porn|politie|poker|pohl|pnc|pn|pm|plus|plumbing|playstation|play|place|pl|pk|pizza|pioneer|pink|ping|pin|pid|pictures|pictet|pics|piaget|physio|photos|photography|photo|philips|pharmacy|ph|pg|pfizer|pf|pet|pe|pccw|pay|passagens|party|parts|partners|pars|paris|panerai|panasonic|pamperedchef|page|pa|ovh|ott|otsuka|osaka|origins|orientexpress|organic|org|orange|oracle|open|ooo|onyourside|online|onl|ong|one|omega|om|ollo|oldnavy|olayangroup|olayan|okinawa|office|off|observer|obi|nz|nyc|nu|ntt|nrw|nra|nr|np|nowtv|nowruz|now|norton|northwesternmutual|nokia|no|nl|nissay|nissan|ninja|nikon|nike|nico|ni|nhk|ngo|ng|nfl|nf|nexus|nextdirect|next|news|newholland|new|neustar|network|netflix|netbank|net|nec|ne|nc|nba|navy|natura|nationwide|name|nagoya|nadex|nab|na|mz|my|mx|mw|mv|mutuelle|mutual|museum|mu|mtr|mtpc|mtn|mt|msd|ms|mr|mq|mp|movistar|movie|mov|motorcycles|moto|moscow|mortgage|mormon|mopar|montblanc|monster|money|monash|mom|moi|moe|moda|mobily|mobi|mo|mn|mma|mm|mls|mlb|ml|mk|mitsubishi|mit|mint|mini|mil|microsoft|miami|mh|mg|metlife|meo|menu|men|memorial|meme|melbourne|meet|media|med|me|md|mckinsey|mcdonalds|mcd|mc|mba|mattel|maserati|marshalls|marriott|markets|marketing|market|mango|management|man|makeup|maison|maif|madrid|macys|ma|ly|lv|luxury|luxe|lupin|lundbeck|lu|ltda|ltd|lt|ls|lr|lplfinancial|lpl|love|lotto|lotte|london|lol|loft|locus|locker|loans|loan|lk|lixil|living|live|lipsy|link|linde|lincoln|limo|limited|lilly|like|lighting|lifestyle|lifeinsurance|life|lidl|liaison|li|lgbt|lexus|lego|legal|lefrak|leclerc|lease|lds|lc|lb|lawyer|law|latrobe|latino|lat|lasalle|lanxess|landrover|land|lancome|lancia|lancaster|lamer|lamborghini|ladbrokes|lacaixa|la|kz|kyoto|ky|kw|kuokgroup|kred|krd|kr|kpn|kpmg|kp|kosher|komatsu|koeln|kn|km|kiwi|kitchen|kindle|kinder|kim|kia|ki|kh|kg|kfh|kerryproperties|kerrylogistics|kerryhotels|ke|kddi|kaufen|juniper|juegos|jprs|jpmorgan|jp|joy|jot|joburg|jobs|jo|jnj|jmp|jm|jll|jlc|jio|jewelry|jetzt|jeep|je|jcp|jcb|java|jaguar|iwc|iveco|itv|itau|it|istanbul|ist|ismaili|iselect|is|irish|ir|iq|ipiranga|io|investments|intuit|international|intel|int|insure|insurance|institute|ink|ing|info|infiniti|industries|in|immobilien|immo|imdb|imamat|im|il|ikano|iinet|ifm|ieee|ie|id|icu|ice|icbc|ibm|hyundai|hyatt|hughes|hu|htc|ht|hsbc|hr|how|house|hotmail|hoteles|hot|hosting|host|hospital|horse|honeywell|honda|homesense|homes|homegoods|homedepot|holiday|holdings|hockey|hn|hm|hkt|hk|hiv|hitachi|hisamitsu|hiphop|hgtv|hermes|here|helsinki|help|healthcare|health|hdfcbank|hdfc|hbo|haus|hangout|hamburg|hair|gy|gw|guru|guitars|guide|guge|gucci|guardian|gu|gt|gs|group|gripe|green|gratis|graphics|grainger|gr|gq|gp|gov|got|gop|google|goog|goodyear|goodhands|goo|golf|goldpoint|gold|godaddy|gn|gmx|gmo|gmbh|gmail|gm|globo|global|gle|glass|glade|gl|giving|gives|gifts|gift|gi|gh|ggee|gg|gf|george|genting|gent|gea|ge|gdn|gd|gbiz|gb|garden|gap|games|game|gallup|gallo|gallery|gal|ga|fyi|futbol|furniture|fund|fujixerox|fujitsu|ftr|frontier|frontdoor|frogans|frl|fresenius|free|fr|fox|foundation|forum|forsale|forex|ford|football|foodnetwork|food|foo|fo|fm|fly|flowers|florist|flir|flights|flickr|fk|fj|fitness|fit|fishing|fish|firmdale|firestone|fire|financial|finance|final|film|fido|fidelity|fiat|fi|ferrero|ferrari|feedback|fedex|fast|fashion|farmers|farm|fans|fan|family|faith|fairwinds|fail|fage|extraspace|express|exposed|expert|exchange|everbank|events|eus|eurovision|eu|et|esurance|estate|esq|es|erni|ericsson|er|equipment|epson|epost|enterprises|engineering|engineer|energy|emerck|email|eg|ee|education|edu|edeka|eco|ec|eat|earth|dz|dvr|dvag|durban|dupont|duns|dunlop|duck|dubai|dtv|drive|download|dot|domains|doha|dog|dodge|doctor|docs|do|dnp|dm|dk|dj|diy|dish|discover|discount|directory|direct|digital|diet|diamonds|dhl|dev|design|desi|dentist|dental|democrat|delta|deloitte|dell|delivery|degree|deals|dealer|deal|de|dds|dclk|day|datsun|dating|date|dance|dad|dabur|cz|cyou|cymru|cy|cx|cw|cv|cuisinella|cu|csc|cruises|cruise|crs|crown|cricket|creditunion|creditcard|credit|cr|courses|coupons|coupon|country|corsica|corp|coop|cool|cookingchannel|cooking|contractors|contact|consulting|construction|condos|comsec|computer|compare|company|community|commbank|comcast|com|cologne|college|coffee|codes|coach|co|cn|cm|clubmed|club|cloud|clothing|clinique|clinic|click|cleaning|claims|cl|ck|cityeats|city|citic|citi|citadel|cisco|circle|cipriani|ci|church|chrysler|chrome|christmas|chloe|chintai|cheap|chat|chase|channel|chanel|ch|cg|cfd|cfa|cf|cern|ceo|center|ceb|cd|cc|cbs|cbre|cbn|cba|catholic|catering|cat|casino|cash|caseih|case|casa|cartier|cars|careers|career|care|cards|caravan|car|capitalone|capital|capetown|canon|cancerresearch|camp|camera|cam|calvinklein|call|cal|cafe|cab|ca|bzh|bz|by|bw|bv|buzz|buy|business|builders|build|bugatti|budapest|bt|bs|brussels|brother|broker|broadway|bridgestone|bradesco|br|box|boutique|bot|boston|bostik|bosch|boots|booking|book|boo|bond|bom|bofa|boehringer|boats|bo|bnpparibas|bnl|bn|bmw|bms|bm|blue|bloomberg|blog|blockbuster|blanco|blackfriday|black|bj|biz|bio|bingo|bing|bike|bid|bible|bi|bharti|bh|bg|bf|bet|bestbuy|best|berlin|bentley|beer|beauty|beats|be|bd|bcn|bcg|bbva|bbt|bbc|bb|bayern|bauhaus|basketball|baseball|bargains|barefoot|barclays|barclaycard|barcelona|bar|bank|band|bananarepublic|banamex|baidu|baby|ba|azure|az|axa|ax|aws|aw|avianca|autos|auto|author|auspost|audio|audible|audi|au|attorney|athleta|at|associates|asia|asda|as|arte|art|arpa|army|archi|aramco|ar|aquarelle|aq|apple|app|apartments|aol|ao|anz|anquan|android|analytics|amsterdam|amica|amfam|amex|americanfamily|americanexpress|am|alstom|alsace|ally|allstate|allfinanz|alipay|alibaba|alfaromeo|al|akdn|airtel|airforce|airbus|aigo|aig|ai|agency|agakhan|ag|afl|afamilycompany|af|aetna|aero|aeg|ae|adult|ads|adac|ad|actor|active|aco|accountants|accountant|accenture|academy|ac|abudhabi|abogado|able|abc|abbvie|abbott|abb|abarth|aarp|aaa";
		var DOMAIN_PART_PATTERN = "(?:[a-z0-9]+(?:-+[a-z0-9]+)*\\.)+(?:" + TLD_PATTERN + ")";
		var SIMPLE_EMAIL_PATTERN_LOCAL_PART = "[-a-z0-9!#$%&'*+/=?^_`{|}~]+(?:\\.[-a-z0-9!#$%&'*+/=?^_`{|}~]+)*";
		var SIMPLE_EMAIL_PATTERN = "^" + SIMPLE_EMAIL_PATTERN_LOCAL_PART + '@' + DOMAIN_PART_PATTERN + "$";
		var DISPLAY_NAME_PATTERN = "(?:\\\\[^\\x00-\\x1f]|[^\"\\x00-\\x1f])*";
		var COMPOUND_EMAIL_PATTERN = "\""+ DISPLAY_NAME_PATTERN +"\"[ \\t]*<" + SIMPLE_EMAIL_PATTERN + ">";
	
		var DIGIT_ONLY_REGEX = /^[0-9]+$/;
		var LOWERALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9a-z_]+$/;
		var ALPHANUMERIC_UNDERSCORE_REGEX = /^[0-9A-Za-z_]+$/;
		var COLOR_HEX_REGEX = /^#[0-9a-fA-F]{6}$/;
		var PACKAGE_REGEX = /^[a-z0-9]+(\.[a-z0-9]+){2}$/;
		var FURIGANA_REGEX = /^[\u0020\u3000\u30A0-\u30FF\uFF61-\uFF9F]+$/;
		var FUNCTION_REGEX = /^[0-9A-Za-z_$]+(\.[0-9A-Za-z_$]+)*$/;
	
		var NON_ALPHANUMERIC_REGEX_G = /[^a-zA-Z0-9]/g;
	
		/**
		 *  validate[type] or validateAndFormat[type] summary
		 *  [type] is determined based on the fieldType
		 *
		 *  @param {*} toValidate - the value to validate
		 *
		 *  @returns {Object} object with the following:
		 *  isValid				 - whether the inputted value was valid or not
		 *  formattedValue		  - the value reformatted appropriately (if just a validateXXXX function, it will equal toValidate)
		 *							if isValid = F, should return an empty string.
		 *
		 *  You can optionally return a code and message (key) from error module ERROR_TYPES to throw specific errors
		 *  errorCode (optional)	- the error code to send back, default: INVALID_FLD_VALUE
		 *  errorMsgKey (optional)  - *just* the message key which will retrieve the desired message later, default: INVALID_FIELD_VALUE
		 *							Will fill in {1} as fieldValue and {2} as fieldName.
		 *  errorFullMsg (optional) - the *entire* message in which to use when throwing error. Use if errorMsgKey does not satisfy your reqs
		 *							You will need to call util.getErrorMessage(yourMessageKey, param1, param2, ...) on your own
		 *							If present, will ignore errorMsgKey.
		 */
	
		// General case where only a test on a specific regex is necessary, and no specific error message is required
		function validateByRegexTest(toValidate, regexPattern, msgKeyOnFail)
		{
			if (!regexPattern.test(toValidate))
			{
				if (!!msgKeyOnFail)
					return {isValid: false, formattedValue: toValidate, errorMsgKey: msgKeyOnFail};
				else
					return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateDateObject(toValidate, fieldType)
		{
			var isDate = Object.prototype.toString.call(toValidate) === '[object Date]';
			if ( !(toValidate instanceof Date || isDate) || (isDate && isNaN(toValidate.getDay())))
			{
				var errorMsg = "";
				if (fieldType === fieldTypeConstants.Type.DATE)
					errorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_DATE_VALUE_MUST_BE_1, FieldValidationHelper.userfacing_dateformat);
				return {isValid: false, formattedValue: "", errorFullMsg: errorMsg};
			}
			else if (DateUtil.isDateTooOld(toValidate))
			{
				var errorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_DATE_VALUE_MUST_BE_ON_OR_AFTER_1CUTOFF_DATE, DateUtil.getOldestDateString());
				return {isValid: false, formattedValue: toValidate, errorFullMsg: errorMsg}
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validateMMYYDateObject(toValidate)
		{
			if ( !(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]') || toValidate.getFullYear() < 1900 || toValidate.getFullYear() > 2100 )
			{
				return {isValid: false, formattedValue: ""};
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function isWithinMinMax(toValidate, minVal, maxVal, exclusive)
		{
			var numVal = parseFloat(toValidate);
			var minimum = isNaN(parseFloat(minVal)) ? -Number.MAX_VALUE : minVal;
			var maximum = isNaN(parseFloat(maxVal)) ?  Number.MAX_VALUE : maxVal;

			var isBelow = !!exclusive ? numVal <= minimum : numVal < minimum;
			var isAbove = !!exclusive ? numVal >= maximum : numVal > maximum;

			var fullErrorMsg;
			if (maxVal == null && isBelow)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_GREATER_THAN_1, String(minimum));
			}
			else if (minVal == null && isAbove)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_LOWER_THAN_1, String(maximum));
			}
			else if (isBelow || isAbove)
			{
				fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_NUMBER_MUST_BE_BETWEEN_1_AND_2, String(minimum), String(maximum));
			}
			else
			{
				return {isValid: true, formattedValue: toValidate};
			}
			return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
		}

		function validateBoolean(toValidate)
		{
			if(toValidate === true || toValidate === false || toString.call(toValidate) === '[object Boolean]')
				return {isValid: true, formattedValue: toValidate} ;
			else
				return {isValid: false, formattedValue: ""};
		}
	
		function validateInteger(toValidate, posOnly, minVal, maxVal)
		{
			var numVal = parseInt(toValidate, 10);
			if (isNaN(toValidate) || (parseFloat(toValidate) !== numVal))
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_NUMBER_OR_PERCENTAGE};
			}
			return isWithinMinMax(toValidate, posOnly ? 0 : minVal, maxVal, posOnly);
		}
	
		function validateNumericValue(toValidate, minVal, maxVal, fieldType)
		{
			if ( isNaN(toValidate) || isNaN(parseFloat(toValidate)))
			{
				return { isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_NUMBER_OR_PERCENTAGE};
			}
	
			var numVal = parseFloat(toValidate);
			var exclusive = false;

			if(fieldType !== null && fieldType !== undefined)
			{
				if ((fieldType === fieldTypeConstants.Type.POSFLOAT) || (fieldType === fieldTypeConstants.Type.POSCURRENCY))
				{
					exclusive = true;
					minVal = 0;
				}
				else if ((fieldType === fieldTypeConstants.Type.NONNEGFLOAT) || (fieldType === fieldTypeConstants.Type.NONNEGCURRENCY))
				{
					minVal = 0;
				}
			}

			return isWithinMinMax(numVal, minVal, maxVal, exclusive);
		}
	
		function validateEmail(toValidate)
		{
			var simpleEmailRegex = new RegExp(SIMPLE_EMAIL_PATTERN, "i");
			var compoundEmailRegex = new RegExp(COMPOUND_EMAIL_PATTERN, "i");
	
			var testResult = simpleEmailRegex.test(toValidate) || compoundEmailRegex.test(toValidate);
	
			return {isValid: testResult, formattedValue: toValidate};
		}
	
		function validateEmails(toValidate)
		{
			var emailList = toValidate.split(/[,;\n\r]/);
			var bademails = [];
	
			for (var i = 0; i < emailList.length; i++)
			{
				var anEmail = util.trim(emailList[i]);
				if (anEmail === "")
					continue;
				if (!validateEmail(anEmail).isValid)
					bademails.push(anEmail);
			}
			if (bademails.length > 0)
			{
				var badEmailString = bademails.join(" ");
				var fullErrorMsg = utilityFunctions.getErrorMessage(error.Type.INVALID_EMAILS_FOUND) + badEmailString;
				return {isValid: false, formattedValue: "", errorFullMsg: fullErrorMsg};
			}
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateUrl(toValidate)
		{
			var val = toValidate.toLowerCase();
	
			if ( !(val.indexOf('/') === 0 || val.indexOf('http://') === 0 || val.indexOf('https://') === 0 || val.indexOf('ftp://') === 0 || val.indexOf('file://') === 0) )
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_URL_MUST_START_WITH_HTTP_HTTPS_FTP_OR_FILE};
			}
	
			if (val.indexOf(' ') > 0 || val.indexOf('\t') > 0)
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.INVALID_URL_SPACES_ARE_NOT_ALLOWED_IN_THE_URL};
			}
	
			return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCNumber(toValidate)
		{
			var cardnum = toValidate;
			// This is for credit card numbers. Do not validate if it is masked (i.e. all but last 4 numbers are masked)
			if ((cardnum.length > 4) &&
				(cardnum.slice(0, -4).replace(new RegExp( "\\*", "g" ), '').length === 0) &&
				(cardnum.slice(-4).replace(new RegExp( "\\*", "g" ), '').length === 4))
			{
				isValid = true;
				return cardnum;
			}
			else //adapted from checkccnumber (NLRecordUtil.js)
			{
				if (cardnum.length < 13 || cardnum.length > 20)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBERS_MUST_CONTAIN_BETWEEN_13_AND_20_DIGITS};
				}
				if (!DIGIT_ONLY_REGEX.test(cardnum))
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_MUST_CONTAIN_ONLY_DIGITS};
				}
	
				// Perform Luhn check
				// http://www.ling.nwu.edu/~sburke/pub/luhn_lib.pl
				var no_digit = cardnum.length;
				var oddoeven = no_digit & 1;
				var sum = 0;
	
				for (var count = 0; count < no_digit; count++)
				{
					var digit = parseInt(cardnum.charAt(count),10);
					if (!((count & 1) ^ oddoeven))
					{
						digit *= 2;
						if (digit > 9)
							digit -= 9;
					}
					sum += digit;
				}
				if (sum % 10 !== 0)
				{
					return {isValid: false, formattedValue: "", errorMsgKey: error.Type.CREDIT_CARD_NUMBER_IS_NOT_VALID__PLEASE_CHECK_THAT_ALL_DIGITS_WERE_ENTERED_CORRECTLY};
				}
	
				return {isValid: true, formattedValue: toValidate};
			}
		}
	
		function validatePhoneNumber(toValidate, isFullPhoneType)
		{
			var validPhoneDigits = String(toValidate).replace(NON_ALPHANUMERIC_REGEX_G, '');
			if (validPhoneDigits.length < 7)
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PHONE_NUMBER_SHOULD_HAVE_SEVEN_DIGITS_OR_MORE};
			}
	
			if (isFullPhoneType && (validPhoneDigits.length < 10) )
			{
				return {isValid: false, formattedValue: "",  errorMsgKey: error.Type.PLEASE_INCLUDE_THE_AREA_CODE_FOR_PHONE_NUMBER};
			}
	
			return {isValid: true, formattedValue: toValidate}
		}
	
		function validateIdentifier(toValidate, lowercaseOnly)
		{
			var re = lowercaseOnly ? LOWERALPHANUMERIC_UNDERSCORE_REGEX : ALPHANUMERIC_UNDERSCORE_REGEX;
			if (!re.test(toValidate))
			{
				return {isValid: false, formattedValue: "", errorMsgKey: error.Type.IDENTIFIERS_CAN_CONTAIN_ONLY_DIGITS_ALPHABETIC_CHARACTERS_OR__WITH_NO_SPACES};
			}
			else
				return {isValid: true, formattedValue: toValidate};
		}
	
		function validateCCDate(toValidate, checkNotBeforeToday)
		{
			var toValidateDate = toValidate.split("/");
			// must be in MM/YYYY form
			if (toValidate.length !== 7 || toValidateDate.length !== 2 || toValidateDate[0].length !== 2 || toValidateDate[1].length !== 4)
			{
				errorKey = checkNotBeforeToday ? error.Type.PLEASE_ENTER_AN_EXPIRATION_DATE_IN_MMYYYY_FORMAT
											   : error.Type.PLEASE_ENTER_A_VALID_FROM_START_DATE_IN_MMYYYY_FORMAT;
				return {isValid: false, formattedValue: "", errorMsgKey: errorKey};
			}
			else
			{
				var toValidateMonth = DIGIT_ONLY_REGEX.test(toValidateDate[0]) ? parseInt(toValidateDate[0], 10) : NaN;
				var toValidateYear = DIGIT_ONLY_REGEX.test(toValidateDate[1]) ? parseInt(toValidateDate[1], 10) : NaN;
				if (isNaN(toValidateMonth) || toValidateMonth < 1 || toValidateMonth > 12 ||
					isNaN(toValidateYear) || toValidateYear < 1000)
				{
					return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
				}
				else
				{
					var today = new Date();
					if (	checkNotBeforeToday && (toValidateYear < today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth < (today.getMonth() + 1) ))
						|| !checkNotBeforeToday && (toValidateYear > today.getFullYear() || ( (toValidateYear === today.getFullYear()) && toValidateMonth > (today.getMonth() + 1) )) )
					{
						return {isValid: false, formattedValue: "", errorMsgKey:  error.Type.NOTICE_THE_CREDIT_CARD_APPEARS_TO_BE_INCORRECT};
					}
					else
					{
						return {isValid: true, formattedValue: toValidate};
					}
				}
			}
		}

		function validateRate(toValidate, minVal, maxVal, allowPercentage)
		{
			if (allowPercentage)
			{
				var strToValidate = "" + toValidate;
				if (strToValidate.indexOf('%') !== -1)
				{
					var numericResult = validateNumericValue(strToValidate.replace('%', ''));
					if (numericResult.isValid)
					{
						return {isValid: true, formattedValue: toValidate};
					}
					else
					{
						return {isValid: false, formattedValue: "", errorMsgKey: numericResult.errorMsgKey};
					}
				}
			}

			return validateNumericValue(toValidate, minVal, maxVal);
		}

		function validateDynamicPrecision(toValidate, minVal, maxVal, scale)
		{
			if (scale)
			{
				var numericResult = validateNumericValue(toValidate);
				if (numericResult.isValid)
				{
					return {isValid: true, formattedValue:  round_float_to_n_places(toValidate, scale)};
				}
				else
				{
					return {isValid: false, formattedValue: "", errorMsgKey: numericResult.errorMsgKey};
				}

			}

			return validateNumericValue(toValidate, minVal, maxVal);
		}
	
		/**
		 * validateValueLength
		 * Checks whether fieldValue is no greater than maxLen (given it is a positive value).
		 * Throws error if fieldValue is longer than maxLen.
		 * If strictValidation is true, then ensures its value is checked even if fieldValue is numeric.
		 * @param {*} fieldName - name of given field
		 * @param {*} fieldValue - value of given field
		 * @param {*} maxLen - cross reference getFieldLength() in NLRecordFieldUtil.java for the value used
		 * @param {*} useStrict - strictly apply to all value types
		 */
		function validateValueLength(fieldName, fieldValue, maxLen, useStrict)
		{
			var validateMe = (useStrict && !isNaN(parseFloat(fieldValue)) && isFinite(fieldValue)) ? ("" + fieldValue) : fieldValue;
			if ( !isNaN(maxLen) && (maxLen > 0) && (validateMe.length > maxLen) )
			{
				throwError({name: error.Type.INVALID_FLD_VALUE,
					           message: utilityFunctions.getErrorMessage(error.Type.THE_FIELD_1_CONTAINED_MORE_THAN_THE_MAXIMUM_NUMBER__2__OF_CHARACTERS_ALLOWED, fieldName, maxLen)});
			}
		}

		/**
		 * validateField
		 * validates the fieldValue from fieldName based on its fieldType, and possibly formats appropriately.
		 * Does nothing if fieldValue is empty UNLESS it is a checkbox
		 *
		 * @param {*} fieldName, fieldType, fieldValue - self explanatory
		 * @param {*} fieldType
		 * @param {*} fieldValue
		 * @param {*} isNum
		 * @param {*} isCurr
		 * @param {*} validationType - gives a specific type for validation ('function' uses this)
		 * @param {*} minVal - minimum valid value
		 * @param {*} maxVal - maximum valid value
		 * @param {*} maxLength - maximum valid length for fieldValue (cross-check NLRecordFieldType.java:getFieldLength )
		 * @param {*} useStrict - record is in a mode that requires stricter validation
		 *
		 * Throws error if fieldValue is invalid or null/undefined
		 * @returns {object} fieldValue
		 * @param {*} mandatory
		 */
		function validateField(fieldName, fieldType, fieldValue, isNum, isCurr, validationType, minVal, maxVal, maxLength, mandatory, useStrict, allowPercentage,scale)
		{
			if ((fieldValue === undefined) || (fieldValue === null) || (fieldValue.length === 0))
			{
				if (mandatory)
				{
					throwError({name: error.Type.INVALID_FLD_VALUE,
							message: utilityFunctions.getErrorMessage(error.Type.FIELD_MUST_CONTAIN_A_VALUE)});
				}
				else if(fieldType !== fieldTypeConstants.Type.CHECKBOX)
				{
					return fieldValue;
				}
			}
	
	
			var isNumeric =   isNum || fieldTypeConstants.isNumeric(fieldType);
			var isCurrency = isCurr || fieldTypeConstants.isCurrency(fieldType);

			// TIME internally converts string time to numeric which can cause unnecessary length error.
			useStrict = useStrict && (fieldType !== fieldTypeConstants.Type.TIME);

			//we should not validate select/multiselect here by length
			//we cannot know how long are the keys itself
			if (fieldType != fieldTypeConstants.Type.MULTISELECT && fieldType != fieldTypeConstants.Type.SELECT) {
				validateValueLength(fieldName, fieldValue, maxLength, useStrict);
			}

			switch(true)
			{
				case (fieldType === fieldTypeConstants.Type.DATE) ||
					 (fieldType === fieldTypeConstants.Type.TIMEOFDAY) ||
                     (fieldType === fieldTypeConstants.Type.DATETIME) ||
					 (fieldType === fieldTypeConstants.Type.DATETIMETZ):
					validationPackage = validateDateObject(fieldValue, fieldType);
					break;
	
				case (fieldType === fieldTypeConstants.Type.MMYYDATE):
					validationPackage = validateMMYYDateObject(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.INTEGER):
					validationPackage = validateInteger(fieldValue, false, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.POSINTEGER):
					validationPackage = validateInteger(fieldValue, true, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIMETRACK):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.TIME):
					minVal = (!minVal || (minVal < 0)) ? 0 : minVal;
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PERCENT):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal);
					break;

				case (fieldType === fieldTypeConstants.Type.RATE) ||
					 (fieldType === fieldTypeConstants.Type.RATEHIGHPRECISION):
					validationPackage = validateRate(fieldValue, minVal, maxVal, allowPercentage);
					break;
				case (fieldType === fieldTypeConstants.Type.DYNAMICPRECISION):
					validationPackage = validateDynamicPrecision(fieldValue, minVal, maxVal, scale);
					break;
				case ( !!isNumeric || !!isCurrency ):
					validationPackage = validateNumericValue(fieldValue, minVal, maxVal, fieldType);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAIL):
					validationPackage = validateEmail(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.EMAILS):
					validationPackage = validateEmails(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.URL):
					validationPackage = validateUrl(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CHECKBOX):
					validationPackage = validateBoolean(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCNUMBER):
					validationPackage = validateCCNumber(fieldValue);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PHONE):
					validationPackage = validatePhoneNumber(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FULLPHONE):
					validationPackage = validatePhoneNumber(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIER):
					validationPackage = validateIdentifier(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.IDENTIFIERANYCASE):
					validationPackage = validateIdentifier(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCEXPDATE):
					validationPackage = validateCCDate(fieldValue, true);
					break;
	
				case (fieldType === fieldTypeConstants.Type.CCVALIDFROM):
					validationPackage = validateCCDate(fieldValue, false);
					break;
	
				case (fieldType === fieldTypeConstants.Type.COLOR):
					validationPackage = validateByRegexTest(fieldValue, COLOR_HEX_REGEX, error.Type.COLOR_VALUE_MUST_BE_6_HEXADECIMAL_DIGITS_OF_THE_FORM_RRGGBB__EXAMPLE_FF0000_FOR_RED);
					break;
	
				case (fieldType === fieldTypeConstants.Type.PACKAGE):
					validationPackage = validateByRegexTest(fieldValue, PACKAGE_REGEX, error.Type.INVALID_SUITEAPP_APPLICATION_ID);
					break;
	
				case (fieldType === fieldTypeConstants.Type.FURIGANA):
					validationPackage = validateByRegexTest(fieldValue, FURIGANA_REGEX, error.Type.NON_KATAKANA_DATA_FOUND);
					break;

                case (fieldType === fieldTypeConstants.Type.FUNCTION):
				case (validationType !== null) && (typeof validationType !== "undefined") &&
					 (validationType.toLowerCase() === fieldTypeConstants.Type.QUOTEDFUNCTION):
					validationPackage = validateByRegexTest(fieldValue, FUNCTION_REGEX);
					break;
	
				default:
					return fieldValue;
			}
	
			if (!validationPackage.isValid || validationPackage.formattedValue.length === 0)
			{
				// If there is a specific error message, use it. Else use the cookie-cutter version.
				var errorCode = validationPackage.errorCode ? validationPackage.errorCode : error.Type.INVALID_FLD_VALUE;
	
				if (!!validationPackage.errorFullMsg)
				{
					throwError({name: errorCode, message: validationPackage.errorFullMsg});
				}
				else
				{
					if ( !!isNumeric || !!isCurrency )
					{
						fieldName = fieldName.replace("_formattedValue", "");
					}
					var errorMsgKey = validationPackage.errorMsgKey ? validationPackage.errorMsgKey : error.Type.INVALID_FIELD_VALUE;
					var errorMessage = utilityFunctions.getErrorMessage(errorMsgKey, String(fieldValue), fieldName);

					throwError({name: errorCode, message: errorMessage.replace(/\\\"/g, "\"")});
				}
			}
	
			return validationPackage.formattedValue;
		}

		function throwError(e)
		{
			throw error.create(e);
		}
	
		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param {*} fieldName, fieldValue - self explanatory
		 * @param {*} radioSet - a set of possible values for the radio buttons with the given fieldname
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns {*} fieldValue
		 */
		function validateRadioField(fieldName, fieldValue, radioSet)
		{
			if ( (radioSet === null) || (typeof radioSet === "undefined") || !radioSet.hasOwnProperty(fieldValue) )
			{
				throw error.create({name: error.Type.INVALID_FLD_VALUE,
									message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(fieldValue), fieldName)});
			}
			return fieldValue;
		}

		/**
		 * validateRadioField
		 * specific method to validate radio fields.
		 * Unlike most other fields, a radio field will NOT accept an empty string (unless it is a radio value)
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * @param {Object} radioSet
		 *
		 * Throws error if fieldValue is not found in radioSet
		 * @returns {*} key
		 */
		function validateRadioFieldByText(fieldId, text, radioSet)
		{
			if(radioSet !== null && radioSet !== undefined)
			{
				for (var key in radioSet)
				{
					if (radioSet.hasOwnProperty(key) && radioSet[key] === text)
						return key;
				}
			}

			throw error.create({name: error.Type.INVALID_FLD_VALUE,
								   message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)});
		}

		/**
		 * validateCheckBoxField
		 * specific method to validate check box fields.
		 * Unlike most other fields, a check box field will NOT accept an empty string
		 *
		 * @param {string} fieldId
		 * @param {string} text
		 * Throws error if fieldValue is empty
		 * @returns {*} text
		 */
		function validateCheckBoxField(fieldId, text)
		{
			if (utilityFunctions.isValEmpty(text))
			{
				throw error.create({
					name: error.Type.INVALID_FLD_VALUE,
					message: utilityFunctions.getErrorMessage(error.Type.INVALID_FIELD_VALUE, String(text), fieldId)
				});
			}
		}

		/* assign util.validator package */
		return Object.freeze({
				validateField: validateField,
				validateRadioField: validateRadioField,
				validateRadioFieldByText: validateRadioFieldByText,
				validateCheckBoxField: validateCheckBoxField
			});
	}
);

/**
 * SuiteScript record field event module
 *
 * @private
 * @module N/record/recordFieldEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordFieldEvent',['N/utilityFunctions', 'N/resultObject'], function (utilityFunctions, resultObject)
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(type, recordField)
	{
		return {
			type: type,
			recordField: recordField
		};
	}

	function addErrorDetails(event, error)
	{
		event.error = error;

		return event;
	}

	function wrapValueValidation(options)
	{
		var func = options.func;
		var emitter = options.emitter;
		var recordField = options.recordField;

		return util.isFunction(func.thenable)
			? utilityFunctions.thenableFunction(utilityFunctions.wraps(func.thenable, function ()
			{
				var args = arguments;
				return resultObject.create(function ()
				{
					return func.thenable.apply(null, args);
				})['catch'](function (error)
				{
					emitter.emit(addErrorDetails(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE, recordField), error));
					throw error;
				});
			}))
			: utilityFunctions.wraps(func, function ()
			{
				var result = undefined;

				try
				{
					result = func.apply(null, arguments);
				}
				catch(error)
				{
					emitter.emit(addErrorDetails(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE, recordField), error));
					throw error;
				}
				return result;
			});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		wrapValueValidation: wrapValueValidation
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordField
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/recordField',['N/restricted/remoteApiBridge', 'N/internal/invoker', 'N/fieldUtil', 'N/utilityFunctions', 'N/error','N/nsobject', 'N/util/formatter', 'N/util/validator', 'N/record/recordFieldEvent', 'N/eventEmitter', 'N/runtime', 'N/util/currencyUtility', 'N/fieldTypeConstants', 'N/resultObject'],
	function (remoteApi, invoker, fieldUtil, utilityFunctions, error, nsobject, formatter, validator, recordFieldEvent, eventEmitter, runtime, currencyUtility, fieldTypeConstants, resultObject){

		var INVALID_KEY_OR_REF = 'INVALID_KEY_OR_REF';

		var UPDATE_FIELD_ATTRIBUTE = "updateFieldAttribute",
			UPDATE_FIELD_ATTRIBUTE_EXCEPTION = "updateFieldAttributeException",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE = "updateLineItemFieldAttribute",
			UPDATE_LINEITEM_FIELD_ATTRIBUTE_EXCEPTION = "updateLineItemFieldAttributeException";

		/**
		 * SelectOption
		 * @param {string} text
		 * @param {string} id
		 * @param {boolean?} isDynamicOption
		 * @protected
		 * @constructor
		 */
		function SelectOption(text, id, isDynamicOption)
		{
			var optionText = utilityFunctions.unescape(text);
			function getText() { return optionText; }
			function getId() { return id; }
			function toJSON() { return {id:id, text:optionText}; }
			function toString() { return "SelectOption"; }
			function isDynamic() { return !!isDynamicOption; } // added dynamically on client, allowed only for current record in NEW UI

			this.getText = getText;
			this.getId = getId;
			this.toJSON = toJSON;
			this.toString = toString();
			this.isDynamic = isDynamic();
			this.proxy = toJSON;
		}
		SelectOption.prototype = nsobject.getNewInstance();
		Object.freeze(SelectOption);

		//TODO JSDoc these methods, this is exported by Record
		/**
		 * Field - Primary object used to encapsulate a record field object.
		 *
		 * @alias RecordField
		 *
		 * @param {FieldObject} params
		 *
		 * @protected
		 * @constructor
		 */
		function Field(params)
		{
			/* private vars */

			var that = this;
			var field = params;
			var recordFunctions = params.recordFunctions;
			var metadata = params.metadata;
			var fieldState = params.fieldState;
			var label = fieldState.label;
			var emitter = eventEmitter.create();

			/* private method */
			function getFieldInfo()
			{
				return {sublistId: getSublistName(), fieldId: String(metadata.name), lineNum: parseInt(getLine(),10), lineInstanceId: getLineInstanceId(), isCommitted: getIsCommitted() };
			}
			function isRecordDynamic()
			{
				return field.isRecordDynamic;
			}
			function isCurrentRecord()
			{
				return field.isCurrentRecord;
			}

			/**
			 *
			 * @returns {OptionCacheDelegate}
			 */
			function getFieldOptions() {
				return recordFunctions.getFieldOptions();
			}

			/**
			 *
			 * @param {*} options
			 * @param {boolean?} isDynamic
			 * @returns {Array<SelectOption>}
			 */
			function constructSelectOptions(options, isDynamic)
			{
				var selectOptions = [];
				for(var i = 0; i < options.length; i++)
				{
					if(options[i] instanceof SelectOption)
					{
						selectOptions.push(options[i]);
						continue;
					}
					/* remove empty option */
					if(!utilityFunctions.isValEmpty(options[i].id))
						selectOptions.push(new SelectOption(options[i].text, options[i].id, !!isDynamic));
				}

				if (metadata && metadata.hasBlankString &&
					selectOptions.filter(function(opt) {return opt.getText() === metadata.blankString}).length === 0)
					selectOptions.splice(0,0, new SelectOption(metadata.blankString, '', false));

				return selectOptions;
			}
			function getValidFilterOperation(op)
			{
				if(typeof op === 'undefined')
					return 'contains';

				var validOperations = ['contains', 'is', 'startswith'];
				if( validOperations.indexOf(op.toLowerCase()) > -1)
					return op.toLowerCase();
				else
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_GETSELECTOPTION_FILTER_OPERATOR, op, validOperations.join(','));
			}
			function filterOptions(options, filter, filterOperation)
			{
				var toRet = [];
				for(var i = 0; i < options.length; i++)
				{
					var isValid = isOptionValid(options[i], filter, filterOperation);
					if(isValid)
						toRet.push(options[i]);
				}
				return toRet;
			}
			function isOptionValid(option, filter, filterOperation)
			{
				var isValid = false;
				if((filterOperation === 'contains') || (filterOperation === 'startswith'))
				{
					var pos = option.getText().toLowerCase().search(filter.toLowerCase());
					if(filterOperation === 'startswith')
						isValid = (pos === 0);
					else
						isValid = (pos > -1);
				}
				else if(filterOperation === 'is')
				{
					isValid = option.getText().toLowerCase() === filter.toLowerCase();
				}

				return isValid;
			}
			function cacheFieldOption(options, action, data)
			{
				if(getRecord().isDynamic)
				{
					getFieldOptions().put(getSublistName(), getName(), getLineInstanceId(), getIsCommitted(), false, options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheFieldColumnOption(options, action, data)
			{
				if(getRecord().isDynamic && getSublistName())
				{
					getFieldOptions().put(getSublistName(), getName(), getLineInstanceId(), getIsCommitted(), true, options, action, data);
					cacheSelectOptionTexts(getSublistName(), getName(), options);
				}
			}
			function cacheSelectOptionTexts(sublistName, fieldName, options)
			{
				var modelController = getRecord().getModelController();
				(options || []).forEach(function(option) {
					modelController.cacheSelectOptionText(sublistName, fieldName, option.getId(), option.getText());
				});
			}

			function getOptionsFromRecordFieldCache()
			{
				if(getRecord().isDynamic)
					return getFieldOptions().get(getSublistName(), getName(), getLineInstanceId(), getIsCommitted(), false);
				else
					return undefined;
			}
			function getOptionsFromRecordFieldColumnCache()
			{
				if(getRecord().isDynamic && getSublistName())
					return getFieldOptions().get(getSublistName(), getName(), getLineInstanceId(), getIsCommitted(), true);
				else
					return undefined;
			}

			function getRecord() { return field.record; }
			function getSubrecordType() { return metadata.subrecordType; }
			function getSubrecordIdField() { return metadata.subrecordIdField; }
			function isSublistField() { return !!field.sublistId; }
			function isMachineHeaderField() { return metadata.isMachineHeaderField; }
			function isRadioField() { return getType() === 'radio'; }
			function isPopup() { return metadata.isPopup; }
			function getType() { return  metadata.type; }
			function getName() { return metadata.name; }
			function getFieldState() { return fieldState; }
			function getSublistName() { return field.sublistId ? String(field.sublistId) : null; }
			function getLine() {
				return getLineInstanceId() ? getRecord().getLineIndexFromInstanceId(getSublistName(), getLineInstanceId()) : -1;
			}
			function getLineInstanceId() {
				return getSublistName() ? fieldState.parentState.lineInstanceId : '';
			}
			function getIsCommitted() {
				if (getSublistName() && fieldState.parentSublistState) {
					var useBuffer = fieldState.parentSublistState.findLineForFieldState(fieldState).useLineBuffer;
					return useBuffer === null ? null : !useBuffer;
				}
			}
			function getMaxLength() { return metadata.maxLength; }
			function isNumeric() { return metadata.isNumeric; }
			function isCurrency() { return metadata.isCurrency; }
			function getMinValue() { return (metadata.hasMinValue) ? metadata.minValue : undefined; }
			function getMaxValue() { return (metadata.hasMaxValue) ? metadata.maxValue : undefined; }
			function getValidationFieldType() { return metadata.fieldTypeForValidation; }
			function noSlaving() { return getFieldState().ignoreSlaving; }
			function setNoSlaving(noSlaving) { 
				getFieldState().ignoreSlaving = noSlaving;
				return that;
			}
			function isDisabled() { return getFieldState().isDisabled; }
			function setDisabled(disable)
			{
				disable = !!disable;
				var oldDisabled = getFieldState().isDisabled;

				if(disable !== oldDisabled){
					getFieldState().isDisabled = disable;
				}

				return that;
			}
			function isDefaultMandatory() { return getFieldState().isDefaultMandatory; }
			function isMandatory() { return getFieldState().isMandatory; }
			function setMandatory(mandatory)
			{
				mandatory = !!mandatory;
				var oldMandatory = getFieldState().isMandatory;

				if(mandatory !== oldMandatory){
					getFieldState().isMandatory = mandatory;
				}

				return that;
			}
			function isDisplay() { return getFieldState().isDisplay; }
			function setDisplay(display)
			{
				display = !!display;
				var oldDisplay = getFieldState().isDisplay;

				if(display !== oldDisplay){
					getFieldState().isDisplay = display;
				}

				return that;
			}
			function isVisible() { return getFieldState().isVisible; }
			function setVisible(visible)
			{
				visible = !!visible;
				var oldVisible = getFieldState().isVisible;

				if(visible !== oldVisible){
					getFieldState().isVisible = visible;
				}

				return that;
			}
			function isReadOnly() { return getFieldState().isReadOnly; }
			function setReadOnly(readonly)
			{
				readonly = !!readonly;
				var oldReadonly = getFieldState().isReadOnly;

				if(readonly !== oldReadonly){
					getFieldState().isReadOnly = readonly;
				}

				return that;
			}
			function getLabel()
			{
				if(getFieldState().label !== label)
					label = getFieldState().label;
				return label;
			}
			function setLabel(newLabel)
			{
				newLabel = '' + newLabel;
				var oldLabel = label;

				if(newLabel !== oldLabel){
					label = newLabel;
					getFieldState().label = newLabel;
				}

				return that;
			}

			function getRecordFieldValue(sublistId, fieldId, lineInstanceId)
			{
				if (sublistId) {
					var isCommitted = !isRecordDynamic() || !getRecord().getModelController().isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
					return getRecord().getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				}
				else {
					return getRecord().getValueAsLegacyString(fieldId);
				}
			}
			function getRecordQueryRequest()
			{
				return recordFunctions.getQueryRequest.call();
			}
			function getRequestParam()
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload,getName());
				return [getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo(), getOptionMastersAndAuxFieldsValue()];
			}
			var getSelectOptionForPopup = utilityFunctions.thenableFunction(function getSelectOptionForPopup(idsOrTexts, byIds, isAsync)
			{
				var lookupBind = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts) || [];
				var requestParam = getRequestParam();
				requestParam.push(lookupBind, byIds);
				return (isAsync ? invoker.promise : invoker)(remoteApi, 'getSelectOptionForPopup', requestParam);
			}, {
				isAsyncArgIndex: 2
			});
			var getSelectOptions = utilityFunctions.thenableFunction(function getSelectOptions(filter, filterOperator, lookupBind, returnNullIfOverflow, isAsync)
			{
				return resultObject.create(function ()
				{
					if(fieldTypeConstants.isSelectType(getType()))
					{
						if (isPopup() && lookupBind)
						{
							return resultObject.create(function ()
							{
								return getSelectOptionForPopup.thenable(lookupBind, true, isAsync);
							}).then(function (options)
							{
								return constructSelectOptions(options);
							});
						}
						else
						{
							return resultObject.create(function () 
							{
								var cachedOpts = getOptionsFromRecordFieldCache();
								if (cachedOpts === undefined)
								{
									return resultObject.create(function ()
									{
										if (Array.isArray(metadata.supplementedOptions))
										{
											return constructSelectOptions(metadata.supplementedOptions, true);
										}
										else
										{
											return resultObject.create(function ()
											{
												return getSelectOptionsFromServer.thenable(isAsync);
											}).then(function (serverOpts)
											{
												return serverOpts.overflow ? null : constructSelectOptions(serverOpts.options);
											});
										}
									}).then(function (cachedOpts)
									{
										cacheFieldOption(cachedOpts); // overflow (too many options) is cached as null
										return cachedOpts;
									});
								}
								else if (cachedOpts !== null)
								{
									return constructSelectOptions(cachedOpts);
								}
								return cachedOpts;
							}).then(function (cachedOpts)
							{
								return cachedOpts ? extendWithColumnOptions(cachedOpts) : (returnNullIfOverflow ? null : []);
							});
						}
					}
					else if(isRadioField())
					{
						return getRadioSelectOption();
					}
					return [];
				}).then(function (selectOptions)
				{
					if(filter && selectOptions)
						selectOptions = filterOptions(selectOptions, filter, getValidFilterOperation(filterOperator));

					return selectOptions;
				});
			}, {
				isAsyncArgIndex: 4
			});

			function getColumnSelectOptions(filter, filterOperator)
			{
				var columnSelectOptions = [];
				if(getSublistName() && fieldTypeConstants.isSelectType(getType()) && !isPopup())
				{
					var options = getOptionsFromRecordFieldColumnCache() || [];
					columnSelectOptions = constructSelectOptions(options);
				}

				if(filter)
					columnSelectOptions = filterOptions(columnSelectOptions, filter, getValidFilterOperation(filterOperator));

				return columnSelectOptions;
			}
			function extendWithColumnOptions(lineOptions)
			{
				lineOptions = lineOptions || [];
				var columnOptions = getColumnSelectOptions();
				columnOptions.forEach(function(columnOption) { if (!lineOptions.some(function(lineOption) {return lineOption.getId() === columnOption.getId();})) lineOptions.push(columnOption); });
				return lineOptions;
			}

			function canExternalUpdateSelectOptions()
			{
				return fieldUtil.isPrefixedWithCustPage(getName());
			}

			function isInternal()
			{
				var scriptId = runtime.getCurrentScript().id;
				return scriptId == null || scriptId === 'internal';
			}

			var insertSelectOption = utilityFunctions.thenableFunction(function insertSelectOption(value, text, selected, isColumnOption, isAsync)
			{
				return resultObject.create(function ()
				{
					return isColumnOption ? getColumnSelectOptions() : getSelectOptions.thenable(undefined, undefined, undefined, undefined, isAsync);
				}).then(function (myOptions)
				{
					if (myOptions.some(function(v) { return v.getId() === value; }))
						utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);

					var addedOpt = new SelectOption(text, value, true);
					myOptions.push(addedOpt);
					(isColumnOption ? cacheFieldColumnOption : cacheFieldOption)(myOptions, 'add', addedOpt);

					return recordFunctions.updateSelectOptions.thenable(getSublistName(), getName(), getLineInstanceId(), myOptions, value, text, selected);
				});
			}, {
				isAsyncArgIndex: 4
			});

			var removeSelectOption = utilityFunctions.thenableFunction(function removeSelectOption(value, isColumnOption, isAsync)
			{
				return resultObject.create(function ()
				{
					return isColumnOption ? getColumnSelectOptions() : getSelectOptions.thenable(undefined, undefined, undefined, undefined, isAsync);
				}).then(function (myOptions)
				{
					var cacheFunction = (isColumnOption ? cacheFieldColumnOption : cacheFieldOption);
					if (value !== null) {
						var internal = isInternal();

						var removedOpt = null;
						var postRemovalOptionList = myOptions.filter(function (v) {
							if ((v.getId() === value) && (v.isDynamic || internal)) {
								removedOpt = v;
								return false;
							}
							return true;
						});
						if (removedOpt === null)
							utilityFunctions.throwSuiteScriptError(error.Type.SELECT_OPTION_NOT_FOUND, value);
						cacheFunction(postRemovalOptionList, 'remove', removedOpt);
					}
					else {
						cacheFunction([], 'remove', null);
					}
				});
			}, {
				isAsyncArgIndex: 2
			});

			function getOptionMastersAndAuxFieldsValue()
			{
				var fields = metadata.optionMastersAndAuxFields;
				var toRet = [];
				fields.forEach(function(field) {
					toRet.push({
						           fieldId: field.fieldName,
						           sublistId: field.sublistName,
						           value: getRecordFieldValue(field.sublistName, field.fieldName, getLineInstanceId())
					           });
				});
				return toRet;
			}
			function getRadioSet(fieldId)
			{
				return recordFunctions.getRadioSet.call(getRecord(), fieldId);
			}
			function getRadioSelectOption()
			{
				var selectOptions = [];
				if(isSublistField() && !isMachineHeaderField())
				{
					for (var i = 1; i <= getRecord().doGetLineCount(getSublistName()); i++)
						selectOptions.push(new SelectOption(getLabel(), String(i)));
				}
				else
				{
					var radioValues = getRadioSet(getName());
					for(var radioValue in radioValues)
					{
						selectOptions.push(new SelectOption(radioValues[radioValue], radioValue));
					}
				}
				return selectOptions;
			}
			var getSelectOptionsFromServer = utilityFunctions.thenableFunction(function getSelectOptionsFromServer(isAsync)
			{
				var queryRequest = getRecordQueryRequest();
				markQueryRequest(queryRequest.payload, getName());
				var requestParam = [ getRecord().type, queryRequest.url, queryRequest.payload , getFieldInfo(), getOptionMastersAndAuxFieldsValue() ];
				return (isAsync ? invoker.promise : invoker)(remoteApi, 'getFieldSelectOptions', requestParam);
			}, {
				isAsyncArgIndex: 0
			});
			function removeEmptyValueForPopUpSelect(value)
			{
				var newArray = [];
				for(var idx = 0; idx < value.length; idx++)
				{
					if(!utilityFunctions.isValEmpty(value[idx]) && !considerAsEmptyForPopup(value[idx]))
						newArray.push(value[idx]);
				}

				return newArray;
			}
			function validateEmptyValue(value)
			{
				var valArray = util.isArray(value) ? value : [value];
				validateEmptyValueInArray(valArray);
			}
			var validateSelectFieldByText = utilityFunctions.thenableFunction(function validateSelectFieldByText(text, isAsync)
			{
				var result = text;

				validateEmptyValue(text);

				if(!utilityFunctions.isValEmpty(text) && !considerAsEmptyForPopup(text))
				{
					if(isPopup())
					{
						if(util.isArray(text))
							text = removeEmptyValueForPopUpSelect(text);
						result = resultObject.create(function ()
						{
							return getSelectOptionForPopup.thenable(text, false, isAsync);
						}).then(function (options)
						{
							options = constructSelectOptions(options);
							return findIdInFieldOptions(options, text);
						});
					}
					else if(isRadioField())
					{
						var thisRadioSet = getRadioSet(getName());
						result = validator.validateRadioFieldByText(getName(), text, thisRadioSet);
					}
					else
					{
						result = resultObject.create(function ()
						{
							return getSelectOptions.thenable(undefined, undefined, undefined, undefined, isAsync);
						}).then(function (options)
						{
							return findIdInFieldOptions(options, text);
						});
					}
				}

				return result;
			}, {
				isAsyncArgIndex: 1
			});
			function considerAsEmptyForPopup(value)
			{
				if(isPopup())
				{
					//TODO translation
					return ["<Type then tab>", "<Type & tab for single value>"].indexOf(value) > -1;
				}
				else
					return false;
			}
			function validateSelectField(value, option)
			{
				validateEmptyValue(value);

				if(!utilityFunctions.isValEmpty(value) && !considerAsEmptyForPopup(value))
				{
					if (util.isArray(value) && !areIdsInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF, message: utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(value))});
					}
					else if (!util.isArray(value) && !isIdInFieldOptions(option, value))
					{
						throw error.create({name:INVALID_KEY_OR_REF,message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), value)});
					}
				}
			}
			function validateEmptyValueInArray(valueArray)
			{
				// validate if there are empty value in values
				if (!metadata.hasBlankString &&
					(utilityFunctions.arrayContains(valueArray, '') || utilityFunctions.arrayContains(valueArray, null) || utilityFunctions.arrayContains(valueArray, undefined) ))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.EMPTY_KEY_NOT_ALLOWED, getName());
				}
			}
			function areIdsInFieldOptions(options, ids)
			{
				var keyList = [];
				for(var i = 0; i < options.length; i++)
					keyList.push(String(options[i].getId()));

				for(var j = 0; j < ids.length; j++)
				{
					if(keyList.indexOf(String(ids[j])) === -1)
						return false;
				}

				return true;
			}
			function isIdInFieldOptions(options, id)
			{
				for (var i = 0; i < options.length; i++)
				{
					if (options[i].getId() == id)
						return true;
				}
				return false;
			}
			function findIdInFieldOptions(options, text)
			{
				if(util.isArray(text))
					return findIdsInFieldOptions(options, text);

				for(var i = 0; i < options.length; i++)
				{
					if(options[i].getText() === text)
						return options[i].getId();
				}

				throw error.create({name:INVALID_KEY_OR_REF,
									message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), String(text))});
			}
			function findIdsInFieldOptions(options, texts)
			{
				var internalIds = [];
				var validTexts = [];
				for(var i = 0; i < options.length; i++)
				{
					if(texts.indexOf(options[i].getText()) > -1)
					{
						internalIds.push(options[i].getId());
						validTexts.push(options[i].getText());
					}
				}

				if(validTexts.length !== texts.length)
				{
					var invalidTexts = [];
					for(var j=0; j < texts.length; j++)
						if(validTexts.indexOf(texts[j]) == -1)
							invalidTexts.push(texts[j]);

					throw error.create({name:INVALID_KEY_OR_REF,
										message:utilityFunctions.getErrorMessage(error.Type.INVALID_KEY_OR_REF, getName(), JSON.stringify(invalidTexts))});
				}

				return internalIds;
			}
			var validateAndFormatFieldValue = utilityFunctions.thenableFunction(function validateAndFormatFieldValue(value, useStrict, allowPercentage, isAsync)
			{
				var returnedValue = value;
				if(fieldTypeConstants.isSelectType(getType()) && isRecordDynamic())
				{
					returnedValue = resultObject.create(function ()
					{
						return getSelectOptions.thenable(null, null, value, true, isAsync);
					}).then(function (options)
					{
						if(options) {
							return validateSelectField(value, options);
						}
						else {
							return validateSelectFieldData.thenable(value, isAsync);
						}
					}).then(function ()
					{
						if(util.isArray(value))
							return value.map(function(val){ return String(val);});
						else
							return String(value);
					});
				}
				else if (isRadioField())
				{
					var thisRadioSet = getRadioSet(getName());
					returnedValue = validator.validateRadioField(getName(), value, thisRadioSet);
				}
				else
				{
					var validateMe = value;
					returnedValue = validator.validateField(getName(), getType(), validateMe, isNumeric(), isCurrency(),
					                                        getValidationFieldType(), getMinValue(), getMaxValue(), getMaxLength(),
					                                        isMandatory(), !!useStrict, allowPercentage);
					if (isCurrency() && !utilityFunctions.isEmpty(value)) {
						returnedValue = getType() === fieldTypeConstants.Type.CURRENCY2 ?
								Number(currencyUtility.format_currency2(returnedValue)) : Number(currencyUtility.format_currency(returnedValue, false, getRecord()));
					}
				}

				return returnedValue;
			}, {
				isAsyncArgIndex: 3
			});
			var validateSelectFieldData = utilityFunctions.thenableFunction(function validateSelectFieldData(idsOrTexts, isAsync)
			{
				var idsOrTexts = utilityFunctions.normalizeArrayOrSingularObjectArg(idsOrTexts);

				var fieldValue = String(idsOrTexts);
				if (fieldTypeConstants.isMultiSelectType(getType()) && idsOrTexts.length > 1)
				{
					fieldValue = idsOrTexts.join(String.fromCharCode(5));
				}

				if (fieldTypeConstants.isSelectType(getType()) && fieldUtil.isPrefixedWithCustPage(getName()) && (idsOrTexts !== null))
				{
					return resultObject.create(function ()
					{
						return getSelectOptions.thenable(undefined, undefined, undefined, undefined, isAsync);
					}).then(function (myOptions)
					{
						cacheFieldOption(myOptions);
						var matchedOptions = myOptions.filter(function(v) { return idsOrTexts.indexOf(v.getId()) > -1; });
						return matchedOptions.length > 0;
					});
				}
				else
				{
					var requestParam = getRequestParam();
					requestParam.push(fieldValue);
					return (isAsync ? invoker.promise : invoker)(remoteApi, 'validateSelectField', requestParam);
				}
			}, {
				isAsyncArgIndex: 1
			});
			function markQueryRequest(request, fieldId)
			{
				request.q = String(fieldId);
			}
			function toString() { return "Field" }
			function toJSON()
			{
				return {
					name: getName(),
					type: getType(),
					label: getLabel()
				};
			}

			/* public undocumented methods */
			this.validateAndFormatFieldValue = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateAndFormatFieldValue
			});
			this.validateSelectFieldByText = recordFieldEvent.wrapValueValidation({
				emitter: emitter,
				recordField: that,
				func: validateSelectFieldByText
			});
			this.getLine = getLine;
			this.getLineInstanceId = getLineInstanceId;
			this.getIsCommitted = getIsCommitted;
			this.on = emitter.on;
			this.off = emitter.off;

			/* public methods */
			this.getType = getType;
			this.getSubrecordType = getSubrecordType;
			this.getSubrecordIdField = getSubrecordIdField;
			this.getName = getName;
			this.getSublistName = getSublistName;
			this.isPopup = isPopup;
			this.getMaxLength = getMaxLength;
			this.isNumeric = isNumeric;
			this.isCurrency = isCurrency;
			this.getMinValue = getMinValue;
			this.getMaxValue = getMaxValue;
			this.getValidationFieldType = getValidationFieldType;
			this.noSlaving = noSlaving;
			this.setNoSlaving = setNoSlaving;
			this.isDisabled = isDisabled;
			this.setDisabled = setDisabled;
			this.isDefaultMandatory = isDefaultMandatory;
			this.isMandatory = isMandatory;
			this.setMandatory = setMandatory;
			this.isDisplay = isDisplay;
			this.setDisplay = setDisplay;
			this.isVisible = isVisible;
			this.setVisible = setVisible;
			this.isReadOnly = isReadOnly;
			this.setReadOnly = setReadOnly;
			this.getLabel = getLabel;
			this.setLabel = setLabel;
			this.getSelectOptions = getSelectOptions;
			this.canExternalUpdateSelectOptions = canExternalUpdateSelectOptions;
			this.insertSelectOption = insertSelectOption;
			this.removeSelectOption = removeSelectOption;
			this.getRequestParam = getRequestParam;
			this.isCurrentRecord = isCurrentRecord;

			/* Debugger support */
			this.toJSON = toJSON;
			this.toString = toString;
		}
		Field.prototype = nsobject.getNewInstance();
		Object.freeze(Field);

		return Object.freeze({
				create: function(params) { return new Field(params); },
			})
	}
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/matrix
 * @suiteScriptVersion 2.x
 */
define(
	'N/record/matrix',['N/utilityFunctions','N/error', 'N/record/recordUtilityFunctions', 'N/resultObject'],
	function(utilityFunctions, error, recordUtil, resultObject){

		function doGetMatrixHeaderCount(sublistId)
		{
			if (sublistId === undefined)
				return 0;

			return parseInt(this.getValue(sublistId + 'headercount'), 10) || 0;
		}

		function getMatrixHeaderFieldName(sublistId, column)
		{
			var prefix = this.getValue(sublistId + 'header');

			return prefix + column;
		}

		function getMatrixFields(sublistId)
		{
			if (sublistId === undefined)
				return [];

			var matrixfieldsvalue = this.getValue(sublistId + 'matrixfields');

			return !!matrixfieldsvalue && matrixfieldsvalue.split(',') || [];
		}

		function isMatrixField(options, fieldId)
		{
			var sublistId,
				undef = undefined;
			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			return utilityFunctions.arrayIndexOf(getMatrixFields.call(this, sublistId), fieldId) !== -1;
		}

		function getMatrixLineFieldName(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
		    {
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			return isMatrixField.call(this, sublistId, fieldId) ? fieldId + "_" + column + "_" : null;
		}

		function getMatrixHeaderCount(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
                fieldId = options.fieldId;
			}

            utilityFunctions.checkArgs( [sublistId, fieldId], ['sublistId', 'fieldId'], this.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderCount'));
			return isMatrixField.call(this, sublistId, fieldId) ? doGetMatrixHeaderCount.call(this, sublistId) : -1;
		}

		function getMatrixHeaderValue(options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderValue'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName.call(this, sublistId, column);
			return this.getValue(matrixHeaderFieldName);
		}

		var setMatrixHeaderValue = utilityFunctions.thenableFunction(function setMatrixHeaderValue(options, fieldId, column, value, ignoreFieldChange, isAsync)
		{
			var sublistId,
				noSlaving = false,
				fireFieldChanged= true,
				matrixHeaderFieldName,
				forceSyncSourcing = false,
				fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], this.getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixHeaderValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName.call(this, sublistId, column);
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			var that = this;
			return this.withForceSyncSourcing(sublistId, matrixHeaderFieldName, forceSyncSourcing, function ()
			{
				return that.setValue.thenable(matrixHeaderFieldName, value, undefined, isAsync);
			});
		}, {
			isAsyncArgIndex: 5
		});

		function getCurrentMatrixSublistValue(options, fieldId, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('getCurrentMatrixSublistValue'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getCurrentMatrixSublistValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);
			return this.getCurrentSublistValue(sublistId, matrixLineFieldName, column);
		}

		var setCurrentMatrixSublistValue = utilityFunctions.thenableFunction(function setCurrentMatrixSublistValue(options, fieldId, column, value, ignoreFieldChange, isAsync)
		{
            var matrixLineFieldName,
                noSlaving = false,
				sublistId,
				fireFieldChanged = true,
	                        forceSyncSourcing = false,
	                        fireSlavingSync = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
				fireFieldChanged = util.isBoolean(ignoreFieldChange) ? !ignoreFieldChange : fireFieldChanged;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], this.getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setCurrentMatrixSublistValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);
			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			var that = this;
			return this.withForceSyncSourcing(sublistId, matrixLineFieldName, forceSyncSourcing, function ()
			{
				return that.setCurrentSublistValue.thenable(sublistId, matrixLineFieldName, value, undefined, isAsync);
			});
		}, {
			isAsyncArgIndex: 5
		});

		function getMatrixSublistValue(options, fieldId, linenum, column)
		{

            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], this.getMissingArgumentErrorMessageFillerValue('getMatrixSublistValue'));
			validateMatrixFieldAndLine.call(this, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);
			return this.getSublistValue(sublistId, matrixLineFieldName, linenum);
		}

		var setMatrixSublistValue = utilityFunctions.thenableFunction(function setMatrixSublistValue(options, fieldId, linenum, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], this.getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], this.getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
			validateMatrixFieldAndLine.call(this, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "setMatrixSublistValue", getMatrixHeaderCount.call(this, sublistId, fieldId));

			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);
			return this.setSublistValue.thenable(sublistId, matrixLineFieldName, linenum, value);
		});

		function findMatrixSublistLineWithValue(options, fieldId, column, value)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], this.getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "findMatrixSublistLineWithValue", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);
			return this.doFindSublistLineWithValue(sublistId, matrixLineFieldName, value);
		}

		function getMatrixHeaderField(options, fieldId, column)
		{
            var matrixHeaderFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], this.getMissingArgumentErrorMessageFillerValue('getMatrixHeaderField'));
			validateMatrixField.call(this, sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixHeaderField", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixHeaderFieldName = getMatrixHeaderFieldName.call(this, sublistId, column);
			return this.getField(matrixHeaderFieldName);
		}

		function getMatrixSublistField(options, fieldId, linenum, column)
		{
            var matrixLineFieldName,
				sublistId,
				undef = undefined;

			if (fieldId !== undef && linenum !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				linenum = options.line;
				column = options.column;
			}

			utilityFunctions.checkArgs( [sublistId, fieldId, linenum, column], ['sublistId', 'fieldId', 'line', 'column'], this.getMissingArgumentErrorMessageFillerValue('getMatrixSublistField'));
			validateMatrixFieldAndLine.call(this, sublistId, fieldId, linenum);
			column = recordUtil.validateAndGetOneBasedIndex(column, "getMatrixSublistField", getMatrixHeaderCount.call(this, sublistId, fieldId));
			matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, fieldId, column);

			return this.getSublistField(sublistId, matrixLineFieldName, linenum);
		}

		function parseMatrixLineField(fieldId, sublistId)
		{
			var result = null,
				fields, field, count, matrixLineFieldName,
				i;

			fields = getMatrixFields.call(this, sublistId);
			count = doGetMatrixHeaderCount.call(this, sublistId);
			for(i = 0; i < fields.length; i++)
			{
				field = fields[i];
				while(count > 0)
				{
					matrixLineFieldName = getMatrixLineFieldName.call(this, sublistId, field, count);
					if(fieldId === matrixLineFieldName)
					{
						result = {
							sublistname: sublistId,
							fieldname: fieldId,
							column: count
						};
						break;
					}
					count--;
				}
				if(!!result){break;}
			}

			return result;
		}

		function validateMatrixField(sublistId, fieldName)
		{
			if(!isMatrixField.call(this, sublistId, fieldName))
				utilityFunctions.throwSuiteScriptError(error.Type.METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD);
		}

		function validateMatrixFieldAndLine(sublistId, fieldName, lineNum)
		{
			validateMatrixField.call(this, sublistId, fieldName);
			if (isNaN(lineNum) || (parseInt(lineNum, 10) >= this.doGetLineCount(sublistId)) )
				utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
		}

		return Object.freeze({
			getMatrixHeaderFieldName : getMatrixHeaderFieldName,
			getMatrixFields : getMatrixFields,
			isMatrixField : isMatrixField,
			getMatrixLineFieldName : getMatrixLineFieldName,
            getMatrixHeaderCount : getMatrixHeaderCount,
			getMatrixHeaderValue : getMatrixHeaderValue,
			setMatrixHeaderValue : setMatrixHeaderValue,
            getCurrentMatrixSublistValue : getCurrentMatrixSublistValue,
            setCurrentMatrixSublistValue : setCurrentMatrixSublistValue,
            getMatrixSublistValue : getMatrixSublistValue,
            setMatrixSublistValue : setMatrixSublistValue,
            findMatrixSublistLineWithValue : findMatrixSublistLineWithValue,
            getMatrixHeaderField : getMatrixHeaderField,
            getMatrixSublistField : getMatrixSublistField,
			parseMatrixLineField : parseMatrixLineField,
			validateMatrixFieldAndLine: validateMatrixFieldAndLine
		})
	}
);

/**
 * Sublist Definition module
 * Will create the appropriate Sublist Object given the desired attributes.
 *
 * @private
 * @module N/sublistDefinition
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistDefinition',['N/internal/invoker', 'N/utilityFunctions', 'N/nsobject', 'N/error'],
    function(invoker, utilityFunctions, nsobject, error) {

    var SUBLIST_CATEGORY = Object.freeze({
                                             REMOTE: "remoteRecord",
                                             REMOTE_DYNAMIC: "remoteDynamicRecord",
                                             CURRENT: "currentRecord",
                                             READ_ONLY: "readOnlyRecord"
                                       });

    var SUBLIST_PROPERTIES = Object.freeze({
                                            ID: "id",
                                            TYPE: "type",
                                            IS_CHANGED: "isChanged",
                                            IS_DISPLAY: "isDisplay",
                                            IS_MULTILINE_EDITABLE : "isMultilineEditable",
                                            GET_COLUMN: "getColumn",
                                            GET_COLUMNS: "getColumns"
                                         });

    var COLUMN_PROPERTIES = Object.freeze({
                                               COLUMN_METADATA: "columnMetadata",
                                               ID: "id",
                                               TYPE: "type",
                                               LABEL: "label",
                                               SUBLIST_ID: "sublistId",
                                               IS_SORTABLE: "isSortable",
                                               IS_MANDATORY: "isMandatory",
                                               IS_DISABLED: "isDisabled",
                                               IS_DISPLAY: "isDisplay"
                                           });

    var ACCESS_LEVEL = Object.freeze({
                NONE: 0,
                READ_ONLY: 1,
                READ_WRITE: 2
                                     });

    function authorizeThenWrite(accessLevel, setFunction, propertyName)
    {
        if (accessLevel === ACCESS_LEVEL.READ_WRITE)
        {
            setFunction();
        }
        else
        {
            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, propertyName );
        }
    }

    function noAction() { }

	/**
	 *
	 * @param {RawSublist|CurrentRecordSublist} sublistDelegate
	 * @param {SublistPermissions} permissions
	 * @returns {Sublist}
	 * @constructor
	 */
    function Sublist(sublistDelegate, permissions)
    {
        if (permissions[SUBLIST_PROPERTIES.ID] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the ID of the Sublist
             * @name Sublist#id
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.ID, {
                get: function ()
                {
                    return sublistDelegate.id;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.ID], noAction, "Sublist." + SUBLIST_PROPERTIES.ID);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.TYPE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return the type of the Sublist
             * @name Sublist#type
             * @type {string}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.TYPE, {
                get: function ()
                {
                    return sublistDelegate.type;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.TYPE], noAction, "Sublist." + SUBLIST_PROPERTIES.TYPE);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_CHANGED] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist has changed
             * @name Sublist#isChanged
             * @type {boolean}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_CHANGED, {
                get: function ()
                {
                    return sublistDelegate.isChanged;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_CHANGED], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_CHANGED);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist is displayed
             * @name Sublist#isDisplay
             * @type {boolean}
             * @readonly
             * @since 2015.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_DISPLAY, {
                get: function ()
                {
                    return sublistDelegate.isDisplay;
                },
                set: function (val)
                {
	                var setFunction = function () {
		                sublistDelegate.isDisplay = val;
	                };
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_DISPLAY], setFunction, "Sublist." + SUBLIST_PROPERTIES.IS_DISPLAY);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE] > ACCESS_LEVEL.NONE)
        {
            /**
             * Return whether this sublist has Multiline Buffer feature enabled.
             * @name Sublist#isMultilineEditable
             * @type {boolean}
             * @readonly
             * @since 2018.2
             */
            Object.defineProperty(this, SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE, {
                get: function ()
                {
                    return sublistDelegate.isMultilineEditable;
                },
                set: function (val)
                {
                    authorizeThenWrite(permissions[SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE], noAction, "Sublist." + SUBLIST_PROPERTIES.IS_MULTILINE_EDITABLE);
                },
                enumerable: true,
                configurable: false
            });
        }
        if (permissions[SUBLIST_PROPERTIES.GET_COLUMN] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns a Column object given the specified fieldId
             * @name Sublist#getColumn
             * @param {{fieldId:string}|string} options fieldId
             * @return {Column}
             * @since 2015.2
             */
            this.getColumn = sublistDelegate.getColumn;
        }
        if (permissions[SUBLIST_PROPERTIES.GET_COLUMNS] > ACCESS_LEVEL.NONE)
        {
            /**
             * Returns an array containing the fieldIds of all columns in the sublist
             * @name Sublist#getColumns
             * @param {*} sublistId
             * @return {Array}
             * @since 2015.2
             */
            this.getColumns = sublistDelegate.getColumns;
        }

        /**
         * Returns the object type name (sublist.Sublist)
         * @returns {string}
         */
        this.toString = function ()
        {
            return "sublist.Sublist"
        };

        /**
         * JSON.stringify() implementation.
         * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean}}
         */
        this.toJSON = function ()
        {
            return {
                id: this.id,
                type: this.type,
                isChanged: this.isChanged,
                isDisplay: this.isDisplay
            }
        };
    }

    Sublist.prototype = nsobject.getNewInstance();
    Object.freeze(Sublist);

    /**
     *
     * @param {RawColumn|CurrentSublistColumn} columnDelegate
	 * @param {SublistPermissions} permissions
     * @returns {Column}
     * @constructor
     */
    function Column(columnDelegate, permissions)
    {
        var columnPermissions = permissions[COLUMN_PROPERTIES.COLUMN_METADATA];
        /**
         * Return the ID of the Column
         * @name Column#id
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, COLUMN_PROPERTIES.ID, {
            get: function ()
            {
                return columnDelegate.id;
            },
            set: function (val)
            {
                authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.ID], noAction, "Column." + COLUMN_PROPERTIES.ID);
            },
            enumerable: true,
            configurable: false
        });

        if (columnPermissions[COLUMN_PROPERTIES.IS_MANDATORY] > ACCESS_LEVEL.NONE) {
            /**
             * Returns if column is mandatory
             * @name Column#isMandatory
             * @type {boolean}
             * @since 2020.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.IS_MANDATORY, {
                get: function () {
                    return columnDelegate.isMandatory;
                },
                set: function (val) {
                    var setFunction = function () {
                        columnDelegate.isMandatory = val;
                    };
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.IS_MANDATORY], setFunction, "Column." + COLUMN_PROPERTIES.IS_MANDATORY);
                },
                enumerable: true,
                configurable: false
            });
        }

        if (columnPermissions[COLUMN_PROPERTIES.IS_DISABLED] > ACCESS_LEVEL.NONE) {
            /**
             * Returns if column is disabled
             * @name Column#isDisabled
             * @type {boolean}
             * @since 2020.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.IS_DISABLED, {
                get: function () {
                    return columnDelegate.isDisabled;
                },
                set: function (val) {
                    var setFunction = function () {
                        columnDelegate.isDisabled = val;
                    };
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.IS_DISABLED], setFunction, "Column." + COLUMN_PROPERTIES.IS_DISABLED);
                },
                enumerable: true,
                configurable: false
            });
        }

        if (columnPermissions[COLUMN_PROPERTIES.IS_DISPLAY] > ACCESS_LEVEL.NONE) {
            /**
             * Returns if column is display
             * @name Column#isDisplay
             * @type {boolean}
             * @since 2020.2
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.IS_DISPLAY, {
                get: function () {
                    return columnDelegate.isDisplay;
                },
                set: function (val) {
                    var setFunction = function () {
                        columnDelegate.isDisplay = val;
                    };
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.IS_DISPLAY], setFunction, "Column." + COLUMN_PROPERTIES.IS_DISPLAY);
                },
                enumerable: true,
                configurable: false
            });
        }

        if (columnPermissions[COLUMN_PROPERTIES.IS_SORTABLE] > ACCESS_LEVEL.NONE) {
            /**
             * Returns if column is sortable
             * @name Column#isSortable
             * @type {boolean}
             * @readonly
             */
            Object.defineProperty(this, COLUMN_PROPERTIES.IS_SORTABLE, {
                get: function ()
                {
                    return columnDelegate.isSortable;
                },
                set: function (val)
                {
                    authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.IS_SORTABLE], noAction, "Column." + COLUMN_PROPERTIES.IS_SORTABLE);
                },
                enumerable: true,
                configurable: false
            });
        }

        /**
         * Return the type of the Column
         * @name Sublist#type
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, COLUMN_PROPERTIES.TYPE, {
            get: function ()
            {
                return columnDelegate.type;
            },
            set: function (val)
            {
                authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.TYPE], noAction, "Column." + COLUMN_PROPERTIES.TYPE);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return the label of the Column
         * @name Sublist#label
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, COLUMN_PROPERTIES.LABEL, {
            get: function ()
            {
                return columnDelegate.label;
            },
            set: function (val)
            {
                var setFunction = function ()
                {
                    columnDelegate.label = val;
                };
                authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.LABEL], setFunction, "Column." + COLUMN_PROPERTIES.LABEL);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return the sublistId of the Column
         * @name Sublist#sublistId
         * @type {string}
         * @readonly
         * @since 2015.2
         */
        Object.defineProperty(this, COLUMN_PROPERTIES.SUBLIST_ID, {
            get: function ()
            {
                return columnDelegate.sublistId;
            },
            set: function (val)
            {
                authorizeThenWrite(columnPermissions[COLUMN_PROPERTIES.SUBLIST_ID], noAction, "Column." + COLUMN_PROPERTIES.SUBLIST_ID);
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Returns the object type name (sublist.Column)
         * @returns {string}
         */
        this.toString = function ()
        {
            return "sublist.Column"
        };

        /**
         * JSON.stringify() implementation.
         * @returns {{id: string, type: string, label: string, sublistId: string}}
         */
        this.toJSON = function ()
        {
            return {
                id: this.id,
                type: this.type,
                label: this.label,
                sublistId: this.sublistId,
                isDisabled: this.isDisabled,
                isMandatory: this.isMandatory,
                isDisplay: this.isDisplay
            }
        };
    }

    Column.prototype = nsobject.getNewInstance();
    Object.freeze(Column);


    return Object.freeze({
	    /** @enum {string} */
        Category: SUBLIST_CATEGORY,
	    /** @enum {string} */
        Property: SUBLIST_PROPERTIES,
	    /** @enum {string} */
        Column: COLUMN_PROPERTIES,
	    /** @enum {number} */
        Access: ACCESS_LEVEL,
	    /**
	     *
	     * @param {RawSublist|CurrentRecordSublist} delegate
	     * @param {SublistPermissions} permissions
	     * @returns {Sublist}
	     */
        create: function (delegate, permissions)
        {
            return !delegate ? null : Object.freeze(new Sublist(delegate, permissions));
        },
	    createColumn: function createColumn(columnInfo, permissions)
	    {
	    	return !columnInfo ? null : Object.freeze(new Column(columnInfo, permissions));
	    }
    });
});
/**
 *
 * @private
 * @module N/sublistPermissions
 * @NApiVersion 2.x
 *
 */
define('N/metadata/sublistPermissions',['N/metadata/sublistDefinition'], 
	function(sublistDef) {

	/** @typedef {Object} SublistPermissions */

    //also for current record in NEW UI
    var sublistRemoteDynamicRecord = {};
    sublistRemoteDynamicRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_WRITE;
    sublistRemoteDynamicRecord[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA]                              = {};
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_WRITE;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_SORTABLE] = sublistDef.Access.READ_ONLY;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISABLED] = sublistDef.Access.READ_WRITE;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_MANDATORY] = sublistDef.Access.READ_WRITE;
    sublistRemoteDynamicRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISPLAY] = sublistDef.Access.READ_WRITE;

    var sublistRemoteRecord = {};
    sublistRemoteRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA]                              = {};
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_WRITE;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_SORTABLE] = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISABLED] = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_MANDATORY] = sublistDef.Access.READ_ONLY;
    sublistRemoteRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISPLAY] = sublistDef.Access.READ_ONLY;

    var readOnlySublist = {};
    readOnlySublist[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA]                              = {};
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_SORTABLE] = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISABLED] = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_MANDATORY] = sublistDef.Access.READ_ONLY;
    readOnlySublist[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISPLAY] = sublistDef.Access.READ_ONLY;

    //current record in OLD UI only
    var sublistCurrentRecord = {};
    sublistCurrentRecord[sublistDef.Property.ID]                                         = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.TYPE]                                       = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_CHANGED]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.IS_DISPLAY]                                 = sublistDef.Access.READ_WRITE;
    sublistCurrentRecord[sublistDef.Property.IS_MULTILINE_EDITABLE]                       = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMN]                                 = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Property.GET_COLUMNS]                                = sublistDef.Access.NONE;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA]                              = {};
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.ID]        = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.TYPE]      = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.LABEL]     = sublistDef.Access.READ_WRITE;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.SUBLIST_ID] = sublistDef.Access.READ_ONLY;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_SORTABLE] = sublistDef.Access.NONE;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISABLED] = sublistDef.Access.READ_WRITE;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_MANDATORY] = sublistDef.Access.READ_WRITE;
    sublistCurrentRecord[sublistDef.Column.COLUMN_METADATA][sublistDef.Column.IS_DISPLAY] = sublistDef.Access.NONE;

    var masterPermission = {};
    masterPermission[sublistDef.Category.REMOTE] = sublistRemoteRecord;
    masterPermission[sublistDef.Category.REMOTE_DYNAMIC] = sublistRemoteDynamicRecord;
    masterPermission[sublistDef.Category.CURRENT] = sublistCurrentRecord;
    masterPermission[sublistDef.Category.READ_ONLY] = readOnlySublist;

    return Object.freeze(masterPermission);
});
/**
 * @module N/record/sublistBase
 * @private
 * @suiteScriptVersion 2.x
 */
define('N/record/sublistBase',[
	'N/record/proxy',
	'N/record/recordConstants',
	'N/metadata/sublistDefinition',
	'N/metadata/sublistPermissions'
], function (
	proxy,
	recordConstants,
	sublistDefinition,
	sublistPermissions
) {
	function SublistBase(record) {
		this.proxy = proxy.initialize(this, record, function (proxy, proxyOptions) {
			if (record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD ||
				record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD)
			{
				var category = sublistDefinition.Category.CURRENT;
			}
			else if (record.isReadOnly || proxyOptions.isReadOnly)
			{
				category = sublistDefinition.Category.READ_ONLY;
			}
			else if (record.isDynamic)
			{
				category = sublistDefinition.Category.REMOTE_DYNAMIC;
			}
			else
			{
				category = sublistDefinition.Category.REMOTE;
			}

			return sublistDefinition.create(proxy, sublistPermissions[category]);
		});
	}

	return SublistBase;
});

/**
 * @module N/record/columnBase
 * @private
 * @suiteScriptVersion 2.x
 */
define('N/record/columnBase',[
	'N/record/proxy',
	'N/record/recordConstants',
	'N/metadata/sublistDefinition',
	'N/metadata/sublistPermissions'
], function (
	proxy,
	recordConstants,
	sublistDefinition,
	sublistPermissions
) {
	function ColumnBase(record) {
		this.proxy = proxy.initialize(this, record, function (proxy, proxyOptions) {
			if (record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD ||
				record.toString() === recordConstants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD)
			{
				var category = sublistDefinition.Category.CURRENT;
			}
			else if (record.isReadOnly || proxyOptions.isReadOnly)
			{
				category = sublistDefinition.Category.READ_ONLY;
			}
			else if (record.isDynamic)
			{
				category = sublistDefinition.Category.REMOTE_DYNAMIC;
			}
			else
			{
				category = sublistDefinition.Category.REMOTE;
			}

			return sublistDefinition.createColumn(proxy, sublistPermissions[category]);
		});
	}

	return ColumnBase;
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublist
 * @suiteScriptVersion 2.x
 *
 */
define(
	'N/record/sublist',['N/nsobject', 'N/record/sublistBase', 'N/record/columnBase', 'N/utilityFunctions'],
	function (nsobject, sublistBase, columnBase, utilityFunctions) {

		var SUBLIST_TYPE = Object.freeze({
											INLINE_EDITOR : 'inlineeditor',
											EDITOR : 'editor',
											STATIC_LIST : 'staticlist',
											LIST: 'list'
										});

		/**
		 * Return a new instance of sublist object
		 *
		 * @alias RawSublist
		 *
		 * @param {Object} sublist
		 * @param {string} sublist.type type of sublist
		 * @param {SublistState} sublist.sublistState SublistState
		 * @param {Object<string,FieldLevelMetadata>} sublist.sublistFields

		 * @return {RawSublist}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function Sublist(sublist, record)
		{
			var sublistType = sublist.type;
			var sublistState = sublist.sublistState;
			var sublistFieldsMetadata = sublist.sublistFields;

			/**
			 * The id of the sublist
			 * @type {string}
			 * @since 2015.2
			 */
			this.id = sublistState.id;

			/**
			 * The type of the sublist.
			 * @type {string}
			 */
			this.type = sublistType;

			/**
			 * The sublist is changed
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isChanged', {
				get: function() {
                    return sublistState.isChanged;
                },
				configurable: true,
				enumerable: true
			});

			/**
			 * The sublist is hidden
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isHidden', {
				get: function() {
                    return sublistState.isHidden;
                },
				configurable: true,
				enumerable: true
			});

			/**
			 * The sublist is display
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isDisplay', {
				get: function() {
                    return sublistState.isDisplay;
                },
				set: function (val) {
					sublistState.isDisplay = val;
				},
				configurable: true,
				enumerable: true
			});

			/**
			 * A flag to indicate whether or not the sublist supports multi-line buffer feature.
			 * @type {boolean}
			 */
			this.isMultilineEditable = sublistState.isMultilineEditable;

			/**
			 * get column delegate
             * @param {{fieldId:string}|string} options fieldId
			 * @returns {RawColumn} rawColumn
			 */
            this.getColumn = function(options)
            {
                var fieldId;
                if (utilityFunctions.isObject(options))
                    fieldId = options.fieldId;
                else
                    fieldId = options;

                utilityFunctions.checkArgs([fieldId], ['fieldId'], 'sublist.getColumn');
                var columnMetadata = null;
                if (sublistFieldsMetadata.hasOwnProperty(fieldId))
                {
                     columnMetadata = new RawColumn(fieldId, sublistFieldsMetadata[fieldId], sublistState, record);
                }
                return columnMetadata;
            };

			/**
			 * get column ids
			 * @returns {Array<string>}
			 */
            this.getColumns = function() { return Object.getOwnPropertyNames(sublistFieldsMetadata); };

			/**
			 * Returns the object type name (sublist.Sublist)
			 * @returns {string}
			 */
			this.toString = function() {
				return "record.Sublist";
			};

			/**
			 * JSON.stringify() implementation.
             * @returns {{id: string, type: string, isChanged: boolean, isDisplay: boolean, isMultilineEditable: boolean}}
			 */
			this.toJSON  = function () {
				return {
					id: this.id,
					type: this.type,
					isChanged: this.isChanged,
                    isDisplay: this.isDisplay,
					isMultilineEditable: this.isMultilineEditable
				};
			};

			sublistBase.call(this, record);

			return this;
		}
		Sublist.prototype = nsobject.getNewInstance();
		Object.freeze(Sublist);

		/**
		 *
		 * @param {string} fieldId
		 * @param {FieldLevelMetadata} fieldLevelMetadata
		 * @param {SublistState} sublistState
		 * @returns {RawColumn}
		 * @constructor
		 */
		function RawColumn(fieldId, fieldLevelMetadata, sublistState, record) {
			/**
			 * column id
			 * @type {string}
			 */
			this.id = fieldLevelMetadata.name;

			/**
			 * column's type
			 * @type {string}
			 */
			this.type = fieldLevelMetadata.type;

			/**
			 * column's label
			 * @type {string}
			 */
			Object.defineProperty(this, 'label', {
				get: function() {
					return sublistState.getColumnProperty(fieldId, 'label');
				},
				set: function(newLabel) {
					sublistState.setColumnProperty(fieldId, 'label', newLabel);
				},
				configurable: true,
				enumerable: true
			});

			/**
			 * column's mandatory flag
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isMandatory', {
				get: function() {
					return sublistState.getColumnProperty(fieldId, 'isMandatory');
				},
				set: function(val) {
					sublistState.setColumnProperty(fieldId, 'isMandatory', val);
				},
				configurable: true,
				enumerable: true
			});

			/**
			 * column's disabled flag
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isDisabled', {
				get: function() {
					return sublistState.getColumnProperty(fieldId, 'isDisabled');
				},
				set: function(val) {
					sublistState.setColumnProperty(fieldId, 'isDisabled', val);
				},
				configurable: true,
				enumerable: true
			});

			/**
			 * column's display flag
			 * @type {boolean}
			 */
			Object.defineProperty(this, 'isDisplay', {
				get: function() {
					var isDisplay = sublistState.getColumnProperty(fieldId, 'isDisplay');
					var isVisible = sublistState.getColumnProperty(fieldId, 'isVisible');
					var isHidden = sublistState.getColumnProperty(fieldId, 'isHidden');

					return isDisplay && isVisible && !isHidden;
				},
				set: function(val) {
					sublistState.setColumnProperty(fieldId,'isDisplay', val);
				},
				configurable: true,
				enumerable: true
			});

			/**
			 * sublist id
			 * @type {string}
			 */
			this.sublistId = sublistState.id;

			/**
			 * check if the column is sortable
			 * @type {boolean}
			 */
			this.isSortable = fieldLevelMetadata.isSortable;

			columnBase.call(this, record);

			return this;
		}
		RawColumn.prototype = nsobject.getNewInstance();
		Object.freeze(RawColumn);

		/*
		 * Return a new instance of sublist v1 object
		 *
		 * @param {Sublist} sublist
		 * @return {SublistV1}
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function SublistV1(sublist)
		{
            this.getName = function() { return sublist.id; };
			this.isChanged = function() { return sublist.isChanged; };
			this.getSublistType = function() { return sublist.type; };
			this.getType = function() { return sublist.type; };
			this.isDisplay = function() { return sublist.isDisplay; };
			this.setDisplay = function(val) {
				// TODO: figure out what it this mess about, but this is not supported in 1.0
				//sublist.isDisplay = val;
			};
			this.isHidden = function() { return sublist.isHidden; };
			this.setHidden = function(val) {
				//sublist.isHidden = val;
			};
			return this;
		}
		SublistV1.prototype = nsobject.getNewInstance();
		Object.freeze(SublistV1);

		return Object.freeze({
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublist
			 * @param {string} sublist.type type of sublist
			 * @param {SublistState} sublist.sublistState SublistState
			 * @param {Object<string,FieldLevelMetadata>} sublist.sublistFields
			 * @returns {RawSublist}
			 */
			create: function(sublist, record) { return new Sublist(sublist, record); },
			/**
			 * return a new instance of sublist object
			 * @param {Object} sublistJson
			 * @returns {SublistV1}
			 */
			newInstanceOfV1Sublist: function(sublistJson, record) {
                var sublist = new Sublist(sublistJson, record);
                return new SublistV1(sublist);
            },
			/**
			 * @enum {string}
			 */
			Type: SUBLIST_TYPE
		});
	}
);

// RecordBehaviorDelegate

/**
 * Performs the actions desired by the record or line objects with respect to the record.
 *
 * @private
 * @module N/common/record/recordActualWork
 * @NApiVersion 2.x
 *
 */
define('N/common/record/recordActualWork',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/formatter', 'N/util/validator', 'N/resultObject', 'N/fieldTypeConstants'],
	function(recordUtil, utilityFunctions, formatter, validator, resultObject, fieldTypeConstants)
{
	var undef = undefined;
	var IS_CHANGED = true;
	var FIELD_ID = "fieldId";
	var SUBLIST_ID = "sublistId";
	var METHOD_GET_FIELD = "getField";
	var METHOD_GET_FIELDS = "getFields";
	var METHOD_GET_VALUE = "getValue";
	var METHOD_SET_VALUE = "setValue";
	var METHOD_GET_TEXT = "getText";
	var METHOD_SET_TEXT = "setText";
	var METHOD_HAS_SUBRECORD = "hasSubrecord";
	var METHOD_GET_SUBRECORD = "getSubrecord";
	var METHOD_REMOVE_SUBRECORD = "removeSubrecord";


	/**
	 * Delegation Service for record-like object
	 * @param {Object} options
	 * @param {RawRecord|RawLine} options.delegate
	 * @returns {RecordBehaviorDelegate}
	 * @constructor
	 */
	function RecordBehaviorDelegate(options)
	{
		var that = this;
		var delegate = options.delegate;


		function getFieldState(fieldId)
		{
			return delegate.getFieldState(fieldId);
		}

		function getFieldLevelMetadata(fieldId)
		{
			return delegate.getFieldLevelMetadataForBodyField(fieldId);
		}

		function isValidField(fieldId)
		{
			return delegate.isValidBodyField(fieldId);
		}

		function getField(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_FIELD));
			fieldId = delegate.convertFieldId(fieldId);
			return delegate.doGetField(fieldId);
		}
		this.getField = getField;

		function getFields()
		{
			return delegate.doGetFields();
		}
		this.getFields = getFields;

		function getValue(options)
		{
			var isTextApi = false;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_VALUE));
			fieldId = delegate.convertFieldId(fieldId);
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_TEXT, METHOD_GET_TEXT);
			return delegate.getParsedValueForBodyField(fieldId, this);
		}
		this.getValue = getValue;

		var setValue = utilityFunctions.thenableFunction(function setValue(options, value, isAsync)
		{
			var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false;
			if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_VALUE));
			recordUtil.validateAgainstSqlInjection(fieldId, value);
			fieldId = delegate.convertFieldId(fieldId);

			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			return delegate.withForceSyncSourcing(fieldId, forceSyncSourcing, function ()
			{
				return delegate.doSetValue.thenable(fieldId, value, fireFieldChange, isAsync);
			}).then(function ()
			{
				return delegate;
			});
		}, {
        	isAsyncArgIndex: 2
		});

		this.setValue = setValue;

		var getText = utilityFunctions.thenableFunction(function getText(options, isAsync)
		{
			var isTextApi = true;
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT));
			fieldId = delegate.convertFieldId(fieldId);
			delegate.validateTextApi(isTextApi, getFieldState(fieldId), METHOD_SET_VALUE, METHOD_GET_VALUE);
			return delegate.doGetText.thenable(fieldId, that, isAsync);
		}, {
        	isAsyncArgIndex: 1
		});

		this.getText = getText;

		var setText = utilityFunctions.thenableFunction(function setText(options, text, isAsync)
		{
			var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false;
			if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}
			delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_TEXT);
			utilityFunctions.checkArgs([fieldId], [FIELD_ID], delegate.getMissingArgumentErrorMessageFillerValue(METHOD_SET_TEXT));
			fieldId = delegate.convertFieldId(fieldId);
			text = recordUtil.emptyIfNullOrUndefined(text);
			recordUtil.validateAgainstSqlInjection(fieldId, text);

			if (!forceSyncSourcing)
			{
				forceSyncSourcing = fireSlavingSync;
			}
			return delegate.withForceSyncSourcing(fieldId, forceSyncSourcing, function ()
			{
				return delegate.doSetText.thenable(fieldId, text, fireFieldChange, isAsync);
			}).then(function ()
			{
				return delegate;
			});
		}, {
        	isAsyncArgIndex: 2
		});

		this.setText = setText;

		function getParsedValue(fieldId, skipPercentage)
		{
			var returnValue = delegate.doGetValue(fieldId);
			var fs = getFieldState(fieldId);
			var fieldLevelMetadata = getFieldLevelMetadata(fieldId);
			var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.CHECKBOX;
			var isRate = fieldLevelMetadata && fieldTypeConstants.isRateType(fieldLevelMetadata.type);

			if ((fs && !fs.isParsed) || (isCheckbox && returnValue === "") || (isRate && ("" + returnValue).indexOf("%") !== -1))
			{
				var isFieldValid = isValidField(fieldId);
				var parsedValue = recordUtil.parseValue(isFieldValid, fieldLevelMetadata, returnValue, undefined, true);
				if (isFieldValid || parsedValue !== undefined)
					delegate.setParsedValueAndUpdateFieldState(fieldId, parsedValue, fs);
				returnValue = (isRate && skipPercentage) ? recordUtil.parseValue(isFieldValid, fieldLevelMetadata, returnValue, true, true) : parsedValue;
			}
			return returnValue;
		}
		this.getParsedValue = getParsedValue;

		var getTextValue = utilityFunctions.thenableFunction(function getTextValue(fieldId, isAsync)
		{
			var isCommitted = true;
			var lineInstanceId = null;
			return getTextValueForInstance.thenable(undef, fieldId, lineInstanceId, isCommitted, isAsync);
		}, {
        	isAsyncArgIndex: 1
		});

		this.getTextValue = getTextValue;

		var getTextValueForInstance = utilityFunctions.thenableFunction(function getTextValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, isAsync)
		{
			var setFieldMetadata = delegate.getSetFieldMetadata(sublistId, fieldId);
			var fieldLevelMetadata = delegate.extractInforFromFieldLevelMetadata(sublistId, fieldId);
			var value = getParsedValue(fieldId);
			return doGetTextValueForInstance.thenable(delegate.getHack(), value, lineInstanceId, isCommitted, setFieldMetadata, fieldLevelMetadata, isAsync);
		}, {
        	isAsyncArgIndex: 4
		});

		this.getTextValueForInstance = getTextValueForInstance;

		var commit = utilityFunctions.thenableFunction(function commit(isAsync)
		{
			return resultObject.create(function ()
			{
				return delegate.doCommit.thenable(isAsync);
			}).then(function ()
			{
				return delegate;
			})
		}, {
        	isAsyncArgIndex: 0
		});

		this.commit = commit;

		var move = utilityFunctions.thenableFunction(function move(options)
		{
			var toInstanceId = (options && options.toInstanceId) || options;
			return resultObject.create(function ()
			{
				return delegate.doMove.thenable(toInstanceId);
			}).then(function ()
			{
				return delegate;
			})
		});

		this.move = move;

		var cancel = utilityFunctions.thenableFunction(function cancel()
		{
			return resultObject.create(function ()
			{
				return delegate.doCancel.thenable();
			}).then(function ()
			{
				return delegate;
			})
		});

		this.cancel = cancel;

		function hasSubrecord(options)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_HAS_SUBRECORD));
			fieldId = delegate.convertFieldId(fieldId);
			return delegate.doHasSubrecord(fieldId);
		}
		this.hasSubrecord = hasSubrecord;

		var getSubrecord = utilityFunctions.thenableFunction(function getSubrecord(options, proxyOptions, isAsync)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_GET_SUBRECORD));
			fieldId = delegate.convertFieldId(fieldId);
			return delegate.doGetSubrecord.thenable(fieldId, proxyOptions, isAsync);
		}, {
        	isAsyncArgIndex: 2
		});

		this.getSubrecord = getSubrecord;

		var removeSubrecord = utilityFunctions.thenableFunction(function removeSubrecord(options, isAsync)
		{
			var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, FIELD_ID, delegate.getMissingArgumentErrorMessageFillerValue(METHOD_REMOVE_SUBRECORD));
			fieldId = delegate.convertFieldId(fieldId);
			return resultObject.create(function ()
			{
				return delegate.doRemoveSubrecord.thenable(fieldId, isAsync);
			}).then(function ()
			{
				return delegate;
			})
		}, {
        	isAsyncArgIndex: 1
		});

		this.removeSubrecord = removeSubrecord;

		var makeCopy = utilityFunctions.thenableFunction(function makeCopy(isAsync)
		{
			return delegate.doMakeCopy.thenable(isAsync);
		}, {
        	isAsyncArgIndex: 0
		});

		this.makeCopy = makeCopy;
	}

	/**
	 *
	 * @param {*} options
	 * @returns {RecordBehaviorDelegate}
	 */
	function create(options)
	{
		return new RecordBehaviorDelegate(options);
	}


	function updateSubrecordStates(record)
	{
		var subrecordSublistState = record.getSubrecordSublistState();
		var subrecordFieldState = record.getSubrecordFieldState();
		if (subrecordSublistState != null)
			subrecordSublistState.isChanged = IS_CHANGED;
		if (subrecordFieldState != null)
			subrecordFieldState.isChanged = IS_CHANGED;
	}

	function formatValueAsText(value, metadata)
	{
		var returnMe;
		if (util.isArray(value))
		{
			returnMe = value.map(function (val)
			{
				return recordUtil.formatArrayToStringType(val);
			});
		}
		else
		{
			returnMe = formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata);
			if (returnMe === null)
			{
				returnMe = doFormatValue(value, metadata);
			}
		}
		return returnMe;
	}

	function formatFieldWithEmptyValueOrSelectTypeOrVirtualField(value, metadata)
	{
		var fieldType = metadata.type || null;
		var formattedValue = null;

		if (!value && value !== "" && value !== 0 && !util.isBoolean(value))
			formattedValue = "";
		else if (metadata.isMultiSelect && util.isArray(value))
			formattedValue = value.join(String.fromCharCode(5));
		else if (metadata.isSelect || fieldType === null)
			formattedValue = String(value);

		return formattedValue;
	}

	function doFormatValue(value, metadata)
	{
		var fieldType = metadata.type || null;
		var isNumeric = metadata.isNumeric || false;
		var isCurrency = metadata.isCurrency || false;
		var formattedValue = formatter.format(value, fieldType, isNumeric, isCurrency);
		return formattedValue ? String(formattedValue) : formattedValue;
	}

	function postDoSetSublistValueForInstance(record, sublistId, fieldId, lineInstanceId, isCommitted)
	{
		record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted).isChanged = IS_CHANGED;
		record.getSublistState(sublistId).isChanged = IS_CHANGED;
		updateSubrecordStates(record);
	}

	var preDoSetValueForInstance = utilityFunctions.thenableFunction(function preDoSetValueForInstance(record, preSetObject, lineInstanceId, isCommitted, isAsync)
	{
		return record.preSetFieldValueForInstance.thenable(preSetObject.sublistId, preSetObject.fieldId,
			lineInstanceId, isCommitted, preSetObject.valueObject,
			preSetObject.fireFieldChange, preSetObject.noSlaving, preSetObject.noValidation, isAsync);
	}, {
		isAsyncArgIndex: 4
	});

	var postDoSetValueForInstance = utilityFunctions.thenableFunction(function postDoSetValueForInstance(record, postSetObject, lineInstanceId, isCommitted, isAsync)
	{
		return resultObject.create(function ()
		{
			return record.postSetFieldValueForInstance.thenable(postSetObject.sublistId, postSetObject.fieldId,
				lineInstanceId, isCommitted, postSetObject.dbValue,
				postSetObject.fireFieldChange, postSetObject.noSlaving, postSetObject.noValidation, isAsync);
		}).then(function ()
		{
			updateSubrecordStates(record);
		});
	}, {
		isAsyncArgIndex: 4
	});

	function createObjectToDoSetSublistValue(val, metadata)
	{
		var value = recordUtil.emptyIfNullOrUndefined(val);
		var dbValue = recordUtil.formatValueForLegacySyntheticRequest(metadata.type, value);
		return {value: value, legacyStringValue: dbValue};
	}

	function createObjectToDoSetValue(val, metadata)
	{
		var dbValue;
		if (metadata.valueIsFormattedAsString)
			dbValue = (val !== null) ? String(val) : null;
		else
			dbValue = recordUtil.formatValueForLegacySyntheticRequest(metadata.type, val);
		return {value: val, legacyStringValue: dbValue};
	}

	function getTextValueForRadioField(value, fieldLevelMetadata)
	{
		var returnText = "";
		if (fieldLevelMetadata.radioSet)
			returnText = fieldLevelMetadata.radioSet[value];
		else if (fieldLevelMetadata.hasBlankString)
			returnText = fieldLevelMetadata.blankString;
		return returnText;
	}

	function getTextValueForCurrencyField(record, value, metadata)
	{
		var retValue = formatter.format(value, metadata.type, metadata.isNumeric, metadata.isCurrency, record);
		return !utilityFunctions.isEmpty(retValue) ? String(retValue) : '';
	}

	var getTextValueForSelectField = utilityFunctions.thenableFunction(function getTextValueForSelectField(record, value, lineInstanceId, isCommitted, fieldLevelMetadata, isMulti, isAsync)
	{
		return resultObject.create(function ()
		{
			var returnText = "";
			if (util.trim(value) || value === 0 || value === false) {
				var getter = Array.isArray(fieldLevelMetadata.supplementedOptions) ? record.doGetTextValueForSupplementedSelectFieldForInstance : record.doGetTextValueForSelectFieldForInstance;
				returnText = getter.thenable(fieldLevelMetadata.sublistId, fieldLevelMetadata.fieldId, value, lineInstanceId, isCommitted, isMulti, isAsync);
			}
			else if (fieldLevelMetadata.hasBlankString) {
				returnText = fieldLevelMetadata.blankString;
			}
			return returnText;
		}).then(function (returnText)
		{
			if (isMulti) {
				return returnText ? String(returnText).split(String.fromCharCode(5)) : [];
			} else {
				return returnText;
			}
		});
	}, {
		isAsyncArgIndex: 6
	});

	var doGetTextValueForInstance = utilityFunctions.thenableFunction(function doGetTextValueForInstance(record, value, lineInstanceId, isCommitted, metadata, fieldLevelMetadata, isAsync)
	{
		var formattedValue;
		if (!metadata.isValidField || value === undef || value === null)
			formattedValue = value;
		else if (metadata.isMultiSelect)
			formattedValue = getTextValueForSelectField.thenable(record, value, lineInstanceId, isCommitted, fieldLevelMetadata, true, isAsync);
		else if (metadata.isSelect)
			formattedValue = getTextValueForSelectField.thenable(record, value, lineInstanceId, isCommitted, fieldLevelMetadata, false, isAsync);
		else if (metadata.isRadio)
			formattedValue = getTextValueForRadioField(value, fieldLevelMetadata);
		else if (metadata.isCurrency)
			formattedValue = getTextValueForCurrencyField(record, value, metadata);
		else
			formattedValue = formatValueAsText(value, metadata);
		return formattedValue;
	}, {
		isAsyncArgIndex: 6
	});

	/**
	 * @param {string|Number|Boolean|Date|Array|null} value
	 * @param {Object} metadata
	 * @param {boolean} metadata.hasFieldExisted filed is set or defined in record metadata
	 * @param {boolean} metadata.isMultiSelect is multiselect field
	 * @param {boolean} isNSE
	 * @returns {string|Number|Boolean|Date|Array|null|undefined} undefined can be returned only for NSN
	 *
	 * called only from record definition
	 */
	function handleMultiSelectAndVirtualFieldForReturnValue(value, metadata, isNSE)
	{
		var returnMe;
		if (metadata.hasFieldExisted)
			returnMe = (metadata.isMultiSelect && !value && value !== 0) ? [] : value;
		else
			returnMe = (isNSE) ? null : undef;
		return returnMe;
	}

	var getValueOrValuesForSelect = utilityFunctions.thenableFunction(function getValueOrValuesForSelect(record, sublistId, fieldId, text, lineInstanceId, isMultiSelect, isCommitted, isAsync)
	{
		var returnMe = "";
		var rf;
		record.validateIfSublistIdEditableAndInstanceIdValid(sublistId, lineInstanceId, isCommitted);
		if (isMultiSelect)
		{
			returnMe = recordUtil.formatValueToArrayType(text);
			rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			returnMe = (isAsync ? rf.validateSelectFieldByText.promise : rf.validateSelectFieldByText)(returnMe);
		}
		else
		{
			var unwrappedText = recordUtil.formatArrayToStringType(text);
			if (unwrappedText || unwrappedText === "")
			{
				rf = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				returnMe = (isAsync ? rf.validateSelectFieldByText.promise : rf.validateSelectFieldByText)(unwrappedText);
			}
		}
		return returnMe;
	}, {
		isAsyncArgIndex: 7
	});

	var convertTextToValueForSetText = utilityFunctions.thenableFunction(function convertTextToValueForSetText(record, sublistId, fieldId, lineInstanceId, text, metadata, isCommitted, isAsync)
	{
		var value;
		if (metadata.isMultiSelect || metadata.isSelect)
			value = getValueOrValuesForSelect.thenable(record, sublistId, fieldId, text, lineInstanceId, metadata.isMultiSelect, isCommitted, isAsync);
		else if (metadata.isRadio)
			value = validator.validateRadioFieldByText(fieldId, text, metadata.radioSet);
		else
		{
			var fieldLevelMetadata = record.getMetadata().getFieldMetadata(sublistId, fieldId);
			if (fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.TIME)
				validator.validateField(fieldId, "text", text, false, false, undefined, undefined, undefined, fieldLevelMetadata.maxLength, false, true);
			if (record.isFieldCheckbox(sublistId, fieldId)) {
				text = "" + text; // to keep legacy behavior where only "T" is accepted as true by parser
			}
			value = recordUtil.parseValue(metadata.isValidField, fieldLevelMetadata, text);
		}
		return value;
	}, {
		isAsyncArgIndex: 7
	});

	return {
		create: create,
		createObjectToDoSetSublistValue : createObjectToDoSetSublistValue,
		createObjectToDoSetValue: createObjectToDoSetValue,
		postDoSetSublistValueForInstance: postDoSetSublistValueForInstance,
		postDoSetValueForInstance: postDoSetValueForInstance,
		preDoSetValueForInstance: preDoSetValueForInstance,
		handleMultiSelectAndVirtualFieldForReturnValue: handleMultiSelectAndVirtualFieldForReturnValue,
		convertTextToValueForSetText: convertTextToValueForSetText
	};
});

/**
 * SuiteScript persisted sublist line impl
 *
 * @private
 * @module N/record/line/sublistLineImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImpl',['N/utilityFunctions'],
	function (utilityFunctions) {

	/**
	 * Line implementation for sublist line instance
	 * @param {RawLine} line
	 * @returns {SublistLineImpl}
	 * @constructor
	 */
	function SublistLineImpl(line) {
		var isCommitted = true;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getFieldState = getFieldState;

		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, isCommitted);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetValue = doGetValue;

		var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
		{
			return getParentRecord().doGetSublistTextForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator, isAsync);
		}, {
			isAsyncArgIndex: 2
		});
		this.doGetText = doGetText;

		var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, isAsync)
		{
			return getParentRecord().doSetSublistValueForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, value, fireFieldChange, undefined, undefined, undefined, isAsync);
		}, {
			isAsyncArgIndex: 3
		});
		this.doSetValue = doSetValue;

		var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text, fireFieldChange, isAsync)
		{
			var noSlaving = false;
			var noValidationAndFormatting = false;
			return getParentRecord().doSetSublistTextForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, text, fireFieldChange, noSlaving, noValidationAndFormatting, undefined, isAsync);
		}, {
			isAsyncArgIndex: 3
		});
		this.doSetText = doSetText;

		function doGetField(fieldId)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		var doMove = utilityFunctions.thenableFunction(function doMove(toInstaceId)
		{
			return getParentRecord().moveLine.thenable({sublistId: getSublistId(), fromInstanceId: getLineInstanceId(), toInstanceId: toInstaceId});
		});
		this.doMove = doMove;

		var doCommit = utilityFunctions.thenableFunction(function doCommit(isAsync)
		{
			return getParentRecord().commitLineForInstance.thenable(getSublistId(), getLineInstanceId(), undefined, isAsync);
		}, {
			isAsyncArgIndex: 0
		});
		this.doCommit = doCommit;

		var doCancel = utilityFunctions.thenableFunction(function doCancel()
		{
			return getParentRecord().cancelLineForInstance.thenable(getSublistId(), getLineInstanceId());
		});
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.hasSubrecord = hasSubrecord;

		var getSubrecord = utilityFunctions.thenableFunction(function getSubrecord(fieldId, proxyOptions, isAsync)
		{
			var isReadOnly = getParentRecord().getIsReadOnlyRecord();
			return getParentRecord().doGetSublistSubrecordForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, isReadOnly, proxyOptions, isAsync);
		}, {
			isAsyncArgIndex: 2
		});
		this.getSubrecord = getSubrecord;

		var removeSubrecord = utilityFunctions.thenableFunction(function removeSubrecord(fieldId, isAsync)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, isAsync);
		}, {
			isAsyncArgIndex: 1
		});
		this.removeSubrecord = removeSubrecord;

		var makeCopy = utilityFunctions.thenableFunction(function makeCopy(isAsync)
		{
			return getParentRecord().makeCopyForInstance.thenable(getSublistId(), getLineInstanceId(), isCommitted, isAsync);
		}, {
			isAsyncArgIndex: 0
		});
		this.makeCopy = makeCopy;
	}

	/**
	 * create a regular sublistline implementation that will supplement line behavior
	 * @param {RawLine} line
	 * @returns {SublistLineImpl}
	 */
	function create(line)
	{
		return new SublistLineImpl(line);
	}

	return {
		create : create
	};
});

/**
 * SuiteScript sublist buffer line impl
 *
 * @private
 * @module N/record/line/sublistLineBufferImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineBufferImpl',['N/utilityFunctions'], function (utilityFunctions) {

	/**
	 * Line implementation for sublist buffer line instance
	 * @param {RawLine} line
	 * @returns {SublistLineBufferImpl}
	 * @constructor
	 */
	function SublistLineBufferImpl(line) {
		var isCommitted = false;

		function getSublistId()
		{
			return line.getSublistId();
		}

		function getLineInstanceId()
		{
			return line.getLineInstanceId();
		}

		function getParentRecord(){
			return line.getUnproxiedRecord();
		}

		function getFieldState(fieldId)
		{
			return getParentRecord().getSublistFieldStateForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.getFieldState = getFieldState;
		
		function getParsedValueForBodyField(fieldId, delegator)
		{
			return getParentRecord().doGetParsedSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator);
		}
		this.getParsedValueForBodyField = getParsedValueForBodyField;

		function setParsedValueForBodyField(fieldId, value)
		{
			getParentRecord().setParsedValueForSublistFieldForInstance(getSublistId(), getLineInstanceId(), fieldId, value, isCommitted);
		}
		this.setParsedValueForBodyField = setParsedValueForBodyField;

		function doGetValue(fieldId)
		{
			return getParentRecord().doGetSublistValueForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetValue = doGetValue;

		var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
		{
			return getParentRecord().doGetSublistTextForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, delegator, isAsync);
		}, {
			isAsyncArgIndex: 2
		});
		this.doGetText = doGetText;

		var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, isAsync)
		{
			return getParentRecord().doSetSublistValueForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, value, fireFieldChange, undefined, undefined, undefined, isAsync);
		}, {
			isAsyncArgIndex: 3
		});
		this.doSetValue = doSetValue;

		var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text, fireFieldChange, isAsync)
		{
			var noSlaving = false;
			var noValidationAndFormatting = false;
			return getParentRecord().doSetSublistTextForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, text, fireFieldChange, noSlaving, noValidationAndFormatting, undefined, isAsync);
		}, {
			isAsyncArgIndex: 3
		});
		this.doSetText = doSetText;

		function doGetField(fieldId)
		{
			return getParentRecord().doGetFieldForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.doGetField = doGetField;

		function doGetFields()
		{
			return getParentRecord().getSublistFields(getSublistId());
		}
		this.doGetFields = doGetFields;

		var doMove = utilityFunctions.thenableFunction(function doMove(toInstaceId)
		{
			return getParentRecord().moveLine.thenable({sublistId: getSublistId(), fromInstanceId: getLineInstanceId(), toInstanceId: toInstaceId});
		});
		this.doMove = doMove;

		var doCommit = utilityFunctions.thenableFunction(function doCommit(isAsync)
		{
			return getParentRecord().commitLineForInstance.thenable(getSublistId(), getLineInstanceId(), undefined, isAsync);
		}, {
			isAsyncArgIndex: 0
		});
		this.doCommit = doCommit;

		var doCancel = utilityFunctions.thenableFunction(function doCancel()
		{
			return getParentRecord().cancelLineForInstance.thenable(getSublistId(), getLineInstanceId());
		});
		this.doCancel = doCancel;

		function hasSubrecord(fieldId)
		{
			return getParentRecord().doHasSubrecordForInstance(getSublistId(), fieldId, getLineInstanceId(), isCommitted);
		}
		this.hasSubrecord = hasSubrecord;

		var getSubrecord = utilityFunctions.thenableFunction(function getSubrecord(fieldId, proxyOptions, isAsync)
		{
			var isReadOnly = getParentRecord().getIsReadOnlyRecord();
			return getParentRecord().doGetSublistSubrecordForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, isReadOnly, proxyOptions, isAsync);
		}, {
			isAsyncArgIndex: 2
		});
		this.getSubrecord = getSubrecord;

		var removeSubrecord = utilityFunctions.thenableFunction(function removeSubrecord(fieldId, isAsync)
		{
			return getParentRecord().doRemoveSublistSubrecordForInstance.thenable(getSublistId(), fieldId, getLineInstanceId(), isCommitted, isAsync);
		}, {
			isAsyncArgIndex: 1
		});
		this.removeSubrecord = removeSubrecord;

		var makeCopy = utilityFunctions.thenableFunction(function makeCopy(isAsync)
		{
			return getParentRecord().makeCopyForInstance.thenable(getSublistId(), getLineInstanceId(), isCommitted, isAsync);
		}, {
			isAsyncArgIndex: 0
		});
		this.makeCopy = makeCopy;
	}

	/**
	 * create a buffered sublistline implementation that will supplement line behavior
	 * @param {RawLine} line
	 * @returns {SublistLineBufferImpl}
	 */
	function create(line)
	{
		return new SublistLineBufferImpl(line);
	}

	return {
		create : create
	};
});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/line/sublistLineImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/line/sublistLineImplementation',['N/record/line/sublistLineImpl', 'N/record/line/sublistLineBufferImpl'], function(sublistLineImpl, sublistLineBufferImpl){

	/**
	 * create the corresponding implementation for line object based on the isCommitted mode
	 * @param {Object} options
	 * @param {RawLine} options.line
	 * @param {boolean} options.isCommitted is not buffer instance
	 * @returns {SublistLineImpl|SublistLineBufferImpl}
	 */
	function create(options)
	{
		var isCommitted = options.isCommitted;
		var line = options.line;
		return isCommitted ? sublistLineImpl.create(line) : sublistLineBufferImpl.create(line);
	}

	return {
		create : create
	};
});

/**
 * SuiteScript sublist line event module
 *
 * @private
 * @module N/record/sublistLineEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLineEvent',[], function()
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE'
		});

	function getEvent(sublistLine, fieldId, type)
	{
		return {
			type: type,
			sublistLine: sublistLine,
			fieldId: fieldId
		};
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, sublistLine, fieldId, type)
	{
		emitter.emit(getEvent(sublistLine, fieldId, type));
	}

	function updateField(emitter, sublistLine, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(getEvent(sublistLine, fieldId, EVENT_TYPE.FIELD_VALUE_CHANGE), oldValue, newValue), isInternalChange));
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		emit: emit,
		updateField: updateField
	});
});
/**
 * SuiteScript model event module
 *
 * @private
 * @module N/record/modelEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelEvent',['N/record/sublistLineEvent'], function(sublistLineEvent)
{
	var EVENT_TYPE = Object.freeze({
			FIELD_VALUE_CHANGE: 'FIELD_VALUE_CHANGE',
			LINE_SELECT: 'LINE_SELECT',
			LINE_CREATE: 'LINE_CREATE',
			LINE_INSERT: 'LINE_INSERT',
			LINE_UPDATE: 'LINE_UPDATE',
			LINE_DELETE: 'LINE_DELETE',
			LINE_MOVE:   'LINE_MOVE',
			LINE_COMMITTABLE: 'LINE_COMMITTABLE',
			LINE_NOT_COMMITTABLE: 'LINE_NOT_COMMITTABLE',
			RECORD_SAVABLE: 'RECORD_SAVABLE',
			RECORD_NOT_SAVABLE: 'RECORD_NOT_SAVABLE'
		});

	var EVENT_ORIGIN = Object.freeze({
			CANCEL: "CANCEL",
			COPY: "COPY",
			INSERT: "INSERT"
		});

	function getEvent(type, origin)
	{
		var returnMe = { type: type };
		if (origin !== undefined)
		{
			returnMe.origin = origin;
		}
		return returnMe;
	}

	function addFieldId(event, fieldId)
	{
		event.fieldId = fieldId;

		return event;
	}

	function addFieldValues(event, oldValue, newValue)
	{
		event.oldValue = oldValue;
		if(newValue !== undefined)
		{
			event.newValue = newValue;
		}

		return event;
	}

	function addSublistInfo(event, sublistLine, isBuffer, suppressEmit, index)
	{
		event.sublistId = sublistLine.id;
		event.lineId = sublistLine.instanceId;
		event.line = index !== undefined ? index : sublistLine.index; //In case of deleted line we do not have a dynamic index reference
		event.useLineBuffer = !!isBuffer;
		if (!!suppressEmit)
			event.suppressEmit = true;

		return event;
	}

	function addInternalFlag(event, isInternalChange)
	{
		if (isInternalChange === true)
			event.internal = true;

		return event;
	}

	function emit(emitter, fieldId, type)
	{
		emitter.emit(addFieldId(getEvent(type), fieldId));
	}

	function updateField(emitter, fieldId, oldValue, newValue, isInternalChange)
	{
		emitter.emit(addInternalFlag(addFieldValues(addFieldId(getEvent(EVENT_TYPE.FIELD_VALUE_CHANGE), fieldId), oldValue, newValue), isInternalChange));
	}

	function selectLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_SELECT), sublistLine, isBuffer));
	}

	function createLine(emitter, sublistLine, isBuffer, origin, suppressEmit)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_CREATE, origin), sublistLine, isBuffer, suppressEmit));
	}

	function insertLine(emitter, sublistLine, isBuffer, origin)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_INSERT, origin), sublistLine, isBuffer));
	}

	function updateLine(emitter, sublistLine, isBuffer)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_UPDATE), sublistLine, isBuffer));
	}

	function deleteLine(emitter, sublistLine, isBuffer, origin, suppressEmit, index)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_DELETE, origin), sublistLine, isBuffer, suppressEmit, index));
	}

	function moveLine(emitter, fromLine)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_MOVE), fromLine, true));
	}

	function committableLine(emitter, sublistLine)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_COMMITTABLE), sublistLine, false, false));
	}

	function notCommittableLine(emitter, sublistLine)
	{
		emitter.emit(addSublistInfo(getEvent(EVENT_TYPE.LINE_NOT_COMMITTABLE), sublistLine, false, false));
	}

	function savableRecord(emitter)
	{
		emitter.emit(getEvent(EVENT_TYPE.RECORD_SAVABLE));
	}

	function notSavableRecord(emitter)
	{
		emitter.emit(getEvent(EVENT_TYPE.RECORD_NOT_SAVABLE));
	}

	var translateSublistLineEventTypeToModelEventType = (function () {
		var eventTranslations = {};

		eventTranslations[sublistLineEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.FIELD_VALUE_CHANGE;

		return function (sublistStateEventType) {
			return eventTranslations[sublistStateEventType];
		}
	}());

	function addSublistLineEventDetails(event, sublistLineEvent, isBuffer)
	{
		event.sublistId = sublistLineEvent.sublistLine.id;
		event.lineId = sublistLineEvent.sublistLine.instanceId;
		event.line = sublistLineEvent.sublistLine.index;
		event.fieldId = sublistLineEvent.fieldId;
		if(sublistLineEvent.oldValue !== undefined){ event.oldValue = sublistLineEvent.oldValue; }
		if(sublistLineEvent.newValue !== undefined){ event.newValue = sublistLineEvent.newValue; }
		event.useLineBuffer = isBuffer;
		if (sublistLineEvent.internal) { event.internal = true; }
		return event;
	}

	function translateSublistLineEventToModelEvent(sublistLineEvent, isBuffer)
	{
		return addSublistLineEventDetails(getEvent(translateSublistLineEventTypeToModelEventType(sublistLineEvent.type)), sublistLineEvent, isBuffer);
	}

	function forwardSublistLineEvent(emitter, isBuffer, sublistStateEvent)
	{
		emitter.emit(translateSublistLineEventToModelEvent(sublistStateEvent, isBuffer));
	}

	function forwardSublistLineEvents(emitter, sublistLine, isBuffer)
	{
		var forward = forwardSublistLineEvent.bind(null, emitter, isBuffer);

		sublistLine.on({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: forward
		});
	}

	function unforwardSublistLineEvents(sublistLine)
	{
		sublistLine.off({
			types: [
				sublistLineEvent.Type.FIELD_VALUE_CHANGE
			]
		});
	}

	return Object.freeze({
		Type: EVENT_TYPE,
		Origin: EVENT_ORIGIN,
		emit: emit,
		updateField: updateField,
		selectLine: selectLine,
		createLine: createLine,
		insertLine: insertLine,
		updateLine: updateLine,
		deleteLine: deleteLine,
		moveLine: moveLine,
		committableLine: committableLine,
		notCommittableLine: notCommittableLine,
		forwardSublistLineEvents: forwardSublistLineEvents,
		unforwardSublistLineEvents: unforwardSublistLineEvents,
		savableRecord: savableRecord,
		notSavableRecord: notSavableRecord
	});
});
/**
 * SuiteScript record definition event filter module
 *
 * @private
 * @module N/common/record/recordDefinitionEventCompressor
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEventCompressor',['N/record/recordEvent'], function (recordEvent) {
	/*
	 UPDATE_FIELD_VALUE: 'UPDATE_FIELD_VALUE',
	 UPDATE_FIELD_OPTIONS: 'UPDATE_FIELD_OPTIONS',
	 CREATE_SUBRECORD: 'CREATE_SUBRECORD',
	 UPDATE_SUBRECORD: 'UPDATE_SUBRECORD',
	 REMOVE_SUBRECORD: 'REMOVE_SUBRECORD',
	 UPDATE_SUBLIST: 'UPDATE_SUBLIST',
	 CREATE_LINE: 'CREATE_LINE',
	 UPDATE_LINE: 'UPDATE_LINE',
	 INSERT_LINE: 'INSERT_LINE',
	 MOVE_LINE: 'MOVE_LINE',
	 REMOVE_LINE: 'REMOVE_LINE',
	 SELECT_LINE: 'SELECT_LINE',
	 UPDATE_RELATED_RECORD_VIEW: 'UPDATE_RELATED_RECORD_VIEW',

	 FIELD_IS_MANDATORY_CHANGE: 'FIELD_IS_MANDATORY_CHANGE',
	 FIELD_IS_HIDDEN_CHANGE: 'FIELD_IS_HIDDEN_CHANGE',
	 FIELD_IS_DISABLED_CHANGE: 'FIELD_IS_DISABLED_CHANGE',
	 FIELD_IS_VISIBLE_CHANGE: 'FIELD_IS_VISIBLE_CHANGE',
	 FIELD_IS_DISPLAY_CHANGE: 'FIELD_IS_DISPLAY_CHANGE',
	 FIELD_IS_READ_ONLY_CHANGE: 'FIELD_IS_READ_ONLY_CHANGE',
	 FIELD_LABEL_CHANGE: 'FIELD_LABEL_CHANGE',

	 SUBLIST_IS_DISPLAY_CHANGE: 'SUBLIST_IS_DISPLAY_CHANGE',
	 SUBLIST_IS_HIDDEN_CHANGE: 'SUBLIST_IS_HIDDEN_CHANGE',
	 SUBLIST_COLUMN_IS_DISABLED_CHANGE: 'SUBLIST_COLUMN_IS_DISABLED_CHANGE',
	 SUBLIST_COLUMN_IS_MANDATORY_CHANGE: 'SUBLIST_COLUMN_IS_MANDATORY_CHANGE',
	 SUBLIST_COLUMN_IS_DISPLAY_CHANGE: 'SUBLIST_COLUMN_IS_DISPLAY_CHANGE',
     SUBLIST_COLUMN_LABEL_CHANGE: 'SUBLIST_COLUMN_LABEL_CHANGE'
	 */

	function isErrorEvent(event)
	{
		return event.error !== undefined;
	}

	function getSingletonEvent(eventType, eventData)
	{
		var event = eventData.singleton[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSaveRecordEvent(eventType, eventData)
	{
		var event = eventData.saveRecord[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getBodyFieldErrorEvent(fieldId, eventData, eventType)
	{
		var event = eventData.body[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistFieldEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistFieldErrorEvent(sublistId, fieldId, lineId, buffer, eventData, eventType)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';
		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event[fieldId];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistErrorEvent(eventType, sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getSublistLineEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.last;

		return event || null;
	}

	function getSublistLineErrorEvent(eventType, sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var event = eventData.sublist[bufferOrActual][sublistId];
		event = !!event && event[lineId];
		event = !!event && event[eventType];
		event = !!event && event.error;

		return event || null;
	}

	function getUpdateAllEvent(eventData)
	{
		return getSingletonEvent(recordEvent.Type.UPDATE_ALL, eventData);
	}

	function getHandleChangeCallEvent(eventData)
	{
		return getSingletonEvent(recordEvent.Type.HANDLE_CHANGE_CALL, eventData);
	}

	function getCreateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.CREATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getUpdateLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.UPDATE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getInsertLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.INSERT_LINE, sublistId, lineId, buffer, eventData);
	}

	function getMoveLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.MOVE_LINE, sublistId, lineId, buffer, eventData);
	}

	function getRemoveLineEvent(sublistId, lineId, buffer, eventData)
	{
		return getSublistLineEvent(recordEvent.Type.REMOVE_LINE, sublistId, lineId, buffer, eventData);
	}

	function hasErrorEvent(event, eventData)
	{
		var hasEvent = false;

		for(var i = 0; i < eventData.errors.length; i+= 1)
		{
			if(event.error !== undefined && event.error === eventData.errors[i].error)
			{
				hasEvent = true;
				break;
			}
		}

		return hasEvent;
	}

	function hasSingletonEvent(event, eventData)
	{
		return event === getSingletonEvent(event.type, eventData);
	}

	function hasSaveRecordEvent(event, eventData)
	{
		return event === getSaveRecordEvent(event.type, eventData);
	}

	function hasFieldEvent(event, eventData)
	{
		var result = false;

		if(!!event.sublistId)
		{
			var func = isErrorEvent(event) ? getSublistFieldErrorEvent : getSublistFieldEvent;
			result = event === func(event.sublistId, event.fieldId, event.lineId, event.useLineBuffer, eventData, event.type);
		}
		else
		{
			var func = isErrorEvent(event) ? getBodyFieldErrorEvent : getBodyFieldEvent;
			result = event === func(event.fieldId, eventData, event.type);
		}

		return result;
	}

	function hasSublistEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistErrorEvent : getSublistEvent;
		return event === func(event.type, event.sublistId, event.useLineBuffer, eventData);
	}

	function hasSublistLineEvent(event, eventData)
	{
		var func = isErrorEvent(event) ? getSublistLineErrorEvent : getSublistLineEvent;
		return event === func(event.type, event.sublistId, event.lineId, event.useLineBuffer, eventData);
	}

	/**
	 * @param {Object} event NotifyEvent|ConfirmEvent
	 * @param {Object} eventData {body:{}, sublist:{actual:{}, buffer:{}}, singleton: {}, errors:[], saveRecord:{}, messages:{}};
	 */
	function hasMessage(event, eventData)
	{
		return eventData.hasOwnProperty(event.type);
	}

	function getSublistEventDataSafe(sublistId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		return data[sublistId];
	}

	function getSublistLineEventDataSafe(sublistId, lineId, buffer, eventData)
	{
		var bufferOrActual = buffer ? 'buffer' : 'actual';

		var data = eventData.sublist[bufferOrActual];
		data[sublistId] = data[sublistId] || {};

		data = data[sublistId];
		data[lineId] = data[lineId] || {};

		return data[lineId];
	}

	function processErrorEvent(event, eventData)
	{
		if(!hasErrorEvent(event, eventData))
		{
			eventData.errors.push(event);
		}
	}

	function processSingletonEvent(event, eventData)
	{
		var data = eventData.singleton;
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSaveRecordEvent(event, eventData)
	{
		var data = eventData.saveRecord;
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processUpdateAllEvent(event, eventData)
	{
		eventData.body = {};
		eventData.sublist = {actual:{}, buffer:{}};
		eventData.singleton = {};
		eventData.errors = [];
		eventData.saveRecord = {};

		processSingletonEvent(event, eventData);
	}

	function updateSublistEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistEventDataSafe(event.sublistId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateSublistEvent(event, data);
		}
	}

	function updateSublistLineEvent(event, data)
	{
		data[event.type] = data[event.type] || {first: null, last: null, error: null};
		data = data[event.type];

		updateFirstLastEvent(event, data);
	}

	function processSublistLineEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll && !getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) || isErrorEvent(event))
		{
			updateSublistLineEvent(event, data);
		}
	}

	function processSublistRemoveLineEvent(event, eventData)
	{
		var isError = isErrorEvent(event);
		if(isError)
		{
			processErrorEvent(event, eventData);
		}

		var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
		var updateAll = !!getUpdateAllEvent(eventData);
		var lineCreatedOrInserted = (getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData));

		if(!isError)
		{
			Object.keys(data).forEach(function (v) {
				delete data[v];
			});
		}

		if(!updateAll && !lineCreatedOrInserted || isError)
		{
			updateSublistLineEvent(event, data);
		}
	}

	function updateFirstLastEvent(event, data)
	{
		var isError = isErrorEvent(event);
		var firstEvent = data.first == null;
		var eventGoesToOriginalState = !firstEvent &&
				data.first.oldValue !== undefined &&
				event.newValue !== undefined &&
				data.first.oldValue === event.newValue;

		if(isError)
		{
			data.error = event;
		}
		else if(firstEvent)
		{
			data.first = event;
			data.last = event;
		}
		else if(eventGoesToOriginalState)
		{
			data.first = null;
			data.last = event;
		}
		else
		{
			if (event.internal && !data.last.internal) {
				delete (event.internal);
			}
			data.last = event;
			if(data.first.hasOwnProperty('oldValue'))
			{
				data.last.oldValue = data.first.oldValue;
			}
		}
	}

	function updateFieldEvent(event, data)
	{
		data[event.type] = data[event.type] || {};
		data = data[event.type];
		data[event.fieldId] = data[event.fieldId] || {first: null, last: null, error:null};
		data = data[event.fieldId];

		updateFirstLastEvent(event, data);
	}

	function processFieldBodyEvent(event, eventData)
	{
		var data = eventData.body;
		var updateAll = !!getUpdateAllEvent(eventData);

		if (!updateAll)
		{
			updateFieldEvent(event, data);
		}
	}

	function processFieldSublistEvent(event, eventData)
	{
		var updateAll = !!getUpdateAllEvent(eventData);
		var ignore = !isErrorEvent(event) && (
				getCreateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getUpdateLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getInsertLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getMoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) ||
				getRemoveLineEvent(event.sublistId, event.lineId, event.useLineBuffer, eventData) );
		
		if (ignore && ignore.type !== recordEvent.Type.REMOVE_LINE && isFieldStatus(event)) {
			ignore = false;
		}
		if(!updateAll && !ignore || isErrorEvent(event))
		{
			var data = getSublistLineEventDataSafe(event.sublistId, event.lineId, event.useLineBuffer, eventData);
			updateFieldEvent(event, data);
		}
	}

	function isFieldStatus(event) {
		return (event.type == recordEvent.Type.FIELD_IS_MANDATORY_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_HIDDEN_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_DISABLED_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_VISIBLE_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_DISPLAY_CHANGE ||
			event.type == recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE ||
			event.type == recordEvent.Type.FIELD_LABEL_CHANGE);
	}

	function processFieldEvent(event, eventData)
	{
		if(isErrorEvent(event))
		{
			processErrorEvent(event, eventData);
		}

		if(!!event.sublistId)
		{
			processFieldSublistEvent(event, eventData)
		}
		else
		{
			processFieldBodyEvent(event, eventData);
		}
	}

	/**
	 * @param {Object} event NotifyEvent|ConfirmEvent
	 * @param {Object} eventData {body:{}, sublist:{actual:{}, buffer:{}}, singleton: {}, errors:[], saveRecord:{}, messages:{}};
	 */
	function processMessage(event, eventData)
	{
		eventData[event.type] = eventData[event.type] || [];
	}

	var processEvent = (function(){
		var process = {};

		process[recordEvent.Type.ERROR] = processErrorEvent;

		process[recordEvent.Type.UPDATE_ALL] = processUpdateAllEvent;
		process[recordEvent.Type.HANDLE_CHANGE_CALL] = processSingletonEvent;
		process[recordEvent.Type.RECORD_INITIALIZED] = processSingletonEvent;
		process[recordEvent.Type.RECORD_SAVABLE] = processSaveRecordEvent;
		process[recordEvent.Type.RECORD_NOT_SAVABLE] = processSaveRecordEvent;

		process[recordEvent.Type.UPDATE_FIELD_OPTIONS] = processFieldEvent;
		process[recordEvent.Type.UPDATE_FIELD_VALUE] = processFieldEvent;
		process[recordEvent.Type.CREATE_SUBRECORD] = processFieldEvent;
		process[recordEvent.Type.UPDATE_SUBRECORD] = processFieldEvent;
		process[recordEvent.Type.REMOVE_SUBRECORD] = processFieldEvent;
		process[recordEvent.Type.CREATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.UPDATE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.INSERT_LINE] = processSublistLineEvent;
		process[recordEvent.Type.MOVE_LINE] = processSublistLineEvent;
		process[recordEvent.Type.REMOVE_LINE] = processSublistRemoveLineEvent;
		process[recordEvent.Type.SELECT_LINE] = processSublistEvent;
		process[recordEvent.Type.LINE_COMMITTABLE] = processSublistLineEvent;
		process[recordEvent.Type.LINE_NOT_COMMITTABLE] = processSublistLineEvent;

		process[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = processFieldEvent;
		process[recordEvent.Type.FIELD_LABEL_CHANGE] = processFieldEvent;

		process[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_IS_DISABLED_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_IS_MANDATORY_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_IS_DISPLAY_CHANGE] = processSublistEvent;
		process[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = processSublistEvent;

		process[recordEvent.Type.VALIDATION_FAILED] = processSublistLineEvent;

		process[recordEvent.Type.NOTIFY] = processMessage;
		process[recordEvent.Type.CONFIRM] = processMessage;

		return function processEvent(event, eventData){
			var func = process[event.type] || function(){};
			func(event, eventData);
		};
	}());

	var hasEvent = (function(){
		var has = {};
		has[recordEvent.Type.ERROR] = hasErrorEvent;

		has[recordEvent.Type.UPDATE_ALL] = hasSingletonEvent;
		has[recordEvent.Type.HANDLE_CHANGE_CALL] = hasSingletonEvent;
		has[recordEvent.Type.RECORD_INITIALIZED] = hasSingletonEvent;
		has[recordEvent.Type.RECORD_SAVABLE] = hasSaveRecordEvent;
		has[recordEvent.Type.RECORD_NOT_SAVABLE] = hasSaveRecordEvent;

		has[recordEvent.Type.UPDATE_FIELD_OPTIONS] = hasFieldEvent;
		has[recordEvent.Type.UPDATE_FIELD_VALUE] = hasFieldEvent;
		has[recordEvent.Type.CREATE_SUBRECORD] = hasFieldEvent;
		has[recordEvent.Type.UPDATE_SUBRECORD] = hasFieldEvent;
		has[recordEvent.Type.REMOVE_SUBRECORD] = hasFieldEvent;
		has[recordEvent.Type.CREATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.UPDATE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.INSERT_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.MOVE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.REMOVE_LINE] = hasSublistLineEvent;
		has[recordEvent.Type.SELECT_LINE] = hasSublistEvent;
		has[recordEvent.Type.LINE_COMMITTABLE] = hasSublistLineEvent;
		has[recordEvent.Type.LINE_NOT_COMMITTABLE] = hasSublistLineEvent;

		has[recordEvent.Type.FIELD_IS_MANDATORY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_HIDDEN_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISABLED_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_VISIBLE_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_DISPLAY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = hasFieldEvent;
		has[recordEvent.Type.FIELD_LABEL_CHANGE] = hasFieldEvent;

		has[recordEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_IS_DISABLED_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_IS_MANDATORY_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_IS_DISPLAY_CHANGE] = hasSublistEvent;
		has[recordEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = hasSublistEvent;

		has[recordEvent.Type.VALIDATION_FAILED] = hasSublistLineEvent;

		has[recordEvent.Type.NOTIFY] = hasMessage;
		has[recordEvent.Type.CONFIRM] = hasMessage;

		return function hasEvent(event, eventData){
			var func = has[event.type] || function(){return false;};
			return func(event, eventData);
		};
	}());

	function createEventData(events)
	{
		var eventData = {body:{}, sublist:{actual:{}, buffer:{}}, singleton: {}, errors:[], saveRecord:{}, messages:{}};

		events.forEach(function(event){
			processEvent(event, eventData);
		});

		return {
			hasEvent: function (event){ return hasEvent(event, eventData); }
		}
	}

	function cleanEvent(event)
	{
		delete event.oldValue;
		delete event.newValue;

		return event;
	}

	// Fixes Issue 467543: If while filtering the eventData, we encounter multiple inserts in a row, we must ensure
	// all intermediate "creates" are suppressed from being emitted, such that the UI does not accidentally wipe out
	// the previously "inserted" line's values. The only surviving "create" should be the last one which indicates
	// the new line buffer being created. 
	function BatchInsertModeHandler(events)
	{
		var isBatchInserting = getEventsByType(events || [], recordEvent.Type.INSERT_LINE).length > 1;
		var lastCreateEvent = getLastEvent(getEventsByType(events || [], recordEvent.Type.CREATE_LINE));

		function isEventThisType(thisEvent, thisType)
		{
			return !!thisEvent && (thisEvent.type === thisType);
		}

		function getLastEvent(eventList)
		{
			return eventList.slice(eventList.length - 1)[0];
		}

		function getEventsByType(eventList, eventType)
		{
			return eventList.filter(function(event) { return event.type === eventType; });
		}

		function shouldIgnoreEvent(thisEvent, filteredEventList)
		{
			if (!isBatchInserting || filteredEventList.length === 0)
				return false;

			var lastEvent = getLastEvent(filteredEventList);
			var isCreateEvent = isEventThisType(thisEvent, recordEvent.Type.CREATE_LINE);
			var isLastCreateEvent = isCreateEvent && thisEvent === lastCreateEvent;
			var doLineIdsMatch = thisEvent.lineId === lastEvent.lineId;

			return isBatchInserting && isCreateEvent && !isLastCreateEvent && doLineIdsMatch;
		}
		this.shouldIgnore = shouldIgnoreEvent;
	}

	function ColumnStateChangeHandler(events)
	{
		var fieldStateEvents = [
			recordEvent.Type.FIELD_IS_DISABLED_CHANGE,
			recordEvent.Type.FIELD_IS_MANDATORY_CHANGE,
			recordEvent.Type.FIELD_IS_DISPLAY_CHANGE,
			recordEvent.Type.FIELD_LABEL_CHANGE
		];

		function getEventsByType(eventList, eventTypes)
		{
			return eventList.filter(function(event) { return eventTypes.indexOf(event.type) > -1; });
		}

		function getLastEvent(eventList)
		{
			return eventList.slice(eventList.length - 1)[0];
		}

		function isLastEventColumnEvent(firstEvent)
		{
			return recordEvent.isColumnEvent(firstEvent.type);
		}

		function isEventInColumn(thisEvent, firstEvent)
		{
			return thisEvent.sublistId === firstEvent.sublistId &&
				thisEvent.fieldId === firstEvent.fieldId &&
				firstEvent.sublistId != null &&
				firstEvent.fieldId != null;
		}

		function shouldIgnoreEvent(thisEvent, filteredEventList)
		{
			var isFieldStateChange = fieldStateEvents.indexOf(thisEvent.type) >= 0;
			if (!isFieldStateChange || filteredEventList.length === 0)
				return false;

			var lastEvent = getLastEvent(filteredEventList);

			return isLastEventColumnEvent(lastEvent) && isEventInColumn(thisEvent, lastEvent);
		}
		this.shouldIgnore = shouldIgnoreEvent;

	}

	function compress(events)
	{
		var eventData = createEventData(events);
		var batchInsertModeChecker = new BatchInsertModeHandler(events);
		var columnStateChangeHandler = new ColumnStateChangeHandler(events);
		var filteredEvents = events.reduce(function(p, c, i, a){
				if(eventData.hasEvent(c) && !batchInsertModeChecker.shouldIgnore(c, p) && !columnStateChangeHandler.shouldIgnore(c, p))
				{
					p.push(cleanEvent(c));
				}
				return p;
			}, []);

		return filteredEvents;
	}

	function noCompress(events)
	{
		return events.map(function(v, i, a){
			return cleanEvent(v);
		});
	}

	return Object.freeze({
		compress: compress,
		noCompress: noCompress
	});
});
/**
 * SuiteScript record definition event module
 *
 * @private
 * @module N/common/record/recordDefinitionEvent
 * @suiteScriptVersion 2.x
 *
 */
define('N/common/record/recordDefinitionEvent',['N/record/recordEvent', 'N/record/modelEvent', 'N/record/recordStateControllerEvent', 'N/record/metadataEvent', 'N/record/recordFieldEvent',
		'N/common/record/recordDefinitionEventCompressor', 'N/eventEmitter', 'N/utilityFunctions', 'N/resultObject'],
function (recordEvent, modelEvent, recordStateControllerEvent, metadataEvent, recordFieldEvent,
		recordDefinitionEventCompressor, eventEmitter, utilityFunctions, resultObject
){
	var EVENT_TYPE = recordEvent.Type;

	function getEvent(type, rawRecord)
	{
		return {
			type: type,
			record: rawRecord
		}
	}

	function addErrorAttribute(obj, error)
	{
		obj.error = error;

		return obj;
	}

	function addOriginAttribute(obj, origin)
	{
		if (origin !== undefined)
		{
			obj.origin = origin;
		}
		return obj;
	}

	function addTokenAttribute(obj, token)
	{
		if (token !== undefined)
		{
			obj.token = token;
		}
		return obj;
	}

	function wrapEmitError(options)
	{
		var rawRecord = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;

		return util.isFunction(func.thenable)
			? utilityFunctions.thenableFunction(utilityFunctions.wraps(func.thenable, function ()
			{
				var args = arguments;
				var eventToken = null;
				if (util.isObject(args[0]))
				{
					eventToken = args[0]._eventToken || null;
				}

				return eventEmitter.callWithToken(eventToken, function () {
					return resultObject.create(function ()
					{
						return func.thenable.apply(rawRecord, args);
					})['catch'](function (error)
					{
						emitError(emitter, rawRecord, error, eventToken);
						throw error;
					});
				});
			}))
			: utilityFunctions.wraps(func, function ()
			{
				var args = arguments;
				var eventToken = null;
				if (util.isObject(args[0]))
				{
					eventToken = args[0]._eventToken || null;
				}

				return eventEmitter.callWithToken(eventToken, function () {
					var result = undefined;

					try
					{
						result = func.apply(rawRecord, args);
					}
					catch(error)
					{
						emitError(emitter, rawRecord, error, eventToken);
						throw error;
					}
					return result;
				});
			});
	}
	function addSublistLineAttributes(rawRecord, event, sublistId, lineInstanceId, isCommitted)
	{
		if (!!sublistId)
		{
			event.sublistId = sublistId;
			event.lineId = lineInstanceId;
			event.line = rawRecord.getLineIndexFromInstanceId(sublistId, lineInstanceId);
			event.useLineBuffer = !isCommitted;
		}
		return event;
	}

	function wrapEmitValidationError(options)
	{
		var rawRecord = options.record;    /* This will always be an unproxied recordDefinition instance */
		var func = options.func;
		var emitter = options.emitter;
		var sublistId = options.sublistId;
		var lineInstanceId = options.lineInstanceId;
		var isCommitted = options.isCommitted;
		var fields = options.fieldId ? [{id: options.fieldId}] : [];
		var origin = options.origin;

		return util.isFunction(func.thenable)
			? utilityFunctions.thenableFunction(utilityFunctions.wraps(func.thenable, function ()
			{
				var args = arguments;
				return resultObject.create(function ()
				{
					return func.thenable.apply(rawRecord, args);
				})['catch'](function (error)
				{
					processValidationError(rawRecord, error, emitter, fields, sublistId, lineInstanceId, isCommitted, origin);
				});
			}))
			: utilityFunctions.wraps(func, function ()
			{
				var result = undefined;

				try
				{
					result = func.apply(rawRecord, arguments);
				}
				catch(error)
				{
					processValidationError(rawRecord, error, emitter, fields, sublistId, lineInstanceId, isCommitted, origin);
				}
				return result;
			});
	}

	function processValidationError(rawRecord, error, emitter, fields, sublistId, lineId, isCommitted, origin)
	{
		var messages;
		if (error.hasOwnProperty('validationDetail'))
		{
			if (error.validationDetail.hasOwnProperty('fields'))
				fields = error.validationDetail.fields;
			messages = error.validationDetail.messages;
			if (error.validationDetail.lineId)
				lineId = error.validationDetail.lineId;
		}
		var line = !!sublistId ? rawRecord.getLineIndexFromInstanceId(sublistId, lineId) : undefined;
		var event = addFieldAttributes(rawRecord, getEvent(EVENT_TYPE.VALIDATION_FAILED, rawRecord), fields, sublistId, lineId, isCommitted);
		event = addOriginAttribute(addErrorAttribute(event, error), origin);
		emitter.emit(event);

		// this object copy is on purpose, so the event compressor does not throw away the alert message with the actual error text
		var errorCopy = Object.create(error);
		if (error.userFacing != null)
			errorCopy.userFacing = error.userFacing;
		errorCopy.validationDetail = {};
		var inputs = [['messages', messages], ['fields', fields], ['sublistId', sublistId], ['line', line], ['lineId', lineId]];
		inputs.forEach(function(v) { if (v[1] != null) errorCopy.validationDetail[v[0]] = v[1]; });
		throw errorCopy;
	}

	function emitError(emitter, rawRecord, error, eventToken)
	{
		emitter.emit(addErrorAttribute(addTokenAttribute(getEvent(EVENT_TYPE.ERROR, rawRecord), eventToken), error));
	}

	function emitUpdateAll(emitter, rawRecord, origin)
	{
		var event = getEvent(EVENT_TYPE.UPDATE_ALL, rawRecord);
		if (origin !== undefined)
			event.origin = origin;
		emitter.emit(event);
	}

	function addFieldAttributes(rawRecord, event, fieldId, sublistId, lineInstanceId, isCommitted)
	{
		var onSublist = !!sublistId;
		var singleMode = !Array.isArray(fieldId);

		if (onSublist)
			event = addSublistLineAttributes(rawRecord, event, sublistId, lineInstanceId, isCommitted);

		event.fieldId = singleMode ? fieldId : fieldId[0] && fieldId[0].id;
		if (singleMode)
			event.field = getField(rawRecord, fieldId, lineInstanceId, isCommitted);
		else
			event.fields = fieldId.map(function(v) { var res = util.extend({}, v); res.field = getField(rawRecord, v.id, lineInstanceId, isCommitted); return res; });

		function getField(rawRecord, fieldId, lineInstanceId, isCommitted)
		{
			if (!onSublist)
				return rawRecord.getField({fieldId: fieldId});
			else
				return rawRecord.doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
		}

		return event;
	}

	function addActionAttributes(event, action, data)
	{
		if (action)
		{
			event.action = action;
			event.data = data;
		}
		return event;
	}

	function emitUpdateFieldOptions(emitter, rawRecord, sublistId, fieldId, lineInstanceId, isCommitted, action, data)
	{
		var event = getEvent(EVENT_TYPE.UPDATE_FIELD_OPTIONS, rawRecord);
		event = addFieldAttributes(rawRecord, event, fieldId, sublistId, lineInstanceId, isCommitted);
		event = addActionAttributes(event, action, data);
		emitter.emit(event);
	}

	function addSubrecordAttributes(event, subrecord)
	{
		if (subrecord)
		{
			event.subrecord = subrecord;
		}
		return event;
	}

	function emitSubrecordEvent(emitter, type, rawRecord, sublistId, fieldId, subrecord, lineInstanceId, isCommitted)
	{
		var event = getEvent(type, rawRecord);
		event = addFieldAttributes(rawRecord, event, fieldId, sublistId, lineInstanceId, isCommitted);
		event = addSubrecordAttributes(event, subrecord);
		emitter.emit(event);
	}

	var translateModelEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[modelEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;
		eventTranslations[modelEvent.Type.LINE_SELECT] = EVENT_TYPE.SELECT_LINE;
		eventTranslations[modelEvent.Type.LINE_CREATE] = EVENT_TYPE.CREATE_LINE;
		eventTranslations[modelEvent.Type.LINE_INSERT] = EVENT_TYPE.INSERT_LINE;
		eventTranslations[modelEvent.Type.LINE_UPDATE] = EVENT_TYPE.UPDATE_LINE;
		eventTranslations[modelEvent.Type.LINE_DELETE] = EVENT_TYPE.REMOVE_LINE;
		eventTranslations[modelEvent.Type.LINE_MOVE] = EVENT_TYPE.MOVE_LINE;
		eventTranslations[modelEvent.Type.LINE_COMMITTABLE] = EVENT_TYPE.LINE_COMMITTABLE;
		eventTranslations[modelEvent.Type.LINE_NOT_COMMITTABLE] = EVENT_TYPE.LINE_NOT_COMMITTABLE;
		eventTranslations[modelEvent.Type.RECORD_SAVABLE] = EVENT_TYPE.RECORD_SAVABLE;
		eventTranslations[modelEvent.Type.RECORD_NOT_SAVABLE] = EVENT_TYPE.RECORD_NOT_SAVABLE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addModelEventDetails(event, modelEvent)
	{
		var onSublist = modelEvent.hasOwnProperty('sublistId');
		var onField = modelEvent.hasOwnProperty('fieldId');

		if(onSublist)
		{
			event.sublistId = modelEvent.sublistId;
			event.lineId = modelEvent.lineId;
			event.line = modelEvent.line;
			event.useLineBuffer = modelEvent.useLineBuffer;
			if (modelEvent.hasOwnProperty("suppressEmit"))
				event.suppressEmit = modelEvent.suppressEmit;
			if (modelEvent.hasOwnProperty("origin"))
				event.origin = modelEvent.origin;
		}

		if(onField) {
			event.fieldId = modelEvent.fieldId;
			if(modelEvent.oldValue !== undefined){ event.oldValue = modelEvent.oldValue; }
			if(modelEvent.newValue !== undefined){ event.newValue = modelEvent.newValue; }
		}

		if (modelEvent.internal)
			event.internal = true;

		return event;
	}

	function translateModelEventToRecordEvent(modelEvent, rawRecord)
	{
		return addModelEventDetails(getEvent(translateModelEventTypeToRecordEventType(modelEvent.type), rawRecord), modelEvent);
	}

	function forwardModelControllerEvent(emitter, modelEvent)
	{
		emitter.emit(translateModelEventToRecordEvent(modelEvent, this));
	}

	function forwardModelControllerEvents(options)
	{
		var rawRecord = options.record;
		var modelController = rawRecord.getModelController();
		var what = options.remove ? modelController.off : modelController.on;

		what({
			types: [
				modelEvent.Type.FIELD_VALUE_CHANGE,
				modelEvent.Type.LINE_SELECT,
				modelEvent.Type.LINE_CREATE,
				modelEvent.Type.LINE_INSERT,
				modelEvent.Type.LINE_UPDATE,
				modelEvent.Type.LINE_DELETE,
				modelEvent.Type.LINE_MOVE,
				modelEvent.Type.LINE_COMMITTABLE,
				modelEvent.Type.LINE_NOT_COMMITTABLE,
				modelEvent.Type.RECORD_SAVABLE,
				modelEvent.Type.RECORD_NOT_SAVABLE
			],
			listener: rawRecord.forwardModelControllerEvent
		});
	}

	var translateRecordStateEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE] = EVENT_TYPE.FIELD_IS_MANDATORY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE] = EVENT_TYPE.FIELD_IS_HIDDEN_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE] = EVENT_TYPE.FIELD_IS_DISABLED_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE] = EVENT_TYPE.FIELD_IS_VISIBLE_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE] = EVENT_TYPE.FIELD_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE] = EVENT_TYPE.FIELD_IS_READ_ONLY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.FIELD_LABEL_CHANGE] = EVENT_TYPE.FIELD_LABEL_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE] = EVENT_TYPE.SUBLIST_IS_HIDDEN_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_DISABLED_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_DISABLED_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_MANDATORY_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_MANDATORY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_DISPLAY_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_IS_DISPLAY_CHANGE;
		eventTranslations[recordStateControllerEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());


	function addRecordStateEventFieldDetails(rawRecord, event, recordStateEvent)
	{
		var onSublist = recordStateEvent.hasOwnProperty('sublistId');
		var useLineBuffer = onSublist && !!recordStateEvent.useLineBuffer;

		if(onSublist)
		{
			event.sublistId = recordStateEvent.sublistId;
			event.lineId = recordStateEvent.lineId;
			event.line = recordStateEvent.line;
			event.field = rawRecord.doGetFieldForInstance(recordStateEvent.sublistId, recordStateEvent.fieldId, event.lineId, !useLineBuffer)
			event.useLineBuffer = useLineBuffer;
		}
		else
		{
			event.field = rawRecord.getField({
				fieldId: recordStateEvent.fieldId
			});
		}

		event.fieldId = recordStateEvent.fieldId;
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventSublistDetails(rawRecord, event, recordStateEvent)
	{
		event.sublistId = recordStateEvent.sublistId;
		event.sublist = rawRecord.getSublist({
			sublistId: recordStateEvent.sublistId
		});
		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventColumnDetails(event, recordStateEvent)
	{
		event.fieldId = recordStateEvent.fieldId;
		event.sublistId = recordStateEvent.sublistId;

		if(recordStateEvent.oldValue !== undefined){ event.oldValue = recordStateEvent.oldValue; }
		if(recordStateEvent.newValue !== undefined){ event.newValue = recordStateEvent.newValue; }

		return event;
	}

	function addRecordStateEventDetails(rawRecord, event, recordStateEvent)
	{
		function isRecordStateFieldEvent(type)
		{
			return [recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
					recordStateControllerEvent.Type.FIELD_LABEL_CHANGE].indexOf(type) !== -1;
		}

		function isRecordStateSublistEvent(type)
		{
			return [recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
					recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE].indexOf(type) !== -1;
		}

		function isRecordStateColumnEvent(type)
		{
			return recordEvent.isColumnEvent(type);
		}

		if(isRecordStateFieldEvent(recordStateEvent.type))
		{
			addRecordStateEventFieldDetails(rawRecord, event, recordStateEvent);
		}
		else if(isRecordStateSublistEvent(recordStateEvent.type))
		{
			addRecordStateEventSublistDetails(rawRecord, event, recordStateEvent);
		}
		else if (isRecordStateColumnEvent(recordStateEvent.type))
		{
			addRecordStateEventColumnDetails(event, recordStateEvent);
		}

		return event;
	}

	//TODO: useLineBuffer not propagated to the record, need to check the impact if it is
	function translateRecordStateEventToRecordEvent(recordStateEvent, rawRecord)
	{
		rawRecord.flushBufferCacheForFieldStateUpdate(recordStateEvent.sublistId, recordStateEvent.fieldId, recordStateEvent.lineId);
		return addRecordStateEventDetails(rawRecord, getEvent(translateRecordStateEventTypeToRecordEventType(recordStateEvent.type), rawRecord), recordStateEvent);
	}

	function forwardRecordStateEvent(emitter, recordStateEvent)
	{
		emitter.emit(translateRecordStateEventToRecordEvent(recordStateEvent, this));
	}

	function forwardRecordStateEvents(rawRecord, remove)
	{
		var recordStateController = rawRecord.getRecordStateController();
		var what = remove ? recordStateController.off : recordStateController.on;

		what({
			types: [
				recordStateControllerEvent.Type.FIELD_IS_MANDATORY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_HIDDEN_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISABLED_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_VISIBLE_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
				recordStateControllerEvent.Type.FIELD_LABEL_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_IS_HIDDEN_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_DISABLED_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_MANDATORY_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_COLUMN_IS_DISPLAY_CHANGE,
				recordStateControllerEvent.Type.SUBLIST_COLUMN_LABEL_CHANGE
			],
			listener: rawRecord.forwardRecordStateEvent
		});
	}

	var translateMetadataEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE] = EVENT_TYPE.SUBLIST_COLUMN_LABEL_CHANGE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addMetadataEventDetails(event, metadataEvent)
	{
		event.sublistId = metadataEvent.sublistId;
		event.fieldId = metadataEvent.fieldId;
		if(metadataEvent.oldValue !== undefined){ event.oldValue = metadataEvent.oldValue; }
		if(metadataEvent.newValue !== undefined){ event.newValue = metadataEvent.newValue; }

		return event;
	}

	function translateMetadataEventToRecordEvent(metadataEvent, rawRecord)
	{
		return addMetadataEventDetails(getEvent(translateMetadataEventTypeToRecordEventType(metadataEvent.type), rawRecord), metadataEvent);
	}

	function forwardMetadataEvent(emitter, metadataEvent)
	{
		emitter.emit(translateMetadataEventToRecordEvent(metadataEvent, this));
	}

	function forwardMetadataEvents(rawRecord, remove)
	{
		var metadata = rawRecord.getMetadata();
		var what = remove ? metadata.off : metadata.on;

		what({
			types: [
				metadataEvent.Type.FIELD_METADATA_LABEL_CHANGE
			],
			listener: rawRecord.forwardMetadataEvent
		});
	}

	var translateRecordFieldEventTypeToRecordEventType = (function () {
		var eventTranslations = {};

		eventTranslations[recordFieldEvent.Type.FIELD_VALUE_CHANGE] = EVENT_TYPE.UPDATE_FIELD_VALUE;

		return function (fieldStateEventType) {
			return eventTranslations[fieldStateEventType];
		}
	}());

	function addRecordFieldEventDetails(event, recordFieldEvent)
	{
		var onSublist = recordFieldEvent.recordField.getSublistName() !== null;

		if(onSublist)
		{
			var recordField = recordFieldEvent.recordField;

			event.sublistId = recordField.getSublistName();
			event.lineId = recordField.getLineInstanceId();
			event.line = recordField.getLine();
			event.useLineBuffer = !recordField.getIsCommitted();
		}

		event.fieldId = recordFieldEvent.recordField.getName();

		if(recordFieldEvent.hasOwnProperty('error'))
		{
			event.error = recordFieldEvent.error;
		}

		return event;
	}
	function translateRecordFieldEventToRecordEvent(recordFieldEvent, rawRecord)
	{
		return addRecordFieldEventDetails(getEvent(translateRecordFieldEventTypeToRecordEventType(recordFieldEvent.type), rawRecord), recordFieldEvent);
	}

	function forwardRecordFieldEvent(emitter, recordFieldEvent)
	{
		emitter.emit(translateRecordFieldEventToRecordEvent(recordFieldEvent, this));
	}

	function forwardRecordFieldEvents(rawRecord, recordField)
	{
		recordField.on({
			types: [
				recordFieldEvent.Type.FIELD_VALUE_CHANGE
			],
			listener: rawRecord.forwardRecordFieldEvent
		});
	}

	return Object.freeze({
		Type : EVENT_TYPE,
		Origin : modelEvent.Origin,
		emitError: emitError,
		emitUpdateAll: emitUpdateAll,
		emitUpdateFieldOptions: emitUpdateFieldOptions,
		emitSubrecordEvent: emitSubrecordEvent,
		forwardModelControllerEvent: forwardModelControllerEvent,
		forwardRecordStateEvent: forwardRecordStateEvent,
		forwardMetadataEvent: forwardMetadataEvent,
		forwardRecordFieldEvent: forwardRecordFieldEvent,
		forwardModelControllerEvents: forwardModelControllerEvents,
		forwardRecordStateEvents: forwardRecordStateEvents,
		forwardMetadataEvents: forwardMetadataEvents,
		forwardRecordFieldEvents: forwardRecordFieldEvents,
		wrapEmitError: wrapEmitError,
		wrapEmitValidationError: wrapEmitValidationError,
		eventCompress: recordDefinitionEventCompressor.compress,
		eventNoCompress: recordDefinitionEventCompressor.noCompress
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/idConverterService
 * @suiteScriptVersion 2.x
 */

define('N/idConverterService',[
	'N/utilityFunctions',
	'N/record/matrix'
], function (
	utilityFunctions,
	matrix
) {

	/**
	 * @param {string} value
	 * @param {Array<string>} values
	 * @returns {string}
	 */
	function findValueInArrayCaseInsensitive(value, values)
	{
		var lower = values.map(function (one) {
			return (one + "").toLowerCase();
		});

		var index = lower.indexOf((value + "").toLowerCase());
		if (index > -1)
			return values[index];

		return value;
	}

	/**
	 * @param {RawRecord} unproxiedRecord
	 * @param {string} sublistId
	 * @returns {string}
	 */
	function convertSublistId(unproxiedRecord, sublistId)
	{
		if (!unproxiedRecord.getIsNSERecord())
			return sublistId;

		return findValueInArrayCaseInsensitive(sublistId, unproxiedRecord.getSublists());
	}

	/**
	 * @param {RawRecord} unproxiedRecord
	 * @param {string} sublistId
	 * @param {string} fieldId
	 * @returns {string}
	 */
	function convertMatrixSublistFieldId(unproxiedRecord, sublistId, fieldId)
	{
		if (!unproxiedRecord.getIsNSERecord())
			return fieldId;

		return findValueInArrayCaseInsensitive(fieldId, matrix.getMatrixFields.call(unproxiedRecord, convertSublistId(unproxiedRecord, sublistId)));
	}

	/**
	 * @param {RawRecord} unproxiedRecord
	 * @param {string} sublistId
	 * @param {string} fieldId
	 * @returns {string}
	 */
	function convertSublistFieldId(unproxiedRecord, sublistId, fieldId)
	{
		if (!unproxiedRecord.getIsNSERecord())
			return fieldId;

		return findValueInArrayCaseInsensitive(fieldId, unproxiedRecord.getSublistFields(convertSublistId(unproxiedRecord, sublistId)));
	}

	/**
	 * @param {RawRecord} unproxiedRecord
	 * @param {string} fieldId
	 * @returns {string}
	 */
	function convertBodyFieldId(unproxiedRecord, fieldId)
	{
		if (!unproxiedRecord.getIsNSERecord())
			return fieldId;

		return findValueInArrayCaseInsensitive(fieldId, unproxiedRecord.getFields());
	}

	/**
	 * Don't use this method on matrix fields/options
	 * @param {RawRecord} unproxiedRecord
	 * @param {Object} options
	 * @return {Object}
	 */
	function convertOptionIds(unproxiedRecord, options)
	{
		if (!unproxiedRecord.getIsNSERecord())
			return options;

		if (utilityFunctions.isObject(options))
		{
			if (options.hasOwnProperty('fieldId') && options.hasOwnProperty('sublistId'))
			{
				options.sublistId = convertSublistId(unproxiedRecord, options.sublistId);
				options.fieldId = convertSublistFieldId(unproxiedRecord, options.sublistId, options.fieldId);
			}
			else
			{
				if (options.hasOwnProperty('fieldId'))
					options.fieldId = convertBodyFieldId(unproxiedRecord, options.fieldId);

				if (options.hasOwnProperty('sublistId'))
					options.sublistId = convertSublistId(unproxiedRecord, options.sublistId);
			}
		}

		return options;
	}

	return Object.freeze({
		convertOptionIds: convertOptionIds,
		convertSublistId: convertSublistId,
		convertSublistFieldId: convertSublistFieldId,
		convertBodyFieldId: convertBodyFieldId,
		convertMatrixSublistFieldId: convertMatrixSublistFieldId
	});
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/dynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/dynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * 
		 * Interface to subrecord line of dynamic record
		 * @param {RawLine} line
		 * @return {DynamicLine}
		 * @constructor
		 * @since 2017.1
		 */
		function DynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @name DynamicLine#instanceId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', function () { return line.instanceId; });
			/**
			 * id of the parent sublist
			 * @name DynamicLine#sublistId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', function () { return line.sublistId; });
			/**
			 * The line sequence (index)
			 * @name DynamicLine#sequence
			 * @type {number}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sequence', function () { return line.sequence; });
			/**
			 * The parent record
			 * @name DynamicLine#record
			 * @type {Record}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'record', function () { return line.record; });

			this.cancel = line.cancel;
			this.commit = line.commit;
			this.move = line.move;
			this.getFields = line.getFields;
			this.getField = line.getField
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = line.getSubrecord;
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.on = line.on;
			this.off = line.off;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DYNAMIC_LINE;};

			return this;
		}

		DynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DynamicLine);

		return DynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/deferredDynamicLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/deferredDynamicLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * Interface to sublist line of deferred dynamic record
		 * @param {RawLine} line
		 * @return {DeferredDynamicLine}
		 * @constructor
		 * @since 2017.1
		 */
		function DeferredDynamicLine(line)
		{
			/**
			 * The instance id of the line
			 * @name DeferredDynamicLine#instanceId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', function () { return line.instanceId; });
			/**
			 * id of the parent sublist
			 * @name DeferredDynamicLine#sublistId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', function () { return line.sublistId; });
			/**
			 * The line sequence (index)
			 * @name DeferredDynamicLine#sequence
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sequence', function () { return line.sequence; });
			/**
			 * The parent record
			 * @name DeferredDynamicLine#record
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'record', function () { return line.record; });

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.setValue = line.setValue;
			this.getText = line.getText;
			this.setText = line.setText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = line.getSubrecord;
			this.removeSubrecord = line.removeSubrecord;
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.DEFERRED_DYNAMIC_LINE;};

			return this;
		}

		DeferredDynamicLine.prototype = nsobject.getNewInstance();

		Object.freeze(DeferredDynamicLine);

		return DeferredDynamicLine;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/line/readOnlyLine
 * @suiteScriptVersion 2.x
 */
define('N/record/line/readOnlyLine',['N/nsobject', 'N/record/recordConstants', 'N/utilityFunctions'],
	function (nsobject, constants, utilityFunctions)
	{
		/**
		 * ReadOnly Line interface
		 * @param {RawLine} line
		 * @return {ReadOnlyLine}
		 * @constructor
		 * @since 2016.2
		 */
		function ReadOnlyLine(line)
		{
			/**
			 * The instance id of the line
			 * @name ReadOnlyLine#instanceId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', function () { return line.instanceId; });
			/**
			 * id of the parent sublist
			 * @name ReadOnlyLine#sublistId
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', function () { return line.sublistId; });
			/**
			 * The line sequence (index)
			 * @name ReadOnlyLine#sequence
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sequence', function () { return line.sequence; });
			/**
			 * The parent record
			 * @name ReadOnlyLine#record
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'record', function () { return line.record; });

			this.getFields = line.getFields;
			this.getField = line.getField;
			this.getValue = line.getValue;
			this.getText = line.getText;
			this.hasSubrecord = line.hasSubrecord;
			this.getSubrecord = line.getSubrecord;
			this.makeCopy = line.makeCopy;
			this.toJSON = line.toJSON;
			this.toString = function () {return constants.LINE_MODE.READ_ONLY_LINE;};

			return this;
		}

		ReadOnlyLine.prototype = nsobject.getNewInstance();

		Object.freeze(ReadOnlyLine);

		return ReadOnlyLine;
	});

/**
 * SuiteScript record sublist line definition common module
 *
 * @private
 * @module N/common/record/line/lineDefinition
 * @NApiVersion 2.x
 *
 */
define(
	'N/common/record/line/lineDefinition',[
		'N/record/proxy',
		'N/utilityFunctions',
		'N/error',
		'N/common/record/recordActualWork',
		'N/record/line/sublistLineImplementation',
		'N/eventEmitter',
		'N/common/record/recordDefinitionEvent',
		'N/idConverterService',
		'N/record/line/dynamicLine',
		'N/record/line/deferredDynamicLine',
		'N/record/line/readOnlyLine'
	],
	function (
		proxy,
		utilityFunctions,
		error,
		recordBehaviorDelegateService,
		sublistLineImplementation,
		eventEmitter,
		recordDefinitionEvent,
		idConverterService,
		DynamicLine,
		DeferredDynamicLine,
		ReadOnlyLine
	)
	{
		/** @typedef {DynamicLine|DeferredDynamicLine|ReadOnlyLine} ProxyLine */
		/** @typedef {ProxyLine} Line */

		/**
		 * Primary object used to encapsulate a record sublist line object.
		 *
		 * @protected
		 * @alias RawLine
		 * @param {Object} options
		 * @param {RawRecord} options.unproxiedRecord - Instance of recordDefinition that owns the Line object.
		 * @param {string} options.sublistId
		 * @param {string} options.lineInstanceId
		 * @param {boolean} options.fromBuffer
		 * @param {boolean} options.isReadOnly
		 * @return {RawLine}
		 * @constructor
		 */
		function Line(options)
		{
			var that = this;
			var lineInstanceId, sublistId, isCommitted, isReadOnly;
			var unproxiedRecord;
			/** @type {RecordBehaviorDelegate} */
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({ delegate: this });
			/** @type {SublistLineImpl|SublistLineBufferImpl} */
			var implementation;

			lineInstanceId = options.lineInstanceId;
			sublistId = options.sublistId;
			isCommitted = !options.fromBuffer;
			unproxiedRecord = options.unproxiedRecord;
			isReadOnly = !!options.isReadOnly;
			implementation = sublistLineImplementation.create({ isCommitted: isCommitted, line: this});

			// Disable re-emitting the Record events via the line object if there's no MLB.
			// Enabling with MLB is also questionable as UI listens only to Record events anyway.
			if (unproxiedRecord.isMultilineEditable(sublistId))
			{
				unproxiedRecord.on({
					types: [
						recordDefinitionEvent.Type.ERROR,
						recordDefinitionEvent.Type.UPDATE_FIELD_VALUE,
						recordDefinitionEvent.Type.UPDATE_FIELD_OPTIONS,
						recordDefinitionEvent.Type.CREATE_SUBRECORD,
						recordDefinitionEvent.Type.UPDATE_SUBRECORD,
						recordDefinitionEvent.Type.REMOVE_SUBRECORD,
						recordDefinitionEvent.Type.CREATE_LINE,
						recordDefinitionEvent.Type.UPDATE_LINE,
						recordDefinitionEvent.Type.INSERT_LINE,
						recordDefinitionEvent.Type.REMOVE_LINE,
						recordDefinitionEvent.Type.MOVE_LINE,
						recordDefinitionEvent.Type.SELECT_LINE,
						recordDefinitionEvent.Type.LINE_COMMITTABLE,
						recordDefinitionEvent.Type.LINE_NOT_COMMITTABLE,
						recordDefinitionEvent.Type.FIELD_IS_MANDATORY_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_HIDDEN_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_DISABLED_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_VISIBLE_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_DISPLAY_CHANGE,
						recordDefinitionEvent.Type.FIELD_IS_READ_ONLY_CHANGE,
						recordDefinitionEvent.Type.FIELD_LABEL_CHANGE,
						recordDefinitionEvent.Type.VALIDATION_FAILED
					],
					listener: function(event)
					{
						if (event.sublistId === sublistId && event.lineId === lineInstanceId && event.useLineBuffer === !isCommitted)
						{
							emitter.emit(event);
						}
					}
				});
			}

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function(v){ return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				blocking: false,
				insulated: true
			});

			function getHack()
			{
				return getUnproxiedRecord();
			}
			this.getHack = getHack;

			function getLineInstanceId() { return lineInstanceId; }
			this.getLineInstanceId = getLineInstanceId;
			/**
			 * @name RawLine#instanceId
			 * @type {string}
			 * @readonly
			 */
			utilityFunctions.addReadOnlyProperty(this, 'instanceId', getLineInstanceId);

			function getSublistId() { return sublistId; }
			this.getSublistId = getSublistId;
			/**
			 * @name RawLine#sublistId
			 * @type {string}
			 * @readonly
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sublistId', getSublistId);

			function getSequence() { return unproxiedRecord.getLineIndexFromInstanceId(sublistId, lineInstanceId); }
			this.getSequence = getSequence;
			/**
			 * @name RawLine#sequence
			 * @type {string}
			 * @readonly
			 */
			utilityFunctions.addReadOnlyProperty(this, 'sequence', getSequence);

			function getRecord() { return unproxiedRecord; }
			this.getRecord = getRecord;
			/**
			 * @name RawLine#record
			 * @type {RawRecord}
			 * @readonly
			 */
			utilityFunctions.addReadOnlyProperty(this, 'record', getRecord);

			function getUnproxiedRecord() { return unproxiedRecord; }
			this.getUnproxiedRecord = getUnproxiedRecord;

			function withForceSyncSourcing(fieldId, forceSyncSourcing, callback)
			{
				return getUnproxiedRecord().withForceSyncSourcing(getSublistId(), fieldId, forceSyncSourcing, callback);
			}
			this.withForceSyncSourcing = withForceSyncSourcing;

			function getIsCurrentRecord() {
				return getUnproxiedRecord().getIsCurrentRecord();
			}
			this.getIsCurrentRecord = getIsCurrentRecord;

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				getUnproxiedRecord().validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}
			this.validateTextApi = validateTextApi;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return getUnproxiedRecord().getFieldLevelMetadataForSublistField(getSublistId(), fieldId);
			}
			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function isValidBodyField(fieldId)
			{
				return getUnproxiedRecord().isValidSublistField(getSublistId(), fieldId);
			}
			this.isValidBodyField = isValidBodyField;
			
			function getFieldState(fieldId)
			{
				return implementation.getFieldState(fieldId);
			}
			this.getFieldState = getFieldState;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				implementation.setParsedValueForBodyField(fieldId, value, fieldState);
				fieldState.isParsed = true;
			}
			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;


			//TODO remove sublistId once refactor getSetFieldMetadata
			function getSetFieldMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					isValidField : isValidBodyField(fieldId),
					isMultiSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeMultiSelect : false,
					isSelect: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeSelect : false,
					isRadio: !!fieldLevelMetadata ? fieldLevelMetadata.isTypeRadio : false,
					isNumeric: !!fieldLevelMetadata ? fieldLevelMetadata.isNumeric : false,
					isCurrency: !!fieldLevelMetadata ? fieldLevelMetadata.isCurrency : false,
					type: !!fieldLevelMetadata ? fieldLevelMetadata.type : null
				};
			}
			this.getSetFieldMetadata = getSetFieldMetadata;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = getFieldLevelMetadataForBodyField(fieldId);
				return {
					fieldId: fieldId,
					sublistId: getSublistId(),
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : false,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : false,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undefined,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undefined
				};
			}
			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;

			var move = utilityFunctions.thenableFunction(function move(options)
			{
				return recordBehaviorDelegate.move.thenable(options);
			});
			this.move = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: move,
				emitter: emitter
			});

			var cancel = utilityFunctions.thenableFunction(function cancel()
			{
				return recordBehaviorDelegate.cancel.thenable();
			});
			this.cancel = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: cancel,
				emitter: emitter
			});

			var commit = utilityFunctions.thenableFunction(function commit(isAsync)
			{
				var modelController = unproxiedRecord.getModelController();
				var commitPromise = modelController.getPendingCommitPromise({
					delegateFunction: function ()
					{
						return recordBehaviorDelegate.commit.thenable(isAsync);
					},
					unproxiedRecord: unproxiedRecord,
					lineInstanceId: lineInstanceId,
					sublistId: sublistId
				});
				return isAsync ? commitPromise : that;
			}, {
				isAsyncArgIndex: 0
			});
			this.commit = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: commit,
				emitter: emitter
			});

			function getFields()
			{
				return recordBehaviorDelegate.getFields();
			}
			this.getFields = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getFields,
				emitter: emitter
			});

			function getField(options)
			{
				return recordBehaviorDelegate.getField(options);
			}
			this.getField = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getField,
				emitter: emitter
			});

			function hasSubrecord(options)
			{
				return recordBehaviorDelegate.hasSubrecord(options);
			}
			this.hasSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: hasSubrecord,
				emitter: emitter
			});

			var getSubrecord = utilityFunctions.thenableFunction(function getSubrecord(options, proxyOptions, isAsync)
			{
				return recordBehaviorDelegate.getSubrecord.thenable(options, proxyOptions, isAsync);
			}, {
				proxyOptionsArgIndex: 1,
				isAsyncArgIndex: 2
			});
			this.getSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getSubrecord,
				emitter: emitter
			});

			var removeSubrecord = utilityFunctions.thenableFunction(function removeSubrecord(options, isAsync)
			{
				return recordBehaviorDelegate.removeSubrecord.thenable(options, isAsync);
			}, {
				isAsyncArgIndex: 1
			});
			this.removeSubrecord = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: removeSubrecord,
				emitter: emitter
			});

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}
			/**
			 * return value of the field on the line instance
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 */
			this.getValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getValue,
				emitter: emitter
			});

			function doGetValue(fieldId)
			{
				return implementation.doGetValue(fieldId);
			}
			this.doGetValue = doGetValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			var setValue = utilityFunctions.thenableFunction(function setValue(options, value, isAsync)
			{
				return recordBehaviorDelegate.setValue.thenable(options, value, isAsync);
			}, {
				isAsyncArgIndex: 2
			});
			this.setValue = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setValue,
				emitter: emitter
			});

			var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, isAsync)
			{
				return implementation.doSetValue.thenable(fieldId, value, fireFieldChange, isAsync);
			}, {
				isAsyncArgIndex: 3
			});
			this.doSetValue = doSetValue;

			var getText = utilityFunctions.thenableFunction(function getText(options, isAsync)
			{
				return recordBehaviorDelegate.getText.thenable(options, isAsync);
			}, {
				isAsyncArgIndex: 1
			});

			/**
			 * get value of the field in text representation
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @returns {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.getText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: getText,
				emitter: emitter
			});

			var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
			{
				delegator = delegator || recordBehaviorDelegate;
				return implementation.doGetText.thenable(fieldId, delegator, isAsync);
			}, {
				isAsyncArgIndex: 2
			});
			this.doGetText = doGetText;

			var setText = utilityFunctions.thenableFunction(function setText(options, text, isAsync)
			{
				return recordBehaviorDelegate.setText.thenable(options, text, isAsync);
			}, {
				isAsyncArgIndex: 2
			});
			this.setText = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: setText,
				emitter: emitter
			});

			var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text, fireFieldChange, isAsync)
			{
				return implementation.doSetText.thenable(fieldId, text, fireFieldChange, isAsync);
			}, {
				isAsyncArgIndex: 3
			});
			this.doSetText = doSetText;

			function doGetField(fieldId)
			{
				return implementation.doGetField(fieldId);
			}
			this.doGetField = doGetField;

			function doGetFields()
			{
				return implementation.doGetFields();
			}
			this.doGetFields = doGetFields;

			var doMove = utilityFunctions.thenableFunction(function doMove(toInstanceId)
			{
				return implementation.doMove.thenable(toInstanceId);
			});
			this.doMove = doMove;

			var doCommit = utilityFunctions.thenableFunction(function doCommit(isAsync)
			{
				return implementation.doCommit.thenable(isAsync);
			}, {
				isAsyncArgIndex: 0
			});
			this.doCommit = doCommit;

			var doCancel = utilityFunctions.thenableFunction(function doCancel()
			{
				return implementation.doCancel.thenable();
			});
			this.doCancel = doCancel;

			function doHasSubrecord(fieldId)
			{
				return implementation.hasSubrecord(fieldId);
			}
			this.doHasSubrecord = doHasSubrecord;

			var doGetSubrecord = utilityFunctions.thenableFunction(function doGetSubrecord(fieldId, proxyOptions, isAsync)
			{
				return implementation.getSubrecord.thenable(fieldId, proxyOptions, isAsync);
			}, {
				isAsyncArgIndex: 2
			});
			this.doGetSubrecord = doGetSubrecord;

			var doRemoveSubrecord = utilityFunctions.thenableFunction(function doRemoveSubrecord(fieldId, isAsync)
			{
				return implementation.removeSubrecord.thenable(fieldId, isAsync);
			}, {
				isAsyncArgIndex: 1
			});
			this.doRemoveSubrecord = doRemoveSubrecord;

			/*
			 * Makes a copy of the line and adds it as a new line.
			 * @returns {RawLine} reference to new line.
			 */
			var makeCopy = utilityFunctions.thenableFunction(function makeCopy(isAsync)
			{
				return recordBehaviorDelegate.makeCopy.thenable(isAsync);
			}, {
				isAsyncArgIndex: 0
			});
			this.makeCopy = recordDefinitionEvent.wrapEmitError({
				record: unproxiedRecord,
				func: makeCopy,
				emitter: emitter
			});

			var doMakeCopy = utilityFunctions.thenableFunction(function doMakeCopy(isAsync)
			{
				return implementation.makeCopy.thenable(isAsync);
			}, {
				isAsyncArgIndex: 0
			});
			this.doMakeCopy = doMakeCopy;

			function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});

				return that;
			}
			this.on = on;

			function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});

				return that;
			}
			this.off = off;

			function toJSON()
			{
				return {
					lineInstanceId : that.instanceId,
					sublistId : that.sublistId,
					fields: unproxiedRecord.getModelController().getSublistLineJSON(that.sublistId, that.instanceId, isCommitted)
				};
			}
			this.toJSON = toJSON;

			function toString()
			{
				return "line.Line";
			}
			this.toString = toString;

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return 'Line.' + methodName;
			}
			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			/**
			 * Convert fieldId how is defined in metadata
			 * @param {string} fieldId
			 * @returns {string}
			 */
			this.convertFieldId = function (fieldId)
			{
				return idConverterService.convertSublistFieldId(unproxiedRecord, sublistId, fieldId);
			}

			this.proxy = proxy.initialize(this, unproxiedRecord, function (proxy, proxyOptions) {
				if (isReadOnly || proxyOptions.isReadOnly) {
					var constructor = ReadOnlyLine;
				} else if (unproxiedRecord.isDynamic) {
					constructor = DynamicLine;
				} else {
					constructor = DeferredDynamicLine;
				}

				return new constructor(proxy);
			});

			utilityFunctions.checkArgs([lineInstanceId, sublistId, unproxiedRecord], ['lineInstanceId', 'sublistId', 'unproxiedRecord'], getMissingArgumentErrorMessageFillerValue("Line() constructor"));

			return that;
		}

		return Line;
	});

/**
 * SuiteScript module
 *
 * @private
 * @module N/util/slaving
 * @suiteScriptVersion 2.x
 */
define('N/util/slaving',['N/utilityFunctions', 'N/resultObject'], function(utilityFunctions, resultObject) {

var slavingUtil =
	function ()
	{
		//noinspection JSUnresolvedVariable
		var MULTISELECT = "multiselect";

		var SlavingMetadataKey = {
			QUERY_URL: "queryurl",
			EDIT:"edit",
			DISPLAY_ONLY:"displayonly",
			AUX_FIELDS:"auxfields",
			MULTILINE:"ln",
			MASTER:"master",
			FIELD_OBJECT: {
				NAME:"name",
				MACHINE:"machine",
				HTML_REF:"htmlReference",
				REQUIRED:"required",
				REQUIRED_SCRIPT:"requiredScript",
				IS_REQUIRED:"isRequired"
			}
		};

		var QueryRequst = {
			URL: "url",
			PAYLOAD: "payload"
		};

		var SlaveResultKey ={
			NAME : 'name',
			MACHINE_NAME : 'machine',
			FIRE_FIELDCHANGE : 'firechange',
			IS_CLIENT_SLAVING: 'isClientSlaving',
			OPTIONS : 'options',
			VALUE : 'value',
			TEXT : 'text',
			NO_OVERRIDE : 'nooverride',
			CONDITION : 'condition'
		};

		function RemoteRecordDelegate(recordDelegate)
		{
			/** @type {RawRecord} */
			var record = recordDelegate.currentRecord;
			var utilFunctionsFromRecordInstance = recordDelegate.util;
			/* Helper Function for finding option index */
			function getFieldOptionIndexById(options, id)
			{
				for(var i = 0; i < options.length; i++)
				{
					if(options[i].id == id)
						return i;
				}
				return -1;
			}

			/**
			 *
			 * @returns {OptionCacheDelegate}
			 */
			function getFieldOptions() { return utilFunctionsFromRecordInstance.getFieldOptions(); }

			function cacheOptionText(sublistId, fieldId, value, text) {
				if (utilFunctionsFromRecordInstance.cacheOptionText)
					utilFunctionsFromRecordInstance.cacheOptionText(sublistId, fieldId, value, text);
			}
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				utilFunctionsFromRecordInstance.setFieldNoSlaving(fieldInfo.machineName, fieldInfo.fieldName, fieldInfo.lineInstanceId, noslaving);
			}
			function isMultilineEditable(machineName)
			{
				return utilFunctionsFromRecordInstance.isMultilineEditable(machineName);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(!!params.lineInstanceId)
					{
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, params.lineInstanceId, false);
					}
					else if(params.ln && params.ln !== -1)
					{
						var lineInstanceId = record.getLineInstanceId(params.machineName, params.ln);
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, lineInstanceId, true); //TODO: shouldn't this be buffered line rather than committed?
						value = value === null || value === undefined ? "" : value;
					}
					else
					{
						var currentInstanceId = record.doGetCurrentSublistLineInstanceId(params.machineName);
						value = record.getSublistLineValueAsLegacyStringForInstance(params.machineName, params.fieldName, currentInstanceId, false);
					}
				}
				else if(params.isMultiSelectField)
					value = record.getValueAsLegacyStringArray(params.fieldName);
				else
					value = record.getValueAsLegacyString(params.fieldName);

				return utilityFunctions.returnEmptyIfNull(value);
			}
			var setValue = utilityFunctions.thenableFunction(function setValue(params, value, fireFieldChange, isClientSlaving, isAsync)
			{
				var noslaving = !isClientSlaving;
				if(params.isMachineField === true) {
					var lineInstanceId;
					if(!!params.lineInstanceId) {
						lineInstanceId = params.lineInstanceId;
					}
					else if (!!params.ln && params.ln !== -1) {
						lineInstanceId = record.getLineInstanceId(params.machineName, params.ln);
					}
					else {
						lineInstanceId = record.doGetCurrentSublistLineInstanceId(params.machineName);
					}
					return record.doSetSublistBufferFieldValue.thenable(params.machineName, params.fieldName, lineInstanceId, value, fireFieldChange, noslaving, true, true, isAsync);
				}
				else if(params.isMultiSelectField)
					return record.doSetFieldValue.thenable(params.fieldName, value, fireFieldChange, noslaving, true, true, isAsync);
				else
					return record.doSetFieldValue.thenable(params.fieldName, value, fireFieldChange, noslaving, true, true, isAsync);
			}, {
				isAsyncArgIndex: 4
			});
			var setSelectValue = utilityFunctions.thenableFunction(function setSelectValue(params, value, text, fireFieldChange, isAsync)
			{
				if(!value && value !== '')
				{
					if(params.isMachineField === true) {
						var lineInstanceId;
						if(!!params.lineInstanceId) {
							lineInstanceId = params.lineInstanceId;
						}
						else if (!!params.ln && params.ln !== -1) {
							lineInstanceId = record.getLineInstanceId(params.machineName, params.ln);
						}
						else {
							lineInstanceId = record.doGetCurrentSublistLineInstanceId(params.machineName);
						}
						return record.doSetSublistTextForInstance.thenable(params.machineName, params.fieldName, lineInstanceId, false, text, fireFieldChange, true, true, undefined, isAsync);
					}
					else
						return record.doSetText.thenable(params.fieldName, text, fireFieldChange, true, true, undefined, isAsync);
				}
				else
					return setValue.thenable(params, value, fireFieldChange, undefined, isAsync);
			}, {
				isAsyncArgIndex: 4
			});
			function getFieldOptionFromCache(params)
			{
				if(getFieldOptions() !== null && !(getFieldOptions().get(params.machineName, params.fieldName, params.lineInstanceId, params.isCommitted, false)))
					putFieldOptionInCache(params, []);

				return getFieldOptions().get(params.machineName, params.fieldName, params.lineInstanceId, params.isCommitted, false);
			}
			function putFieldOptionInCache(params, optionList)
			{
				getFieldOptions().put(params.machineName, params.fieldName, params.lineInstanceId, params.isCommitted, false, optionList);
				(optionList || []).forEach(function (option) {
					cacheOptionText(params.machineName, params.fieldName, option.id, utilityFunctions.unescape(option.text));
				});
			}
			function removeOption(params, value)
			{
				var options = getFieldOptionFromCache(params);
				if(options.length > 0)
				{
					if(value || value === 0)
					{
						var idx = getFieldOptionIndexById(options, value);
						options.splice(idx,1);
					}
					else
					{
						options.splice(0, options.length);
					}
					putFieldOptionInCache(params, options);
				}
			}
			function insertOption(params, value, text)
			{
				var options = getFieldOptionFromCache(params);
				if(options && options instanceof Array)
				{
					options.push({ text:text, id:value });
					putFieldOptionInCache(params, options);
				}
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.isMultilineEditable = isMultilineEditable;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = utilFunctionsFromRecordInstance.isEditableSublist;
			this.isFieldMultiSelect = utilFunctionsFromRecordInstance.isFieldMultiSelect;
			this.returnEmptyIfNull = utilityFunctions.returnEmptyIfNull;
			this.isValEmpty = utilityFunctions.isValEmpty;

			this.getCurrentLineItemIndex = function(sublist){ return record.getCurrentSublistIndex({sublistId: sublist});};
			this.eval = record.runLegacyScript;
			this.getIsNSERecord = record.getIsNSERecord;
		}

		/** @deprecated - not used */
		function BrowserRecordDelegate()
		{
			function setFieldNoSlaving(fieldInfo, noslaving)
			{
				var field = getFieldObject(fieldInfo);
				if(field)
					field.noslaving = noslaving;
			}
			function getFieldObject(params)
			{
				if(params.isMachineField === true)
					return nlapiGetLineItemField(params.machineName, params.fieldName, params.lineNum);
				else
					return nlapiGetField(params.fieldName);
			}
			function getValue(params)
			{
				var value = "";
				if(params.isMachineField === true)
				{
					if(params.ln)
						value = utilityFunctions.returnEmptyIfNull(nlapiGetLineItemValue(params.machineName, params.fieldName, params.ln));
					else
						value = nlapiGetCurrentLineItemValue(params.machineName, params.fieldName);
				}
				else if(params.isMultiSelectField)
					value = nlapiGetFieldValues(params.fieldName);
				else
					value = nlapiGetFieldValue(params.fieldName);

				return value;
			}
			var setValue = utilityFunctions.thenableFunction(function setValue(params, value, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemValue(params.machineName, params.fieldName, value, fireFieldChange, true);
				else if(params.isMultiSelectField)
					nlapiSetFieldValues(params.fieldName, value, fireFieldChange, true);
				else
					nlapiSetFieldValue(params.fieldName, value, fireFieldChange, true);
			});
			var setSelectValue = utilityFunctions.thenableFunction(function setSelectValue(params, value, text, fireFieldChange)
			{
				if(params.isMachineField === true)
					nlapiSetCurrentLineItemSelectValue(params.machineName, params.fieldName, value, text, fireFieldChange, getSlavingAsync());
				else
					nlapiSetSelectValue(params.fieldName, value, text, fireFieldChange, getSlavingAsync());
			});
			function insertSelectOption(fieldName, value, text)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function insertLineItemOption(machineName, fieldName, value, text)
			{
				var form = document.forms[machineName+'_form'];
				doInsertSelectOption(form, fieldName, text, value);
			}
			function doInsertSelectOption(form, fieldName, text, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
					addSelectOption( document, fld, text, value );
			}
			function removeSelectOption(fieldName, value)
			{
				var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fieldName)] != null ? document.forms[ftabs[getFieldName(fieldName)]+'_form'] : document.forms[0];
				doRemoveSelectOption(form, fieldName, value);
			}

			function removeLineItemOption(machineName, fieldName, value)
			{
				var form = document.forms[machineName+'_form'];
				doRemoveSelectOption(form, fieldName, value);
			}
			function doRemoveSelectOption(form, fieldName, value)
			{
				var fld = getFormElement( form, getFieldName(fieldName) );
				if (fld != null)
				{
					if(value != null)
						deleteOneSelectOption( fld, value );
					else
						deleteAllSelectOptions( fld, window );
				}
			}
			function removeOption(params, value)
			{
				if(params.isMachineField === true)
					removeLineItemOption(params.machineName, params.fieldName, value);
				else
					removeSelectOption(params.fieldName, value)
			}
			function insertOption(params, value, text)
			{
				if(params.isMachineField === true)
					insertLineItemOption(params.machineName, params.fieldName, value, text);
				else
					insertSelectOption(params.fieldName, value, text)
			}
			function isFieldMultiSelect(sublistId, fieldId, line)
			{
				var field = getFieldObject({isMachineField: !!sublistId, machineName: sublistId, fieldName: fieldId, lineNum: line});
				return field ? field.getType() === MULTISELECT : false;
			}

			this.setFieldNoSlaving = setFieldNoSlaving;
			this.getValue = getValue;
			this.setValue = setValue;
			this.setSelectValue = setSelectValue;
			this.removeOption = removeOption;
			this.insertOption = insertOption;
			this.isEditableSublist = isEditMachine;
			this.isMultilineEditable = function() { return false; };
			this.isFieldMultiSelect = isFieldMultiSelect;
			this.serverCall = nsServerCall;
			this.returnEmptyIfNull = emptyIfNull;
			this.isValEmpty = isValEmpty;

			this.getCurrentLineItemIndex = nlapiGetCurrentLineItemIndex;
			this.eval = eval;
		}

		/**
		 * getQueryRequest - static util function which transform metadata and dynamic recordDelegate context to query request
		 * object
		 *
		 * @param {object} metadata - slaving metadata for current field
		 * @param {object} masterInfo - a js object with 'queryFieldName', 'queryFieldValue', 'lineNum', 'fieldspec'
		 * @param {SlavingRecordDelegate} recordDelegate - recordDelegate scope for client object. It should be null for Browser
		 * @returns {*}
		 */
		function getQueryRequest(metadata, masterInfo, recordDelegate)
		{
			var IS_EDIT = 'e';
			var RECORD_ID = 'id';
			var QUERY_PARAMETER_NAME = 'q';
			var QUERY_PARAMETER_VALUE = 'si';
			var MACHINE_NAME = 'machine';
			var QUERYREQUEST_SLAVING_FIELD = 'f';
			var LIST_MACHINE_LINE_NUMBER = 'ln';

			var RecordDelegate = (recordDelegate) ? new RemoteRecordDelegate(recordDelegate) : new BrowserRecordDelegate();
			var isBrowserRequest = !recordDelegate;
			var lineNum = masterInfo.hasOwnProperty('lineNum') && masterInfo.lineNum != null ? masterInfo.lineNum : null;
			var sublistName = masterInfo.sublistId || masterInfo.sublistName;
			var lineInstanceId = masterInfo.hasOwnProperty('lineInstanceId') && masterInfo.lineInstanceId != null ? masterInfo.lineInstanceId : null;
			    lineInstanceId = !lineInstanceId && sublistName && recordDelegate ? recordDelegate.currentRecord.doGetCurrentSublistLineInstanceId(sublistName) : lineInstanceId;
			var result = cleanupQueryURL(metadata[SlavingMetadataKey.QUERY_URL]);
			var url = result[QueryRequst.URL];
			var payload = result[QueryRequst.PAYLOAD];

			// adding id and edit flag
			if (metadata[SlavingMetadataKey.EDIT] === 'T')
			{
				var id = (recordDelegate ? recordDelegate.currentRecord.id : RecordDelegate.getValue({fieldName: 'id'}));
				if(id || id === 0)
					payload[RECORD_ID] = String(id);
				if (metadata[SlavingMetadataKey.DISPLAY_ONLY] !== 'T')
					payload[IS_EDIT] = 'T';
			}
			// adding q and si
			payload[QUERY_PARAMETER_NAME] = masterInfo['queryFieldName'];
			payload[QUERY_PARAMETER_VALUE] = masterInfo['queryFieldValue'];
			if(sublistName) {
				payload[MACHINE_NAME] = sublistName;
				payload['lineInstanceId'] = lineInstanceId;
			}
			if(masterInfo['fieldspec'].length !== 0)
				payload[QUERYREQUEST_SLAVING_FIELD] = masterInfo['fieldspec'];
			// adding ln -- list machine field only
			if (metadata[SlavingMetadataKey.MULTILINE] === 'T' && lineNum > 0 )
				payload[LIST_MACHINE_LINE_NUMBER] = String(lineNum);

			// adding aux fields params
			var valid = addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate);
			if(!valid)
				return null;
			// adding master of query field
			addMasterValueToPayload(metadata, lineNum, lineInstanceId, payload, RecordDelegate);

			return { url : url, payload : payload /* all value should be String */};
		}
		/*
		 * Description: helper function to add aux field value to payload for field query request
		 */
		function addAuxFieldValueToPayloadAndReturnFalseWhenInvalid(isBrowserRequest, metadata, lineNum, lineInstanceId, payload, RecordDelegate)
		{
			var auxfields = metadata[SlavingMetadataKey.AUX_FIELDS];
			for (var idx = 0; auxfields && idx < auxfields.length; idx++)
			{
				var auxfld = auxfields[idx];
				var fieldName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.NAME) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.NAME] : "";
				var machineName = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				var htmlReference = auxfld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.HTML_REF) ? auxfld[SlavingMetadataKey.FIELD_OBJECT.HTML_REF] : null;
				var fieldValue = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: fieldName, ln: lineNum, lineInstanceId: lineInstanceId});

				if(isBrowserRequest && !fieldValue && fieldValue !== 0 && fieldValue !== "")
					fieldValue = eval(htmlReference);

				if(auxfld[SlavingMetadataKey.FIELD_OBJECT.REQUIRED] === 'T' && isInvalidRequiredAuxField(isBrowserRequest, auxfld, fieldValue))
					return false;

				payload['si_'+fieldName] = fieldValue;
			}

			return true;
		}
		/*
		 * Description: helper function to add master value of the query field to payload for field query request
		 */
		function addMasterValueToPayload(metadata, lineNum, lineInstanceId, payload, RecordDelegate)
		{
			if (metadata[SlavingMetadataKey.MASTER] && metadata[SlavingMetadataKey.MASTER] !== '')
			{
				var fld = metadata[SlavingMetadataKey.MASTER];
				var masterFieldName = fld[SlavingMetadataKey.FIELD_OBJECT.NAME];
				var machineName = fld.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.MACHINE) ? fld[SlavingMetadataKey.FIELD_OBJECT.MACHINE] : null;
				// adding master value
				payload['si_' + masterFieldName] = RecordDelegate.getValue({isMachineField: machineName !== null, machineName: machineName, fieldName: masterFieldName, ln: lineNum, lineInstanceId: lineInstanceId});
			}
		}

		/*
		 * Description: helper function to separate the base url into url and payload
		 */
		function cleanupQueryURL(url)
		{
			var payload = {};
			if(url.indexOf("?") !== -1)
			{
				var list = url.split("?");
				url = list[0];
				if(list[1].length >0)
				{
					var params = list[1].split("&");

					for(var i=0; i < params.length; i++)
					{
						//noinspection JSUnfilteredForInLoop
						if(params[i].length >0)
						{
							//noinspection JSUnfilteredForInLoop
							var pair = params[i].split("=");
							payload[pair[0]] = String(pair[1]);
						}
					}
				}
			}
			return { url : url, payload : payload };
		}

		function isInvalidRequiredAuxField(isBrowserRequest, field, value)
		{
			var requiredScriptCondition = true;
			if (isBrowserRequest && field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT))
				requiredScriptCondition = ( eval(field[SlavingMetadataKey.FIELD_OBJECT.REQUIRED_SCRIPT]) ) ? true : false;
			else if(field.hasOwnProperty(SlavingMetadataKey.FIELD_OBJECT.IS_REQUIRED) && field.isRequired)
				requiredScriptCondition = true;

			var isValidValue = (value && value.length != 0) ? true : false;

			return requiredScriptCondition && !isValidValue;
		}

		function getURL(metadata, masterInfo)
		{
			var requestObj = getQueryRequest(metadata, masterInfo, undefined /* no remote record context required */);
			var fullUrl = requestObj['url'];
			var payload = requestObj['payload'];
			if(fullUrl.indexOf('?') == -1)
			{
				fullUrl+='?';
			}
			var first = true;
			for(var key in payload)
			{
				if(!first)
					fullUrl+='&';
				else
					first = false;

				if(key.indexOf('si_')===0 || key==='q' || key==='si' || key==='id')
					fullUrl = fullUrl+key+'='+encodeURIComponent(emptyIfNull(payload[key])) ;
				else
					fullUrl = fullUrl+key+'='+emptyIfNull(payload[key]) ;
			}

			return fullUrl;
		}

		function addEscaping(value)
		{
			value= value.replace(/\\/g, "\\\\");
			value= value.replace(/'/g, "\\\'");
			value= value.replace(/"/g, "\\\"");
			return value;
		}

		/**
		 * static function that verifies that slaving data sent from server using new format are the same that were set by legacy
		 * code. fields parameter is needed so we call verify before slaving script execution as fields can be modified by slave
		 * script.
		 * @param {*} fields  fields that need to be checked on the current level
		 * @param {*} slavingValues array of all slaving values
		 */
		function verifySlavingValues(fields,slavingValues)
		{
			try{
				for(var j = 0; fields && j < fields.length; j++)
				{
					for (var idx = 0; slavingValues && idx < slavingValues.length; idx++)
					{
						var slaveInfo = slavingValues[idx];
						if(isFunction(slaveInfo))
						{
							continue;
						}
						if(slaveInfo['name'] != fields[j][0] || (slaveInfo['machine']!= null && slaveInfo['machine']!= fields[j][1] || slaveInfo['machine'] == null && fields[j][1] != ""))
							continue;
						var options = slaveInfo["options"];
						var fld = nlapiGetLineItemField(slaveInfo["machine"],slaveInfo["name"]);
						if(slaveInfo["machine"] != null)
						{
							if(options != null)
							{
								var legacyValues = getLineItemOptionValues(slaveInfo["machine"],slaveInfo["name"],fld.type);
								var legacyTexts = getLineItemOptionTexts(slaveInfo["machine"],slaveInfo["name"],fld.type);
								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name'] +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)
									{
										var option = options[i];
										// need to take care of escape character difference
										var legacyValue= addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');


										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyTexts[i]  +' ,path = '+  window.location.pathname]);
										   break;
										}
									}
								}

							}

							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;
							// need to take care of escape character difference
							var oldvalue = nlapiGetCurrentLineItemValue(slaveInfo["machine"],slaveInfo["name"]);
							oldvalue= addEscaping(oldvalue);

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo["value"]+', actualValue  = ' + oldvalue +' ,path = '+  window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetCurrentLineItemText(slaveInfo["machine"],slaveInfo["name"]);
								oldtext= addEscaping(oldtext);

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl',
											'logSlavingError',['Json Value mismatch',
												'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+ window.location.pathname]);

								}
							}
						}
						else
						{
							// need to take care of escape character difference

							var oldvalue = nlapiGetFieldValue(slaveInfo["name"]);
							oldvalue=  addEscaping(oldvalue);

							var options = slaveInfo["options"];
							var fld = nlapiGetField(slaveInfo["name"]);
							if(options != null)
							{
								var legacyValues = getOptionValues(slaveInfo["name"], fld.type);
								var legacyTexts = getOptionTexts(slaveInfo["name"],fld.type);

								if(legacyValues.length != options.length)
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Length mismatch',
										'Options length do not match. Field name:' + slaveInfo['name']  +' ,path = '+  window.location.pathname]);
								else
								{
									for( var i= 0; options && i <options.length; i++)

									{
										var option = options[i];
										var legacyValue=  addEscaping(legacyValues[i]);
										var legacyText= addEscaping(legacyTexts[i]);
										// some options have extra CR in legacy ignoring it
										legacyText = legacyText.replace('\n','');

										if(option[0] != legacyValue)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving value do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[0] +' legacyValue = ' + legacyValues[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
										if(option[1] != legacyText)
										{
											nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json option Value mismatch',
												'Options slaving text do not match. Field name:' + slaveInfo['name'] +' jsonValue =' +option[1] +' legacyValue = ' + legacyText[i]  +' ,path = '+  window.location.pathname]);
											break;
										}
									}
								}
							}
							// don't know the old value (before slaving)
							// so can not check values for this case.
							if(slaveInfo["nooverride"] != null)
							{
								continue;
							}
							if(slaveInfo["condition"] != null)
								if(!eval(slaveInfo["condition"]))
									continue;

							if(slaveInfo["value"] != null && slaveInfo["value"] != oldvalue  )
							{
								nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
									'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['value'] +', actualValue  = ' + oldvalue +' ,path = '+
																																	window.location.pathname]);

							}
							if(slaveInfo["text"] != null)
							{
								// need to take care of escape character difference
								var oldtext = nlapiGetFieldText(slaveInfo["name"]);
								oldtext= addEscaping(oldtext);;

								if(slaveInfo["text"] != oldtext)
								{
									nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Json Value mismatch',
										'Value slaving result do not match. Field name:' + slaveInfo['name'] + ', jsonText = '+ slaveInfo['text'] +', actualValue  = ' + oldtext +' ,path = '+
										window.location.pathname]);
								}
							}
						}
					}
				}
			}
			catch(err)
			{
				nsServerCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in verifying values', err.msg +' ,path = '+	  window.location.pathname]);
			}
		}

		function isFunction(obj)
		{
			return Object.prototype.toString.call(obj) === '[object Function]';
		}

		/**
		 * static utility function that process the slavingResponse data in the json format and sets the data in the DOM using
		 * Nlapi when possible.
		 * @param {object} slavingValues
		 * @param {SlavingRecordDelegate} record
		 */
		var processSlavingValues = utilityFunctions.thenableFunction(function processSlavingValues(slavingValues, record, isAsync)
		{
			var RecordDelegate = (record) ? new RemoteRecordDelegate(record) : new BrowserRecordDelegate();
			return utilityFunctions.forEachThenable(slavingValues, function (slaveResult)
			{
				var fieldName = slaveResult[SlaveResultKey.NAME];
				var isMachineField = slaveResult.hasOwnProperty(SlaveResultKey.MACHINE_NAME);
				var machineName = (isMachineField) ? slaveResult[SlaveResultKey.MACHINE_NAME] : null;
				var lineNum = (isMachineField) ? RecordDelegate.getCurrentLineItemIndex(machineName) : -1;
				var lineInstanceId = (isMachineField && record) ? record.currentRecord.doGetCurrentSublistLineInstanceId(machineName) : null;
				var fieldInfo = {isMachineField: isMachineField, machineName: machineName, fieldName: fieldName, lineNum: lineNum, lineInstanceId: lineInstanceId};
				fieldInfo.isMultiSelectField = RecordDelegate.isFieldMultiSelect(machineName, fieldName, lineNum, lineInstanceId);

				if(isFunction(slaveResult))
				{
					slaveResult(RecordDelegate); // TODO: what if it uses line numbers for RecordDelegate
					return;
				}

				if(isMachineField && lineNum === -1 && RecordDelegate.isMultilineEditable(machineName))
				{
					return utilityFunctions.forEachThenable(record.currentRecord.getLines({sublistId: machineName}), function(line) {
						lineNum = line.sequence;
						lineInstanceId = line.instanceId;
						fieldInfo = {isMachineField: isMachineField, machineName: machineName, fieldName: fieldName, lineNum: lineNum, lineInstanceId: lineInstanceId};
						return applySlaveValueToRecord.thenable(RecordDelegate, slaveResult, fieldInfo, isAsync);
					})
				}

				return resultObject.create(function ()
				{
					return applySlaveValueToRecord.thenable(RecordDelegate, slaveResult, fieldInfo, isAsync);
				})['catch'](function (err)
				{
					if(RecordDelegate instanceof BrowserRecordDelegate)
						RecordDelegate.serverCall('/app/common/scripting/nlapijsonhandler.nl', 'logSlavingError',['Excepion in processing values', err.msg +',path =  '+  ((record)? "" : window.location.pathname)]);
					else
						throw err;
					// this will allow the code to proceed further even if there is an error in slaving
					// we probably need to do something here rather than fail silently
				})['finally'](function ()
				{
					if(record == null)
						RecordDelegate.setFieldNoSlaving(fieldInfo, false);
				});
			});
		}, {
			isAsyncArgIndex: 2
		});

		var applySlaveValueToRecord = utilityFunctions.thenableFunction(function applySlaveValueToRecord(RecordDelegate, slaveResult, fieldInfo, isAsync)
		{
			var fireFieldChangeEvent = slaveResult.hasOwnProperty(SlaveResultKey.FIRE_FIELDCHANGE);
			var isClientSlaving = slaveResult.hasOwnProperty(SlaveResultKey.IS_CLIENT_SLAVING);

			RecordDelegate.setFieldNoSlaving(fieldInfo, !fireFieldChangeEvent);

			return resultObject.create(function ()
			{
				var options = slaveResult[SlaveResultKey.OPTIONS];
				if(options)
				{
					var oldValue = RecordDelegate.getValue(fieldInfo);

					var isOldValueInOptions = false;
					RecordDelegate.removeOption(fieldInfo); // clear all options
					for(var j = 0; j < options.length; j++)
					{
						var option = options[j];
						RecordDelegate.insertOption(fieldInfo, option[0], option[1]);
						if(oldValue === option[0])
							isOldValueInOptions = true;
					}

					var preserveOriginalValueWhenOptionSlavingOnly = (RecordDelegate.isValEmpty(slaveResult[SlaveResultKey.VALUE]) && !RecordDelegate.isValEmpty(oldValue) && isOldValueInOptions);
					if(preserveOriginalValueWhenOptionSlavingOnly)
						return RecordDelegate.setValue.thenable(fieldInfo, oldValue, false, undefined, isAsync);
				}
			}).then(function ()
			{
				/* skip slaving when there is old value */
				if(slaveResult[SlaveResultKey.NO_OVERRIDE] != null && !RecordDelegate.isValEmpty(RecordDelegate.getValue(fieldInfo)))
					return;

				if (!RecordDelegate.getIsNSERecord())
				{
					/* skip slaving when condition is not met */
					var slavingCondition = typeof slaveResult[SlaveResultKey.CONDITION] === 'boolean' ? slaveResult[SlaveResultKey.CONDITION] : RecordDelegate.eval(slaveResult[SlaveResultKey.CONDITION]);
					if(slaveResult.hasOwnProperty(SlaveResultKey.CONDITION) && !slavingCondition)
						return;
				}

				if(slaveResult.hasOwnProperty(SlaveResultKey.TEXT))
					return RecordDelegate.setSelectValue.thenable(fieldInfo, slaveResult[SlaveResultKey.VALUE], slaveResult[SlaveResultKey.TEXT], fireFieldChangeEvent, isAsync);
				else if(slaveResult.hasOwnProperty(SlaveResultKey.VALUE))
					return RecordDelegate.setValue.thenable(fieldInfo, slaveResult[SlaveResultKey.VALUE],  fireFieldChangeEvent, isClientSlaving, isAsync);
			});
		}, {
			isAsyncArgIndex: 3
		});


		/**
		 * redraws edit machines in case new slaving response is used.
		 * @param {*} machinedata
		 */
		function redrawEditMachines(machinedata)
		{
			for (var machineName in machinedata)
			{

				var slaveMachineData =  machinedata[machineName];

				if( slaveMachineData['edit'] != null && (slaveMachineData["nooverride"] == null || document.forms[0].elements['next' + machineName  + 'idx'].value == 1))
				{
					var data = slaveMachineData['data'];
					var strValue='';
					for (var i = 0; data && i < data.length; i++)
					{
						var row = data[i];
						for (var j = 0; row && j < row.length; j++)
						{
							if(strValue != '')
								strValue += String.fromCharCode(1);
							strValue +=row[j];
						}
						if(i != data.length -1)
							strValue += String.fromCharCode(2);
					}
					document.forms[0].elements[machineName+'data'].value=strValue;
					clearLineArray(name);

					document.forms[0].elements['next'+ machineName  + 'idx'].value=data==null?1:data.length+1;
					document.forms[0].elements[machineName+'valid'].value='T';
					setMachineContentUpdated(machineName, true);
					clearLineArray(name);
					if (parent.document.forms.main_form.elements[machineName+'loaded'] != null) parent.document.forms.main_form.elements[machineName+'loaded'].value = 'T';
					if (parent.document.forms.main_form.elements[machineName+'dotted'] != null) parent.document.forms.main_form.elements[machineName+'dotted'].value = 'T';
					if(window[machineName+'_machine'] != null)
					{
						window[machineName+'_machine'].refresheditmachine(true);

						window[machineName+'_machine'].recalc();
					}
					var tabTD = parent.document.getElementById(machineName+'lnkdot');
					if (tabTD != null) { tabTD.style.display='';}
				}
				if(isFunction(slaveMachineData['metadata']))
				{
					slaveMachineData['metadata'].call();
					continue;
				}
			}
		}

		function getOptionValues(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getOptionTexts(fldnam,type)
		{
			var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)]+'_form'] : document.forms[0];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}
		function getLineItemOptionValues(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).getValues();
				else
					return getDropdown(fld,window).getValues();
			else
				return null;
		}
		function getLineItemOptionTexts(machine,fldnam, type)
		{
			var form = document.forms[machine+'_form'];
			var fld = getFormElement( form, getFieldName(fldnam) );
			if (fld != null)
				if(type === MULTISELECT)
					return getMultiDropdown(fld,window).textArray;
				else
					return getDropdown(fld,window).getTexts();
			else
				return null;
		}

		return {
				cleanupQueryURL: cleanupQueryURL,
				getQueryRequest: getQueryRequest,
				getURL: getURL,
				processSlavingValues:processSlavingValues,
				verifySlavingValues:verifySlavingValues,
				redrawEditMachines:redrawEditMachines
			};
	}();

if (typeof Object.freeze == 'function')
	slavingUtil = Object.freeze(slavingUtil);

    return slavingUtil;});
/**
 * SuiteScript module
 *
 * @private
 * @module N/pagination/paginationObject
 * @suiteScriptVersion 2.x
 */
define('N/pagination/paginationObject',['N/nsobject', 'N/internal/invoker', 'N/error', 'N/utilityFunctions'],
       function (nsobject, invoker, error, utilityFunctions)
       {
           var interfaces = {};
           
           /**
            * PagedData interface
            *
            * @classdesc Holds metadata for a paginated query.
            * @protected
            * @param {Object} delegate PagedData implementation
            * @return {PagedData}
            * @constructor
            *
            * @since 2015.2
            */
           function PagedData(delegate)
           {
               var that = this;
               var pageRanges;

               function validateFetchParameter(options)
               {
                   var index;
                   index = options !== undefined && options !== null && !util.isNumber(options) && !util.isString(options) ? options.index : options;
                   utilityFunctions.checkArgs([index],['index'], 'PagedData.fetch');
                   return validateIndex(index);
               }

               function validateIndex(index)
               {
                   var i = parseInt(index, 10);
                   if(isNaN(i))
                       utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_INDEX, index);

                   return i;
               }
               
               /**
                * The total number of results when Search.runPaged(options) was executed.
                * @name PagedData#count
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'count', {
                   get: function () {
                       return delegate.count;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'count' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * The collection of PageRange objects that divide the entire result set into smaller groups.
                * @name PagedData#pageRanges
                * @type {Array<PageRange>}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           delegate.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRanges' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * Maximum number of entries per page
                * @name PagedData#pageSize
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                * 
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageSize', {
                   get: function () {
                       return delegate.pageSize;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageSize' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * The search criteria used to execute the result set for this PagedData Object.
                * @name PagedData#searchDefinition
                * @type {Search}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                * 
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchDefinition', {
                   get: function () {
                       return utilityFunctions.freezeObjectIfPossible(delegate.searchDefinition);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition' );
                   },
                   enumerable: true,
                   configurable: false
               });
               
               /**
                * This method retrieves the data within the specified page range.
                * @governance 5 units
                * @param {Object} options the options object
                * @param {number} options.index the index of the page
                * @return {Page}
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when index parameter is missing
                * 
                * @since 2015.2
                */
               this.fetch = function(options){
                   var index = validateFetchParameter(options);
                   return delegate.fetch(index);
               };

               if (delegate.fetch.promise)
               {
	               /**
	                * This method asynchronously retrieves the data bounded by the pageRange parameter.
	                * @governance 5 units
	                * @param {Object} options the options object
	                * @param {number} options.index the index of the page
	                * @return {Promise}
	                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when index parameter is missing
	                *
	                * @since 2015.2
	                */
                   this.fetch.promise = function(options){
                       var index = validateFetchParameter(options);
                       return delegate.fetch.promise(index);
                   }
               }

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            * 
	            * @since 2015.2
	            */
               this.toJSON = function toJSON(){
                   return {
                       count: that.count,
                       pageRanges: that.pageRanges,
                       pageSize: that.pageSize,
                       searchDefinition: that.searchDefinition
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            * 
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.PagedData";
               };
           }
           PagedData.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PagedData);
           interfaces.PagedData = PagedData;

	       /*
	        * ReadonlyPagedData interface
	        *
	        * @classdesc Holds read-only metadata for a paginated query.
	        * @protected
	        * @param {Object} pagedData PagedData delegate
	        * @return {PagedData}
	        * @constructor
	        *
	        * @since 2015.2
	        */
           function ReadonlyPagedData(pagedData)
           {
               var pageRanges;

	           /*
	            * The collection of PageRange objects that divide the entire result set into smaller groups.
	            * @name ReadonlyPagedData#pageRanges
	            * @type {Array<PageRange>}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageRanges', {
                   get: function () {
                       if(!pageRanges)
                       {
                           pageRanges = [];
                           pagedData.pageRanges.forEach(function (v) { pageRanges.push(new PageRange(v)); });
                       }
                       return pageRanges;
                   },
                   enumerable: true,
                   configurable: false
               });

	           /*
	            * The total number of results when Search.runPaged(options) was executed.
	            * @name ReadonlyPagedData#count
	            * @type {number}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'count', {
                   value : pagedData.count,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * Maximum number of entries per page
	            * @name ReadonlyPagedData#pageSize
	            * @type {number}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageSize', {
                   value : pagedData.pageSize,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * The search criteria used to execute the result set for this PagedData Object.
	            * @name ReadonlyPagedData#searchDefinition
	            * @type {Search}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'searchDefinition', {
                   value : pagedData.searchDefinition,
                   enumerable: true,
                   configurable: false,
                   writable: false
               });

	           /*
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
               this.toJSON = pagedData.toJSON;

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function (){ return "search.PagedData(readonly)"; }
           }
           utilityFunctions.freezeObjectIfPossible(ReadonlyPagedData);

           /**
            * Page interface
            *
            * @classdesc Encapsulates an individual search page containing a result set for a paginated search.
            * @protected
            * @param {Object} delegate Page implementation
            * @return {Page}
            * @constructor
            * 
            * @since 2015.2
            */
           function Page(delegate)
           {
               var that = this;
               var _pageRange, readonlyPagedData;

               function getReadOnlyPagedDataInstance()
               {
                   if (!readonlyPagedData)
                       readonlyPagedData = utilityFunctions.freezeObjectIfPossible(new ReadonlyPagedData(delegate.pagedData));

                   return readonlyPagedData;
               }

               /**
                * The PagedData Object used to fetch this Page Object.
                * @name Page#pageData
                * @type {PagedData}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pagedData', {
                   get: function () {
                       return getReadOnlyPagedDataInstance(delegate.pagedData);
                   },
                   set: function () {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pagedData' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The PageRange Object used to fetch this Page Object.
                * @name Page#pageRange
                * @type {PageRange}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'pageRange', {
                   get: function () {
                       if(!_pageRange)
                       {
                           _pageRange = new PageRange(delegate.pageRange);
                       }
                       return _pageRange;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'pageRange' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Indicates whether the page is within the first range of the result set.
                * @name Page#isFirst
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isFirst', {
                   get: function () {
                       return delegate.isFirst;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isFirst' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Indicates whether a page is within the last range of the result set.
                * @name Page#isLast
                * @type {boolean}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isLast', {
                   get: function () {
                       return delegate.isLast;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isLast' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The results from a paginated search.
                * @name Page#data
                * @type {Array<Result>}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'data', {
                   get: function () {
                       return delegate.data;
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'data' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Method used to fetch the next segment of data
                * @governance 5 units
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                *
                * @since 2015.2
                */
               this.next = delegate.next;
               if(delegate.next.promise)
               {
                   /**
                    * Method used to asynchronously fetch the next segment of data.
                    * @governance 5 units
                    * @return {Promise}
                    * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                    *
                    * @since 2015.2
                    */
                   this.next.promise = delegate.next.promise;
               }

               /**
                * Method used to fetch the previous segment of data
                * @governance 5 units
                * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                *
                * @since 2015.2
                */
               this.prev = delegate.prev;
               if(delegate.prev.promise)
               {
                   /**
                    * Method used to asynchronously fetch the previous segment of data.
                    * @governance 5 units
                    * @return {Promise}
                    * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
                    *
                    * @since 2015.2
                    */
                   this.prev.promise = delegate.prev.promise;
               }

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
	           this.toJSON = function toJSON(){
                   return{
                       pagedData: that.pagedData,
                       pageRange: that.pageRange,
                       isFirst: that.isFirst,
                       isLast: that.isLast,
                       data: that.data
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.Page";
               };
           }
           Page.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(Page);
           interfaces.Page = Page;

           /**
            * PageRange interface
            *
            * @classDescription Defines the page range to contain the result set
            * @protected
            * @param {Object} delegate PageRange implementation
            * @return {PageRange}
            * @constructor
            *
            * @since 2015.2
            */
           function PageRange(delegate)
           {
               var that = this;

               /**
                * The index of the pageRange
                * @name PageRange#index
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'index', {
                   get: function () {
                       return invoker(delegate,'getIndex', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Human-readable label with beginning and ending range identifiers
                * @name PageRange#compoundLabel
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'compoundLabel', {
                   get: function () {
                       return invoker(delegate,'getCompoundLabel', []);
                   },
                   set: function (val) {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
                   },
                   enumerable: true,
                   configurable: false
               });

	           /**
	            * get JSON format of the object
	            * @governance none
	            * @return {Object}
	            *
	            * @since 2015.2
	            */
               this.toJSON = function toJSON(){
                   return {
                       index: that.index,
                       compoundLabel: that.compoundLabel
                   }
               };

	           /**
	            * Returns the object type name
	            * @governance none
	            * @return {string}
	            *
	            * @since 2015.2
	            */
               this.toString = function toString(){
                   return "search.PageRange";
               };
           }
           PageRange.prototype = nsobject.getNewInstance();
           utilityFunctions.freezeObjectIfPossible(PageRange);
           interfaces.PageRange = PageRange;


           return Object.freeze(interfaces);
       });
/**
 * SuiteScript RelatedRecord module
 * @private Ignore for JSDoc stub generation
 * @module N/record/relatedRecord
 * @NApiVersion 2.x
 *
 */
define('N/record/relatedRecord',['N/restricted/remoteApiBridge', 'N/internal/invoker','N/error', 'N/nsobject', 'N/util/slaving', 'N/pagination/paginationObject', 'N/utilityFunctions', 'N/format'],
       function (remoteApi, invoker, error, nsobject, slaving, paginationObject, utilityFunctions, format){

    var SORTING_DIRECTION = ["ASC", "DESC"];
    var freezeObjectIfPossible = utilityFunctions.freezeObjectIfPossible;

    var LINK_TYPE = Object.freeze({
        NONE: "NONE",
        REGULAR: "REGULAR",
        POPUP: "POPUP"
    });

    /**
     * Data model for search result machine
     *
     * @protected
     * @param {Object} options
     * @return {RelatedRecord}
     * @constructor
     */
    function RelatedRecord(options)
    {
        var that = this,
                id = options.id,
                notify = options.notify,
                sourceRecordType = options.owningRecordType,
                queryField = options.queryField,
                formUrl = options.queryUrl,
                currentView,
                customViews,
                exposedUtil = { notify: notify, getQueryRequest: getQueryRequest };

        var searchDefinition;

        function initializeRelatedRecord(config)
        {
            var views = config.customViews;
            var _customViews = [];
            views.forEach(function(v){
                if(v.isSelected)
                    currentView = v.id;

                _customViews.push(new CustomView(v));
            });
            utilityFunctions.checkArgs([currentView], ['currentView'], 'relatedRecord.initialize');

            customViews = freezeObjectIfPossible(_customViews);
            initializeSearchDefinition(config)
        }
        initializeRelatedRecord(options);

        function validateView(viewId)
        {
            var found = null;
            customViews.forEach(function(v){
                if(v.id === String(viewId))
                    found = v;
            });

            if(!found)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_CUSTOM_VIEW_VALUE, viewId);
            return found;
        }

        function setView(view)
        {
            var oldView = currentView;
            var result = validateView(view);
            currentView = String(view);
            postViewChanged(view, oldView);
            return result;
        }

        function postViewChanged(view, oldView)
        {
            var request = getQueryRequest(queryField);
            var relatedRecordObj = invoker(remoteApi, "getRelatedRecord", [sourceRecordType, request.url, request.payload], null /* callback */, false /* parseResult */);
            relatedRecordObj.currentView = view;
            initializeSearchDefinition(relatedRecordObj);
        }

        function getQueryRequest(queryField)
        {
            var request = slaving.cleanupQueryURL(formUrl);
            request.payload.q = queryField;
            request.payload.si = "0"; //default loading first page
            request.payload.machine = id;
            request.payload.si_searchid = currentView;

            return request;
        }

        function initializeSearchDefinition(relatedRecordObj)
        {
            relatedRecordObj.util = exposedUtil;
            searchDefinition = new RelatedRecordSearchDefinition(relatedRecordObj);
        }

        function toJSON()
        {
            return {
                id: that.id,
                currentView: that.currentView,
                customViews: that.customViews
            }
        }

        function toString()
        {
            return "record.RelatedRecord"
        }

        /**
         * Search definition of the related record
         * @name RelatedRecord#searchDefinition
         * @type {SearchDefinition}
         * @readonly
         */
        Object.defineProperty(this, 'searchDefinition', {
            get: function() {
                return searchDefinition
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchDefinition');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The list of available custom views
         * @name RelatedRecord#customViews
         * @type {Array<CustomView>}
         * @readonly
         */
        Object.defineProperty(this, 'customViews', {
            get: function() {
                return customViews;
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'customViews');
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Return the currently selected custom view (as CustomView object)
         * @name RelatedRecord#currentView
         * @type {CustomView}
         * @readonly
         */
        Object.defineProperty(this, 'currentView', {
            get: function() {
                return validateView(currentView)
            },
            set: function() {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'currentView');
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Select custom view with the given ID
         * @param {Object} options  the options object
         * @param {string} options.id  ID of the view
         * @returns {CustomView} object corresponding to the selected view
         * @throws {SuiteScriptError} INVALID_CUSTOM_VIEW_VALUE if input value is invalid
         */
        this.selectView = function selectView(options)
        {
            var id;
            if(options !== undefined && options !== null)
            {
                id = options.id;
            }
            utilityFunctions.checkArgs([id], ['id'], 'RelatedRecord.selectView');
            
            return setView(id);
        };
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecord.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecord);


    function ReadonlyRelatedRecordSearchDefinition(searchDefinition)
    {
        Object.defineProperty(this, 'type', {
            value : searchDefinition.type,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'columns', {
            value : searchDefinition.columns,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'filters', {
            value : searchDefinition.filters,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'sortBy', {
            value : searchDefinition.sortBy,
            enumerable: true,
            configurable: false,
            writable: false
        });
        Object.defineProperty(this, 'settings', {
            value : searchDefinition.settings,
            enumerable: true,
            configurable: false,
	    });
        this.getFilterValue = searchDefinition.getFilterValue;
        this.toJSON = searchDefinition.toJSON;
        this.toString = function (){ return searchDefinition.toString() + "(readonly)"; }
    }
    ReadonlyRelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(ReadonlyRelatedRecordSearchDefinition);


    function RelatedRecordSearchDefinition(options)
    {
        var that = this,
                notify = options.notify,
                currentView = options.currentView,
                _util = options.util,
                id = options.id,
                queryField = options.queryField,
                sourceRecordType = options.owningRecordType,
                searchType = options.recordType,
                formUrl = options.queryUrl,
                filterFieldMetadata, /* internal map */
                returnFieldMetadata, /* internal map */
                filters,
                columns,
                settings,
                filterFields,
                sortBy;

        function initializeSearchDefinition(config)
        {
            var rawFilterFields = config.filterFields,
                rawReturnFields = config.fields,
                _returnFieldMetadata = {},
                _columns = [],
                _settings = [],
                _filterFieldMetadata = {},
                _filterFields = [],
                _sortBy;

            // initialize filters
            filters = {};

            rawReturnFields.forEach(function(field){
                _returnFieldMetadata[field.id] = field;
                var c = new Column(field);
                _columns.push(freezeObjectIfPossible(c));
            });
            rawFilterFields.forEach(function(field){
                _filterFieldMetadata[field.id] = field;
                var f = new FilterField(field);

                _filterFields.push(freezeObjectIfPossible(f));
                setDefaultValue(filters, field);
            });

            if(config.defaultSortCol)
            {
                _sortBy = {};
                _sortBy.columnId = config.defaultSortCol;
                _sortBy.direction = config.defaultSortDir;
            }

            returnFieldMetadata = freezeObjectIfPossible(_returnFieldMetadata);
            columns = freezeObjectIfPossible(_columns);
            settings = freezeObjectIfPossible(_settings);
            sortBy = freezeObjectIfPossible(_sortBy);
            filterFieldMetadata = freezeObjectIfPossible(_filterFieldMetadata);
            filterFields = freezeObjectIfPossible(_filterFields);
        }
        initializeSearchDefinition(options);

        function resetFilters()
        {
            filterFields.forEach(function(fieldObj) {
                setDefaultValue(filters, filterFieldMetadata[fieldObj.id]);
            });
        }

        function setDefaultValue(data, metadata)
        {
            if(metadata.defaultValue)
            {
                if(metadata.type === 'select')
                {
                    if(!!metadata.isMultiSelect)
                        data[metadata.id] = metadata.defaultValue.split(String.fromCharCode(5));
                    else
                        data[metadata.id] = metadata.defaultValue;
                }
                else
                    data[metadata.id] = parseFilterValue(metadata, metadata.defaultValue);
            }
        }

        function runPaged(){
            var pagedDataOptions = doGetPagedData(null);
            var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(pagedDataOptions));
            return new paginationObject.PagedData(pagedData);
        }

        function runPagedPromise()
        {
            return new Promise(function(resolve, reject){
                function callback(result, exception) {
                    if (exception) {
                        reject(exception);
                    }
                    else {

                        var pagedData = new RelatedRecordPagedData(postGetRelatedRecordPagedData(result));
                        resolve(new paginationObject.PagedData(pagedData));
                    }
                }

                try {
                    doGetPagedData(callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }

        function getQueryRequestWithDynamicValues()
        {
            var request = _util.getQueryRequest(queryField);
            updateSortingForQueryRequest(request.payload);
            updateFilterValuesForQueryRequest(request.payload);
            return request;
        }

        function doGetPagedData(callback)
        {
            var request = getQueryRequestWithDynamicValues();
            return invoker(remoteApi, 'getRelatedRecordPagedData', [sourceRecordType, request.url, request.payload], callback, true /* parseResult */);
        }

        function postGetRelatedRecordPagedData(pagedDataOptions)
        {
            pagedDataOptions.parent = that;
            var requestorConfiguration = {
                rawUrl: formUrl,
                id: id,
                view: currentView,
                recordType: sourceRecordType,
                queryField: queryField,
                pageRanges: pagedDataOptions.pageRanges,
                dynamicValues: {}
            };
            updateSortingForQueryRequest(requestorConfiguration.dynamicValues);
            updateFilterValuesForQueryRequest(requestorConfiguration.dynamicValues);
            pagedDataOptions.pageRequestor = new RelatedRecordPageRequestor(requestorConfiguration);
            pagedDataOptions.returnFieldMetadata = returnFieldMetadata;
            return pagedDataOptions;
        }

        function updateSortingForQueryRequest(payload){
            if(sortBy)
            {
                payload.si_sortcol = returnFieldMetadata[sortBy.columnId].alias_key;
                payload.si_sortdir = sortBy.direction;
            }
        }

        function updateFilterValuesForQueryRequest(payload){
            for(var fieldId in filters)
            {
                if(filters.hasOwnProperty(fieldId))
                    payload['si_' + fieldId] = formatFilterValue(filterFieldMetadata[fieldId]);
            }
        }

        function setSortBy(options)
        {
            var columnId, direction;
            if(options !== undefined && options !== null)
            {
                columnId = options.columnId;
                direction = options.direction || 'ASC';
            }
            utilityFunctions.checkArgs([columnId], ['columnId'], 'RelatedRecord.sortBy');

            validateColumnId(columnId);
            validateDirection(direction);

            sortBy = {columnId: columnId, direction: direction};
        }

        function validateColumnId(columnId)
        {
            if(!returnFieldMetadata.hasOwnProperty(columnId))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_COLUMN_FOR_SORTING, columnId);
        }

        function validateDirection(dir)
        {
            if(SORTING_DIRECTION.indexOf(dir) === -1)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_DIRECTION_FOR_SORTING, dir);
        }

        function getSortBy()
        {
            return sortBy;
        }

        function getFilterValue(options)
        {
            var fieldId;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.getFilterValue');

            return doGetFilterValue(fieldId);
        }

        function doGetFilterValue(fieldId)
        {
            if(filterFieldMetadata.hasOwnProperty(fieldId))
                return (filters[fieldId] !== undefined) ? filters[fieldId] : "";
            else
                return undefined;
        }

        function setFilterValue(options)
        {
            var fieldId, value;
            if(options !== undefined && options !== null)
            {
                fieldId = options.fieldId;
                value = options.value;
            }
            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'RelatedRecord.setFilterValue');

            doSetFilterValue(fieldId, value);
        }

        function doSetFilterValue(fieldId, value)
        {
            var metadata = filterFieldMetadata[fieldId];
            if(!!metadata.isMultiSelect && !util.isArray(value))
                value = [value];

            filters[fieldId] = validateAndFormatFilterValue(metadata, value);
        }

        function validateAndFormatFilterValue(metadata, value)
        {
            if(!metadata)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FILTER_FIELD_FOR_CURRENT_VIEW, metadata.id);

            var formattedValue = '';
            if(value && value !== 0 && value !== false)
            {
                if(metadata.type === 'select')
                {
                    formattedValue = validateSelectFilter(metadata, value);
                }
                else if(metadata.type === 'date')
                    formattedValue = validateDateFilter(metadata, value);
                else
                    formattedValue = String(value);
            }

            return formattedValue;
        }

        function validateSelectFilter(metadata, value)
        {
            var input = util.isArray(value) ? value : [value];

            input.forEach(function(v){
                var isValid = false;
                for(var index in metadata.options)
                {
                    if(v === metadata.options[index].id)
                    {
                        isValid = true;
                        break;
                    }
                }

                if(!isValid)
                    utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, v, metadata.id);
            });

            return value;
        }

        function validateDateFilter(metadata, toValidate)
        {
            if (!(toValidate instanceof Date || Object.prototype.toString.call(toValidate) === '[object Date]'))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_VALUE, toValidate, metadata.id);

            return toValidate;
        }

        function formatFilterValue(metadata)
        {
            var formattedValue;
            var value = filters[metadata.id];
            if(!value || value === '')
            {
                formattedValue = '';
            }
            else if(metadata.type === 'select' && !!metadata.isMultiSelect)
            {
                value = (util.isArray(value)) ? value : [value];
                formattedValue = value.join(String.fromCharCode(5));
            }
            else
            {
                formattedValue = String(format.format({value: value, type: metadata.type}));
            }

            return formattedValue;
        }

        function parseFilterValue(metadata, value)
        {
            if(metadata.type === 'date')
            {
                value = format.parse({value: value, type: metadata.type});
            }
            return value;
        }

        function toJSON()
        {
            return {
                type: that.type,
                sortBy: that.sortBy,
                filters: filters,
                columns: that.columns,
                settings: that.settings
            }
        }

        function toString()
        {
            return "SearchDefinition"
        }

        /**
         * The type of the related record
         * @name RelatedRecordSearchDefinition#type
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return searchType;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The list of return columns
         * @name RelatedRecordSearchDefinition#columns
         * @type {Array<Column>}
         * @readonly
         */
        Object.defineProperty(this, 'columns', {
            get: function () {
                return columns;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
            },
            enumerable: true,
            configurable: false
        });

	    /**
	     * The list of settings
	     * @name RelatedRecordSearchDefinition#settings
	     * @type {Array<Setting>}
	     * @readonly
	     */
	    Object.defineProperty(this, 'settings', {
		    get: function () {
			    return settings;
		    },
		    set: function () {
			    utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'settings' );
		    },
		    enumerable: true,
		    configurable: false
	    });


	    /**
         * The list of return filter fields
         * @name RelatedRecordSearchDefinition#filters
         * @type {Array<FilterField>}
         * @readonly
         */
        Object.defineProperty(this, 'filters', {
            get: function () {
                return filterFields;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'filters' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The property determines how related record is sorted. The value is an object with two properties:
         * columnId - determines column for sorting
         * direction - sorting order, values are "ASC" or "DESC"
         * @name RelatedRecordSearchDefinition#sortBy
         * @type {Object}
         * @throws {SuiteScriptError} INVALID_COLUMN_FOR_SORTING if columnId is invalid
         * @throws {SuiteScriptError} INVALID_DIRECTION_FOR_SORTING if direction is invalid
         */
        Object.defineProperty(this, 'sortBy', {
            get: getSortBy,
            set: setSortBy,
            enumerable: true,
            configurable: false
        });

        /**
         * Change the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @param {Object} options.value value to be set
         * @throws {SuiteScriptError} INVALID_FILTER_FIELD_FOR_CURRENT_VIEW if options.fieldId is invalid
         * @throws {SuiteScriptError} INVALID_FIELD_VALUE if options.value is invalid
         */
        this.setFilterValue = setFilterValue;
        /**
         * Return the filter value for related record query
         * @param {Object} options the options object
         * @param {string} options.fieldId the id of the filter field
         * @returns {Object} current filter setting for the given filter field
         */
        this.getFilterValue = getFilterValue;
        /**
         * Reset the filter values to the default state for the currently selected custom view
         */
        this.resetFilters = resetFilters;
        /**
         * Pagination API for related record
         * @returns {PagedData}
         * @since 2016.1
         */
        this.runPaged = runPaged;
        /**
         * Pagination API for related record using promise
         * @returns {Promise}
         * @since 2016.1
         */
        this.runPaged.promise = runPagedPromise;
        /**
         * JSON.stringify() implementation
         * @returns {Object}
         */
        this.toJSON = toJSON;
        /**
         * Returns the object type name
         * @returns {string}
         */
        this.toString = toString;
    }
    RelatedRecordSearchDefinition.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordSearchDefinition);


    /**
    * Requestor for Related Record Page
    *
    * @private
    * @param {Object} config
    * @param {String} config.rawUrl the raw url for record handler, which includes some default parameters
    * @param {String} config.recordType the source record type
    * @param {String} config.queryField the page range field id
    * @param {String} config.id the id of the search result machine
    * @param {String} config.view the selected custom view of the search result machine
    * @param {Object} config.dynamicValues the dynamic values of the search result machine
    * @return {RelatedRecordPageRequestor}
    * @constructor
    */
    function RelatedRecordPageRequestor(config){
        var pageRequest = slaving.cleanupQueryURL(config.rawUrl);
        var sourceRecordType = config.recordType;
        var recordUrl = pageRequest.url;
        var payload = util.extend({
            q: config.queryField,
            machine: config.id,
            si_searchid: config.view
        }, pageRequest.payload);
        payload = util.extend(config.dynamicValues, payload);

        function request(index, callback){
            payload.si = String(index);
            return invoker(remoteApi, 'getRelatedRecordPage', [sourceRecordType, recordUrl, payload], callback, true /* parseResult */);
        }

        this.request = request;
    }

    /**
     * Data model for relatedrecord filter field
     *
     * @private
     * @param {Object} field
     * @return {FilterField}
     * @constructor
     */
    function FilterField(field)
    {
        var that = this, options;

        /**
         * The ID of the filter field
         * @name FilterField#id
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The label of the filter field
        * @name FilterField#label
        * @type {string}
        * @readonly
        */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
        * The type of the filter field
        * @name FilterField#type
        * @type {string}
        * @readonly
        */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The hidden property of the filter field
         * @name FilterField#isHidden
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'isHidden', {
            get: function () {
                return field.isHidden;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isHidden' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The multi-select property of the filter field
         * @name FilterField#isMultiSelect
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'isMultiSelect', {
            get: function () {
                return field.isMultiSelect;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMultiSelect' );
            },
            enumerable: true,
            configurable: false
        });

        function getSelectOptions()
        {
            if(!options)
            {
                var options = [];
                if(field.options)
                {
                    field.options.forEach(function (v) {
                        options.push(freezeObjectIfPossible({value: v.id, text: v.text}));
                    });
                }
            }
            return options;
        }


        function toJSON()
        {
            return {
                id: that.id,
                type: that.type,
                label: that.label,
                isHidden: that.isHidden,
                isMultiSelect: that.isMultiSelect
            }
        }
        if(that.type === 'select')
        {
            /**
             * Return available options for select type filter field
             * @returns {Array<Object>}
             */
            this.getSelectOptions = getSelectOptions;
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.FilterField"; }
    }
    FilterField.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(FilterField);



    /**
     * Data model for relatedrecord setting field
     *
     * @private
     * @param {Object} field
     * @return {SettingField}
     * @constructor
     */
    function Setting(field)
    {
    	var that = this;

        /**
         * The Name of the setting field
         * @name Setting#name
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'name', {
    	       get: function () {
    		       return field.name;
    	       },
    	       set: function () {
    		       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
    	       },
    	       enumerable: true,
    	       configurable: false
        });
        /**
         * The Value of the setting field
         * @name Setting#value
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'value', {
    	       get: function () {
    		       return field.value;
    	       },
    	       set: function () {
    		       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value' );
    	       },
    	       enumerable: true,
    	       configurable: false
        });


        function toJSON()
        {
    	       return {
    		       name: that.name,
    		       value: that.value
    	       }
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.Setting"; }
    }
    Setting.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(Setting);


    /**
     * Data model for relatedrecord column
     *
     * @private
     * @param {Object} field
     * @return {Column}
     * @constructor
     */
    function Column(field)
    {
        var that = this;
        /**
         * The index of the column
         * @name Column#index
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'index', {
            get: function () {
                return field.index;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The ID of the column
         * @name Column#columnId
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'columnId', {
            get: function () {
                return field.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columnId' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The label of the column
         * @name Column#label
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'label', {
            get: function () {
                return field.label;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * The value type of the column
         * @name Column#type
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'type', {
            get: function () {
                return field.type;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Record type of the column, if applicable
         * @name Column#recordType
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'recordType', {
            get: function () {
                return field.rec_type ? field.rec_type : null;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates whether the data returned in this column is expected to contain a link URL
         * @name Column#hasLink
         * @type {boolean}
         * @readonly
         * @deprecated [use linkType instead]
         */
        Object.defineProperty(this, 'hasLink', {
            get: function () {
                return field.has_link;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'hasLink' );
            },
            enumerable: true,
            configurable: false
        });
        /**
         * Indicates what kind of link URL is expected in the data returned for this column. Uses values from the LinkType enum:
         * NONE = no link URL
         * REGULAR = link URL that should be opened in the same window
         * POPUP = link URL that should be opened in a new window
         * @name Column#linkType
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'linkType', {
            get: function () {
                return Object.keys(LINK_TYPE)[field.linktype];
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'linkType' );
            },
            enumerable: true,
            configurable: false
        });
        function toJSON()
        {
            return {
                index: that.index,
                columnId: that.columnId,
                label: that.label,
                type: that.type,
                recordType: that.recordType,
                hasLink: that.hasLink,
                linkType: that.linkType
            }
        }
        this.toJSON = toJSON;
        this.toString = function (){ return "RelatedRecord.Column"; }
    }
    Column.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(Column);

    /**
     * Data model for custom view option
     *
     * @private
     * @param {Object} view
     * @return {CustomView}
     * @constructor
     */
    function CustomView(view)
    {
        var that = this;

        /**
         * The ID of the custom view
         * @name CustomView#id
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'id', {
            get: function () {
                return view.id;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * The name of the custom view
         * @name CustomView#text
         * @type {string}
         * @readonly
         */
        Object.defineProperty(this, 'text', {
            get: function () {
                return view.text;
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'text' );
            },
            enumerable: true,
            configurable: false
        });

        function toJSON()
        {
            return {id: that.id, text: that.text};
        }

        function toString()
        {
            return "RelatedRecord.CustomView";
        }

        this.toJSON = toJSON;
        this.toString = toString;
    }
    CustomView.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(CustomView);

    /**
     * PageRange implementation for RelatedRecord
     *
     * @private
     * @param {Object} options JS Object for RelatedRecordPageRange
     * @return {RelatedRecordPageRange}
     * @constructor
     */
    function RelatedRecordPageRange(options)
    {
        function getIndex() { return parseInt(options.id, 10);};
        function getCompoundLabel() { return options.text; };

        Object.defineProperty(this, 'index', {
            get: function () {
                return getIndex();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'index' );
            },
            enumerable: true,
            configurable: false
        });

        Object.defineProperty(this, 'compoundLabel', {
            get: function () {
                return getCompoundLabel();
            },
            set: function () {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'compoundLabel' );
            },
            enumerable: true,
            configurable: false
        });
        this.getIndex = getIndex;
        this.getCompoundLabel = getCompoundLabel;
    }
    RelatedRecordPageRange.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPageRange);

    /**
     * PagedData implementation for RelatedRecord
     *
     * @protected
     * @param {Object} options JS Object for RelatedRecordPagedData
     * @return {RelatedRecordPagedData}
     * @constructor
     */
    function RelatedRecordPagedData(options)
    {
        var that = this,
            pageRequestor = options.pageRequestor,
            readOnlyRelatedRecord = new ReadonlyRelatedRecordSearchDefinition(options.parent),
            returnFieldMetadata = options.returnFieldMetadata,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RelatedRecordPageRange(v);}) || [],
            firstPageData = options.firstPageData; //createRelatedRecordPageInstance({index : 0, page: options.firstPageData});

        function createRelatedRecordPageInstance(configs)
        {
            var options = {
                parent: that,
                isFirst: configs.index === 0,
                isLast: configs.index === pageRanges.length-1,
                pageRange: pageRanges[configs.index]
            };

            if(configs.page && util.isArray(configs.page.data))
            {
                var page = [];
                configs.page.data.forEach(function(row){
                    page.push(new RelatedRecordResult({columns: configs.page.columns, row: row, returnFieldMetadata: returnFieldMetadata}));
                });
                options.data = page;
            }
            return new RelatedRecordPage(options);
        }

        function validateIndex(index)
        {
            if(index < 0 || index >= pageRanges.length)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
            }
        }

        function getPage(index)
        {
            validateIndex(index);
            var pageData = doGetPageRawResult(index, null);
            var page = createRelatedRecordPageInstance({index : index, page: pageData});
            return new paginationObject.Page(page);
        }

        function getPagePromise(index)
        {
            var result;
            if(index < 0 || index >= pageRanges.length)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: fetch.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = new Promise(function(resolve, reject){
                    function callback(result, exception) {
                        if (exception) {
                            reject(exception);
                        }
                        else {
                            var page = createRelatedRecordPageInstance({index : index, page: result});
                            resolve(new paginationObject.Page(page));
                        }
                    }

                    try {
                        doGetPageRawResult(index, callback);
                    }
                    catch(e)
                    {
                        reject(e);
                    }
                });
            }
            return result;
        }

        function doGetPageRawResult(index, callback)
        {
            var pageData;
            if(index === 0)
            {
                pageData = (callback) ? callback(firstPageData) : firstPageData;
            }
            else
            {
                pageData = pageRequestor.request(index, callback);
            }
            return pageData;
        }

        function toJSON(){
            return {
                count: that.count,
                pageRanges: that.pageRanges,
                pageSize: that.pageSize,
                searchDefinition: that.searchDefinition
            }
        }

        function toString()
        {
            return "search.PagedData"
        }

        this.searchDefinition = readOnlyRelatedRecord;
        this.pageRanges = pageRanges;
        this.pageSize = pageSize;
        this.count = totalRows;
        this.fetch = getPage;
        this.fetch.promise = getPagePromise;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordPagedData.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPagedData);

    function RelatedRecordPage(options)
    {
        var that = this,
            parentPagedData = options.parent,
            pageRange = options.pageRange;

        function getNextPage()
        {
            if(that.isLast)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
            }
            return parentPagedData.fetch(pageRange.getIndex()+1);
        }
        function getPrevPage()
        {
            if(that.isFirst)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
            }
            return parentPagedData.fetch(pageRange.getIndex()-1);
        }
        function getNextPagePromise()
        {
            var result;
            if(that.isLast)
            {
                result = Promise.reject(error.create({
                                                         name: error.Type.INVALID_PAGE_RANGE,
                                                         message: 'Invalid page range: next.promise.',
                                                         notifyOff: false
                                                     }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex()+1);
            }
            return result;
        }
        function getPrevPagePromise()
        {
            var result;
            if(that.isFirst)
            {
                result = Promise.reject(error.create({
                                                name: error.Type.INVALID_PAGE_RANGE,
                                                message: 'Invalid page range: prev.promise.',
                                                notifyOff: false
                                            }));
            }
            else
            {
                result = parentPagedData.fetch.promise(pageRange.getIndex() - 1);
            }
            return result;
        }

        this.data = options.data;
        this.pagedData = options.parent;
        this.pageRange = options.pageRange;
        this.isFirst = options.isFirst;
        this.isLast = options.isLast;
        this.next = getNextPage;
        this.prev = getPrevPage;
        this.next.promise = getNextPagePromise;
        this.prev.promise = getPrevPagePromise;
    }
    RelatedRecordPage.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordPage);

    function RelatedRecordResult(options)
    {
        var returnFieldMetadata = options.returnFieldMetadata,
            dataByIndex = [],
            dataByFieldId= {};

        (function(opt){
            var columns = opt.columns;
            var row = opt.row;
            row.forEach(function(v,i){
                dataByIndex[i] = v;
                dataByFieldId[columns[i]] = v;
            })
        })(options);

        function getValue(options)
        {
            var index, columnId;
            if(options instanceof Column)
            {
                index = options.index;
                columnId = options.columnId;
            }
            else if(!!options && utilityFunctions.isObject(options))
            {
                columnId = options.columnId;
            }

            utilityFunctions.checkArgs([columnId],['columnId'], 'Result.getValue');

            return doGetValue(index, columnId);
        }
        function doGetValue(index, id)
        {
            var returnValue = doGetValueById(id);
            return returnValue;
        }

        function doGetValueByIndex(index)
        {
            if(index < 0 || index >= dataByIndex.length)
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_INDEX, index );

            return dataByIndex[index];
        }

        function doGetValueById(id)
        {
            if(!returnFieldMetadata.hasOwnProperty(id))
                utilityFunctions.throwSuiteScriptError(error.Type.INVALID_FIELD_ID, id );

            return dataByFieldId[returnFieldMetadata[id].alias];
        }

        function toJSON()
        {
            var toRet = {};
            for(var id in returnFieldMetadata)
            {
                if(returnFieldMetadata.hasOwnProperty(id))
                    toRet[id] = dataByFieldId[returnFieldMetadata[id].alias];
            }

            return toRet;
        }
        function toString()
        {
            return "RelatedRecord.Result";
        }

        this.getValue = getValue;
        this.toJSON = toJSON;
        this.toString = toString;
    }
    RelatedRecordResult.prototype = nsobject.getNewInstance();
    freezeObjectIfPossible(RelatedRecordResult);

    function doGetRelatedRecord(options, callback)
    {
        var rec = options != null ? options.record : null;
        var sublistId = options != null ? options.sublistId : null;
        utilityFunctions.checkArgs([rec, sublistId], ['record', 'sublistId'], 'relatedRecord.get');

        var request = rec.query;
        if (!request)
            utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD); // not supported on this type of record object
        request.payload['machine'] = sublistId;
        request.payload['r'] = "T";
        return invoker(remoteApi, "getRelatedRecord", [rec.type, request.url, request.payload], callback, false /* parseResult */);
    }

    function getRelatedRecord(options)
    {
        var relatedRecordObj = doGetRelatedRecord(options, null);
        relatedRecordObj.owningRecordType = options.record.type;

        return new RelatedRecord(relatedRecordObj);
    }

    function promiseToGetRelatedRecord(options)
    {
        var myPromise = new Promise(function (resolve, reject)
        {
            function callback(result, exception)
            {
                if (exception)
                {
                    reject(exception);
                    return;
                }
                result.owningRecordType = options.record.type;
                resolve(new RelatedRecord(result));
            }

            try
            {
                doGetRelatedRecord(options, callback);
            }
            catch (e)
            {
                reject(e);
            }
        });
        return myPromise;
    }

    getRelatedRecord.promise = promiseToGetRelatedRecord;

    return {
        /**
         * Obtain the related record object that can be used to fetch search result machine data.
         *
         * @param {Object} options
         * @param {Record} options.record  the record object that the sublist is related to
         * @param {string} options.sublistId  the ID of the sublist
         * @return {RelatedRecord}
         *
         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if one of the arguments is missing
         * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if options.sublistId is incorrect
         *
         * @since 2017.1
         */
        get: getRelatedRecord,

        /**
         * Enum for link types contained within column data.
         * @enum {string}
         */
        LinkType: LINK_TYPE
    };
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/subrecordUtilityFunctions
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/subrecordUtilityFunctions',['N/error', 'N/utilityFunctions', 'N/fieldTypeConstants'],
       function(error, utilityFunctions, fieldTypeConstants){

    var getNextSysId = (function(){
       var nextSysId = Date.now();

       return function getNextSysId(isNew){
           return String((isNew ? -1 : 1) * (nextSysId++));
       };
    }());

    /**
     * validate if the given field is summary field
     * @param {Field} field
     * @param {string} fieldId
     * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD
     */
    function validateIfSummaryField(field, fieldId)
    {
        if (field === null || field.getType() !== fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE)
        {
            utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
        }
    }

    return {
        SYS_OP: 'sys_op',
        SYS_ID: 'sys_id',
        SYS_PARENT_ID: 'sys_parentid',
        getNextSysId: getNextSysId,
        validateIfSummaryField: validateIfSummaryField
    };
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/sublistLine
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/sublistLine',['N/record/recordUtilityFunctions', 'N/record/sublistLineEvent', 'N/eventEmitter'],
	function(recordUtil, sublistLineEvent, eventEmitter)
	{
	    /**
	     * data structure to hold the sublist line data
	     *
	     * @param {Object} options
	     * @param {SublistLine} [options.toBeCloned]
	     * @param {string} options.id sublistId
	     * @param {string} options.lineInstanceId
	     * @param {Object} [options.defaultLineData] default is empty
	     * @param {Object?} options.noCopyToDefaultMap
	     * @param {Function} options.getIsNSERecord
	     * @param {(instanceId: string) => number} options.getIndexByInstanceId
	     * @return {SublistLine}
	     * @constructor
	     */
	    function SublistLine(options)
	    {
	        var that = this;
	        var sublistId, data = {};
	        var emitter = eventEmitter.create();

	        /**
	         * sublist id
	         * @name SublistLine#id
	         * @type {string}
	         */
	        Object.defineProperty(this, 'id', {
	            get: function ()
	            {
	                return sublistId;
	            },
	            enumerable: true,
	            configurable: false
	        });

		    /**
		     * sublist id
		     * @name SublistLine#instanceId
		     * @type {string}
		     */
		    Object.defineProperty(this, 'instanceId', {
			    get: function ()
			    {
				    return getFieldValue("_id");
			    },
			    enumerable: true,
			    configurable: false
		    });


	        /**
	         * line index - to suppoer v1 events
	         * @name SublistLine#index
	         * @type {number}
	         */
	        Object.defineProperty(this, 'index', {
	            get: function ()
	            {
					return options.getIndexByInstanceId(that.instanceId);
	            },
	            enumerable: true,
	            configurable: false
	        });

	        function setValues(anotherLine, noCopyToDefaultMap)
	        {
		        noCopyToDefaultMap = noCopyToDefaultMap || {};
	            recordUtil.forEachProperty(anotherLine.getData(), function(fieldId, value){
	                var oldValue = getFieldValue(fieldId);
	                if(noCopyToDefaultMap.hasOwnProperty(fieldId))
	                {
	                	value = {value: undefined, legacyStringValue: noCopyToDefaultMap[fieldId]};
	                }
	                else if(!recordUtil.matchRecordFieldValueSchema(value))
	                {
	                    value = util.isArray(value) && value.length === 1 ? value[0] : value;
	                    value = {value: undefined, legacyStringValue: value};
	                }
	                data[fieldId] = {value: value.value, legacyStringValue: value.legacyStringValue};
	                var newValue = getFieldValue(fieldId);
	                if(oldValue !== newValue)
	                {
	                    sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	                }
	            });
	        }
	        this.setValues = setValues;

	        function removeFieldValue(fieldId)
	        {
	            if(data.hasOwnProperty(fieldId))
	            {
	                var oldValue = getFieldValue(fieldId);
	                delete data[fieldId];
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue);
	            }
	        }
	        this.removeFieldValue = removeFieldValue;

	        function setPrimitiveValue(fieldId, value)
	        {
	            var oldValue = getFieldValue(fieldId);
	            if(hasFieldValue(fieldId))
	                data[fieldId].value = value;
	            else
	                data[fieldId] = {value: value, legacyStringValue: undefined};
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue, true);
	            }
	        }
	        this.setPrimitiveValue = setPrimitiveValue;

	        function hasFieldValue(fieldId) {
	            return data.hasOwnProperty(fieldId);
	        }
	        this.hasFieldValue = hasFieldValue;

	        function setFieldValue(fieldId, recordFieldValue)
	        {
	            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
	            var oldValue = getFieldValue(fieldId);
	            data[fieldId] = recordFieldValue;
	            var newValue = getFieldValue(fieldId);
	            if(oldValue !== newValue)
	            {
	                sublistLineEvent.updateField(emitter, that, fieldId, oldValue, newValue);
	            }
	        }
	        this.setFieldValue = setFieldValue;

		    /**
		     * @param {String} fieldId
		     * @returns {string|Number|Boolean|Date|Array|null}
		     */
	        function getFieldValue(fieldId)
	        {
		        return recordUtil.getFieldValue(data, fieldId, options.getIsNSERecord());
	        }
	        this.getFieldValue = getFieldValue;

	        function getValueAsLegacyString(fieldId)
	        {
	            var fieldValue = "";
	            if(util.isObject(data[fieldId]))
	            {
	                if(!!data[fieldId].legacyStringValue || data[fieldId].legacyStringValue === "" || data[fieldId].legacyStringValue === 0 || data[fieldId].legacyStringValue === false)
	                    fieldValue = data[fieldId].legacyStringValue;
	            }
	            return fieldValue;
	        }
	        this.getValueAsLegacyString = getValueAsLegacyString;

	        function getData()
	        {
	            var toRet = {};
	            recordUtil.forEachProperty(data, function(fieldId, value){
	                toRet[fieldId] = value;
	            });
	            return toRet;
	        }
	        this.getData = getData;

	        function toJSON()
	        {
	            return util.extend({}, data);
	        }
	        this.toJSON = toJSON;

	        this.on = emitter.on;
	        this.off = emitter.off;


		    if(options.toBeCloned)
		    {
			    var toBeCloned = options.toBeCloned;
			    var noCopyToDefaultMap = options.noCopyToDefaultMap;
			    sublistId = toBeCloned.id;
			    setValues(toBeCloned, noCopyToDefaultMap);
		    }
		    else
		    {
			    sublistId = options.id;
			    if(options.defaultLineData)
			    {
				    recordUtil.forEachProperty(options.defaultLineData, function(fieldId, value){
					    data[fieldId] = {value: value, legacyStringValue: value};
				    })
			    }
		    }
		    if (options.lineInstanceId) {
			    setPrimitiveValue("_id",  options.lineInstanceId);
		    }
	    }



	    return {
	        /**
	         * create record sublist line data storage
	         * @param {object} options
	         * @returns {SublistLine}
	         */
	        create: function (options){
	            return new SublistLine(options);
	        },
	        /**
	         * return true if object is an instance of SublistLine
	         * @param {Object} obj
	         * @returns {boolean}
	         */
	        isInstance: function(obj) { return obj instanceof SublistLine; }
	    }
	});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/selectFieldOptionTextCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/selectFieldOptionTextCache',[], function(){

	function createKey(sublistId, fieldId, value){
		return [sublistId, fieldId, value].join(String.fromCharCode(1));
	}

	function SelectFieldOptionTextCache()
	{
		var cache = {};

		function set(sublistId, fieldId, value, text){
				cache[createKey(sublistId, fieldId, value)] = text;
		}
		this.set = set;

		function get(sublistId, fieldId, value){
				return cache[createKey(sublistId, fieldId, value)];
		}
		this.get = get;

		function has(sublistId, fieldId, value){
				return cache.hasOwnProperty(createKey(sublistId, fieldId, value));
		}
		this.has = has;

		return this;
	}

	return {
		create: function(){
			return new SelectFieldOptionTextCache();
		}
	};
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/util/uuid
 * @NApiVersion 2.x
 *
 */
define('N/util/uuid',[], function () {
	function getRandomHexString(length)
	{
		var result = '';

		while(result.length < length)
		{
			result += getHexString(getRandomValue());
		}

		return result;
	}

	function getRandomValue()
	{
		return Math.floor(Math.random() * 16);
	}

	function getHexString(value)
	{
		return value.toString(16);
	}


	function generateV4()
	{
		return getRandomHexString(8) + '-' +
			getRandomHexString(4) + '-' +
			'4' + getRandomHexString(3) + '-' +
			getHexString(getRandomValue(1) & 11 | 8) + getRandomHexString(3) + '-' +
			getRandomHexString(12);
	}

	/**
	 * @alias N/util/uuid
	 */
	return Object.freeze({
		generateV4: generateV4
	});
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/model
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/model',['N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions', 'N/record/sublistLine', 'N/record/selectFieldOptionTextCache',
        'N/record/modelEvent', 'N/eventEmitter',
        'N/util/uuid', 'N/utilityFunctions', 'N/resultObject'],
    function(recordUtil, subrecordUtil, sublistLine, selectOptionTextCache,
             modelEvent, eventEmitter,
             uuid, utilityFunctions, resultObject){

    function SublistsController(sublistLineSequence)
    {
        var that = this;
        var sublists = {};

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }
        this.sublistExists = sublistExists;

        function getSublist(sublistId)
        {
            if (!sublistExists(sublistId))
            {
                sublists[sublistId] = {};
            }

            return sublists[sublistId];
        }

        function getSublists(){
            return Object.keys(sublists);
        }
        this.getSublists = getSublists;

        function hasSublistLine(sublistId, lineInstanceId)
        {
            var hasLine = false;
            var hasSublist = sublistExists(sublistId);

            if(hasSublist)
            {
                var sublist = getSublist(sublistId);
                hasLine = sublist.hasOwnProperty(lineInstanceId);
            }

            return hasLine;
        }
        this.hasSublistLine = hasSublistLine;

        function getSublistLine(sublistId, lineInstanceId)
        {
            var sublistLine = null;
            var hasLine = hasSublistLine(sublistId, lineInstanceId);

            if(hasLine)
            {
                var sublist = getSublist(sublistId);
                sublistLine = sublist[lineInstanceId];
            }

            return sublistLine;
        }
        this.getSublistLine = getSublistLine;

        function putSublistLine(sublistLine)
        {
            var sublistId = sublistLine.id;
            var lineInstanceId = sublistLine.instanceId;
            var previousSublistLine = getSublistLine(sublistId, lineInstanceId);

            getSublist(sublistId)[lineInstanceId] = sublistLine;

            return previousSublistLine;
        }
        this.putSublistLine = putSublistLine;

        function removeSublistLine(sublistId, lineInstanceId)
        {
            var removedSublistLine = getSublistLine(sublistId, lineInstanceId);
            delete getSublist(sublistId)[lineInstanceId];

            return removedSublistLine;
        }
        this.removeSublistLine = removeSublistLine;

        function getSublistLinesAsOrderedList(sublistId)
        {
	        return sublistLineSequence.get(sublistId).reduce(function(res, lineInstanceId) {
		        var line = getSublistLine(sublistId, lineInstanceId);
		        if (line) {
			        res.push(line);
		        }
		        return res;
	        }, []);
        }
        this.getSublistLinesAsOrderedList = getSublistLinesAsOrderedList;

	    function getSublistLineInstanceIdsAsOrderedList(sublistId)
	    {
		    return sublistLineSequence.get(sublistId).filter(function(lineInstanceId) {
			    return hasSublistLine(sublistId, lineInstanceId);
		    });
	    }
	    this.getSublistLineInstanceIdsAsOrderedList = getSublistLineInstanceIdsAsOrderedList;
    }

	    function SublistsSequenceToInstanceId()
	    {
		    /** @type {{string:string[]}} */
		    var sublists = {};

		    /**
		     * @param {string} sublistId
		     * @param {string} lineId
		     * @return {number}
		     */
		    function getIndex(sublistId, lineId) {
			    return (sublists[sublistId] || []).indexOf(lineId);
		    }
		    this.getIndex = getIndex;

		    /**
		     * @param {string} sublistId
		     * @param {string} lineId
		     * @param {string} [beforeLineId]
		     */
		    function insert(sublistId, lineId, beforeLineId)
		    {
			    if (!lineId) {
				    throw "Unexpected empty line instanceId";
			    }
			    if (getIndex(sublistId, lineId) === -1) {
				    var sequence = sublists[sublistId] || [];
				    var insertIndex = beforeLineId ? sequence.indexOf(beforeLineId) : -1;
				    if (insertIndex === -1) {
					    insertIndex = sequence.length;
				    }
				    sequence.splice(insertIndex, 0, lineId);
				    sublists[sublistId] = sequence;
			    }
		    }

		    /**
		     * @param {string} sublistId
		     * @param {string} lineId
		     */
		    function remove(sublistId, lineId)
		    {
			    if (!lineId) {
				    throw "Unexpected empty line instanceId";
			    }
			    var sequence = sublists[sublistId] || [];
			    var lineIndex = sequence.indexOf(lineId);
			    if (lineIndex > -1) {
				    sequence.splice(lineIndex, 1);
			    }
			    sublists[sublistId] = sequence;
		    }
		    this.remove = remove;

		    /**
		     * @param {string} sublistId
		     * @param {string} lineId
		     * @param {string} [beforeLineId]
		     */
		    function update(sublistId, lineId, beforeLineId)
		    {
			    if (!lineId) {
				    throw "Unexpected empty line instanceId";
			    }
			    var lineIndex = getIndex(sublistId, lineId);
			    if (lineIndex === -1) {
				    insert(sublistId, lineId, beforeLineId);
			    }
			    else {
				    if (beforeLineId && ((lineIndex + 1) !== getIndex(sublistId, beforeLineId))) {
					    remove(sublistId, lineId);
					    insert(sublistId, lineId, beforeLineId);
				    }
			    }
		    }
		    this.update = update;

		    /**
		     * @param {string} sublistId
		     * @param {string} fromLineId
		     * @param {string} toLineId
		     */
		    function move(sublistId, fromLineId, toLineId)
		    {
			    var lineIndex = getIndex(sublistId, fromLineId);
			    if (lineIndex === -1) {
				    throw "Unexpected index for line instanceId";
			    }
			    var toIndex = getIndex(sublistId, toLineId);
			    if (toIndex === -1) {
				    throw "Unexpected index for target line instanceId";
			    }
			    var beforeLineId = (toIndex >= lineIndex) ? sublists[sublistId][toIndex + 1] : toLineId;
			    remove(sublistId, fromLineId);
			    insert(sublistId, fromLineId, beforeLineId);
		    }
		    this.move = move;
		    /**
		     * @param {string} sublistId
		     * @return {string[]} sequence
		     */
		    function get(sublistId)
		    {
			    return (sublists[sublistId] || []).slice();
		    }
		    this.get = get;

		    /**
		     * @param {string} sublistId
		     * @return {number}
		     */
		    function size(sublistId) {
			    return (sublists[sublistId] || []).length;
		    }
		    this.size = size;
	    }

    function SelectedLineController()
    {
        var that = this;
        var sublists = {};

        function sublistExists(sublistId)
        {
            return sublists.hasOwnProperty(sublistId);
        }

        function has(sublistId)
        {
            var result = false;

            if(sublists.hasOwnProperty(sublistId))
            {
                var thisIdList = sublists[sublistId];
                result = !!thisIdList && (thisIdList.length > 0);
            }
            
            return result;
        }

        function getLastAndPop(sublistId, shouldPop)
        {
            var result = null;
            if(has(sublistId))
            {
                var thisIdList = sublists[sublistId];
                if (!shouldPop)
                    thisIdList = thisIdList.slice(-1);

                result = thisIdList.pop();
            }

            return result;
        }

        function get(sublistId)
        {
            return getLastAndPop(sublistId, false);
        }
        this.get = get;

        function put(sublistId, lineInstanceId)
        {
            var previousCurrentSublistLineInstanceId = get(sublistId);
            if (!has(sublistId))
                sublists[sublistId] = [lineInstanceId];
            else
                sublists[sublistId].push(lineInstanceId);
            return previousCurrentSublistLineInstanceId;
        }

        function clear(sublistId)
        {
	        sublists[sublistId] = [];
        }
        this.clear = clear;

        function update(sublistId, lineInstanceId)
        {
	        clear(sublistId);
            put(sublistId, lineInstanceId);
        }
        this.update = update;

        function set(sublistId, instanceId)
        {
        	if (!has(sublistId))
	        {
	        	// if it's empty add some filler so reset would not keep the silently set line as selected
        		put(sublistId, null);
	        }
        	put(sublistId, instanceId);
        }
        this.set = set;

	    function reset(sublistId, instanceId)
	    {
		    if(get(sublistId) === instanceId)
		    {
			    var last = getLastAndPop(sublistId, true);
			    if (!has(sublistId))
			    {
			    	// if it's empty just return the value there since someone had to call update in the mean time
				    put(sublistId, last);
			    }
		    }
	    }
	    this.reset = reset;
    }

    /**
     * @typedef {Object} RecordDataObject
     * @property {FieldDataSet} bodyField - fieldId/values
     * @property {{link:Object<string, *>}} [subrecord]
     * @property {SublistDataObject} sublist - fieldId/values for each line of all sublists
     * @property {{isMandatory:boolean, isDefaultMandatory:boolean, isDisabled:boolean, isReadOnly:boolean}[]}
     *     [sublistFieldState]
     *
     * @see RecordDataTransfomer.java
     */

    /**
     * @typedef {Array<string>|Array<{id:string, text:string}>} FieldDataObject
     */
    /**
     * @typedef {Object<string, FieldDataObject>} FieldDataSet
     */
    /**
     * @typedef {FieldDataSet[]} LineDataCollection
     */
    /**
     * @typedef {Object<string,LineDataCollection>} SublistDataObject
     */


    /**
     * object holds the record data
     *
     * @param {Object} options
     * @param {Metadata} options.metadata record metadata
     * @param {RecordCacheController} options.subrecordCache
     * @param {RecordDataObject} options.data serialized data
     * @return {Model}
     * @constructor
     */
    function Model(options)
    {
        var that = this;
        var recordType = options.metadata.type;
        var recordDataObj = options.data;
        var recordInitialization = recordDataObj.initialization;
	    var isNew = !recordInitialization || recordInitialization.method !== 'loadRecord';
        var emitter = eventEmitter.create();
        var bodyFields = {};
        var subrecordData = {cache: options.subrecordCache};
	    var sublistsLinesSequencesToInstanceIds = new SublistsSequenceToInstanceId();
	    var sublists = new SublistsController(sublistsLinesSequencesToInstanceIds);
	    var sublistsBuffers = new SublistsController(sublistsLinesSequencesToInstanceIds);
	    var sublistsSelectedLineInstanceIds = new SelectedLineController();
        var optionTextCache = selectOptionTextCache.create();
	    var getIsNSERecord = options.getIsNSERecord;

        (function constructor(recordDataObj, getIsNSERecord)
        {
            function bindCachingFunction(sublistId, fieldId){
                return function(value, text) {
                    optionTextCache.set(sublistId, fieldId, value, text);
                };
            }

            (function initSubrecord(data)
            {
                subrecordData.link = data.link || {};

            })(recordDataObj.subrecord || {});

            (function initBodyFields(fields)
            {

                recordUtil.forEachProperty(fields, function(fieldId, value)
                {
                    var cacher = bindCachingFunction(undefined, fieldId);
                    if(!recordUtil.matchRecordFieldValueSchema(value))
                    {
                        value = recordUtil.transformRawValueToFieldValueSchema(value, cacher, options.metadata.getFieldMetadata(null, fieldId));
                    }

                    bodyFields[fieldId] = value;
                });

                if (bodyFields[subrecordUtil.SYS_ID] === undefined)
                {
                    var valueForSystemId = subrecordUtil.getNextSysId(isNew);
                    bodyFields[subrecordUtil.SYS_ID] = {value: valueForSystemId, legacyStringValue: valueForSystemId};

                    bodyFields[subrecordUtil.SYS_PARENT_ID] = {value: "0", legacyStringValue: "0"};
                }
            })(recordDataObj.bodyField || {});


            (function initSublists(sublistData)
            {
                for (var sublistId in sublistData)
                {
                    if (sublistData.hasOwnProperty(sublistId))
                    {
                        var lines = sublistData[sublistId];
                        lines.forEach(function (line)
                                      {
                                          var uniqueId = (line._id && line._id.value) || uuid.generateV4();

                                          var sublistline = createSublistLine({
                                              id: sublistId,
                                              lineInstanceId: uniqueId
                                          });

										  if (line[subrecordUtil.SYS_ID] === undefined)
										  {
											  // note: this modifies recordDataObj
											  line[subrecordUtil.SYS_ID] = subrecordUtil.getNextSysId(isNew);
											  line[subrecordUtil.SYS_PARENT_ID] = "0";
										  }

                                          recordUtil.forEachProperty(line, function(fieldId, value){
                                              var cacher = bindCachingFunction(sublistId, fieldId);
                                              if(!recordUtil.matchRecordFieldValueSchema(value))
                                              {
                                                  value = recordUtil.transformRawValueToFieldValueSchema(value, cacher, options.metadata.getFieldMetadata(sublistId, fieldId));
                                              }

                                              sublistline.setFieldValue(fieldId, value);
                                          });
                                      });
                    }
                }
            })(recordDataObj.sublist || {});

        })(recordDataObj, getIsNSERecord);

        this.on = emitter.on;
        this.off = emitter.off;

	    /**
	     *
	     * @param {object} options
	     * @param {string} options.id
	     * @param {string?} options.lineInstanceId
	     * @param {SublistLine?} options.toBeCloned  lineToCopy
	     * @param {object?} options.defaultLineData
	     * @param {object?} options.noCopyToDefaultMap
	     * @param {Origin?} options.origin
	     * @param {boolean?} options.asBuffer
	     * @param {boolean?} options.suppressEmit
	     * @param {string?} options.beforeLineInstanceId
	     * @returns {SublistLine}
	     */
        function createSublistLine(options)
        {
            var newSublistLine = sublistLine.create({
                    id: options.id,
                    toBeCloned: options.toBeCloned,
                    defaultLineData: options.defaultLineData,
                    noCopyToDefaultMap: options.noCopyToDefaultMap,
	                lineInstanceId: options.lineInstanceId || uuid.generateV4(),
	                getIsNSERecord: getIsNSERecord,
	                getIndexByInstanceId: function (instanceId) {
						return getSublistLineIndexForInstance(options.id, instanceId);
	                }
                });


            var asBuffer = !!options.asBuffer;
	        (asBuffer ? sublistsBuffers : sublists).putSublistLine(newSublistLine);
	        sublistsLinesSequencesToInstanceIds.update(newSublistLine.id, newSublistLine.instanceId, options.beforeLineInstanceId);

            modelEvent.forwardSublistLineEvents(emitter, newSublistLine, asBuffer);
            modelEvent.createLine(emitter, newSublistLine, asBuffer, options.origin, options.suppressEmit);

            return newSublistLine;
        }

	    /**
	     * returns Line for given lineInstanceId, when isCommitted is false, it creates the buffered line from committed
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @param {boolean?} suppressEmit
	     * @returns {SublistLine|null}
	     */
        function getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit)
        {
            function getSublistCommittedLineForInstance(sublistId, lineInstanceId)
            {
	            return sublists.getSublistLine(sublistId, lineInstanceId);
            }

            function getSublistBufferedLineForInstance(sublistId, lineInstanceId)
            {
                var sublistLineBuffer = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);

                if (!sublistLineBuffer)
                {
                    var sublistLine = getSublistCommittedLineForInstance(sublistId, lineInstanceId);
                    if(!!sublistLine)
                    {
                        sublistLineBuffer = createBufferFromLine({line: sublistLine, suppressEmit: !!suppressEmit});
                    }
                }

                return sublistLineBuffer;
            }

            return (isCommitted ? getSublistCommittedLineForInstance : getSublistBufferedLineForInstance)(sublistId, lineInstanceId);
        }
	    this.getSublistLineForInstance = getSublistLineForInstance;

        function getSublistSelectedLine(sublistId)
        {
            var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
            return sublistLineBuffer;
        }

	    /**
	     * remove line from buffer
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean?} suppressEmit
	     * @param {Origin?} origin
	     * @returns {SublistLine} removed line
	     */
	    function removeLineBufferForInstance(sublistId, lineInstanceId, suppressEmit, origin)
        {
        	var removedLine = null;
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                var bufferIsSelected = lineInstanceId === sublistsSelectedLineInstanceIds.get(sublistId);
                if (bufferIsSelected) {
                    //TODO this can not be removed during a commit
                    // a dead zone exists where data has been moved but the knowledge of the selected line exists
                    // some scripts are taking advantage of this
                    // nlapiGetLineItemField with no line param is being called during recalc
                    // Update: if this needs to be done, then only when there's no committed line for the lineInstanceId
                    // The runFunctionWhileSilentlySelectingLine takes care of an opposite deadzone problem where the
                    // selected instance id was just deleted in the removeLine API call
                    // by running the recalc while selecting next line with the same index as the currently removed line
                    //sublistsSelectedLineInstanceIds.clear(sublistId);
                }

				var index = getSublistLineIndexForInstance(sublistId, lineInstanceId);
	            removedLine = sublistsBuffers.removeSublistLine(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(removedLine);
	            if (!sublists.hasSublistLine(sublistId, lineInstanceId))
		            sublistsLinesSequencesToInstanceIds.remove(sublistId, lineInstanceId);
                modelEvent.deleteLine(emitter, removedLine, true, origin, !!suppressEmit, index);
            }
            return removedLine;
        }

	    /**
	     * run a function while selecting a line 
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {Function} func funciton to be called while line is selected
	     * @param {object} thisArg this arg to the .apply function
	     * @param {Array} argList of funcs arguments
	     * @returns {?} result of the func.apply(thisArg, argList) call
	     */
        var runFunctionWhileSilentlySelectingLine = utilityFunctions.thenableFunction(function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
        	return resultObject.create(function ()
	        {
	            sublistsSelectedLineInstanceIds.set(sublistId, lineInstanceId);
	            return func.apply(thisArg, argList);
	        })['finally'](function ()
	        {
	            sublistsSelectedLineInstanceIds.reset(sublistId, lineInstanceId);
	        });
        });

        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

	    /**
	     * do select sublist line
	     * @param {string} sublistId
	     * @param {SublistLine} sublistline
	     * @param {boolean} isMultilineEditable
	     * @returns {string|null} resultLineInstanceId selected line's instanceId
	     */
        function doSelect(sublistId, sublistline, isMultilineEditable)
        {
            var previousSelectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
            if(previousSelectedLineInstanceId !== null && !sublists.hasSublistLine(sublistId, previousSelectedLineInstanceId) && !isMultilineEditable)
            {
                removeLineBufferForInstance(sublistId, previousSelectedLineInstanceId);
            }

            sublistsSelectedLineInstanceIds.update(sublistId, sublistline.instanceId);
            modelEvent.selectLine(emitter, sublistline, true);
        }

        function doAdd(sublistId, sublistline, isCommitted, origin)
        {
	        modelEvent.insertLine(emitter, sublistline, !isCommitted, origin);
        }

        function doInsert(sublistId, sublistline, isCommitted)
        {
	        doAdd(sublistId, sublistline, isCommitted, modelEvent.Origin.INSERT);
        }

        function doUpdate(sublistId, sublistline)
        {
            modelEvent.updateLine(emitter, sublistline, false);
        }

	    function createBufferFromLine(options) {
		    var sublistlineBuffer = cloneSublistLine(util.extend(options, { asBuffer: true }));
		    return sublistlineBuffer;
	    }

        function cloneSublistLine(options) {
            var sublistLineOptions = {
                asBuffer: !!options.asBuffer,
		        suppressEmit: !!options.suppressEmit,
	            id: options.line.id,
	            lineInstanceId: options.line.instanceId,
	            toBeCloned: options.line,
            };

            return createSublistLine(sublistLineOptions);
        }

	    /**
	     * update new line buffer with line copy
	     * @param {object} sublistLineOptions
	     * @param {boolean}sublistLineOptions.asBuffer
	     * @param {string} sublistLineOptions.id
	     * @param {string} sublistLineOptions.lineInstanceId
	     * @param {SublistLine} sublistLineOptions.toBeCloned  lineToCopy
	     * @param {object} sublistLineOptions.noCopyToDefaultMap
	     * @returns {string} lineInstanceId of fresh copy
	     */
        function updateNewLineBufferWithCopy(sublistLineOptions)
        {
        	var fromBuffer = true;
	        removeLineBufferForInstance(sublistLineOptions.id, sublistLineOptions.lineInstanceId);

	        var newNewLineBuffer = doCopyLine(sublistLineOptions);
	        modelEvent.updateLine(emitter, newNewLineBuffer, fromBuffer);
	        modelEvent.selectLine(emitter, newNewLineBuffer, fromBuffer);
	        return newNewLineBuffer.instanceId;
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

	    /**
	     * do copy line
	     * @param {object} sublistLineOptions
	     * @param {boolean}sublistLineOptions.asBuffer
	     * @param {string} sublistLineOptions.id
	     * @param {string?} sublistLineOptions.lineInstanceId
	     * @param {SublistLine} sublistLineOptions.toBeCloned  lineToCopy
	     * @param {object} sublistLineOptions.noCopyToDefaultMap
	     * @returns {SublistLine} copied line
	     */
        function doCopyLine(sublistLineOptions)
        {
	        sublistLineOptions = util.extend(sublistLineOptions, {origin: modelEvent.Origin.COPY});
	        var newNewLineBuffer = createSublistLine(sublistLineOptions);
	        return newNewLineBuffer;
        }

	    /**
	     * put line copy into line buffer
	     * @param {string} sublistId
	     * @param {SublistLine} line
	     * @param {boolean} isMultilineEditable
	     * @param {object} noCopyToDefaultMap
	     * @returns {string} instanceId of the copied line
	     */
		function putCopyIntoNewLineBuffer(sublistId, line, isMultilineEditable, noCopyToDefaultMap)
		{
			var newLineIndex = getSublistLineCount(sublistId, isMultilineEditable);
			var previousNewLineInstanceId = getSpecifiedLineInstanceIdByIndex(sublistId, newLineIndex);
			var wasPreviousNewLineSelected = sublistsSelectedLineInstanceIds.get(sublistId) === previousNewLineInstanceId;
			var sublistLineOptions = {
				asBuffer: true,
				id: sublistId,
				toBeCloned: line,
				noCopyToDefaultMap: noCopyToDefaultMap
			};

			if(!isMultilineEditable)
			{
				removeLineBufferForInstance(sublistId, previousNewLineInstanceId);
			}

			var newNewLineBuffer = doCopyLine(sublistLineOptions);
			var newNewLineInstanceId = newNewLineBuffer.instanceId;

			if (!isMultilineEditable)
			{
				modelEvent.selectLine(emitter, newNewLineBuffer, true); // select the newly created line only in SLB mode.

				if(wasPreviousNewLineSelected)
				{
					sublistsSelectedLineInstanceIds.update(sublistId, newNewLineInstanceId);
				}
			}

			return newNewLineInstanceId;
		}
		this.putCopyIntoNewLineBuffer = putCopyIntoNewLineBuffer;

        //TODO: Support Public
        function getSublists()
        {
            return sublists.getSublists();
        }
        this.getSublists = getSublists;

	    /**
	     *
	     * @param {string} sublistId
	     * @param {boolean} isMultilineEditable
	     * @returns {Number}
	     */
	    function getSublistLineCount(sublistId, isMultilineEditable)
	    {
		    return isMultilineEditable
			    ? sublistsLinesSequencesToInstanceIds.size(sublistId)
			    : sublists.getSublistLinesAsOrderedList(sublistId).length; // old way
	    }
	    this.getSublistLineCount = getSublistLineCount;

	    /**
	     * get the index for the next new line
	     * @param {string} sublistId
	     * @return {Number} next new line index
	     */
	    function getNextNewLineIndex(sublistId)
	    {
	    	return getSublistLineCount(sublistId, true);
	    }
	    this.getNextNewLineIndex = getNextNewLineIndex;

	    /**
	     * returns an instanceId of the currently selected line or null
	     * @param {string} sublistId
	     * @returns {string|null} lineInstanceId of a currently selected line
	     */
        function getSublistSelectedLineInstanceId(sublistId)
        {
            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

	    /**
	     * returns true when the line with lineInstanceId is selected
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {boolean}
	     */
        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            var selectedLineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);

            return lineInstanceId === selectedLineInstanceId;
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

	    /**
	     * returns true when line with exists for given lineInstanceId in either buffered or committed lines based on the
	     * isCommitted
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted)
        {
            var sublistsController = isCommitted ? sublists : sublistsBuffers;
	        return sublistsController.hasSublistLine(sublistId, lineInstanceId);
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

	    /**
	     * get committed line's instanceId for given index (sequence)
	     * @param {string} sublistId
	     * @param {number} lineIndex
	     * @returns {string|null} instanceId of a line with given index
	     */
	    function getCommittedSublistLineInstanceIdForIndex(sublistId, lineIndex)
	    {
		    return sublists.getSublistLineInstanceIdsAsOrderedList(sublistId)[lineIndex];
	    }
	    this.getCommittedSublistLineInstanceIdForIndex = getCommittedSublistLineInstanceIdForIndex;

	    /**
	     * get index for line by lineInstanceId - looks for the index in both buffered and committed lines
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {number} index (sequence) of the line with given lineInstanceId
	     */
	    function getSublistLineIndexForInstance(sublistId, lineInstanceId)
	    {
		    return sublistsLinesSequencesToInstanceIds.getIndex(sublistId, lineInstanceId);
	    }
	    this.getSublistLineIndexForInstance = getSublistLineIndexForInstance;

	    /**
	     * returns an instanceId with given index from both buffered and committed and lines
	     * @param {string} sublistId
	     * @param {number} index
	     * @returns {string} lineInstanceId with given index
	     */
        function getSpecifiedLineInstanceIdByIndex(sublistId, index)
        {
	        return sublistsLinesSequencesToInstanceIds.get(sublistId)[index] || null;
        }
        this.getSpecifiedLineInstanceIdByIndex = getSpecifiedLineInstanceIdByIndex;

	    /**
	     * check if the given line instance is a NEW line (has no committed line)
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {boolean}
	     */
	    function lineInstanceIsNewLine(sublistId, lineInstanceId)
	    {
		    var uncommitted = sublistsBuffers.hasSublistLine(sublistId, lineInstanceId);
		    var committed = sublists.hasSublistLine(sublistId, lineInstanceId);
		    return (uncommitted && !committed);
	    }
	    this.lineInstanceIsNewLine = lineInstanceIsNewLine;

	    /**
	     * update current line to a new line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     */
	    function updateCurrentLineToANewLine_MLB(sublistId, lineInstanceId)
	    {
	        var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, false);
		    sublistsSelectedLineInstanceIds.update(sublistId, lineInstanceId);

		    modelEvent.selectLine(emitter, sublistLine, true);
	    }
	    this.updateCurrentLineToANewLine_MLB = updateCurrentLineToANewLine_MLB;

	    /**
	     * returns all instance ids for a given sublistId & its bufferState, ordered by sequence
	     * @param {string} sublistId
	     * @param {boolean} isCommitted
	     * @returns {Array<string>} list of lineInstanceIds in order of sequence
	     */
	    function getSublistLineInstanceIds(sublistId, isCommitted)
	    {
		    var sublistList;

		    if (isCommitted)
		    {
			    sublistList = sublists.getSublistLineInstanceIdsAsOrderedList(sublistId);
		    }
		    else // return both committed and uncommitted instance ids.
		    {
			    sublistList = sublistsLinesSequencesToInstanceIds.get(sublistId);
		    }
		    return sublistList;
	    }
	    this.getSublistLineInstanceIds = getSublistLineInstanceIds;
// ==================================================================

	    /**
	     * return list of all body fields with value
	     * @returns {Array<string>}
	     */
        function getBodyFieldIds()
        {
            var fieldIds = [];
            for (var fieldId in bodyFields)
                fieldIds.push(fieldId);

            return fieldIds;
        }
        this.getBodyFieldIds = getBodyFieldIds;

	    /**
	     * get a list of fields in the currently selected sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @return {Array<string>}
	     */
        function getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted)
        {
            var fieldIds = [];
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);

            if (!!sublistLine)
            {
                fieldIds = Object.keys(sublistLine.getData());
            }
            return fieldIds;
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

	    /**
	     * return the primitive value for body field
	     * @param {string} fieldId
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function getBodyValue(fieldId)
        {
			return recordUtil.getFieldValue(bodyFields, fieldId, getIsNSERecord());
        }
        this.getBodyValue = getBodyValue;

	    /**
	     * returns value of a sublist field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function getSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var value = null;
	        if (doesSublistExist(sublistId))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
                if (!!sublistline)
                {
                    value = sublistline.getFieldValue(fieldId);
                }
            }

            return value;
        }
        this.getSublistLineValue = getSublistLineValue;

	    /**
	     * return the value for body field as legacy string format
	     * @param {string} fieldId
	     * @returns {string}
	     */
        function getBodyValueAsLegacyString(fieldId)
        {
            var fieldValue = "";
            if(util.isObject(bodyFields[fieldId]))
            {
                if(!!bodyFields[fieldId].legacyStringValue || bodyFields[fieldId].legacyStringValue === "" || bodyFields[fieldId].legacyStringValue === 0 || bodyFields[fieldId].legacyStringValue === false)
                    fieldValue = bodyFields[fieldId].legacyStringValue;
            }
            return fieldValue;
        }
        this.getBodyValueAsLegacyString = getBodyValueAsLegacyString;

	    /**
	     * return the value for sublist field as legacy string format
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {string} fieldId
	     * @param {boolean} isCommitted
	     * @returns {string|null}
	     */
        function getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var value = null;

            if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

	        if (doesSublistExist(sublistId))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
                if(!!sublistline)
                {
                    value = sublistline.getValueAsLegacyString(fieldId);
                }
            }
            return value;
        }
        this.getSublistLineValueAsLegacyString = getSublistLineValueAsLegacyString;

	    /**
	     * set field value
	     * @param {string} fieldId
	     * @param {Object|null} recordFieldValue
	     * @param {string|Number|Boolean|Date|Array|null} recordFieldValue.value
	     * @param {string} recordFieldValue.legacyStringValue
	     */
        function setBodyValue(fieldId, recordFieldValue)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var oldValue = getBodyValue(fieldId);
            bodyFields[fieldId] = recordFieldValue;
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue);
            }
        }
        this.setBodyValue = setBodyValue;

	    /**
	     * set sublist value for instance
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {Object|null} recordFieldValue
	     * @param {string|Number|Boolean|Date|Array|null} recordFieldValue.value
	     * @param {string} recordFieldValue.legacyStringValue
	     * @param {boolean} isCommitted
	     */
        function setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, isCommitted)
        {
            recordUtil.validateRecordFieldValueSchema(recordFieldValue);
            var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
            if(!!sublistline)
            {
                sublistline.setFieldValue(fieldId, recordFieldValue);
            }
        }
        this.setSublistLineValue = setSublistLineValue;

	    /**
	     * set value by js primitive form for body field
	     * @param {string} fieldId
	     * @param {string|Number|Boolean|Date|Array|null} value
	     */
        function setBodyValuePrimitive(fieldId, value)
        {
            var oldValue = getBodyValue(fieldId);
            if (hasBodyValue(fieldId))
                bodyFields[fieldId].value = value;
            else
                bodyFields[fieldId] = {value: value, legacyStringValue: undefined};
            var newValue = getBodyValue(fieldId);
            if(oldValue !== newValue)
            {
                modelEvent.updateField(emitter, fieldId, oldValue, newValue, true);
            }
        }
        this.setBodyValuePrimitive = setBodyValuePrimitive;

	    /**
	     * set value by js primitive form for body field
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {string} fieldId
	     * @param {string|Number|Boolean|Date|Array|null} value
	     * @param {boolean} isCommitted
	     */
        function setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, isCommitted)
        {
            var sublistLine = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted);
            sublistLine.setPrimitiveValue(fieldId, value);
        }
        this.setSublistLineValuePrimitive = setSublistLineValuePrimitive;

	    /**
	     * return true if field exists
	     * @param {*} fieldId
	     * @returns {boolean}
	     */
        function hasBodyValue(fieldId)
        {
            return bodyFields.hasOwnProperty(fieldId);
        }
        this.hasBodyValue = hasBodyValue;

	    /**
	     * returns true if sublist field has value
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function hasSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted)
        {
            var result = false;
            var lineExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, !!isCommitted);
            if (!lineExists && !isCommitted) {
	            lineExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, true);
            }
            if (lineExists)
            {
                result = getSublistLineForInstance(sublistId, lineInstanceId, !!isCommitted, true).hasFieldValue(fieldId);
            }
            return result;
        }
        this.hasSublistLineValue = hasSublistLineValue;

	    /**
	     * check if the sublist exists
	     * @param {string} sublistId
	     * @returns {boolean}
	     */
	    function doesSublistExist(sublistId)
	    {
		    return sublists.sublistExists(sublistId) || sublistsBuffers.sublistExists(sublistId);
	    }

	    /**
	     * remove field
	     * @param {string} fieldId
	     */
        function removeBodyValue(fieldId)
        {
            if (bodyFields.hasOwnProperty(fieldId)) {
                var oldValue = getBodyValue(fieldId);
                delete bodyFields[fieldId];
                modelEvent.updateField(emitter, fieldId, oldValue);
            }
        }
        this.removeBodyValue = removeBodyValue;

	    /**
	     * insert sublist line
	     * @param {string} sublistId
	     * @param {string} beforeLineInstanceId
	     * @param {boolean} isCommitted
	     */
        function insertSublistLine(sublistId, beforeLineInstanceId, isCommitted)
        {
            var isBeforeLineCommitted = null;
            var beforeSublistline = null;

            if(sublists.hasSublistLine(sublistId, beforeLineInstanceId))
            {
	            isBeforeLineCommitted = true;
            }
            else if(sublistsBuffers.hasSublistLine(sublistId, beforeLineInstanceId))
            {
	            isBeforeLineCommitted = false;
            }

            if(isBeforeLineCommitted !== null)
            {
                beforeSublistline = getSublistLineForInstance(sublistId, beforeLineInstanceId, isBeforeLineCommitted);
            }

	        var sublistline = createSublistLine({
		        id: sublistId,
		        asBuffer: !isCommitted,
		        origin: modelEvent.Origin.INSERT,
		        beforeLineInstanceId: beforeSublistline && beforeSublistline.instanceId
	        });
            doInsert(sublistId, sublistline, isCommitted);

            return sublistline.instanceId;
        }
        this.insertSublistLine = insertSublistLine;

	    /**
	     * remove sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {SublistLine|undefined} removedLine
	     */
        function removeSublistLine(sublistId, lineInstanceId)
        {
            if (sublists.hasSublistLine(sublistId, lineInstanceId))
            {
                cancelSublistLine(sublistId, lineInstanceId, true);

				var index = getSublistLineIndexForInstance(sublistId, lineInstanceId);
                var sublistline = sublists.removeSublistLine(sublistId, lineInstanceId);
	            sublistsLinesSequencesToInstanceIds.remove(sublistId, lineInstanceId);
                modelEvent.unforwardSublistLineEvents(sublistline);
                modelEvent.deleteLine(emitter, sublistline, false, undefined, undefined, index);
                return sublistline;
            }
        }
        this.removeSublistLine = removeSublistLine;

	    /**
	     * Move one line to new position.
	     * Order of all other lines is preserved.
	     * Line indexes between from and to position are shifted by one.
	     * @param {string} sublistId
	     * @param {string} fromInstanceId From line instance ID
	     * @param {string} toInstanceId To line instance ID
	     */
	    function moveSublistLine(sublistId, fromInstanceId, toInstanceId) {
		    var fromLine = getSublistLineForInstance(sublistId, fromInstanceId, false);
		    var toLine = getSublistLineForInstance(sublistId, fromInstanceId, false);
		    if (fromInstanceId === toInstanceId || !fromLine || !toLine)
			    return;
		    sublistsLinesSequencesToInstanceIds.move(sublistId, fromInstanceId, toInstanceId);
		    modelEvent.moveLine(emitter, fromLine, toLine);
	    }
	    this.moveSublistLine = moveSublistLine;

	    /**
	     * select sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isMultilineEditable
	     */
	    function selectSublistLine(sublistId, lineInstanceId, isMultilineEditable)
        {
	        var sublistlineBuffer;
	        if (isMultilineEditable) {
		        sublistlineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
	        }
			else {
				sublistlineBuffer = createBufferFromLine({line: getSublistLineForInstance(sublistId, lineInstanceId, true)});
			}
            doSelect(sublistId, sublistlineBuffer, isMultilineEditable);
        }
        this.selectSublistLine = selectSublistLine;

	    /**
	     * select new line
	     * @param {string} sublistId
	     * @param {Object} defaultValues
	     * @param {boolean} isMultilineEditable
	     * @returns {string} lineInstanceId of the selected new line
	     */
	    function selectNewSublistLine(sublistId, defaultValues, isMultilineEditable)
        {
            doSelect(sublistId, addNewSublistLine(sublistId, defaultValues), isMultilineEditable);

            return sublistsSelectedLineInstanceIds.get(sublistId);
        }
        this.selectNewSublistLine = selectNewSublistLine;

	    /**
	     * add new line
	     * @param {string} sublistId
	     * @param {Object} defaultValues
	     * @returns {SublistLine} newSublistline
	     */
	    function addNewSublistLine(sublistId, defaultValues)
	    {
		    var newSublistline = createSublistLine({
			    asBuffer : true,
			    id: sublistId,
			    defaultLineData: defaultValues
		    });
		    return newSublistline;
	    }
	    this.addNewSublistLine = addNewSublistLine;

	    /**
	     * cancel line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} suppressEmit
	     * @param {boolean?} originNotCancel
	     */
        function cancelSublistLine(sublistId, lineInstanceId, suppressEmit, originNotCancel)
        {
        	var removedLine = null;
            if(sublistsBuffers.hasSublistLine(sublistId, lineInstanceId))
            {
                var origin = originNotCancel ? undefined : modelEvent.Origin.CANCEL;
	            removeLineBufferForInstance(sublistId, lineInstanceId, !!suppressEmit, origin);
            }
        }
        this.cancelSublistLine = cancelSublistLine;

	    /**
	     * reset sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {Object} defaultValues
	     * @param {boolean} isCommitted
	     */
        function resetSublistLine(sublistId, lineInstanceId, defaultValues, isCommitted)
        {
	        if (isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

            if(isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted))
            {
                var sublistline = getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
                var newSublistlineOptions = {
                        asBuffer: !isCommitted,
                        id: sublistline.id,
                        lineInstanceId: sublistline.instanceId,
                        defaultLineData: defaultValues,
	                    origin: modelEvent.Origin.INSERT,
	                    suppressEmit: true
                    };

                createSublistLine(newSublistlineOptions);
            }
        }
        this.resetSublistLine = resetSublistLine;

	    /**
	     * commit line for instanceId
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isMultiLineEditable
	     */
        function commitSublistLine(sublistId, lineInstanceId, isMultiLineEditable)
        {
            if (isSublistLineInstanceIdValid(sublistId, lineInstanceId, false))
            {
            	var isUpdate = isSublistLineInstanceIdValid(sublistId, lineInstanceId, true);

	            var bufferedLine = getSublistLineForInstance(sublistId, lineInstanceId, false);

	            var sublistLine = cloneSublistLine({
		            suppressEmit: isUpdate,
		            asBuffer: false,
		            line: bufferedLine
                });
                modelEvent.forwardSublistLineEvents(emitter, sublistLine, false);

                if(!isUpdate)
                {
                    doAdd(sublistId, sublistLine, true);
	                if (isSublistLineInstanceIdSelected(sublistId, lineInstanceId) && !isMultiLineEditable) // ensure the SELECT event is not lost due to the previous REMOVE event
		                modelEvent.selectLine(emitter, bufferedLine, true);
                }
                else
                {
                    doUpdate(sublistId, sublistLine);
                }
            }
        }
        this.commitSublistLine = commitSublistLine;

        function emitLineIsCommittableEvent(sublistId, lineInstanceId)
        {
        	var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
        	modelEvent.committableLine(emitter, sublistLineBuffer);
        }
        this.emitLineIsCommittableEvent = emitLineIsCommittableEvent;

	    function emitLineIsNotCommittableEvent(sublistId, lineInstanceId)
	    {
		    var sublistLineBuffer = getSublistLineForInstance(sublistId, lineInstanceId, false);
		    modelEvent.notCommittableLine(emitter, sublistLineBuffer);
	    }
	    this.emitLineIsNotCommittableEvent = emitLineIsNotCommittableEvent;

	    function emitRecordIsSavableEvent()
	    {
		    modelEvent.savableRecord(emitter);
	    }
	    this.emitRecordIsSavableEvent = emitRecordIsSavableEvent;

	    function emitRecordIsNotSavableEvent()
	    {
		    modelEvent.notSavableRecord(emitter);
	    }
	    this.emitRecordIsNotSavableEvent = emitRecordIsNotSavableEvent;

        function getSubrecordDataForSubmission()
        {
            var result;

            var subrecordLinks = Object.keys(subrecordData.link);
            if (subrecordLinks.length > 0)
            {
                result = {};
                result['subrecord_parent'] = {
                    fields: ['parent'],
                    size: subrecordLinks.length,
                    data: subrecordLinks.map(function (v)
					{
						return [v];
					})
                };
            }

            subrecordLinks.forEach(function (sublistId)
			{
				var link = subrecordData.link[sublistId];

				result['children_' + sublistId] = {
					fields: ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
					size: link.length,
					data: link.map(function (v2)
					{
						return [v2.childfieldname, v2.childmachinename, v2.childlinktype, v2.childtype];
					})
				};

				link.forEach(function (v2)
				{
				    var fieldId = v2.childfieldname,
			            subrecords;

				    if (!!v2.sublinks && v2.sublinks.length > 0)
				    {
				        result['children_' + v2.childmachinename] = {
				            fields : ['childfieldname', 'childmachinename', 'childlinktype', 'childtype'],
				            size : v2.sublinks.length,
				            data : v2.sublinks.map(function(v3)
				            {
				                return [v3.childfieldname || null, v3.childmachinename, v3.childlinktype, v3.childtype];
				            })
				        };
				    }

				    if (sublistId === recordType)
				    {
				        subrecords = subrecordData.cache.get(null, fieldId, null, true);
				        subrecords = subrecords === undefined ? [] : [subrecords];
				    }
				    else
				    {
				        subrecords = subrecordData.cache.getSublist(sublistId);
				        subrecords = subrecords === undefined ? [] : Object.keys(subrecords).map(function(lineInstanceId)
				        {
			                var cache = subrecords[lineInstanceId];
			                return !!cache && cache.get(fieldId) || undefined;
			            }).reduce(function (p, c)
				        {
			                if (c !== undefined)
			                {
			                    p.push(c);
			                }
			                return p;
			            }, []);
				    }

				    if (subrecords.length > 0)
				    {
				        subrecords.forEach(function (v3)
						{
							var subrecord = v3.subrecord, deleteId = v3.deleteId;

							var isExistingSubrecord = !!subrecord && !subrecord.isNewRecord();
							if (isExistingSubrecord)
							{
								storeSubrecordAsSublist(result, subrecord, 'EDIT', v2.childmachinename, v2.sublinks);
							}
							else
							{
								var isNewSubrecord = !!subrecord;
								if (isNewSubrecord)
								{
									storeSubrecordAsSublist(result, subrecord, 'CREATE', v2.childmachinename, v2.sublinks);
								}
								var isSubrecordDeleted = !!deleteId && (!subrecord || subrecord.id !== deleteId);
								if (isSubrecordDeleted)
								{
					                storeAsSublist(result, v2.childmachinename, [subrecordUtil.SYS_OP, 'id'], ['DELETE', String(deleteId)]);
								}
							}
						});
				    }
				});
			});

            return result;
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function storeSubrecordAsSublist(data, record, operation, childmachinename, sublinks)
        {
            var fieldIds = [subrecordUtil.SYS_OP].concat(Array.prototype.sort.apply(record.getFields()));
            var values = fieldIds.map(function(fieldId){return recordUtil.emptyIfNullOrUndefined(record.getValueAsLegacyString(fieldId));});
            values[0] = operation;

            storeAsSublist(data, childmachinename, fieldIds, values);
            storeSubrecordSublistsAsSublist(data, record, operation, sublinks);
        }
        function storeSubrecordSublistsAsSublist(data, record, operation, sublinks)
        {
            if(!!sublinks && sublinks.length > 0)
            {
                sublinks.forEach(function (sublink){
                    storeSubrecordSublistAsSublist(data, record, sublink.childtype, operation, sublink.childmachinename, sublink.childfieldname);
                });
            }
        }
        function storeSubrecordSublistAsSublist(data, record, sublistId, operation, childmachinename, childfieldname)
        {
            var fieldIds, values;

            if (childfieldname === 'null')
            {
                fieldIds = [subrecordUtil.SYS_OP, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID].concat(Array.prototype.sort.apply(record.getSublistFields(sublistId)));

                record.getSublistLineInstanceIds(sublistId, true).forEach(function(lineInstanceId) {
                    values = fieldIds.map(function (fieldId) {return recordUtil.emptyIfNullOrUndefined(record.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, true));});
                    values[0] = operation;

                    if (operation === 'EDIT')
                    {
                        if (!record.getSublistState(sublistId).isLineChangedForInstance(lineInstanceId, true))
                        {
                            values[0] = 'VIEW';
                        }
                        if (record.getSublistState(sublistId).isLineInsertedForInstance(lineInstanceId, true))
                        {
                            values[0] = 'CREATE';
                        }
                    }

                    storeAsSublist(data, childmachinename, fieldIds, values);
                });
            }
        }

        function storeAsSublist(sublistData, sublistId, fieldIds, values)
        {
            sublistData[sublistId] = sublistData[sublistId] || {};
            sublistData[sublistId].fields = sublistData[sublistId].fields || fieldIds;
            sublistData[sublistId].data = sublistData[sublistId].data || [];
            sublistData[sublistId].data.push(values);
            sublistData[sublistId].size = sublistData[sublistId].data.length;
        }


        function getData()
        {
            return {body: util.extend({}, bodyFields), sublists: getSublistData()};
        }
        this.getData = getData;

        function getSublistData()
        {
            var sublistData = {};
	        sublists.getSublists().forEach(function(sublistId){
                var currentLine = getSublistSelectedLine(sublistId);
                sublistData[sublistId] = {currentline: (!!currentLine ? currentLine.toJSON() : {})};

                sublists.getSublistLinesAsOrderedList(sublistId).
                forEach(function(sublistline) {
	                sublistData[sublistId]['line ' + sublistsLinesSequencesToInstanceIds.getIndex(sublistId, sublistline.instanceId)] = sublistline.toJSON();
                });
            });

            return sublistData;
        }
        this.getSublistData = getSublistData;

	    function getSublistLineJSON(sublistId, lineInstanceId, isCommitted)
	    {
		    return getSublistLineForInstance(sublistId, lineInstanceId, isCommitted).toJSON();
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        function getClonedData()
        {
            return {
                        bodyField: getClonedBodyFields(),
                        sublist: getClonedSublistData(),
                        subrecord: recordDataObj.subrecord
                    };
        }
        this.getClonedData = getClonedData;

        function cloneRecordValue(val)
        {
            var clone = val;
            if(util.isObject(val))
            {
                clone = recordUtil.clone({},val);
            }
            else if(util.isArray(val))
            {
                clone = val.map(function(entry){
                    return cloneRecordValue(entry);
                });
            }
            else if(util.isDate(val))
            {
                clone = new Date(val);
            }

            return clone;
        }

        function getClonedBodyFields()
        {
            var clone = {};
            recordUtil.forEachProperty(bodyFields, function(fieldId, value){
                clone[fieldId] = cloneRecordValue(value);
            });

            return clone;
        }

        function getClonedSublistData()
        {
            return getSublists().reduce(function(result, sublistId){
                result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId).
                    map(function(sublistline){
                        var rawData = sublistline.getData();
                        var clonedLine = {};
                        recordUtil.forEachProperty(rawData, function(fieldId, value){
                            clonedLine[fieldId] = cloneRecordValue(value);
                        });

                        return clonedLine;
                    });

                return result;
            }, {});
        }

        function toJSON()
        {
            var currentLines = {};
            return {
                body: bodyFields,
                sublists: getSublists().reduce(function(result, sublistId){
                    result[sublistId] = sublists.getSublistLinesAsOrderedList(sublistId);

                    return result;
                },{}),
                currentsublists: sublistsBuffers.getSublists().reduce(function(result, sublistId){
	                var lineInstanceId = sublistsSelectedLineInstanceIds.get(sublistId);
                    if(lineInstanceId)
                    {
                        result[sublistId] = sublistsBuffers.getSublistLine(sublistId, lineInstanceId);
                    }

                    return result;
                },{})
            };
        }

        function shouldSetupSublistSystemId(id)
        {
            var hasExplicitLink = !!subrecordData.link[id];
            var hasImplicitLink = !!getBodyValue(subrecordUtil.SYS_ID) &&
                                  !!getBodyValue(subrecordUtil.SYS_PARENT_ID) && getBodyValue(subrecordUtil.SYS_PARENT_ID) !== '0';

            return hasExplicitLink || hasImplicitLink;
        }
        this.shouldSetupSublistSystemId = shouldSetupSublistSystemId;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
        	var values = util.isArray(value) ? value : [value];
	        values = values.map(optionTextCache.get.bind(optionTextCache, sublistId, fieldId));
            return values;
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
	        var values = util.isArray(value) ? value : [value];
	        var texts = util.isArray(text) ? text : [text];
	        for (var i = 0; i < values.length && i < texts.length; i++)
		        optionTextCache.set(sublistId, fieldId, values[i], texts[i]);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;
    }

    return {
        /**
         * create record model
         * @param {Object} options
         * @param {Metadata} options.metadata record metadata
         * @param {RecordCacheController} options.subrecordCache
         * @param {RecordDataObject} options.data serialized data
         * @returns {Model}
         */
        create: function create(options)
        {
            return new Model(options);
        }
    };
});

/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCache
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCache',[], function(){

    /**
     * javascript object for holding cached object for record
     *
     * @protected
     * @return {RecordCache}
     * @constructor
     */
    function RecordCache()
    {
        var cache = {};

        /**
         * return true if entry existed
         *
         * @param {string} fieldId
         * @return {boolean}
         */
        function has(fieldId)
        {
            return cache.hasOwnProperty(fieldId);
        }
        this.has = has;

        /**
         * cache an entry
         *
         * @param {string} fieldId
         * @param {*} object
         */
        function put(fieldId, object)
        {
            cache[fieldId] = object;
        }
        this.put = put;

        /**
         * return a cached entry
         *
         * @param {string} fieldId
         * @return {*}
         */
        function get(fieldId)
        {
            return cache[fieldId];
        }
        this.get = get;

        /**
         * delete a cached entry
         *
         * @param {string} fieldId
         */
        function invalidate(fieldId)
        {
            delete cache[fieldId];
        }
        this.invalidate = invalidate;

        /**
         * get all cache keys
         *
         */
        function keys()
        {
            var keys = [];
            for(var k in cache)
                if(cache.hasOwnProperty(k))
                    keys[keys.length] = k;

            return keys;
        }
        this.keys = keys;
        return this;
    }

    return {
        /**
         * return a new instance of RecordCache
         * @returns {RecordCache}
         */
        create: function() { return new RecordCache(); }
    };
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/recordCacheController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordCacheController',['N/record/recordCache', 'N/utilityFunctions'], function(recordCache, utilityFunctions) {

    /**
     * record cache controller
     *
     * @protected
     * @return {RecordCacheController}
     * @constructor
     */
    function RecordCacheController()
    {
        var body = recordCache.create();
        var sublists = {};
        var sublistsBuffers = {};

        /**
         * put an entry into given record cache
         *
         * @param {string|null} sublistId
         * @param {string|null} fieldId
         * @param {string|null} lineId
         * @param {boolean} isCommitted
         */
        function has(sublistId, fieldId, lineId, isCommitted)
        {
            var result = false;
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                result = cache.has(fieldId);

            return result;
        }
        this.has = has;

        /**
         * put an entry into given record cache
         *
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @param {*} object
         */
        function put(sublistId, fieldId, lineId, object, isCommitted)
        {
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                cache.put(fieldId, object);
        }
        this.put = put;

        /**
         * get an entry from given record cache
         *
         * @param {string|null} sublistId
         * @param {string|null} fieldId
         * @param {string|null} lineId
         * @param {boolean} isCommitted
         * @return {*|null} object
         */
        function get(sublistId, fieldId, lineId, isCommitted)
        {
            var obj = null;
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            if(cache)
                obj = cache.get(fieldId);

            return obj;
        }
        this.get = get;

        /**
         * invalidate an entry for given record cache
         *
         * @param {string|null} sublistId
         * @param {string|null} fieldId
         * @param {string|null} lineId
         * @param {boolean} isCommitted
         */
        function invalidate(sublistId, fieldId, lineId, isCommitted)
        {
            var cache = null;

            if(!sublistId)
            {
                cache = getRecordCache();
            }
            else
            {
                if(!!lineId)
                {
                    if(!!fieldId)
                    {
                        cache = getRecordCache(sublistId, lineId, isCommitted);
                    }
                    else
                    {
                        var sublist = !isCommitted ? getSublistBuffer(sublistId) : getSublist(sublistId);
                        delete sublist[lineId];
                    }
                }
                else
                {
                    if(!isCommitted)
                    {
                        delete sublistsBuffers[sublistId];
                    }
                    else
                    {
                        delete sublists[sublistId];
                    }
                }
            }

            if(!!cache)
            {
                cache.invalidate(fieldId);
            }
        }
        this.invalidate = invalidate;

        /**
         * invalidate the sublist cache
         * @param {String} sublistId
         */
        function invalidateSublist(sublistId)
        {
            invalidate(sublistId, null, null, false);
        }
        this.invalidateSublist = invalidateSublist;

        /**
         * get record cache
         *
         * @param {string|null} sublistId
         * @param {string|null} lineId
         * @param {boolean} isCommitted
         * @return {RecordCache}
         */
        function getRecordCache(sublistId, lineId, isCommitted)
        {
            var cache = null;
            if (!!sublistId)
            {
                cache = getSublistCache(sublistId, lineId, isCommitted);
            }
            else
            {
                cache = body
            }

            return cache;
        }

        /**
         * get sublist cache
         *
         * @param {string} sublistId
         * @return {Object} sublist cache with sublistId as key
         */
        function getSublist(sublistId)
        {
            if (!sublists.hasOwnProperty(sublistId))
                sublists[sublistId] = {};
            return sublists[sublistId];
        }
        this.getSublist = getSublist;

        /**
         * get sublist buffer cache
         *
         * @param {string} sublistId
         * @return {Object} sublist buffer cache with sublistId as key
         */
        function getSublistBuffer(sublistId)
        {
            if (!sublistsBuffers.hasOwnProperty(sublistId))
                sublistsBuffers[sublistId] = {};
            return sublistsBuffers[sublistId];
        }
        this.getSublistBuffer = getSublistBuffer;

        /**
         * get sublist cache by line id
         *
         * @param {string} sublistId
         * @param {string} lineId
         * @param {boolean} isCommitted
         * @return {RecordCache}
         */
        function getSublistCache(sublistId, lineId, isCommitted)
        {
            var sublist = !isCommitted ? getSublistBuffer(sublistId) : getSublist(sublistId);

            var cache = sublist[lineId] || null;
            if(!cache)
            {
                cache = sublist[lineId] = recordCache.create();
            }
            return cache;
        }

	    /**
	     * get fields cache keys
	     *
	     * @param {string|null} sublistId
	     * @param {string|null} lineId
	     * @param {boolean} isCommitted
	     * @return {Array<string>}
	     */
        function fields(sublistId, lineId, isCommitted)
        {
            var cache = getRecordCache(sublistId, lineId, isCommitted);
            return cache.keys();
        }
        this.fields = fields;

        /**
         * copy/clone the data from sublist cache to sublist buffer cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function} functionToMigrate to migrate the cache arg1 is fieldId, arg2 is the entry to be migrated, arg3 is sublist buffer cache
         */
        function migrateFromSublistToSublistBuffer(sublistId, lineId, functionToMigrate)
        {
                    var sublistBufferCache = getSublistCache(sublistId, lineId, false);
            var sublistCache = getSublistCache(sublistId, lineId, false);

            sublistCache.keys().forEach(function(cacheKey){
                functionToMigrate(cacheKey, sublistCache.get(cacheKey), sublistBufferCache);
            });
        }
        this.migrateFromSublistToSublistBuffer = migrateFromSublistToSublistBuffer;


        /**
         * commit the data in sublist buffer cache to sublist cache
         * @param {String} sublistId
         * @param {String} lineId
         * @param {Function} functionToCommit function to commit the sublist buffer cache: arg1 is fieldId, arg2 is the entry to be committed, arg3 is sublist cache
         */
        var commitFromSublistBufferToSublist = utilityFunctions.thenableFunction(function commitFromSublistBufferToSublist(sublistId, lineId, functionToCommit)
        {
            var sublistCache = getSublistCache(sublistId, lineId, true);
            var sublistBufferCache = getSublistCache(sublistId, lineId, false);
            var bufferedKeys = sublistBufferCache.keys();

			sublistCache.keys().forEach(function(key) {
				if (bufferedKeys.indexOf(key) < 0)
					sublistCache.invalidate(key);
			});

	        return utilityFunctions.forEachThenable(bufferedKeys, function(cacheKey)
	        {
                return functionToCommit(cacheKey, sublistBufferCache.get(cacheKey), sublistCache);
            });
        });
        this.commitFromSublistBufferToSublist = commitFromSublistBufferToSublist;

        return this;
    }


    return {
        /**
         * get a new instance of RecordCacheController
         * @return {RecordCacheController}
         */
        create: function()
        {
            return new RecordCacheController();
        }
    }
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/record/modelController
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/modelController',['N/record/model', 'N/record/recordCacheController', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/record/subrecordUtilityFunctions', 'N/resultObject'],
	function(model, recordCacheController, utilityFunctions, recordUtil, subrecordUtil, resultObject){

    /**
     *
     * @param {Object} options
     * @param {Metadata} options.metadata record metadata
     * @param {Function} options.getIsNSERecord
     * @param {RecordDataObject} options.data record data
     * @returns {ModelController}
     * @constructor
     */
    function ModelController(options)
    {
        var fieldObjectCache = recordCacheController.create();
        var userFieldCache = recordCacheController.create();
        var selectOptionsCache = recordCacheController.create();
        var subrecordCache = recordCacheController.create();
        var subrecordTracker = {};
        var slavingTrackingMap = {};
        var scriptTrackingArray = [];
        var scriptTrackingNextSerial = 1;
        var pendingCalls = {};
        var saveRecordScriptTriggered = false;

        var _model = model.create({
	        metadata: options.metadata,
	        data: options.data,
	        subrecordCache: subrecordCache,
	        getIsNSERecord: options.getIsNSERecord
        });

        /**
         * return true if field exists
         * @param {*} fieldId
         * @returns {boolean}
         */
        function hasFieldValue (fieldId) {
            return _model.hasBodyValue(fieldId);
        }
        this.hasFieldValue = hasFieldValue;

	    /**
	     * returns an instanceId of the currently selected line or null
	     * @param {string} sublistId
	     * @returns {string|null} lineInstanceId of a currently selected line
	     */
        function getSublistSelectedLineInstanceId(sublistId)
        {
            return _model.getSublistSelectedLineInstanceId(sublistId);
        }
        this.getSublistSelectedLineInstanceId = getSublistSelectedLineInstanceId;

	    /**
	     * returns true when line with exists for given lineInstanceId in either buffered or committed lines based on the isCommitted
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted)
        {
            return _model.isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted);
        }
        this.isSublistLineInstanceIdValid = isSublistLineInstanceIdValid;

	    /**
	     * returns Line for given lineInstanceId, when isCommitted is false, it creates the buffered line from committed
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @param {boolean?} suppressEmit
	     * @returns {SublistLine|null}
	     */
        function getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit)
        {
            return _model.getSublistLineForInstance(sublistId, lineInstanceId, isCommitted, suppressEmit);
        }
        this.getSublistLineForInstance = getSublistLineForInstance;

	    /**
	     * returns true when the line with lineInstanceId is selected
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {boolean}
	     */
        function isSublistLineInstanceIdSelected(sublistId, lineInstanceId)
        {
            return _model.isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
        }
        this.isSublistLineInstanceIdSelected = isSublistLineInstanceIdSelected;

        /**
         * set value by js primitive form for body field
         * @param {string} fieldId
         * @param {string|Number|Boolean|Date|Array|null} value
         */
        function setParsedValueForBodyField(fieldId, value)
        {
            _model.setBodyValuePrimitive(fieldId, value);
        }
        this.setParsedValueForBodyField = setParsedValueForBodyField;

	    /**
	     * set value by js primitive form for sublist field
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {string} fieldId
	     * @param {string|Number|Boolean|Date|Array|null} value
	     * @param {boolean} isCommitted
	     */
        function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted)
        {
            _model.setSublistLineValuePrimitive(sublistId, lineInstanceId, fieldId, value, isCommitted);
	        // TODO: promote committed change to buffered line for dynamic record
        }
        this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

        /**
         * set field value
         * @param {string} fieldId
         * @param {Object|null} recordFieldValue
         * @param {string|Number|Boolean|Date|Array|null} recordFieldValue.value
         * @param {string} recordFieldValue.legacyStringValue
         */
        function setFieldValue(fieldId, recordFieldValue)
        {
            _model.setBodyValue(fieldId, recordFieldValue);
        }
        this.setFieldValue = setFieldValue;

        /**
         * return the primitive value for body field
         * @param {string} fieldId
         * @returns {string|Number|Boolean|Date|Array|null}
         */
        function getFieldValue(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValue(fieldId) : (options.getIsNSERecord() ? null : "");
        }
        this.getFieldValue = getFieldValue;

        /**
         * return the value for body field as legacy string format
         * @param {string} fieldId
         * @returns {string}
         */
        function getValueAsLegacyString(fieldId)
        {
            return hasFieldValue(fieldId) ? _model.getBodyValueAsLegacyString(fieldId) : null;
        }
        this.getValueAsLegacyString = getValueAsLegacyString;

        /**
         * return list of all body fields with value
         * @returns {Array<string>}
         */
        function getBodyFieldIds()
        {
            return _model.getBodyFieldIds();
        }
        this.getBodyFieldIds = getBodyFieldIds;

        /**
         * remove field
         * @param {string} fieldId
         */
        function removeFieldValue(fieldId)
        {
            _model.removeBodyValue(fieldId);
            invalidateRecordCacheForInstance(null, fieldId, null, false);
        }
        this.removeFieldValue = removeFieldValue;

        /**
         * remove all sublist lines
         * @param {string} sublistId
         * @param {boolean} isMultilineEditable
         */
        function clearSublistData(sublistId, isMultilineEditable)
        {
	        for (var i = getSublistLineCount(sublistId, isMultilineEditable) - 1; i >= 0; i--)
            {
            	var lineInstanceId = getSpecifiedLineInstanceIdByIndex(sublistId, i);
	            if(lineInstanceIsNewLine(sublistId, lineInstanceId))
	            {
		            // line isn't committed, call cancel
		            cancelSublistLineForInstance(sublistId, lineInstanceId);
	            }
	            else
	            {
		            //line is committed, call remove
		            removeSublistLineForInstance(sublistId, lineInstanceId);
	            }
            }
        }
        this.clearSublistData = clearSublistData;

        /**
         * @returns {Array<string>} list of sublist in model
         */
        function getSublists()
        {
            return _model.getSublists();
        }
        this.getSublists = getSublists;

	    /**
	     * get sublist line count
	     * @param {string} sublistId
	     * @param {boolean} isMultilineEditable
	     * @returns {Number}
	     */
	    function getSublistLineCount(sublistId, isMultilineEditable)
	    {
		    return _model.getSublistLineCount(sublistId, isMultilineEditable);
	    }
	    this.getSublistLineCount = getSublistLineCount;

	    /**
	     * returns an instanceId with given index from both buffered and committed and lines
	     * @param {string} sublistId
	     * @param {number} index
	     * @returns {string|null} lineInstanceId with given index
	     */
        function getSpecifiedLineInstanceIdByIndex(sublistId, index)
        {
			return _model.getSpecifiedLineInstanceIdByIndex(sublistId, index);
        }
        this.getSpecifiedLineInstanceIdByIndex = getSpecifiedLineInstanceIdByIndex;

	    /**
	     * returns all instance ids for a given sublistId & its bufferState, ordered by sequence
	     * @param {string} sublistId
	     * @param {boolean} isCommitted
	     * @returns {Array<string>} list of lineInstanceIds in order of sequence
	     */
	    function getSublistLineInstanceIds(sublistId, isCommitted)
	    {
		    return _model.getSublistLineInstanceIds(sublistId, isCommitted);
	    }
	    this.getSublistLineInstanceIds = getSublistLineInstanceIds;

	    /**
	     * get the index that the next new line will be assigned, it's always sublist size +1
	     * @param {string} sublistId
	     * @returns {number} next new line index
	     */
	    function getNextNewLineIndex(sublistId)
	    {
	    	return _model.getNextNewLineIndex(sublistId);
	    }
	    this.getNextNewLineIndex = getNextNewLineIndex;

	    /**
	     * check if the given line instance is a NEW line (has no committed line)
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {boolean}
	     */
	    function lineInstanceIsNewLine(sublistId, lineInstanceId)
	    {
		    return _model.lineInstanceIsNewLine(sublistId, lineInstanceId);
	    }
	    this.lineInstanceIsNewLine = lineInstanceIsNewLine;

	    /**
	     * lineInstanceIsLastNewLine_MLB
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {boolean}
	     */
	    function lineInstanceIsLastNewLine_MLB(sublistId, lineInstanceId)
	    {
		    return lineInstanceIsNewLine(sublistId, lineInstanceId) && (getSublistLineCount(sublistId, true) - 1 === getSublistLineIndexForInstance(sublistId, lineInstanceId));
	    }
	    this.lineInstanceIsLastNewLine_MLB = lineInstanceIsLastNewLine_MLB;

	    /**
	     * update current line to a new line for MLB
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {string} lineInstanceId
	     */
	    function updateCurrentLineToANewLine_MLB(sublistId, lineInstanceId)
	    {
		    if(!isSublistLineInstanceIdSelected(sublistId, lineInstanceId) && isSublistLineInstanceIdValid(sublistId, lineInstanceId, false))
		    {
			    _model.updateCurrentLineToANewLine_MLB(sublistId, lineInstanceId);
		    }
	    }
	    this.updateCurrentLineToANewLine_MLB = updateCurrentLineToANewLine_MLB;

	    /**
	     * returns true if sublist field has value
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.hasSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.hasSublistLineValueForInstance = hasSublistLineValueForInstance;

	    /**
	     * returns value of a sublist field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineValue(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.getSublistLineValueForInstance = getSublistLineValueForInstance;

	    /**
	     * return the value for sublist field as legacy string format
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {string}
	     */
        function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineValueAsLegacyString(sublistId, lineInstanceId, fieldId, isCommitted);
        }
        this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

	    /**
	     * set sublist value for instance
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {Object|null} recordFieldValue
	     * @param {string|Number|Boolean|Date|Array|null} recordFieldValue.value
	     * @param {string} recordFieldValue.legacyStringValue
	     * @param {boolean} isCommitted
	     */
        function setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, recordFieldValue, isCommitted)
        {
            _model.setSublistLineValue(sublistId, lineInstanceId, fieldId, recordFieldValue, isCommitted);
            // TODO: promote committed change to buffered line for dynamic record
        }
        this.setSublistLineValueForInstance = setSublistLineValueForInstance;

	    /**
	     * insert sublist line
	     * @param {string} sublistId
	     * @param {string} beforeLineInstanceId
	     * @param {boolean} isCommitted
	     */
        function insertSublistLineForInstance(sublistId, beforeLineInstanceId, isCommitted)
        {
            var lineInstanceId = _model.insertSublistLine(sublistId, beforeLineInstanceId, isCommitted);
            if(!!lineInstanceId)
            {
                setupSublistSubrecordSystemId(sublistId, lineInstanceId, isCommitted);
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId, isCommitted);
            }

            return lineInstanceId;
        }
        this.insertSublistLineForInstance = insertSublistLineForInstance;

	    /**
	     * Move one line to new position.
	     * Order of all other lines is preserved.
	     * Line indexes between from and to position are shifted by one.
	     * @param {string} sublistId
	     * @param {string} fromInstanceId From line instance ID
	     * @param {string} toInstanceId To line instance ID
	     */
	    function moveSublistLine(sublistId, fromInstanceId, toInstanceId)
	    {
		    _model.moveSublistLine(sublistId, fromInstanceId, toInstanceId);
	    }
	    this.moveSublistLine = moveSublistLine;

	    /**
	     * update new line buffer wil copied line
	     * @param {string} sublistId
	     * @param {SublistLine} lineToCopy
	     * @param {object} noCopyToDefaultMap
	     * @param {boolean} isMultiLineEditable
	     * @returns {string} lineInstanceId of fresh copy
	     */
	    function updateNewLineBufferWithCopy(sublistId, lineToCopy, noCopyToDefaultMap, isMultiLineEditable)
        {
	        var currentNewLineIndex = getSublistLineCount(sublistId, isMultiLineEditable);
	        var currentNewLineInstanceId = getSpecifiedLineInstanceIdByIndex(sublistId, currentNewLineIndex);
	        var sublistLineOptions = {
		        asBuffer: true,
		        id: sublistId,
		        lineInstanceId: currentNewLineInstanceId,
		        toBeCloned: lineToCopy,
		        noCopyToDefaultMap: noCopyToDefaultMap
	        };
	        invalidateSublistRecordCacheForInstance(sublistId, currentNewLineInstanceId);
	        return _model.updateNewLineBufferWithCopy(sublistLineOptions);
        }
        this.updateNewLineBufferWithCopy = updateNewLineBufferWithCopy;

	    /**
	     * make copy of a line
	     * @param {string} sublistId
	     * @param {SublistLine} lineToCopy
	     * @param {boolean} isMultilineEditable
	     * @param {object} noCopyToDefaultMap
	     * @returns {string} lineInstanceId of fresh copy
	     */
        function makeCopyForInstance(sublistId, lineToCopy, isMultilineEditable, noCopyToDefaultMap)
        {
	        return _model.putCopyIntoNewLineBuffer(sublistId, lineToCopy, isMultilineEditable, noCopyToDefaultMap);
        }
        this.makeCopyForInstance = makeCopyForInstance;

	    /**
	     * setup sublist subrecord systemId
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     */
        function setupSublistSubrecordSystemId(sublistId, lineInstanceId, isCommitted)
        {
            if (_model.shouldSetupSublistSystemId(sublistId))
            {
                var sys_id = subrecordUtil.getNextSysId(true);
                var parent_sys_id = String(getFieldValue(subrecordUtil.SYS_ID));
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, {value: sys_id, legacyStringValue: sys_id}, isCommitted);
                setSublistLineValueForInstance(sublistId, subrecordUtil.SYS_PARENT_ID, lineInstanceId, {value: parent_sys_id, legacyStringValue: parent_sys_id}, isCommitted);
            }
        }

	    /**
	     * remove sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {number} removedLineIndex
	     */
        function removeSublistLineForInstance(sublistId, lineInstanceId)
        {
            var lineExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, true);

            if(lineExists)
            {
	            var index = getSublistLineIndexForInstance(sublistId, lineInstanceId);
                _model.removeSublistLine(sublistId, lineInstanceId);
                removeLineForRecordCacheForInstance(sublistId, lineInstanceId);
                invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
                return index;
            }
			return -1;
        }
        this.removeSublistLineForInstance = removeSublistLineForInstance;

	    /**
	     * get sublist line field ids
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {Array<string>|null} sublist field ids
	     */
        function getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted)
        {
            return _model.getSublistLineFieldIds(sublistId, lineInstanceId, isCommitted);
        }
        this.getSublistLineFieldIds = getSublistLineFieldIds;

	    /**
	     * select sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isMultilineEditable
	     * @returns {string|null} resultLineInstanceId selected line's instanceId
	     */
        function selectSublistLineForInstance(sublistId, lineInstanceId, isMultilineEditable)
        {
            var resultLineInstanceId = null;
            var lineInstanceExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, true);
            if (!lineInstanceExists && isMultilineEditable) {
	            lineInstanceExists = isSublistLineInstanceIdValid(sublistId, lineInstanceId, false);
            }

            if(lineInstanceExists)
            {
                resultLineInstanceId = lineInstanceId;
                var lineInstanceIsSelected = isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
                if(!lineInstanceIsSelected)
                {
                    if (!isMultilineEditable) {
	                    var selectedLineInstanceId = getSublistSelectedLineInstanceId(sublistId);
                        if(!isSublistLineInstanceIdValid(sublistId, selectedLineInstanceId, true)) {
	                        // selected line is uncommitted
	                        removeLineForRecordCacheForInstance(sublistId, selectedLineInstanceId);
	                    }
	                    invalidateSublistRecordCacheForInstance(sublistId, selectedLineInstanceId);
                    }

                    _model.selectSublistLine(sublistId, lineInstanceId, isMultilineEditable);
                }
            }

            return resultLineInstanceId;
        }
        this.selectSublistLineForInstance = selectSublistLineForInstance;

        /**
         * select new line
         * @param {string} sublistId
         * @param {Object} defaultValues
         * @param {boolean} isMultilineEditable
         * @returns {string} lineInstanceId of the selected new line
         */
        function selectNewSublistLine(sublistId, defaultValues, isMultilineEditable)
        {
            var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);
            if(!lineInstanceIsLastNewLine_MLB(sublistId, lineInstanceId))
            {
            	if (!isMultilineEditable) {
		            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
	            }
                lineInstanceId = _model.selectNewSublistLine(sublistId, defaultValues, isMultilineEditable);
	            setupSublistSubrecordSystemId(sublistId, lineInstanceId, false);
            }

            return lineInstanceId;
        }
        this.selectNewSublistLine = selectNewSublistLine;

	    /**
	     * add new line (MLB)
	     * @param {string} sublistId
	     * @param {Object} defaultValues
	     * @returns {string} lineInstanceId of the added new line
	     */
	    function addNewSublistLine(sublistId, defaultValues)
	    {
		    var lineInstanceId = _model.addNewSublistLine(sublistId, defaultValues).instanceId;
		    setupSublistSubrecordSystemId(sublistId, lineInstanceId, false);
		    return lineInstanceId;
	    }
	    this.addNewSublistLine = addNewSublistLine;

	    /**
	     * cancel line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean?} originNotCancel
	     */
        function cancelSublistLineForInstance(sublistId, lineInstanceId, originNotCancel)
        {
            invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
            _model.cancelSublistLine(sublistId, lineInstanceId, false, originNotCancel);
        }
        this.cancelSublistLineForInstance = cancelSublistLineForInstance;

	    /**
	     * reset committed sublist line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {Object} defaultValues
	     */
        function resetSublistCommittedLineForInstance(sublistId, lineInstanceId, defaultValues)
        {
            _model.resetSublistLine(sublistId, lineInstanceId, defaultValues, true);
        }
        this.resetSublistCommittedLineForInstance = resetSublistCommittedLineForInstance;

	    /**
	     * run a function while showing a given line as currently selected line
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {Function} func funciton to be called while line is selected
	     * @param {object} thisArg this arg to the .apply function
	     * @param {Array} argList of funcs arguments
	     * @returns {?} result of the func.apply(thisArg, argList) call
	     */
        var runFunctionWhileSilentlySelectingLine = utilityFunctions.thenableFunction(function runFunctionWhileSilentlySelectingLine(sublistId, lineInstanceId, func, thisArg, argList)
        {
	        argList = argList || [];
	        if (util.isFunction(func) && util.isArray(argList))
	        {
               return _model.runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, func, thisArg, argList);
	        }
        });

        this.runFunctionWhileSilentlySelectingLine = runFunctionWhileSilentlySelectingLine;

	    /**
	     * get index for line by lineInstanceId - looks for the index in both buffered and committed lines
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @returns {number} index (sequence) of the line with given lineInstanceId or -1
	     */
	    function getSublistLineIndexForInstance(sublistId, lineInstanceId)
	    {
		    return _model.getSublistLineIndexForInstance(sublistId, lineInstanceId);
	    }
	    this.getSublistLineIndexForInstance = getSublistLineIndexForInstance;

	    /**
	     * get instanceId of a committed line for given index (sequence)
	     * @param {string} sublistId
	     * @param {number} line
	     * @returns {string|null} instanceId of a line with given index
	     */
	    function getCommittedLineInstanceIdByIndex(sublistId, line)
        {
	        return _model.getCommittedSublistLineInstanceIdForIndex(sublistId, line);
        }
        this.getCommittedLineInstanceIdByIndex = getCommittedLineInstanceIdByIndex;

	    /**
	     * get value of a sublist line buffer field
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {string} fieldId
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function getSublistLineBufferValueForInstance(sublistId, lineInstanceId, fieldId)
        {
            var isCommitted = false;

            return getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getSublistLineBufferValueForInstance = getSublistLineBufferValueForInstance;

	    /**
	     * commit line for instanceId
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isMultiLineEditable
	     */
        var commitSublistLineForInstance = utilityFunctions.thenableFunction(function commitSublistLineForInstance(sublistId, lineInstanceId, isMultiLineEditable, isAsync)
        {
            if(!isSublistLineInstanceIdValid(sublistId, lineInstanceId, true))
            {
            	// committed line does not exist yet
                insertLineForRecordCacheForInstance(sublistId, lineInstanceId, true);
            }

            _model.commitSublistLine(sublistId, lineInstanceId, isMultiLineEditable);
            return handleRecordCacheWhileCommittingLine.thenable(sublistId, lineInstanceId, isAsync);
        }, {
        	isAsyncArgIndex: 3
        });
        this.commitSublistLineForInstance = commitSublistLineForInstance;

        var handleRecordCacheWhileCommittingLine = utilityFunctions.thenableFunction(function handleRecordCacheWhileCommittingLine(sublistId, lineInstanceId, isAsync)
        {
            handleFieldWhileCommittingLine(sublistId, lineInstanceId);
            return handleSubrecordsWhileCommittingLine.thenable(sublistId, lineInstanceId, isAsync);
        }, {
        	isAsyncArgIndex: 2
        });

        function handleFieldWhileCommittingLine(sublistId, lineInstanceId)
        {
            fieldObjectCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, false);
            });

            userFieldCache.commitFromSublistBufferToSublist(sublistId, lineInstanceId, function(fieldId, entryToBeCommitted, sublistCache){
                sublistCache.put(fieldId, entryToBeCommitted);
                userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, false);
            });
        }

        var handleSubrecordsWhileCommittingLine = utilityFunctions.thenableFunction(function handleSubrecordsWhileCommittingLine(sublistId, lineInstanceId, isAsync)
        {
            return subrecordCache.commitFromSublistBufferToSublist.thenable(sublistId, lineInstanceId, function (fieldId, entryToBeCommitted)
            {
                var subrecord = entryToBeCommitted.subrecord;
                var isCommitted = true;
                return resultObject.create(function ()
                {
	                if (subrecord)
	                {
	                    return subrecord.clone.thenable(isCommitted, isAsync);
	                }
	                else
	                {
	                    return null;
	                }
                }).then(function (committedSubrecord)
                {
                	if (subrecord)
	                {
	                	subrecord.abandon();
	                }
	                doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, committedSubrecord);
                });
            });
        }, {
        	isAsyncArgIndex: 2
        });


        /**
         * insert a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         * @param {boolean} isCommitted
         */
        function insertLineForRecordCacheForInstance(sublistId, lineInstanceId, isCommitted)
        {
            userFieldCache.get(sublistId, null, lineInstanceId, isCommitted);
            fieldObjectCache.get(sublistId, null, lineInstanceId, isCommitted);
            selectOptionsCache.get(sublistId, null, lineInstanceId, isCommitted);
            subrecordCache.get(sublistId, null, lineInstanceId, isCommitted);
        }

        /**
         * remove a line buffer to cache
         * @param {string} sublistId
         * @param {string} lineInstanceId
         */
        function removeLineForRecordCacheForInstance(sublistId, lineInstanceId)
        {
            var isCommitted = true;

            userFieldCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
            subrecordCache.invalidate(sublistId, null, lineInstanceId, isCommitted);
        }

	    /**
	     * invalidate a cache object
	     * @param {string|null} sublistId
	     * @param {string|null} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     */
        function invalidateRecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            selectOptionsCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
            subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
        }

	    /**
	     * invalidate a the field Object Caches when fieldState update occurs.
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     */
	    function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId)
	    {
		    userFieldCache.invalidate(sublistId, fieldId, lineInstanceId, false);
		    fieldObjectCache.invalidate(sublistId, fieldId, lineInstanceId, false);
	    }
	    this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

	    /**
	     * invalidate Sublist Record Cache for given buffered line instance
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     */
        function invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId)
        {
            fieldObjectCache.invalidate(sublistId, null, lineInstanceId, false);
	        userFieldCache.invalidate(sublistId, null, lineInstanceId, false);
            selectOptionsCache.invalidate(sublistId, null, lineInstanceId, false);
            if(isSublistLineInstanceIdSelected(sublistId, lineInstanceId))
            {
                abandonBufferedSublistSubrecordCacheEntries(sublistId, lineInstanceId);
            }
            subrecordCache.invalidate(sublistId, null, lineInstanceId, false);
        }
		this.invalidateSublistRecordCacheForInstance = invalidateSublistRecordCacheForInstance;

	    function getPendingCommitPromise(internalOptions)
	    {
		    var delegateFunction = internalOptions.delegateFunction;
		    var unproxiedRecord = internalOptions.unproxiedRecord;
		    var lineInstanceId = internalOptions.lineInstanceId;
		    var sublistId = internalOptions.sublistId;
		    var pendingPromise = getFromPendingCalls("commit", lineInstanceId);

		    if (!pendingPromise) {
			    var isPending = true;
			    var promise = new Promise(function(resolve, reject) {
				    var resolveWhenCommittable = function (delegateFunction, lineInstanceId, event) {
					    if (event && event.lineId !== lineInstanceId)
						    return;
					    try {
						    resolve(delegateFunction());
					    } catch (e) {
						    reject(e);
					    } finally {
						    removePendingCommitPromise(lineInstanceId);
						    if (event) {
							    off({
								    types: ['LINE_COMMITTABLE'],
								    listener: resolveWhenCommittable
							    });
						    }
					    }
				    }.bind(null, delegateFunction, lineInstanceId);

				    if (isSelectedLineCommittable(lineInstanceId))
				    {
					    resolveWhenCommittable();
					    isPending = false;
				    }
				    else
				    {
					    on({
						    types: ['LINE_COMMITTABLE'],
						    listener: resolveWhenCommittable
					    });
				    }
			    });
			    if (isPending)
			    {
				    addPendingCommitPromise(lineInstanceId, promise);
			    }
			    return promise;
		    }
		    return pendingPromise;
	    }
	    this.getPendingCommitPromise = getPendingCommitPromise;

	    function getPendingSavePromise(internalOptions)
	    {
		    var delegateFunction = internalOptions.delegateFunction;
		    var pendingPromise = getFromPendingCalls("save");

		    if (!pendingPromise) {
			    var isPending = true;
			    var promise = new Promise(function(resolve, reject) {
				    var resolveWhenSavable = function (delegateFunction, event) {
					    try {
						    delegateFunction({resolve: resolve, reject: reject});
					    } catch (e) {
						    reject(e);
					    } finally {
						    removePendingSavePromise();
						    if (event) {
							    off({
								    types: ['RECORD_SAVABLE'],
								    listener: resolveWhenSavable
							    });
						    }
					    }
				    }.bind(null, delegateFunction);

				    if (isRecordSavable())
				    {
					    resolveWhenSavable();
					    isPending = false;
				    }
				    else
				    {
					    on({
						    types: ['RECORD_SAVABLE'],
						    listener: resolveWhenSavable
					    });
				    }
			    });
			    if (isPending)
			    {
				    addPendingSavePromise(promise);
			    }
			    return promise;
		    }
		    return pendingPromise;
	    }
	    this.getPendingSavePromise = getPendingSavePromise;

        function getFromPendingCalls(call, lineInstanceId)
        {
	        var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
	        if (!!pendingCalls[pendingCallKey])
	        {
		        return pendingCalls[pendingCallKey];
	        }
	        else
	        {
		        return null;
	        }
        }

	    function addPendingCommitPromise(lineInstanceId, commitPromise)
	    {
		    addToPendingCalls("commit",  commitPromise, lineInstanceId);
	    }
	    this.addPendingCommitPromise = addPendingCommitPromise;

        function addPendingSavePromise(promise)
        {
        	addToPendingCalls("save", promise);
        }

	    function addToPendingCalls(call, promise, lineInstanceId)
	    {
		    var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
		    pendingCalls[pendingCallKey] = promise;
	    }

	    function removeFromPendingCalls(call, lineInstanceId)
	    {
		    var pendingCallKey = call + (lineInstanceId? "_" + lineInstanceId : "");
		    if (!!pendingCalls[pendingCallKey])
		    {
			    pendingCalls[pendingCallKey] = null;
		    }
	    }

	    function removePendingCommitPromise(lineInstanceId)
	    {
		    removeFromPendingCalls("commit", lineInstanceId);
	    }
	    this.removePendingCommitPromise = removePendingCommitPromise;

	    function removePendingSavePromise() {
		    removeFromPendingCalls("save");
	    }
	    this.removePendingSavePromise = removePendingSavePromise;

	    function addToSlavingSet(sublistId, fieldId, lineInstanceId, slavingId)
	    {
		    var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId, fieldId);
		    if (!!lineInstanceId && isSelectedLineCommittable(lineInstanceId))
		    {
			    emitLineIsNotCommittableEvent(sublistId, lineInstanceId);
		    }
		    if (isRecordSavable())
		    {
			    emitRecordIsNotSavableEvent();
		    }
        	if (!!slavingTrackingMap[slavingTrackingMapKey])
        	{
        		slavingTrackingMap[slavingTrackingMapKey].push(slavingId);
	        }
	        else
	        {
        		slavingTrackingMap[slavingTrackingMapKey] = [slavingId];
	        }
	    }
	    this.addToSlavingSet = addToSlavingSet;

	    function removeFromSlavingSet(sublistId, fieldId, lineInstanceId, slavingId)
	    {
		    var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId, fieldId);
		    var slavingQueue = slavingTrackingMap[slavingTrackingMapKey];
		    var i = slavingQueue.indexOf(slavingId);
		    if (i !== -1) slavingQueue.splice(i, 1);
		    if (!!slavingQueue && slavingQueue.length === 0)
		    {
			    delete slavingTrackingMap[slavingTrackingMapKey];
		    }
		    if (!!lineInstanceId && isSelectedLineCommittable(lineInstanceId))
		    {
			    emitLineIsCommittableEvent(sublistId, lineInstanceId);
		    }
		    if (isRecordSavable())
		    {
			    emitRecordIsSavableEvent();
		    }
	    }
	    this.removeFromSlavingSet = removeFromSlavingSet;

	    function isSelectedLineCommittable(lineInstanceId)
	    {
	    	var slavingTrackingMapKey = getSlavingTrackingMapKey(lineInstanceId);
	    	return slavingTrackingMap[slavingTrackingMapKey] ? (slavingTrackingMap[slavingTrackingMapKey].length === 0) : true;
	    }
	    this.isSelectedLineCommittable = isSelectedLineCommittable;

	    function addToScriptSet()
	    {
		    if (isRecordSavable())
		    {
			    emitRecordIsNotSavableEvent();
		    }
		    var serial = scriptTrackingNextSerial++;
		    scriptTrackingArray.push(serial);
		    return serial;
	    }
	    this.addToScriptSet = addToScriptSet;

	    function removeFromScriptSet(serial)
	    {
		    var index = scriptTrackingArray.indexOf(serial);
		    if (index === -1)
		    {
			    return;
		    }
		    scriptTrackingArray.splice(index, 1);
		    if (isRecordSavable())
		    {
			    emitRecordIsSavableEvent();
		    }
	    }
	    this.removeFromScriptSet = removeFromScriptSet;

	    this.trackScript = function trackScript(callback)
	    {
	    	var serial = addToScriptSet();
	        return resultObject.create(function ()
	        {
	        	return callback();
	        })['finally'](function (result)
	        {
	        	removeFromScriptSet(serial);
	        	return result;
	        });
	    };

	    function isRecordSavable()
	    {
	    	return JSON.stringify(slavingTrackingMap) === "{}" && scriptTrackingArray.length === 0;
	    }
	    this.isRecordSavable = isRecordSavable;

	    function getSlavingTrackingMapKey(lineInstanceId, fieldId)
	    {
	    	if (!!lineInstanceId)
	    	{
	    		return "line" + "_" + lineInstanceId;
		    }
		    else if (fieldId)
		    {
	    		return "body" + "_" + fieldId;
		    }
		    else
		    {
	    		return null;
		    }
	    }
	    this.getSlavingTackingMapKey = getSlavingTrackingMapKey;


	    function emitLineIsCommittableEvent(sublistId, lineInstanceId)
	    {
	    	_model.emitLineIsCommittableEvent(sublistId, lineInstanceId);
	    }
	    this.emitLineIsCommittableEvent = emitLineIsCommittableEvent;

	    function emitLineIsNotCommittableEvent(sublistId, lineInstanceId)
	    {
		    _model.emitLineIsNotCommittableEvent(sublistId, lineInstanceId);
	    }
	    this.emitLineIsNotCommittableEvent = emitLineIsNotCommittableEvent;

	    function emitRecordIsSavableEvent()
	    {
		    _model.emitRecordIsSavableEvent();
	    }
	    this.emitRecordIsSavableEvent = emitRecordIsSavableEvent;

	    function emitRecordIsNotSavableEvent()
	    {
		    _model.emitRecordIsNotSavableEvent();
	    }
	    this.emitRecordIsNotSavableEvent = emitRecordIsNotSavableEvent;

	    function isSaveRecordScriptTriggered()
	    {
	    	return saveRecordScriptTriggered;
	    }
	    this.isSaveRecordScriptTriggered = isSaveRecordScriptTriggered;

	    function setSaveRecordScriptTriggered()
	    {
	    	saveRecordScriptTriggered = true;
	    }
	    this.setSaveRecordScriptTriggered = setSaveRecordScriptTriggered;

	    function unsetSaveRecordScriptTriggered()
	    {
	    	saveRecordScriptTriggered = false;
	    }
	    this.unsetSaveRecordScriptTriggered = unsetSaveRecordScriptTriggered;

        /**
         * return cache of selec options
         * @returns {RecordCacheController}
         */
        function getSelectOptionCache()
        {
            return selectOptionsCache;
        }
        this.getSelectOptionCache = getSelectOptionCache;

	    /**
	     * cache select options
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {object} options
	     * @param {boolean} isCommitted
	     */
	    function cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, options, isCommitted)
        {
            selectOptionsCache.put(sublistId, fieldId, lineInstanceId, options, isCommitted);
        }
        this.cacheSelectOptionsForInstance = cacheSelectOptionsForInstance;

	    /**
	     * cache record field object
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {RecordField} field
	     * @param {boolean} isCommitted
	     */
        function cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted)
        {
            fieldObjectCache.put(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheRecordFieldForInstance = cacheRecordFieldForInstance;

	    /**
	     * get cached record field object
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {RecordField|null} field
	     */
        function getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return fieldObjectCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getRecordfieldForInstance = getRecordfieldForInstance;

	    /**
	     * cache user field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {object} field
	     * @param {boolean} isCommitted
	     */
        function cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, field, isCommitted)
        {
            userFieldCache.put(sublistId, fieldId, lineInstanceId, field, isCommitted);
        }
        this.cacheUserFieldForInstance = cacheUserFieldForInstance;

	    /**
	     * get cached user field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {*} field
	     */
        function getUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return userFieldCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.getUserFieldForInstance = getUserFieldForInstance;

	    /**
	     * contain cached user field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return userFieldCache.has(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasUserFieldForInstance = hasUserFieldForInstance;

	    /**
	     * cache subrecrd object
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {RawRecord} subrecordObj
	     * @param {boolean} isCommitted
	     */
        function doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, subrecordObj, isCommitted)
        {
            subrecordCache.put(sublistId, fieldId, lineInstanceId, subrecordObj, isCommitted);
        }

        /**
        * get cached subrecrd object
        * @param {string|null} sublistId
        * @param {string} fieldId
        * @param {string|null} lineInstanceId
        * @param {boolean} isCommitted
        * @returns {RawRecord|null} subrecordObj
        */
        function doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return subrecordCache.get(sublistId, fieldId, lineInstanceId, isCommitted);
        }

	    /**
	     * check if value exists for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function _doHasValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, isCommitted,
                hasFieldValue, hasSublistLineValueForInstance);
        }

	    /**
	     * check if value exists for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {number|null} line
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     * @deprecated - should be accessed by lineInstance
	     */

	    /**
	     * get value for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function _doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return recordUtil.executeRecordGetterFunctionsForInstance(
                sublistId, fieldId, lineInstanceId, isCommitted,
                getFieldValue, getSublistLineValueForInstance);
        }

	    /**
	     * get value for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {number|null} line
	     * @param {boolean} isCommitted
	     * @returns {string|Number|Boolean|Date|Array|null}
	     * @deprecated - should be accessed by lineInstance
	     */
	    /**
	     * check if subrecord exists for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {string|Number|Boolean|Date|Array|null}
	     */
        function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			if (!cachedSubrecord && !isCommitted)
			{
				cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, true);
			}

            var hasSubrecord = !!cachedSubrecord && cachedSubrecord.subrecord !== null;

            if(!hasSubrecord && _doHasValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
            {
                hasSubrecord = !!_doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            }

            return hasSubrecord;
        }

	    /**
	     * get subrecord for body or line field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {RawRecord} subrecord
	     */
        function doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            var cachedSubrecord = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

            return !!cachedSubrecord ? cachedSubrecord.subrecord : null;
        }
	    this.doGetSubrecordForInstance = doGetSubrecordForInstance;

	    /**
	     * set subrecord for body field, sublist field, or current sublist field
	     * @param {string|null} sublistId
	     * @param {string} fieldId
	     * @param {string|null} lineInstanceId
	     * @param {boolean} isCommitted
	     * @param {RawRecord} subrecord
	     */
        function doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord)
        {
            var cachedEntry = doGetCachedSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
            if(!cachedEntry)
            {
                cachedEntry = {};
                var existingSubrecordId = parseInt(_doGetValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted));
                var isValidRecordId = !isNaN(existingSubrecordId);

                if(isValidRecordId)
                {
                    cachedEntry.deleteId = existingSubrecordId;
                }

                doCacheSubrecordForInstance(sublistId, fieldId, lineInstanceId, cachedEntry, isCommitted);
            }
            cachedEntry.subrecord = subrecord;

            if(!!subrecord)
            {
                var subrecordSystemId = subrecord.doGetValue(subrecordUtil.SYS_ID);
                if(!subrecordSystemId || subrecordSystemId === "0")
                {
                    var sys_id = subrecordUtil.getNextSysId(subrecord.isNewRecord());
                    subrecord.internalSetFieldValue(subrecordUtil.SYS_ID, sys_id);
                    updateDependentSysIds();
                }
                if(!subrecord.doGetValue(subrecordUtil.SYS_PARENT_ID))
                {
                    var systemParentId = String(_doGetValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, isCommitted));
                    subrecord.internalSetFieldValue(subrecordUtil.SYS_PARENT_ID, systemParentId);
                }
            }

            var isCurrentSublistSubrecord = !isCommitted && isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
            if(!isCurrentSublistSubrecord)
            {
                var parentSystemId = getParentSystemIdForInstance(sublistId, lineInstanceId);

                subrecordTracker[parentSystemId] = subrecordTracker[parentSystemId] || {};
                subrecordTracker[parentSystemId][fieldId] = { isDeleted: !subrecord };
            }
        }

	    /**
	     * check whether a new subrecord exists for given body field
	     * @param {string} systemId
	     * @param {string} fieldId
	     * @returns {boolean}
	     */
        function hasNewlyCommittedSublistSubrecord(systemId, fieldId)
        {
            return subrecordTracker.hasOwnProperty(systemId)
                   && subrecordTracker[systemId][fieldId]
                   && !subrecordTracker[systemId][fieldId].isDeleted;
        }
        this.hasNewlyCommittedSublistSubrecord = hasNewlyCommittedSublistSubrecord;

        function getParentSystemIdForInstance(sublistId, lineInstanceId, isCommitted)
        {
	        if(isCommitted === undefined) isCommitted = true; // this is added to maintain old behavior, after renaming useBuffer to isCommitted.

            var sys_parent_id = !!sublistId ?
                    getSublistSystemIdForInstance(sublistId, lineInstanceId, isCommitted) :
                    getSystemId();

            return sys_parent_id;
        }
        this.getParentSystemIdForInstance = getParentSystemIdForInstance;

        function getSystemId()
        {
            return getFieldValue(subrecordUtil.SYS_ID);
        }
        this.getSystemId = getSystemId;

        function getSublistSystemIdForInstance(sublistId, lineInstanceId, isCommitted)
        {
            return getSublistLineValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, isCommitted);
        }
        this.getSublistSystemIdForInstance = getSublistSystemIdForInstance;

        function updateDependentSysIds()
        {
            //TODO: update sublist lines sys_parentid field
        }

        /**
         * return true if field has a subrecord instance
         * @param {string} fieldId
         * @returns {boolean}
         */
        function hasSubrecord(fieldId)
        {
            return doHasSubrecordForInstance(null, fieldId, null, false);
        }
        this.hasSubrecord = hasSubrecord;

        /**
         * return the subrecord instance of given field
         * @param {string} fieldId
         * @returns {*}
         */
        function getSubrecord(fieldId)
        {
            return doGetSubrecordForInstance(null, fieldId, null, false);
        }
        this.getSubrecord = getSubrecord;

        /**
         * update the subrecord instance of the given field
         * @param {string} fieldId
         * @param {*} subrecord
         */
        function cacheSubrecord(fieldId, subrecord)
        {
            return doSetSubrecordForInstance(null, fieldId, null, false, subrecord);
        }
        this.cacheSubrecord = cacheSubrecord;

	    /**
	     * return true if sublist field has a subrecord instance
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @returns {boolean}
	     */
        function hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.hasSublistSubrecordForInstance = hasSublistSubrecordForInstance;

	    /**
	     * cache subrecord instance of given sublist line field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     * @param {RawRecord} subrecord
	     */
        function cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord)
        {
            return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
        }
        this.cacheSublistSubrecordForInstance = cacheSublistSubrecordForInstance;

	    /**
	     * clear subrecord cache of given sublist line field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     */
        function clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
	        return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, null);
        }
	    this.clearSubrecordCacheForInstance = clearSubrecordCacheForInstance;	    

	    /**
	     * invalidate subrecord cache of given sublist line field
	     * @param {string} sublistId
	     * @param {string} fieldId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     */
        function invalidateSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
        {
            subrecordCache.invalidate(sublistId, fieldId, lineInstanceId, isCommitted);
        }
        this.invalidateSublistSubrecordForInstance = invalidateSublistSubrecordForInstance;

        /**
         * update the subrecord instance of the current sublist field
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {RawRecord} subrecord
         */
        function setCurrentSublistSubrecord(sublistId, fieldId, subrecord)
        {
	        var lineInstanceId = getSublistSelectedLineInstanceId(sublistId);
            return doSetSubrecordForInstance(sublistId, fieldId, lineInstanceId, false, subrecord);
        }
        this.setCurrentSublistSubrecord = setCurrentSublistSubrecord;

        function getData()
        {
            return _model.getData();
        }
        this.getData = getData;

        function getSublistData()
        {
            return _model.getSublistData();
        }
        this.getSublistData = getSublistData;

        function getSubrecordDataForSubmission()
        {
            return _model.getSubrecordDataForSubmission();
        }
        this.getSubrecordDataForSubmission = getSubrecordDataForSubmission;

        function clone()
        {
            return new ModelController({
                metadata: options.metadata,
                data: _model.getClonedData(),
	            getIsNSERecord: options.getIsNSERecord
            });
        }
        this.clone = clone;

	    /**
	     * abandon buffered sublist subrecord cache entries
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     */
        function abandonBufferedSublistSubrecordCacheEntries(sublistId, lineInstanceId)
        {
            var fields = subrecordCache.fields(sublistId, lineInstanceId, false);
            fields.forEach(function(fieldId){
                var entry = subrecordCache.get(sublistId, fieldId, lineInstanceId, false);
                var subrecord = entry ? entry.subrecord : null;
                if(subrecord != null)
                {
                    subrecord.abandon();
                }
            });
        }

	    /**
	     * get sublist line as json
	     * @param {string} sublistId
	     * @param {string} lineInstanceId
	     * @param {boolean} isCommitted
	     */
	    function getSublistLineJSON(sublistId, lineInstanceId, isCommitted)
	    {
		    return _model.getSublistLineJSON(sublistId, lineInstanceId, isCommitted);
	    }
	    this.getSublistLineJSON = getSublistLineJSON;

        /**
         * retrieve the select option text from the cache by value
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         */
        function getSelectOptionTextFromCache(sublistId, fieldId, value)
        {
            return _model.getSelectOptionTextFromCache(sublistId, fieldId, value);
        }
        this.getSelectOptionTextFromCache = getSelectOptionTextFromCache;

        /**
         * cache the option text into cache
         * @param {string} sublistId
         * @param {string} fieldId
         * @param {string} value
         * @param {string} text
         */
        function cacheSelectOptionText(sublistId, fieldId, value, text)
        {
            _model.cacheSelectOptionText(sublistId, fieldId, value, text);
        }
        this.cacheSelectOptionText = cacheSelectOptionText;

        function on(options)
        {
            _model.on(options);
        }
        this.on = on;

        function off(options)
        {
            _model.off(options);
        }
        this.off = off;

        return this;
    }

    return {
        /**
         * return a new instance of ModelController
         * @param {Object} options
         * @param {Metadata} options.metadata record metadata
         * @param {RecordDataObject} options.data record data
         * @param {Function} options.getIsNSERecord
         * @returns {ModelController}
         */
        create: function create(options){
            return new ModelController(options);
        },
        /**
         * return true if object is an instance of ModelController
         * @param {Object} obj
         * @returns {boolean}
         */
        isInstance: function(obj) { return obj instanceof ModelController; }
    };
});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/dynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define(
	'N/record/dynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/util/validator', 'N/resultObject'],
	function (recordUtil, utilityFunctions, validator, resultObject)
	{
		/**
		 * Dynamic Record Implementation for record behavior
		 * @param {RawRecord} record
		 * @constructor
		 */
		function DynamicRecordImpl(record)
		{
			var that = this;
			var undef = undefined;
			var getRecordScriptingScope = record.getRecordScriptingScope;

			var returnRecord = utilityFunctions.thenableFunction(function returnRecord()
			{
				return record;
			});

			function isDynamic() { return true; }

			this.isDynamic = isDynamic;

			this.validateTextApi = recordUtil.no_op_function;

			function getLineInstanceId(sublistId, line)
			{
				return record.getModelController().getSpecifiedLineInstanceIdByIndex(sublistId, line);
			}

			this.getLineInstanceId = getLineInstanceId;

			function shouldValidateFieldPermissions()
			{
				return 'T' === record.getRecordRequestContext().enablefieldpermissions && !record.isInternal();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function validateLineIndex(lineNumberIndex, lowerBoundInclusive, upperBoundExclusive)
			{
				lineNumberIndex = parseInt(lineNumberIndex, 10);
				recordUtil.assertValidSublistOperation(lowerBoundInclusive <= lineNumberIndex && lineNumberIndex < upperBoundExclusive);
			}

			this.validateLineIndex = validateLineIndex;

			var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
			{
				return delegator.getTextValue.thenable(fieldId, isAsync);
			}, {
				isAsyncArgIndex: 2
			});

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return delegator.getParsedValue(fieldId, true);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting, isAsync)
			{
				value = recordUtil.emptyIfNullOrUndefined(value);
				if (record.isFieldMultiSelect(undef, fieldId))
					value = recordUtil.formatValueToArrayType(value);
				else if (record.isFieldRadio(undef, fieldId))
					value = String(value);
				return resultObject.create(function ()
				{
					return noValidationAndFormatting ? value : record.validateAndFormatFieldValueForInstance.thenable(undef, fieldId, undef, value, isInteractive, allowPercentage, isAsync);
				}).then(function (validatedValue)
				{
					return record.doSetFieldValue.thenable(fieldId, validatedValue, fireFieldChange, noSlaving, undefined, noValidationAndFormatting, isAsync);
				});
			}, {
				isAsyncArgIndex: 7
			});

			this.doSetValue = doSetValue;

			var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isInteractive, isAsync)
			{
				var value, recordField;
				noSlaving = !!noSlaving;
				noValidationAndFormatting = !!noValidationAndFormatting;
				return resultObject.create(function ()
				{
					if (record.isFieldMultiSelect(undef, fieldId))
					{
						var texts = recordUtil.formatValueToArrayType(text);
						return record.doSetTexts.thenable(fieldId, texts, fireFieldChange, noSlaving, noValidationAndFormatting, isAsync);
					}
					else if (record.isFieldSelectType(undef, fieldId))
					{
						return resultObject.create(function ()
						{
							value = "";
							var unwrappedText = recordUtil.formatArrayToStringType(text);
							if (unwrappedText || unwrappedText === "")
							{
								recordField = record.getCachedRecordFieldForInstance(undef, fieldId, undef, undef);
								value = (isAsync ? recordField.validateSelectFieldByText.promise : recordField.validateSelectFieldByText)(text);
							}
							return value;
						}).then(function (value)
						{
							return record.doSetFieldValue.thenable(fieldId, value, fireFieldChange, noSlaving, true, noValidationAndFormatting, isAsync);
						});
					}
					else if (record.isFieldRadio(undef, fieldId))
					{
						var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
						value = validator.validateRadioFieldByText(fieldId, text, fieldLevelMetadata.radioSet);
						return record.doSetFieldValue.thenable(fieldId, value, fireFieldChange, noSlaving, true, noValidationAndFormatting, isAsync);
					}
					else
					{
						if (record.isFieldCheckbox(undef, fieldId)) {
							validator.validateCheckBoxField(fieldId, text);
							text = "" + text; // to keep legacy behavior where only "T" is accepted as true by parser
						}
						var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
						value = recordUtil.parseValue(record.isValidBodyField(fieldId), fieldLevelMetadata, text);
						return record.doSetValue.thenable(fieldId, value, fireFieldChange, noSlaving, isInteractive, true, noValidationAndFormatting, isAsync);
					}
				}).then(function ()
				{
					record.getFieldState(fieldId).useTextApi = true;
				});
			}, {
				isAsyncArgIndex: 6
			});

			this.doSetText = doSetText;

			var validateAndFormatFieldValueForInstance = utilityFunctions.thenableFunction(function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, value, isInteractive, allowPercentage, isAsync)
			{
				if (record.isValidField(sublistId, fieldId))
				{
					var field = record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, false);
					value = (isAsync ? field.validateAndFormatFieldValue.promise : field.validateAndFormatFieldValue)(value, isInteractive, allowPercentage);
				}

				return value;
			}, {
				isAsyncArgIndex: 6
			});

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			var getSublistSubrecord = utilityFunctions.thenableFunction(function getSublistSubrecord(sublistId, fieldId, line, proxyOptions, isAsync)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line);
				return record.doGetSublistSubrecordForInstance.thenable(sublistId, fieldId, lineInstanceId, true, record.getIsReadOnlyRecord(), proxyOptions, isAsync);
			}, {
				isAsyncArgIndex: 4
			});
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return delegator.getParsedValue(fieldId, true);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			var setSublistValue = utilityFunctions.thenableFunction(function setSublistValue(options, isAsync)
			{
				utilityFunctions.checkArgs([options], ['options'], record.getMissingArgumentErrorMessageFillerValue("setSublistValue"));
				var sublistId = options.sublistId;
				var fieldId = options.fieldId;
				var lineInstanceId = options.lineInstanceId;
				var line = options.line;
				var value = options.value;

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setSublistValue"));
				utilityFunctions.checkMutuallyExclusiveArguments(lineInstanceId, line, 'lineInstanceId', 'line');
				utilityFunctions.checkArgsDefined([value], ['value'], record.getMissingArgumentErrorMessageFillerValue('setSublistValue'));
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				if (!lineInstanceId && line >= 0) {
					lineInstanceId = record.getModelController().getCommittedLineInstanceIdByIndex(sublistId, line);
				}

				return resultObject.create(function () {
					return record.doSetSublistValueForInstance.thenable(sublistId, fieldId, lineInstanceId, true, value);
				}).then(function () {
					if (record.doGetCurrentSublistLineInstanceId(sublistId) === lineInstanceId) {
						return record.doSetSublistBufferValue.thenable(sublistId, fieldId, lineInstanceId, value, false, true, undefined, undefined, undefined, isAsync);
					}
				}).then(function () {
					var fs = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true);
					fs.useTextApi = false;
					fs.isParsed = false;
					return record;
				});
			}, {
				isAsyncArgIndex: 1
			});

			this.setSublistValue = setSublistValue;

			var doGetSublistTextForInstance = utilityFunctions.thenableFunction(function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator, isAsync)
			{
				return delegator.getTextValueForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, isAsync);
			}, {
				isAsyncArgIndex: 5
			});

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			this.setSublistText = returnRecord;


			var preInsertLineForInstance = utilityFunctions.thenableFunction(function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				var selectedInstanceId = beforeLineInstanceId;
				return resultObject.create(function ()
				{
					if (!record.isMultilineEditable(sublistId))
					{
						if (record.doGetCurrentSublistLineInstanceId(sublistId) !== beforeLineInstanceId &&
							record.getModelController().isSublistLineInstanceIdValid(sublistId, beforeLineInstanceId, true))
						{
							return record.doSelectLineForInstance.thenable(sublistId, beforeLineInstanceId);
						}
						else
						{
							if (record.getSublistState(sublistId).isLineInsertedForInstance(beforeLineInstanceId, true))
							{
								return resultObject.create(function ()
								{
									return record.doRemoveSublistLineForInstance.thenable(sublistId, beforeLineInstanceId);
								}).then(function (removedLineIndex)
								{
									record.getSublistState(sublistId).removeSublistLineState(beforeLineInstanceId, false);
									selectedInstanceId = getLineInstanceId(sublistId, removedLineIndex);
								});
							}
						}
					}
				}).then(function ()
				{
					return record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, selectedInstanceId, record.triggerValidateInsertScript.thenable, record, [sublistId, selectedInstanceId]);
				});
			});

			this.preInsertLineForInstance = preInsertLineForInstance;

			var postInsertLineForInstance = utilityFunctions.thenableFunction(function postInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				return resultObject.create(function ()
				{
					return record.triggerRecalcScript.thenable(sublistId, false, {operation: 'insert'}, ignoreRecalc);
				}).then(function ()
				{
					record.doResetCommittedLineForInstance(sublistId, lineInstanceId, record.getMetadata().getSublistDefaultValue(sublistId));
					record.getSublistState(sublistId).updateBufferLineStateForInstance(lineInstanceId);
					if(!record.isMultilineEditable(sublistId))
					{
						return record.doSelectLineForInstance.thenable(sublistId, lineInstanceId);
					}
				});
			});

			this.postInsertLineForInstance = postInsertLineForInstance;

			var removeSublistLineForInstance = utilityFunctions.thenableFunction(function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc, noValidation)
			{
				return resultObject.create(function ()
				{
					if (!record.isMultilineEditable(sublistId))
					{
						if (record.doGetCurrentSublistLineInstanceId(sublistId) !== lineInstanceId)
						{
							return record.doSelectLineForInstance.thenable(sublistId, lineInstanceId);
						}
					}
				}).then(function ()
				{
					if (!noValidation) {
						return record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, record.triggerValidateDeleteScript.thenable, record, [sublistId, lineInstanceId, ignoreRecalc, noValidation]);
					}
				}).then(function ()
				{
					return record.doRemoveSublistLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc);
				}).then(function (removedLineIndex)
				{
					return resultObject.create(function ()
					{
						if (removedLineIndex !== -1) {
							record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, record.getLineInstanceId(sublistId, removedLineIndex), record.triggerTotalingScript.thenable, record, [sublistId, null, {lineInstanceId: lineInstanceId, lineIndex: removedLineIndex, operation:'remove'}]);
						}
					}).then(function ()
					{
						return removedLineIndex;
					});
				});
			});

			this.removeSublistLineForInstance = removeSublistLineForInstance;

			var postRemoveLineForInstance = utilityFunctions.thenableFunction(function postRemoveLineForInstance(sublistId, removedLineIndex)
			{
				return resultObject.create(function ()
				{
					if (!record.isMultilineEditable(sublistId))
					{
						if (removedLineIndex !== -1 && (removedLineIndex < record.doGetLineCount(sublistId)))
							return record.doSelectLineForInstance.thenable(sublistId, getLineInstanceId(sublistId, removedLineIndex));
						else
							return record.doSelectNewLine.thenable(sublistId);
					}
				}).then(function ()
				{
					if (removedLineIndex !== -1)
					{
						return triggerPostDeleteLineScript.thenable(sublistId, getLineInstanceId(sublistId, removedLineIndex));
					}
				});
			});

			this.postRemoveLineForInstance = postRemoveLineForInstance;

			var addNewLine = utilityFunctions.thenableFunction(function addNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("addLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				return record.doAddNewLine.thenable(sublistId);
			});

			this.addNewLine = addNewLine;

			var selectLine = utilityFunctions.thenableFunction(function selectLine(options, line)
			{
				var sublistId, lineInstanceId;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;

					utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');
				}

				if (line != null)
				{
					utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], record.getMissingArgumentErrorMessageFillerValue("selectLine"));
					lineInstanceId = record.getLineInstanceId(sublistId, line);
				}
				else
				{
					utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], record.getMissingArgumentErrorMessageFillerValue('selectLine'));
				}

				return resultObject.create(function ()
				{
					return record.doSelectLineForInstance.thenable(sublistId, lineInstanceId);
				}).then(function (lineObj)
				{
					return record.isMultilineEditable(sublistId) ? lineObj : record;
				});
			});

			this.selectLine = selectLine;

			var selectNewLine = utilityFunctions.thenableFunction(function selectNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', record.getMissingArgumentErrorMessageFillerValue("selectNewLine"));
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId));
				return resultObject.create(function ()
				{
					return record.doSelectNewLine.thenable(sublistId);
				}).then(function (lineObj)
				{
					return record.isMultilineEditable(sublistId) ? lineObj : record;
				});
			});

			this.selectNewLine = selectNewLine;

			var cancelLineForInstance = utilityFunctions.thenableFunction(function cancelLineForInstance(sublistId, lineInstanceId)
			{
				recordUtil.assertValidSublistOperation(record.isSublistAnEditMachine(sublistId) && lineInstanceId);
				return record.doCancelLineForInstance.thenable(sublistId, lineInstanceId);
			});

			this.cancelLineForInstance = cancelLineForInstance;

			var commitLineForInstance = utilityFunctions.thenableFunction(function commitLineForInstance(sublistId, lineInstanceId, ignoreRecalc, isAsync)
			{
				recordUtil.assertValidSublistOperation(record.isSublistEditable(sublistId) && lineInstanceId);
				ignoreRecalc = !!ignoreRecalc;
				return record.doCommitLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc, isAsync);
			}, {
				isAsyncArgIndex: 3
			});

			this.commitLineForInstance = commitLineForInstance;

			function getCurrentSublistValue(options, fieldId)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistValue"));

				var lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				if (lineInstanceId) {
					var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, false);
					return lineDefinitionObject.getParsedValueForBodyField(fieldId);
				}
				return null;
			}

			this.getCurrentSublistValue = getCurrentSublistValue;

			var setCurrentSublistValue = utilityFunctions.thenableFunction(function setCurrentSublistValue(options, fieldId, value, proxyOptions, isAsync)
			{
				var sublistId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistValue"));
				utilityFunctions.checkArgsDefined([value], ['value'], record.getMissingArgumentErrorMessageFillerValue('setCurrentSublistValue'));
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				var lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				return record.withForceSyncSourcing(sublistId, fieldId, forceSyncSourcing, function ()
				{
					return record.doSetSublistBufferValue.thenable(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, record.getIsInteractive(proxyOptions), undefined, undefined, isAsync);
				}).then(function ()
				{
					return record;
				});
			}, {
				isAsyncArgIndex: 4
			});

			this.setCurrentSublistValue = setCurrentSublistValue;

			var getCurrentSublistText = utilityFunctions.thenableFunction(function getCurrentSublistText(options, fieldId, isAsync)
			{
				var sublistId;
				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("getCurrentSublistText"));

				var lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				var lineDefinitionObject = record.getLineObjectFromCache(sublistId, lineInstanceId, false);
				return lineDefinitionObject.doGetText.thenable(fieldId, undefined, isAsync);
			}, {
				isAsyncArgIndex: 2
			});

			this.getCurrentSublistText = getCurrentSublistText;

			var setCurrentSublistText = utilityFunctions.thenableFunction(function setCurrentSublistText(options, fieldId, text, proxyOptions, isAsync)
			{
				var sublistId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], record.getMissingArgumentErrorMessageFillerValue("setCurrentSublistText"));
				utilityFunctions.checkArgsDefined([text], ['text'], record.getMissingArgumentErrorMessageFillerValue('setCurrentSublistText'));
				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				return record.withForceSyncSourcing(sublistId, fieldId, forceSyncSourcing, function ()
				{
					return record.doSetSublistTextForInstance(sublistId, fieldId, record.doGetCurrentSublistLineInstanceId(sublistId), false, text, fireFieldChange, noSlaving, false, record.getIsInteractive(proxyOptions), isAsync);
				}).then(function ()
				{
					return record;
				});
			}, {
				isAsyncArgIndex: 4
			});

			this.setCurrentSublistText = setCurrentSublistText;

			var preSetFieldValueForInstance = utilityFunctions.thenableFunction(function preSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, valueObject, fireFieldChange, noSlaving, noValidation)
			{
				return resultObject.create(function () {
					if (sublistId && (record.isSublistAListMachine(sublistId) || record.isMultilineEditable(sublistId)))
					{
						if (!noValidation && record.getIsNSERecord())
						{
							return record.getModelController()
								.runFunctionWhileSilentlySelectingLine
								.thenable(sublistId, lineInstanceId, record.triggerValidateFieldScript.thenable, record, [sublistId, fieldId, lineInstanceId, isCommitted, valueObject]);
						}
					}
					else
					{
						if (!noValidation && record.getIsNSERecord())
							return record.triggerValidateFieldScript.thenable(sublistId, fieldId, lineInstanceId, isCommitted, valueObject);
					}
				});
			});

			this.preSetFieldValueForInstance = preSetFieldValueForInstance;

			var postSetFieldValueForInstance = utilityFunctions.thenableFunction(function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation, isAsync)
			{
				var internalFieldChangeScriptFieldId = 'nlapiFC';
				if (fireFieldChange === undef)
					fireFieldChange = true;

				if (noSlaving === undef)
					noSlaving = false;

				var nlapiFCValue = null;
				if (!fireFieldChange && !utilityFunctions.isValEmpty(record.doGetValue(internalFieldChangeScriptFieldId)) && !record.isInternal())
				{
					fireFieldChange = true;
					nlapiFCValue = record.getModelController().getFieldValue(internalFieldChangeScriptFieldId);
					record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: '', legacyStringValue: ''});
				}

				return resultObject.create(function ()
				{
					if (fireFieldChange)
					{
						if (sublistId && (record.isSublistAListMachine(sublistId) || record.isMultilineEditable(sublistId)))
						{
							return resultObject.create(function ()
							{
								if (!noValidation && !record.getIsNSERecord())
									return record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, record.triggerValidateFieldScript.thenable, record, [sublistId, fieldId, lineInstanceId, isCommitted, null]);
							}).then(function ()
							{
								return record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, record.triggerFieldChangeEvent.thenable, record, [sublistId, fieldId, lineInstanceId, isCommitted, dbValue, noSlaving, isAsync]);
							});
						}
						else
						{
							return resultObject.create(function ()
							{
								if (!noValidation && !record.getIsNSERecord())
									return record.triggerValidateFieldScript.thenable(sublistId, fieldId, lineInstanceId, isCommitted, null);
							}).then(function ()
							{
								return record.triggerFieldChangeEvent.thenable(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, noSlaving, isAsync);
							});
						}
					}
				}).then(function ()
				{
					if (!nlapiFCValue)
						record.getModelController().setFieldValue(internalFieldChangeScriptFieldId, {value: nlapiFCValue, legacyStringValue: ""});

					record.getLocaleContext().checkLocaleAndTriggerContextChange({sublistId:sublistId, fieldId:fieldId, valueGetter: record.getValue, lineCountGetter: record.getLineCount, lineValueGetter: record.getSublistValue});
				});
			}, {
				isAsyncArgIndex: 8
			});

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			var triggerFieldChangeEvent = utilityFunctions.thenableFunction(function triggerFieldChangeEvent(sublistId, fieldId, lineInstanceId, isCommitted, value, noSlaving, isAsync)
			{
				return resultObject.create(function ()
				{
					return record.triggerFieldChangeScript.thenable(sublistId, fieldId, lineInstanceId);
				}).then(function ()
				{
					if (!noSlaving)
					{
						return record.doSlaving.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, undefined, isAsync);
					}
				});
			}, {
				isAsyncArgIndex: 6
			});

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			var doProcessSlavingValues = utilityFunctions.thenableFunction(function doProcessSlavingValues(slaveValues, sublistId, fieldId, lineInstanceId, isAsync)
			{
				return resultObject.create(function ()
				{
					return record.applySlaveValues.thenable(postProcessSlaveValues(slaveValues, lineInstanceId), isAsync);
				}).then(function ()
				{
					return record.triggerCustomPostSourcingScript.thenable(sublistId, fieldId, lineInstanceId);
				});
			}, {
				isAsyncArgIndex: 4
			});

			var doSlaving = utilityFunctions.thenableFunction(function doSlaving(sublistId, fieldId, lineInstanceId, isCommitted, value, restrictField, isAsync)
			{
				var modelController = record.getModelController();
				var fieldLevelMetadata = sublistId == null ? record.getFieldLevelMetadataForBodyField(fieldId) : record.getFieldLevelMetadataForSublistField(sublistId, fieldId);
				var metadata = record.getSlavingMetadata(sublistId, fieldId);
				var clientMetadata = record.getClientSlavingMetadata(sublistId, fieldId);
				var forceSync = (metadata && metadata.forceSyncSlaving)
					|| !record.getIsCurrentRecord()
					|| record.isSyncSourcingForced(sublistId, fieldId)
					|| modelController.isSaveRecordScriptTriggered();
				var slavingId;

				var result = resultObject.create(function ()
				{
					if (metadata && metadata.noSlavingValue !== String(value) && String(value).indexOf(metadata.noSlavingPrefix) !== 0)
					{
						var fieldToSlave = (restrictField && typeof restrictField !== 'boolean') ? restrictField : 'T';
						var lineNum = record.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);
						var machine = sublistId;
						if (!sublistId && fieldLevelMetadata && fieldLevelMetadata.isMachineHeaderField && metadata.machine) {
							machine = metadata.machine;
						}
						var masterInfo = {queryFieldName: String(fieldId), queryFieldValue: String(value), sublistId: machine ? String(machine) : undef, fieldspec: fieldToSlave, lineNum: lineNum, lineInstanceId: lineInstanceId, isCommitted: isCommitted};

						if (isAsync || !forceSync)
						{
							slavingId = String(sublistId || '') + String(fieldId || '') + Date.now().toString();
							modelController.addToSlavingSet(sublistId, fieldId, lineInstanceId, slavingId);
						}
						return record.sendSlavingRequest.thenable(postProcessSlavingMetadata(metadata), masterInfo, isAsync || !forceSync);
					}
					else if (clientMetadata)
					{
						if (isAsync)
						{
							slavingId = String(sublistId || '') + String(fieldId || '') + Date.now().toString();
							modelController.addToSlavingSet(sublistId, fieldId, lineInstanceId, slavingId);
						}
						return recordUtil.getClientSlavingResultFromMetadata(clientMetadata, String(value), record.getClientSlavingMetadata);
					}
				}).then(function (slaveValues)
				{
					if (slaveValues)
					{
						if (sublistId && lineInstanceId)
						{
							return record.getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, doProcessSlavingValues.thenable, that, [slaveValues, sublistId, fieldId, lineInstanceId, isAsync]);
						}
						else
						{
							return doProcessSlavingValues.thenable(slaveValues, sublistId, fieldId, lineInstanceId, isAsync);
						}
					}
				})['finally'](function ()
				{
					if (slavingId)
					{
						modelController.removeFromSlavingSet(sublistId, fieldId, lineInstanceId, slavingId);
					}
				});

				if (forceSync)
				{
					return result;
				}
			}, {
				isAsyncArgIndex: 6
			});

			this.doSlaving = doSlaving;

			function postProcessSlavingMetadata(metadata)
			{
				var REQUIRED_SCRIPT = 'requiredScript';

				var auxfields = metadata['auxfields'];
				for (var idx = 0; auxfields && idx < auxfields.length; idx++)
				{
					var auxfld = auxfields[idx];
					if (auxfld.hasOwnProperty(REQUIRED_SCRIPT))
					{
						auxfld.isRequired = getRecordScriptingScope().runInternalScriptAndReturnBooleanResult(auxfld[REQUIRED_SCRIPT]);
					}
				}

				return metadata;
			}

			function postProcessSlaveValues(slaveValues, lineInstanceId)
			{
				var CONDITION = 'condition';

				for (var idx = 0; slaveValues.fields && idx < slaveValues.fields.length; idx++)
				{
					if (slaveValues.fields[idx].hasOwnProperty('machine'))
					{
						slaveValues.fields[idx].lineInstanceId = lineInstanceId;
					}
				}

				for (var idx = 0; slaveValues.body && idx < slaveValues.body.length; idx++)
				{
					if (slaveValues.body[idx].hasOwnProperty(CONDITION))
					{
						slaveValues.body[idx][CONDITION] = getRecordScriptingScope().runInternalScriptAndReturnBooleanResult(slaveValues.body[idx][CONDITION]);
					}
				}

				return slaveValues;
			}


			function triggerLocalizationContextChange() {
				record.getLocaleContext().triggerLocalizationContextChange();
			}

			this.triggerLocalizationContextChange = triggerLocalizationContextChange;

			var triggerLineInitScript = utilityFunctions.thenableFunction(function triggerLineInitScript(sublistId)
			{
				return getRecordScriptingScope().lineInit.thenable(sublistId);
			});

			this.triggerLineInitScript = triggerLineInitScript;

			var triggerPostDeleteLineScript = utilityFunctions.thenableFunction(function triggerPostDeleteLineScript(sublistId, lineInstanceId)
			{
				return getRecordScriptingScope().postDeleteLine.thenable(sublistId, lineInstanceId);
			});

			this.triggerPostDeleteLineScript = triggerPostDeleteLineScript;

			var triggerLineCommitScript = utilityFunctions.thenableFunction(function triggerLineCommitScript(sublistId, lineInstanceId)
			{
				return getRecordScriptingScope().lineCommit.thenable(sublistId, lineInstanceId);
			});

			this.triggerLineCommitScript = triggerLineCommitScript;

			var triggerValidateLineScript = utilityFunctions.thenableFunction(function triggerValidateLineScript(sublistId)
			{
				return getRecordScriptingScope().validateLine.thenable(sublistId);
			});

			this.triggerValidateLineScript = triggerValidateLineScript;

			var triggerValidateInsertScript = utilityFunctions.thenableFunction(function triggerValidateInsertScript(sublistId)
			{
				return getRecordScriptingScope().validateInsert.thenable(sublistId);
			});

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			var triggerValidateDeleteScript = utilityFunctions.thenableFunction(function triggerValidateDeleteScript(sublistId)
			{
				return getRecordScriptingScope().validateDelete.thenable(sublistId);
			});

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			var triggerValidateFieldScript = utilityFunctions.thenableFunction(function triggerValidateFieldScript(sublistId, fieldId, lineInstanceId, matrixColumn, valueObject)
			{
				return getRecordScriptingScope().validateField.thenable(sublistId, fieldId, lineInstanceId, matrixColumn, valueObject);
			});

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			var triggerFieldChangeScript = utilityFunctions.thenableFunction(function triggerFieldChangeScript(sublistId, fieldId, lineInstanceId, matrixColumn)
			{
				return getRecordScriptingScope().fieldChange.thenable(sublistId, fieldId, lineInstanceId, matrixColumn);
			});

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScript(sublistId, fieldId, lineInstanceId)
			{
				getRecordScriptingScope().canCreateSubrecord(sublistId, fieldId, lineInstanceId);
			}

			this.triggerCanCreateSubrecordScript = triggerCanCreateSubrecordScript;

			var triggerSaveRecordScript = utilityFunctions.thenableFunction(function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				return getRecordScriptingScope().saveRecord.thenable(ignoreMandatoryFields);
			});

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			var triggerRecalcScript = utilityFunctions.thenableFunction(function triggerRecalcScript(sublistId, localRecalc, options, ignoreRecalc)
			{
				return getRecordScriptingScope().recalc.thenable(sublistId, localRecalc, options, ignoreRecalc);
			});

			this.triggerRecalcScript = triggerRecalcScript;

			var triggerTotalingScript = utilityFunctions.thenableFunction(function triggerTotalingScript(sublistId, fieldId, options)
			{
				return getRecordScriptingScope().totaling.thenable(sublistId, fieldId, options);
			});

			this.triggerTotalingScript = triggerTotalingScript;

			function triggerMachinePostSourcing(postSourcingScript)
			{
				getRecordScriptingScope().postSublistSourcing(postSourcingScript);
			}

			this.triggerMachinePostSourcing = triggerMachinePostSourcing;

			var triggerCustomPostSourcingScript = utilityFunctions.thenableFunction(function triggerCustomPostSourcingScript(sublistId, fieldId, lineInstanceId)
			{
				return getRecordScriptingScope().postSourcing.thenable(sublistId, fieldId, lineInstanceId);
			});

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;

			function triggerSubrecordEvent(type, sublistId, fieldId, lineInstanceId, subrecord, isCommitted)
			{
				record.doTriggerSubrecordEvent(type, sublistId, fieldId, lineInstanceId, subrecord, isCommitted);
			}

			this.triggerSubrecordEvent = triggerSubrecordEvent;
		}

		/**
		 * create a dynamic record implementation that will supplement record behavior
		 * @param {RawRecord} record
		 * @returns {DynamicRecordImpl}
		 */
		function create(record)
		{
			return new DynamicRecordImpl(record);
		}

		return {
			create: create
		};
	});

/**
 * SuiteScript dynamic record impl
 *
 * @private
 * @module N/record/deferredDynamicRecordImpl
 * @NApiVersion 2.x
 *
 */
define('N/record/deferredDynamicRecordImpl',['N/record/recordUtilityFunctions', 'N/utilityFunctions', 'N/error', 'N/resultObject'],
	function(recordUtil, utilityFunctions, error, resultObject)
	{
		/**
		 * Deferred Dynamic Record Implementation for record behavior
		 * @param {RawRecord} record
		 * @constructor
		 */
		function DeferredDynamicRecordImpl(record)
		{
			var undef = undefined;

			var returnRecord = utilityFunctions.thenableFunction(function returnRecord()
			{
				return record;
			});

			this.shouldValidateFieldPermissions = recordUtil.no_op_function;

			function isUnchangedExistingRecord(fieldState)
			{
				return !record.isNewRecord() && !fieldState.isChanged;
			}

			function validateTextApi(isTextApi, fieldState, setterMethod, suggestedMethod)
			{
				if (((isTextApi && !fieldState.useTextApi) || (!isTextApi && fieldState.useTextApi)) && !isUnchangedExistingRecord(fieldState))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_API_USAGE, suggestedMethod, setterMethod);
				}
			}

			this.validateTextApi = validateTextApi;

			this.validateLineIndex = recordUtil.no_op_function;

			function isSublistAScriptableMachine(sublistId)
			{
				return record.getSublistMetadata(sublistId) && record.getSublistMetadata(sublistId).isScriptableMachine;
			}

			var insertLineIfNewLineAndGetNewInstanceId = utilityFunctions.thenableFunction(function insertLineIfNewLineAndGetNewInstanceId(sublistId, line)
			{
				var isScriptableOrEditable = (isSublistAScriptableMachine(sublistId) || record.isSublistAnEditMachine(sublistId));
				var allowInsertLine = line <= Math.max(record.doGetLineCount(sublistId), 0);
				return resultObject.create(function ()
				{
					if (isScriptableOrEditable && allowInsertLine)
						return record.doInsertLineForInstance.thenable(sublistId, null); // new line
				}).then(function ()
				{
					return getLineInstanceId(sublistId, line);
				});
			});

			function getLineInstanceId(sublistId, line)
			{
				var lineInstanceId = record.getModelController().getCommittedLineInstanceIdByIndex(sublistId, line);
				return lineInstanceId || null;
			}
			this.getLineInstanceId = getLineInstanceId;

			var getOrCreateLineInstanceId = utilityFunctions.thenableFunction(function getOrCreateLineInstanceId(sublistId, line, proxyOptions)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line);
				if (lineInstanceId === null && !record.getIsReadOnlyRecord(proxyOptions))
					lineInstanceId = insertLineIfNewLineAndGetNewInstanceId.thenable(sublistId, line);
				return lineInstanceId;
			});

			var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
			{
				var value = undef;
				var fieldState = record.getFieldState(fieldId);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValue.thenable(fieldId, isAsync);
				}
				else
					value = record.doGetValue(fieldId);

				return value;
			}, {
				isAsyncArgIndex: 2
			});

			this.doGetText = doGetText;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				var isFieldChange = record.getFieldState(fieldId).isChanged;
				if (!isFieldChange)
					return delegator.getParsedValue(fieldId, true);
				else
					return record.doGetValue(fieldId);
			}
			this.getParsedValueForBodyField = getParsedValueForBodyField;

			var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, noSlaving)
			{
				return record.doSetFieldValue.thenable(fieldId, value, false, true);
			});

			this.doSetValue = doSetValue;

			this.preSetFieldValueForInstance = recordUtil.no_op_function;

			this.postSetFieldValueForInstance = recordUtil.no_op_function;

			var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text)
			{
				var fireFieldChanged = false;
				var noSlaving = true;
				return resultObject.create(function ()
				{
					return record.doSetFieldValue.thenable(fieldId, text, fireFieldChanged, noSlaving);
				}).then(function ()
				{
					record.getFieldState(fieldId).useTextApi = true;
				});
			});

			this.doSetText = doSetText;

			this.validateAndFormatFieldValueForInstance = recordUtil.no_op_function;

			var getSublistSubrecord = utilityFunctions.thenableFunction(function getSublistSubrecord(sublistId, fieldId, line, proxyOptions, isAsync)
			{
				var lineInstanceId = getOrCreateLineInstanceId(sublistId, line, proxyOptions);
				return record.doGetSublistSubrecordForInstance.thenable(sublistId, fieldId, lineInstanceId, true, record.getIsReadOnlyRecord(), proxyOptions, isAsync);
			}, {
				isAsyncArgIndex: 4
			});
			this.getSublistSubrecord = getSublistSubrecord;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				var value = undef;
				var isFieldChanged = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true).isChanged;
				if (!isFieldChanged)
				{
					value = delegator.getParsedValue(fieldId, true);
				}
				else
				{
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, true);
				}

				return value;
			}
			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			var setSublistValue = utilityFunctions.thenableFunction(function setSublistValue(options, fieldId, line, value)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef && value != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistValue"));
				utilityFunctions.checkArgsDefined([value], ['value'], record.getMissingArgumentErrorMessageFillerValue('setSublistValue'));
				if (line < 0)
					return;
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				var lineInstaceId = getOrCreateLineInstanceId(sublistId, line);
				return resultObject.create(function ()
				{
					return record.doSetSublistValueForInstance.thenable(sublistId, fieldId, lineInstaceId, true, value);
				}).then(function ()
				{
					record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstaceId, true).useTextApi = false;
					return record;
				});
			});

			this.setSublistValue = setSublistValue;

			var doGetSublistTextForInstance = utilityFunctions.thenableFunction(function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator, isAsync)
			{
				var value = undef;
				var fieldState = record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true);
				if (isUnchangedExistingRecord(fieldState))
				{
					value = delegator.getTextValueForInstance.thenable(sublistId, fieldId, lineInstanceId, true, isAsync);
				}
				else
					value = record.doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, true);

				return value;
			}, {
				isAsyncArgIndex: 5
			});

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			var setSublistText = utilityFunctions.thenableFunction(function setSublistText(options, fieldId, line, text)
			{
				var sublistId;
				if (fieldId !== undef && line !== undef && text != undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
					text = options.text;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], record.getMissingArgumentErrorMessageFillerValue("setSublistText"));
				utilityFunctions.checkArgsDefined([text], ['text'], record.getMissingArgumentErrorMessageFillerValue('setSublistText'));
				recordUtil.validateAgainstSqlInjection(fieldId, text);
				var lineInstanceId = getOrCreateLineInstanceId(sublistId, line);
				return resultObject.create(function ()
				{
					return record.doSetSublistValueForInstance.thenable(sublistId, fieldId, lineInstanceId, true, text);
				}).then(function ()
				{
					record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true).useTextApi = true;
					return record;
				});
			});

			this.setSublistText = setSublistText;

			this.preInsertLineForInstance = recordUtil.no_op_function;
			this.postInsertLineForInstance = recordUtil.no_op_function;

			var removeSublistLineForInstance = utilityFunctions.thenableFunction(function removeSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				record.doRemoveSublistLineForInstance(sublistId, lineInstanceId);
			});

			this.removeSublistLineForInstance = removeSublistLineForInstance;

			this.doSlaving = recordUtil.no_op_function;

			this.postRemoveLineForInstance = recordUtil.no_op_function;

			this.addNewLine = recordUtil.no_op_function;

			this.selectLine = recordUtil.no_op_function;

			this.selectNewLine = recordUtil.no_op_function;

			this.cancelLineForInstance = recordUtil.no_op_function;

			this.commitLineForInstance = recordUtil.no_op_function;

			this.getCurrentSublistValue = recordUtil.no_op_function;

			this.setCurrentSublistValue = returnRecord;

			this.getCurrentSublistText = recordUtil.no_op_function;

			this.setCurrentSublistText = returnRecord;

			this.triggerFieldChangeEvent = recordUtil.no_op_function;

			this.triggerLocalizationContextChange = recordUtil.no_op_function;

			this.triggerLineInitScript = recordUtil.no_op_function;

			this.triggerPostDeleteLineScript = recordUtil.no_op_function;

			this.triggerLineCommitScript = recordUtil.no_op_function;

			this.triggerValidateLineScript = recordUtil.no_op_function;

			this.triggerValidateInsertScript = recordUtil.no_op_function;

			this.triggerValidateDeleteScript = recordUtil.no_op_function;

			this.triggerValidateFieldScript = recordUtil.no_op_function;

			this.triggerFieldChangeScript = recordUtil.no_op_function;

			this.triggerCanCreateSubrecordScript = recordUtil.no_op_function;

			this.triggerSaveRecordScript = recordUtil.no_op_function;

			this.triggerRecalcScript = recordUtil.no_op_function;

			this.triggerTotalingScript =recordUtil.no_op_function;

			this.triggerMachinePostSourcing = recordUtil.no_op_function;

			this.triggerCustomPostSourcingScript = recordUtil.no_op_function;

			this.triggerSubrecordEvent = recordUtil.no_op_function;
		}

		/**
		 * create a deferred dynamic record implementation that will supplement record behavior
		 * @param {RawRecord} record
		 * @returns {DeferredDynamicRecordImpl}
		 */
		function create(record)
		{
			return new DeferredDynamicRecordImpl(record);
		}

		return {
			create : create
		};
	});

/**
 * SuiteScript record impl factory
 *
 * @private
 * @module N/record/recordImplementation
 * @NApiVersion 2.x
 *
 */
define('N/record/recordImplementation',['N/record/dynamicRecordImpl', 'N/record/deferredDynamicRecordImpl'], function(dynamicRecordImpl, deferredDynamicRecordImpl){

	/**
	 * create the corresponding implementation for record object based on the record mode
	 * @param {boolean} isDynamicRecord
	 * @param {RawRecord} record object
	 * @returns {DeferredDynamicRecordImpl|DynamicRecordImpl}
	 */
    function create(isDynamicRecord, record)
    {
        return isDynamicRecord ? dynamicRecordImpl.create(record) : deferredDynamicRecordImpl.create(record);
    }

    return {
        create : create
    };
});
/**
 * SuiteScript nlobjrecord implementation for version 2 record
 *
 * @private
 * @module N/record/legacyNLObjects
 * @NApiVersion 2.x
 *
 */
define('N/record/legacyNLObjects',['N/restricted/remoteApiBridge', 'N/internal/invoker', 'N/utilityFunctions', 'N/runtime'],
function(remoteApi, invoker, utilityFunctions, runtime) {

	var getModule = (function() {
		var moduleCache = {};
		return function getRecordModule(name, isInternal)
		{
			if (!!moduleCache[name])
				return moduleCache[name];

			var wasSync = require.isSync();
			require.forceSync(true);
			var wasInternal = require.isInternal();
			if (!!isInternal) require.setInternal(true);
			try
			{
				require([name], function(rm) { moduleCache[name] = rm; });
			}
			finally
			{
				if (!!isInternal) require.setInternal(wasInternal);
				require.forceSync(wasSync);
			}
			return moduleCache[name];
		}
	})();

	var getRecordModule = getModule.bind(null, 'N/record', false);
	var getRecordImplModule = getModule.bind(null, 'N/record/recordImpl', true);
	var getRecordImplV1Module = getModule.bind(null, 'N/record/recordImplV1', true);

	var getRecordImplV1 = function(rawRecord) {
		if (!rawRecord) return null;
		var constructorName = utilityFunctions.getConstructorName(rawRecord);
		if (constructorName === 'RecordImplV1') return rawRecord;
		if (constructorName === 'Record') return getRecordImplV1Module().create({record: rawRecord});
		return null;
	};

	var nlobjRecordGetter = (function()
	{
		var nlobjRecord;
		return function nlobjRecordGetter()
		{
			if (!nlobjRecord)  // must be defined only once so the instanceOf works properly
			{
				nlobjRecord = function nlobjRecord(type, id) {
					this.type = type;
					this.id = id;
					this.fields = {};
					this.fieldnames = [];
					this.lineitems = [];
					this.linetypes = {};
					this.linefields = {};
					this.matrixfields = {};
					this.currentlineitems = {};
					this.currentlineitemindexes = {};
					this.initialized = false;
					this.operations = [];
				};
				nlobjRecord.prototype.getId = function () { return this.id; };
				nlobjRecord.prototype.getRecordType = function () { return this.type; };
				nlobjRecord.prototype.setFieldValue = function (name, value) {
					this.fields[name] = value;
					this.logOperation("setFieldValue", {"field": name, "value": value})
				};
				nlobjRecord.prototype.setFieldValues = function (name, values) {
					this.fields[name] = values;
					this.logOperation("setFieldValues", {"field": name, "value": values})
				};
				nlobjRecord.prototype.getFieldValue = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getFieldValues = function (name) { return !!this.fields[name] ? this.fields[name] : null; };
				nlobjRecord.prototype.getAllFields = function () {
					var s = [];
					for (var f in this.fields)
						if (this.fields.hasOwnProperty(f))
							s[s.length++] = f;
					for (var i = 0; i < this.fieldnames.length; i++)
						utilityFunctions.arrayAdd(s, this.fieldnames[i]);
					return s;
				};
				nlobjRecord.prototype.getAllLineItems = function () {
					var s = [];
					for (var f in this.lineitems)
						if (this.lineitems.hasOwnProperty(f))
							s[s.length++] = f;
					return s;
				};
				nlobjRecord.prototype.getAllLineItemFields = function (name) {
					var linegroup = this.linefields[name];
					if (!linegroup)
						return null;

					var s = [];
					for (var i = 0; i < this.linefields[name].length; i++)
						s[s.length++] = this.linefields[name][i];
					return s;
				};
				nlobjRecord.prototype.setLineItemValue = function (group, name, line, value) {
					assertTrue(line > 0 && line - 1 <= this.getLineItemCount(group), 'SSS_INVALID_SUBLIST_OPERATION');
					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					if (line - 1 === this.getLineItemCount(group))
						this.selectNewLineItem(group);
					else if (line <= this.getLineItemCount(group))
						this.selectLineItem(group, line);
					this.setCurrentLineItemValue(group, name, value);
					this.commitLineItem(group)
				};
				nlobjRecord.prototype.setAndCommitLineItemValue = function (group, name, line, value) {
					var linegroup = this.lineitems[group];
					if (!linegroup) {
						linegroup = [];
						this.lineitems[group] = linegroup;
					}
					var lineitem = linegroup[line];
					if (!lineitem) {
						lineitem = new Array(1);
						linegroup[line] = lineitem;
					}
					lineitem[name] = value;
				};
				nlobjRecord.prototype.insertLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}
					var linegroup = this.lineitems[type];
					if (!linegroup) {
						linegroup = new Array(1);
						this.lineitems[type] = linegroup;
					}
					linegroup.splice(line, 0, []);
					this.logOperation("insertLineItem", {"type": type})
				};
				nlobjRecord.prototype.removeLineItem = function (type, line) {
					assertTrue(this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					if (this.getCurrentLineItemIndex(type) === -1) {
						if (line - 1 === this.getLineItemCount(type) || isNaN(parseInt(line)))
							this.selectNewLineItem(type);
						else if (line <= this.getLineItemCount(type))
							this.selectLineItem(type, line)
					}

					var linegroup = this.lineitems[type];
					if (!linegroup || this.getLineItemCount(type) < line)
						return;
					linegroup.splice(line, 1);
					this.logOperation("removeLineItem", {"type": type});
					if (this.getCurrentLineItemIndex(type) !== -1) {
						this.currentlineitems[type] = null;
						this.currentlineitemindexes[type] = null;
					}
				};
				nlobjRecord.prototype.getLineItemValue = function (group, name, line) {
					var value = null;
					var linegroup = this.lineitems[group];
					if (!!linegroup) {
						var lineitem = linegroup[line];
						if (!!lineitem)
							value = lineitem[name];
					}
					return value != null ? value : null;
				};
				nlobjRecord.prototype.getLineItemCount = function (group) {
					var linegroup = this.lineitems[group];
					return !!linegroup ? linegroup.length - 1 /* zeroth line is unused. */ : 0;
				};
				nlobjRecord.prototype.setLineItemMatrixValue = function (type, fldnam, linenum, column, value) {
					if (this.isMatrixField(type, fldnam))
						this.setLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum, value)
				};
				nlobjRecord.prototype.getLineItemMatrixValue = function (type, fldnam, linenum, column) {
					if (this.isMatrixField(type, fldnam))
						return this.getLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), linenum);
					return null;
				};
				nlobjRecord.prototype.findLineItemValue = function (type, fldnam, value) {
					for (var linenum = 1; linenum <= this.getLineItemCount(type); linenum++)
						if (value == this.getLineItemValue(type, fldnam, linenum))
							return linenum;
					return -1;
				};
				nlobjRecord.prototype.findLineItemMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam))
						return this.findLineItemValue(type, this.getMatrixFieldName(type, fldnam, column), value);
					return -1;
				};
				nlobjRecord.prototype.setMatrixValue = function (type, fldnam, column, value) {
					if (this.isMatrixField(type, fldnam)) {
						this.fields[this.getFieldValue(type + 'header') + column] = value;
						this.logOperation("setMatrixValue", {"type": type, "field": name, "column": column, "value": value})
					}
				};
				nlobjRecord.prototype.getMatrixValue = function (type, fldnam, column) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'header') + column) : null;
				};
				nlobjRecord.prototype.getMatrixCount = function (type, fldnam) {
					return this.isMatrixField(type, fldnam) ? this.getFieldValue(this.getFieldValue(type + 'headercount')) : null;
				};
				nlobjRecord.prototype.selectLineItem = function (type, linenum) {
					assertTrue(!!this.linetypes[type] && linenum > 0 && linenum <= this.getLineItemCount(type), 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = linenum;
					var flds = this.getAllLineItemFields(type);
					for (var i = 0; i < flds.length; i++)
						this.currentlineitems[type][flds[i]] = this.getLineItemValue(type, flds[i], linenum)
					this.logOperation("selectLineItem", {"type": type, "linenum": linenum})
				};
				nlobjRecord.prototype.selectNewLineItem = function (type) {
					assertTrue(!!this.linetypes[type] && this.linetypes[type] === 'edit', 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = {};
					this.currentlineitemindexes[type] = this.getLineItemCount(type) + 1;
					this.logOperation("selectNewLineItem", {"type": type})
				};
				nlobjRecord.prototype.cancelLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("cancelLineItem", {"type": type})
				};
				nlobjRecord.prototype.commitLineItem = function (type) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					var flds = this.getAllLineItemFields(type);
					var linenum = this.getCurrentLineItemIndex(type);
					for (var i = 0; i < flds.length; i++)
						this.setAndCommitLineItemValue(type, flds[i], linenum, this.currentlineitems[type][flds[i]])
					this.currentlineitems[type] = null;
					this.currentlineitemindexes[type] = null;
					this.logOperation("commitLineItem", {"type": type})
				};
				nlobjRecord.prototype.getCurrentLineItemIndex = function (type) { return !!this.currentlineitems[type] ? this.currentlineitemindexes[type] : -1; };
				nlobjRecord.prototype.getCurrentLineItemValue = function (type, name) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][name]
				};
				nlobjRecord.prototype.setCurrentLineItemValue = function (type, name, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][name] = value;
					this.logOperation("setCurrentLineItemValue", {"type": type, "field": name, "value": value})
				};
				nlobjRecord.prototype.setCurrentLineItemMatrixValue = function (type, fldnam, column, value) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)] = value;
					this.logOperation("setCurrentLineItemMatrixValue", {
						"type": type,
						"field": fldnam,
						"column": column,
						"value": value
					})
				};
				nlobjRecord.prototype.getCurrentLineItemMatrixValue = function (type, fldnam, column) {
					assertTrue(this.getCurrentLineItemIndex(type) !== -1, 'SSS_INVALID_SUBLIST_OPERATION');
					return this.currentlineitems[type][this.getMatrixFieldName(type, fldnam, column)]
				};
				/* field text APIs and field metadata APIs not yet supported via nlobjRecord interface in Client SuiteScript */

				nlobjRecord.prototype.setFieldText = function (name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setFieldTexts = function (name, texts) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldText = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldTexts = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemText = function (type, name, line) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getCurrentLineItemText = function (type, name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.setCurrentLineItemText = function (type, name, text) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getSublist = function (type) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getMatrixField = function (type, fldnam) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemField = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisabled = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldMandatory = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldVisibility = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getFieldLabel = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisplay = function (name) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemDisabled = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemMandatory = function (type, name, linenum) { throwLegacyUnsupportedError(); };
				nlobjRecord.prototype.getLineItemLabel = function (type, name) { throwLegacyUnsupportedError(); };

				/* internal nlobjRecord helper methods */
				nlobjRecord.prototype.isMatrixField = function (type, fld) {
					return this.getFieldValue(type + 'matrixfields') != null && utilityFunctions.arrayIndexOf(this.getFieldValue(type + 'matrixfields')
						.split(","), fld) !== -1;
				};
				nlobjRecord.prototype.getMatrixFieldName = function (type, fldnam, column) { return this.isMatrixField(type, fldnam) ? fldnam + "_" + column + "_" : null; };
				nlobjRecord.prototype.logOperation = function (operation, args) {
					if (this.initialized) this.operations.push({
						"operation": operation,
						"args": args
					});
				};
				nlobjRecord.prototype.getDateTimeValue = function (fldname, timezone) {
					if (!timezone)
						return this.getFieldValue(fldname);
					else {
						var storedDateTime = this.getFieldValue(fldname);
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return storedDateTime;
						else
							return invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [storedDateTime, timezone]);
					}
				};

				nlobjRecord.prototype.setDateTimeValue = function (fldname, value, timezone) {
					if (!timezone)
						return this.setFieldValue(fldname, value);
					else {
						var preferredTimeZone = runtime.getCurrentUser().getPreference("TIMEZONE");
						if (preferredTimeZone === timezone)
							return this.setFieldValue(fldname, value);
						else {
							var newVal = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [value, timezone]);
							return this.setFieldValue(fldname, newVal);
						}
					}
				};

				// this is only supported on server-side dynamic record
				nlobjRecord.prototype.calculateTax = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjRecord;
		};
	})();

	var nlobjRecordWrapper = function(record, operation, options)
	{
		if (!record) return record;

		var v1Record = getRecordImplV1(record);
		if (v1Record)
		{
			var nlobjrecord = new (nlobjRecordGetter())(v1Record.getRecordType(), v1Record.getId());

			nlobjrecord.fieldnames = v1Record.getAllFields() || [];
			nlobjrecord.fieldnames.forEach(function (fld) {
				var val = v1Record.getFieldValue(fld);
				nlobjrecord.setFieldValue(fld, val);
			});

			nlobjrecord.linetypes = (function () {
				var linetypes = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					linetypes[sl] = v1Record.getSublistType(sl);
				});
				return linetypes;
			})();

			nlobjrecord.linefields = (function () {
				var linefields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {

					linefields[sl] = v1Record.getAllLineItemFields(sl) || [];

					var backwardCompatibilityMap = (v1Record._getSubrecordBackwardCompatibilityMap(sl) || []);
					backwardCompatibilityMap.forEach(function (fld) {
						if (linefields[sl].indexOf(fld) == -1 && linefields[sl].indexOf(fld + '_initialvalue') > -1)
							linefields[sl].push(fld);
					});

					var lineCount = v1Record.getLineItemCount(sl);
					for (var line_1 = 1; line_1 < lineCount+1; line_1++)
					{
						linefields[sl].forEach(function (lineFld) {
							var val = v1Record.getLineItemValue(sl, lineFld, line_1);
							nlobjrecord.setAndCommitLineItemValue(sl, lineFld, line_1, val);
						});
					}
				});
				return linefields;
			})();

			nlobjrecord.matrixfields = (function () {
				var matrixfields = {};
				(v1Record.getAllSublists() || []).forEach(function (sl) {
					var mfv = v1Record.getFieldValue(sl + 'matrixfields');
					if (!!mfv) matrixfields[sl] = mfv.split(',');
				});
				return matrixfields;
			})();

			nlobjrecord.initialized = true;

			nlobjrecord.logOperation(operation, {'defaultValues': options.defaultValues});

			return nlobjrecord;
		}
	};

	var nlobjSublistGetter = (function()
	{
		var nlobjSubList;

		return function nlobjSublistGetter(record)
		{
			var getSublist = function(name) {
				var sl = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return sl;
				return v1Record.getSublist(name) || null;
			};

			if (!nlobjSubList)  // must be defined only once so the instanceOf works properly
			{
				nlobjSubList = function nlobjSubList(name) {
					var sl = getSublist(name);
					this.name = name;
					this.type = sl ? sl.getType() : null;
					this.label = null;
					this.hidden = false;
					this.display = true;
				};

				nlobjSubList.prototype.getName = function () { return this.name; };
				nlobjSubList.prototype.getType = function () { return this.type; };
				nlobjSubList.prototype.getLabel = function () { return this.label != null ? this.label : ""; };
				nlobjSubList.prototype.isHidden = function () { return this.hidden; };
				nlobjSubList.prototype.isDisplay = function () { return this.display; };
				nlobjSubList.prototype.isChanged = function () {
					var sl = getSublist(this.name);
					return sl ? sl.isChanged() : false;
				};

				nlobjSubList.prototype.setLabel = function (label) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setHelpText = function (help) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setDisplayType = function (type) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValue = function (field, line, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemMatrixValue = function (field, line, column, value) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setLineItemValues = function (values) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getField = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getAllHeaderFields = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addField = function (name, type, label, source, group) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addHeaderField = function (name, type, label, source) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setAmountField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.setUniqueField = function (fldnam) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getMatrixCount = function (field) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addButton = function (name, label, script) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.getButton = function (name) { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addRefreshButton = function () { throwLegacyUnsupportedError(); };
				nlobjSubList.prototype.addMarkAllButtons = function () { throwLegacyUnsupportedError(); };
			}
			return nlobjSubList;
		};
	})();

	var nlobjSublistWrapper = function(record, sublist)
	{
		if (!sublist) return sublist;

		var nlobjsublist = new (nlobjSublistGetter(record))(sublist.getName());
		nlobjsublist.type = sublist.getType();
		nlobjsublist.hidden = !!sublist.isHidden();
		nlobjsublist.display = !!sublist.isDisplay();
		return  nlobjsublist;
	};

	var nlobjFieldGetter = (function()
	{
		var nlobjField;

		return function nlobjFieldGetter(record)
		{
			var getField = function(name, sublist, line_1)
			{
				var fld = null;
				var v1Record = getRecordImplV1(record);
				if (!v1Record)
					return fld;

				if (sublist) {
					fld = v1Record.getLineItemField(sublist, name, line_1);
				}
				else {
					fld = v1Record.getField(name);
				}
				return fld;
			};

			if (!nlobjField)  // must be defined only once so the instanceOf works properly
			{
				nlobjField = function nlobjField(name, type, sublist) {
					this.name = name;
					this.type = type;
					this.noslaving = false;
					this.sublist = sublist;
					this.label = null;
					this.required = false;
					this.disabled = false;
					this.hidden = false;
					this.display = false;
					this.visible = false;
					this.popup = false;
					this.readonly = false;
					this.parent = null;
					this.uifield = null;
					this.linenum = -1;
				};

				nlobjField.prototype.getName = function () { return this.name; };
				nlobjField.prototype.getType = function () { return this.type; };
				nlobjField.prototype.getLabel = function () { return this.label != null ? this.label : "" };
				nlobjField.prototype.getSubList = function () { return this.sublist; };
				nlobjField.prototype.getParent = function () { return this.parent; };
				nlobjField.prototype.getLine = function () { return this.linenum; };
				nlobjField.prototype.getUIField = function () { return this.uifield; };
				nlobjField.prototype.noSlaving = function () { return this.noslaving; };
				nlobjField.prototype.isMandatory = function () { return this.required; };
				nlobjField.prototype.isDisabled = function () { return this.disabled; };
				nlobjField.prototype.isHidden = function () { return this.hidden; };
				nlobjField.prototype.isPopup = function () { return this.popup; };
				nlobjField.prototype.isDisplay = function () { return this.display; };
				nlobjField.prototype.isVisible = function () { return this.visible; };
				nlobjField.prototype.isReadOnly = function () { return this.readonly; };

				nlobjField.DISPLAY_TYPE =
					{
						INLINE: 'inline', //not yet supported, throws SSS_NOT_YET_SUPPORTED
						HIDDEN: 'hidden',
						READ_ONLY: 'readonly', //only works for text area or rich text (different from server, where only text area works)
						ENTRY: 'entry',   //does not override Display Type : "Disabled" or "Hidden" UI setting
						DISABLED: 'disabled',
						NORMAL: 'normal'  //does override Display Type : "Disabled" or "Hidden" UI setting
					};

				nlobjField.prototype.setDisplayType = function (displayType) {
					checkArgs([displayType], ['displayType'], 'nlobjField.setDisplayType');
					console.log('setDisplayType: ' + displayType);

					var fld = getField(this.name, this.sublist, this.line);
					if (!fld)
						return;

					switch (displayType.toLowerCase()) {
						case nlobjField.DISPLAY_TYPE.INLINE:
							throwLegacyUnsupportedError();
							break;

						case nlobjField.DISPLAY_TYPE.HIDDEN:
							fld.setDisplay(false);
							fld.setVisible(false);

							this.hidden = true;
							this.visible = false;
							this.display = false;
							break;

						case nlobjField.DISPLAY_TYPE.READ_ONLY:
							if (!this.type || this.type !== "textarea")
								return;
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.ENTRY:
							if (this.hidden || this.disabled)
								return;

							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						case nlobjField.DISPLAY_TYPE.DISABLED:
							fld.setDisabled(true);
							this.disabled = true;
							break;

						case nlobjField.DISPLAY_TYPE.NORMAL:
							fld.setDisabled(false);
							fld.setDisplay(true);
							fld.setVisible(true);

							this.hidden = false;
							this.visible = true;
							this.display = true;
							this.disabled = false;
							break;

						default:
							break;
					}
				};

				nlobjField.prototype.setLabel = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setAlias = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDefaultValue = function (required) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisabled = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMandatory = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setMaxLength = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLayoutType = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setLinkText = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setHelpText = function (text) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setDisplaySize = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.setPadding = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.addSelectOption = function (disabled) { throwLegacyUnsupportedError(); };
				nlobjField.prototype.getSelectOptions = function (token) { throwLegacyUnsupportedError(); };
			}
			return nlobjField;
		}
	})();

	var nlobjFieldWrapper = function(record, field, linenum)
	{
		if (!field) return field;

		var fieldState = record && record.hasOwnProperty("getFieldState") ? record.getFieldState(field.getName()) : null;

		var nlobjfield = new (nlobjFieldGetter(record))(field.getName(), field.getType(), field.getSublistName());

		nlobjfield.noslaving = field.noSlaving();
		nlobjfield.label = field.getLabel();
		nlobjfield.required = field.isMandatory();
		nlobjfield.disabled = field.isDisabled();
		nlobjfield.hidden = (fieldState && fieldState.isHidden) || false;
		nlobjfield.display = field.isDisplay();
		nlobjfield.visible = field.isVisible();
		nlobjfield.popup = field.isPopup();
		nlobjfield.readonly = field.isReadOnly();
		nlobjfield.parent = null; // most likely not doable in NEW UI
		nlobjfield.uifield = null;  // most likely not doable in NEW UI
		nlobjfield.linenum = linenum != null ? linenum : -1;

		return nlobjfield;
	};

	var nlobjErrorGetter = (function()
	{
		var nlobjError;

		return function nlobjErrorGetter()
		{
			function stacktrace()
			{
				var stackstring = "stacktrace: ";
				var history = [];
				var func = arguments.callee.caller;

				while (func != null)
				{
					var funcName = getFuncName(func);
					var funcArgs = getFuncArgs(func);
					var caller = func.caller;
					var infiniteLoopDetected = history.indexOf(funcName) !== -1;
					var historyTooLong = history.length > 50;
					var callerIsSelf = (caller === func);

					if (infiniteLoopDetected || historyTooLong || callerIsSelf)
						break;

					stackstring += funcName + funcArgs + "\n\n";
					history.push(funcName);
					func = caller;
				}
				return stackstring;
			}

			function getFuncArgs(a)
			{
				var s = "arguments: {";
				for (var i = 0; i < a.arguments.length; i++)
				{
					if (typeof a.arguments[i] == "undefined")
						s += '\'undefined\'';
					else if (a.arguments[i] == null)
						s += 'null';
					else if (typeof a.arguments[i] == "string")
						s += "'" + a.arguments[i].toString() + "'";
					else
						s += a.arguments[i].toString();
					if (i < a.arguments.length -1)
						s += ",";
				}
				s += "}";
				return s;
			}

			function getFuncName(f)
			{
				var s = f.toString();
				if (s.indexOf("anonymous") >= 0)
				{
					if (s.length > 100)
						return s.substr(0, 100) + "\n";
					else
						return s + "\n";
				}
				else
				{
					s = s.match(/function[^{]*/);
					if (s !== null)
						s = s[0];
				}
				if ((s == null) || (s.length == 0)) return "anonymous \n";
				return s;
			}

			if (!nlobjError)
			{
				nlobjError = function nlobjError(code, error, suppressnotification)
				{
					this.id = null;
					this.code = code;
					this.details = error;
					this.stacktrace = stacktrace();
					this.suppressnotification = suppressnotification;
					if (code instanceof nlobjError)
					{
						this.id = code.getId();
						this.code = code.getCode();
						this.details = code.getDetails();
						this.stacktrace = code.getStackTrace();
					}
					this.name = this.code;
					this.message = this.details;
					this.description = this.details;
				};
				nlobjError.prototype.getId = function( ) { return this.id; };
				nlobjError.prototype.getCode = function( ) { return this.code; };
				nlobjError.prototype.getDetails = function( ) { return this.details; };
				nlobjError.prototype.getStackTrace = function( ) { return this.stacktrace; };
			}
			return nlobjError;
		}
	})();

	var nlobjErrorWrapper = function(exception)
	{
		return exception && exception.hasOwnProperty('notifyOff') ? new (nlobjErrorGetter())(exception.name, exception.message || undefined, exception.notifyOff) : exception;
	};
	nlobjErrorWrapper.wrapEmitLegacyError = function(func)
	{
		var fun = func;
		return function()
		{
			try {
				return fun.apply(this, arguments);
			}
			catch (e)
			{
				throw nlobjErrorWrapper(e);
			}
		}
	};

	function throwLegacyError(code, error, suppressnotification) { throw new (nlobjErrorGetter())(code, error, suppressnotification); }
	function throwLegacyUnsupportedError(error) { throwLegacyError('SSS_NOT_YET_SUPPORTED', error); }

	var assertTrue = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.assertTrue);

	var checkArgs = nlobjErrorWrapper.wrapEmitLegacyError(utilityFunctions.checkArgs);

	var NLSubrecordGetter = (function ()
	{
		var NLSubrecord, NLSubrecordGetter;
		var isInternal = false;

		NLSubrecordGetter = function NLSubrecordGetter()
		{
			if (!NLSubrecord)
			{
				NLSubrecord = function NLSubrecord(machinename, name, linenum)
				{
					var v1Subrecord;

				    this.machinename = machinename;
				    this.name = name;
				    this.isOnServer = false;
				    this.linenum = linenum;
				    this.rowIdx = linenum - 1;
				    this.childRecordManagerCurrentLine = {};
				    this.iframeId = undefined;
				    this.recordmanagername = null;
				    this.recordmanager = null;

				    Object.defineProperty(this, 'v1Subrecord', {
				    	get: function () { if (isInternal) return v1Subrecord; },
					    set: function (value) { if (isInternal) v1Subrecord = value; }
				    });
				};
				NLSubrecord.prototype.getFieldValue = function NLSubrecord_getFieldValue(fieldname)
				{
					return NLSubrecordGetter.doInternal(function () { return this.v1Subrecord.getFieldValue(fieldname); }, this);
				};
				NLSubrecord.prototype.setFieldValue = function NLSubrecord_setFieldValue(fieldname, fieldValue)
				{
					return NLSubrecordGetter.doInternal(function () { this.v1Subrecord.setFieldValue(fieldname, fieldValue); }, this);
				};
				NLSubrecord.prototype.selectLineItem = function NLSubrecord_selectLineItem(machinename, linenum)
				{
					return NLSubrecordGetter.doInternal(function () { this.v1Subrecord.selectLineItem(machinename, linenum); }, this);
				};
				NLSubrecord.prototype.getCurrentLineItemValue = function NLSubrecord_getCurrentLineItemValue(machinename, fieldname)
				{
					return NLSubrecordGetter.doInternal(function () { return this.v1Subrecord.getCurrentLineItemValue(machinename, fieldname); }, this);
				};
				NLSubrecord.prototype.getLineItemCount = function NLSubrecord_getLineItemCount(machinename)
				{
					return NLSubrecordGetter.doInternal(function () { return this.v1Subrecord.getLineItemCount(machinename); }, this);
				};
				NLSubrecord.prototype.commit = function NLSubrecord_commit()
				{
					return NLSubrecordGetter.doInternal(function () { this.v1Subrecord.commit(); }, this);
				};
				NLSubrecord.prototype.cancel = function NLSubrecord_cancel()
				{
					return NLSubrecordGetter.doInternal(function () { this.v1Subrecord.cancel(); }, this);
				};
				NLSubrecord.prototype.reload = function NLSubrecord_reload() { throwLegacyUnsupportedError('NLSubrecord.reload'); };
				NLSubrecord.prototype.removeFromCache = function NLSubrecord_removeFromCache() { throwLegacyUnsupportedError('NLSubrecord.removeFromCache'); };
				NLSubrecord.prototype.getChildMachineRecordManager = function NLSubrecord_getChildMachineRecordManager() { throwLegacyUnsupportedError('NLSubrecord.getChildMachineRecordManager'); };
				NLSubrecord.prototype.remove = function NLSubrecord_remove() { throwLegacyUnsupportedError('NLSubrecord.remove'); };
				NLSubrecord.prototype.isReady = function NLSubrecord_isReady() { throwLegacyUnsupportedError('NLSubrecord.isReady'); };
				NLSubrecord.prototype.wasEdited = function NLSubrecord_wasEdited() { throwLegacyUnsupportedError('NLSubrecord.wasEdited'); };
				NLSubrecord.prototype.prepareForWrite = function NLSubrecord_prepareForWrite() { throwLegacyUnsupportedError('NLSubrecord.prepareForWrite'); };
			}
			return NLSubrecord;
		};

		NLSubrecordGetter.doInternal = function doInternal(fn, thisArg)
		{
			var wasInternal = isInternal;
			isInternal = true;
			try
			{
				return fn.call(thisArg);
			}
			finally
			{
				isInternal = wasInternal;
			}
		};

		return NLSubrecordGetter;
	})();

	/**
	 * @return {null}
	 */
	function NLSubrecordWrapper(v1Subrecord, machinename, name, linenum)
	{
		if (!v1Subrecord)
		{
			return null;
		}
		var nlSubrecord = v1Subrecord.nlSubrecord;
		if (!nlSubrecord)
		{
			nlSubrecord = new (NLSubrecordGetter())(machinename, name, linenum);
			NLSubrecordGetter.doInternal(function () { nlSubrecord.v1Subrecord = v1Subrecord; });
			v1Subrecord.nlSubrecord = nlSubrecord;
		}
		return nlSubrecord;
	}

	var nonRecordV1Functions = function() {

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(type, initializeValues)
		{
			var options = {type: type, defaultValues: initializeValues};

			return nlobjRecordWrapper(getRecordImplModule().create_raw(options), 'createRecord', options);
		}
		this.createRecord = nlobjErrorWrapper.wrapEmitLegacyError(createRecord);

		function copyRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().copy_raw(options), 'copyRecord', options);
		}
		this.copyRecord = nlobjErrorWrapper.wrapEmitLegacyError(copyRecord);

		function loadRecord(type, id, initializeValues)
		{
			var options = {type: type, id: id, defaultValues: initializeValues};
			return nlobjRecordWrapper(getRecordImplModule().load_raw(options), 'loadRecord', options);
		}
		this.loadRecord = nlobjErrorWrapper.wrapEmitLegacyError(loadRecord);

		function transformRecord(type, id, transformType, transformValues)
		{
			var options = {fromType: type, fromId: id, toType: transformType, defaultValues: transformValues};
			return nlobjRecordWrapper(getRecordImplModule().transform_raw(options), 'transformRecord', options);
		}
		this.transformRecord = nlobjErrorWrapper.wrapEmitLegacyError(transformRecord);

		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(type, id)
		{
			var options = {type: type, id: id};
			getRecordModule()['delete'](options);
		}
		this.deleteRecord = nlobjErrorWrapper.wrapEmitLegacyError(deleteRecord);

		function submitField(type, id, fields, values, doSourcing)
		{
			checkArgs([type, id, fields], ['type', 'id', 'fields'], 'nlapiSubmitField');

			try
			{
				var valuesObj = {};
				var flds = util.isArray(fields) ? fields : [fields];
				var vals = util.isArray(values) ? values : [values];
				for (var i = 0; i < flds.length; i++)
					valuesObj[flds[i]] = vals[i];
				var options = {type: type, id: id, values: valuesObj, enableSourcing: doSourcing};
				getRecordModule().submitFields(options);
			}
			catch(e)
			{
				throw nlobjErrorWrapper(utilityFunctions.getConstructorName(e) === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitField = nlobjErrorWrapper.wrapEmitLegacyError(submitField);

		function attachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, to: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().attach(options);
		}
		this.attachRecord = nlobjErrorWrapper.wrapEmitLegacyError(attachRecord);

		function detachRecord(type, id, type2, id2, attributes)
		{
			var options = {record: {type: type, id: id}, from: {type: type2, id: id2}, attributes: attributes};
			getRecordModule().detach(options);
		}
		this.detachRecord = nlobjErrorWrapper.wrapEmitLegacyError(detachRecord);

		function submitRecord(nlobjRecord, options, ignoreMandatoryFields)
		{
			checkArgs([nlobjRecord], ['nlobjRecord'], 'nlapiSubmitRecord');

			if (runtime.getCurrentScript().getRemainingUsage() < 0)
				throwLegacyError('SCRIPT_EXECUTION_USAGE_LIMIT_EXCEEDED', 'Script Execution Usage Limit Exceeded');

			if (utilityFunctions.getConstructorName(nlobjRecord) !== 'nlobjRecord')
				throwLegacyError('SSS_INVALID_RECORD_OBJ', 'The record is not a valid object.');

			try
			{
				var attributes = {
					'enableSourcing':  ""+(options === true || (!!options && options.enableSourcing === true)),
					'disableTriggers': ""+(!!options && options.disableTriggers === true),
					'ignoreMandatoryFields': ""+(ignoreMandatoryFields === true || (!!options && options.ignoreMandatoryFields === true))
				};

				var recordData = JSON.stringify({
					attributes: attributes,
					type: nlobjRecord.type,
					id: nlobjRecord.id,
					load: nlobjRecord.operations[0],
					operations: Array.prototype.slice.call(nlobjRecord.operations, 1)
				});

				var sKey = invoker(remoteApi, 'submitLegacyRecord', [recordData]);
				// TODO: check if need to charge usage
				//nlapiGetContext().setUsage('nlapiSubmitRecord', nlobjRecord.getRecordType());
				return sKey;
			}
			catch(e)
			{
				throw nlobjErrorWrapper(utilityFunctions.getConstructorName(e) === 'SuiteScriptError' ? e : utilityFunctions.createSuiteScriptError(e));
			}
		}
		this.submitRecord = nlobjErrorWrapper.wrapEmitLegacyError(submitRecord);

		return Object.freeze(this);
		/** END: Non-record functions */
	};

	var nlobjWrappers = Object.freeze({
		nlobjRecordWrapper:  nlobjRecordWrapper,
		nlobjSublistWrapper:  nlobjSublistWrapper,
		nlobjFieldWrapper: nlobjFieldWrapper,
		nlobjErrorWrapper: nlobjErrorWrapper,
		NLSubrecordWrapper: NLSubrecordWrapper,
	});
	var nlobjGetters = Object.freeze({
		nlobjRecordGetter: nlobjRecordGetter,
		nlobjSublistGetter: nlobjSublistGetter,
		nlobjFieldGetter: nlobjFieldGetter,
		nlobjErrorGetter: nlobjErrorGetter,
		NLSubrecordGetter: NLSubrecordGetter
	});

	return {
		nonRecordV1Functions: new(nonRecordV1Functions),
		nlobjWrappers: nlobjWrappers,
		nlobjGetters: nlobjGetters
	};
});
/**
 * SuiteScript record implementation for version one based on version 2 record
 *
 * @private
 * @module N/record/recordImplV1
 * @NApiVersion 2.x
 */

define('N/record/recordImplV1',['N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions', 'N/internal/invoker', 'N/restricted/remoteApiBridge', 'N/record/sublist', 'N/record/legacyNLObjects', 'N/record/matrix', 'N/internal/reflet'],
	function(error, utilityFunctions, recordUtil, invoker, remoteApi, sublist, legacyNLObjects, matrix, reflet) {

		/**
		 * @param {Object} options
		 * @param {RawRecord} options.record
		 * @param {boolean} options.isSubrecord
		 * @param {RecordImplV1} options.parentV1Record
		 * @constructor
		 */
		function RecordImplV1(options)
		{
			var undef = undefined;
			var that = this;
			/** @type {RawRecord} */
			var record = options.record;
			var isSubrecord = options.isSubrecord;
			var parentV1Record = options.parentV1Record;

			this.nonRecordV1Functions = legacyNLObjects.nonRecordV1Functions;
			this.nlobjects = {
				nlobjRecordWrapper: legacyNLObjects.nlobjWrappers.nlobjRecordWrapper,
				nlobjSublistWrapper:  legacyNLObjects.nlobjWrappers.nlobjSublistWrapper.bind(null, record),
				nlobjFieldWrapper: legacyNLObjects.nlobjWrappers.nlobjFieldWrapper.bind(null, record),
				nlobjErrorWrapper: legacyNLObjects.nlobjWrappers.nlobjErrorWrapper,
				NLSubrecordWrapper: legacyNLObjects.nlobjWrappers.NLSubrecordWrapper,

				nlobjRecordGetter: legacyNLObjects.nlobjGetters.nlobjRecordGetter,
				nlobjSublistGetter: legacyNLObjects.nlobjGetters.nlobjSublistGetter.bind(null, record),
				nlobjFieldGetter: legacyNLObjects.nlobjGetters.nlobjFieldGetter.bind(null, record),
				nlobjErrorGetter: legacyNLObjects.nlobjGetters.nlobjErrorGetter,
				NLSubrecordGetter: legacyNLObjects.nlobjGetters.NLSubrecordGetter
			};

			var wrapEmitLegacyError = legacyNLObjects.nlobjWrappers.nlobjErrorWrapper.wrapEmitLegacyError;

			function getDelegate()
			{
				return record;
			}
			this.getDelegate = wrapEmitLegacyError(getDelegate);

			function getId()
			{
				return record.id;
			}
			this.getId = wrapEmitLegacyError(getId);

			function getRecordType()
			{
				return record.getRecordType();
			}
			this.getRecordType = wrapEmitLegacyError(getRecordType);

			function abandon()
			{
				if (parentV1Record)
				{
					var exParentV1Record = parentV1Record;
					parentV1Record = undefined;
					exParentV1Record.removeV1Subrecord(that);
				}
			}
			this.abandon = abandon;

			function checkNotAbandoned()
			{
				if (isSubrecord && (!parentV1Record || record.isAbandoned()))
				{
					utilityFunctions.throwSuiteScriptError('TIMEOUT_THE_RECORD_DOESNT_EXIST_ANYMORE');
				}
			}

			function fixNullEmptyBug()
			{
				return true;
			}

			function removeField(fieldId)
			{
				return record.doRemoveField(fieldId);
			}
			this.removeField = wrapEmitLegacyError(removeField);

			function removeLineItemField(sublistId, fieldId, line_1)
			{
				//TODO missing in recordDefinition.js
			}
			this.removeLineItemField = wrapEmitLegacyError(removeLineItemField);

			function getSubrecordRedirect(sublistId, fieldId)
			{
				var metadata = record.getMetadata();
				var subrecordFieldIds = !!sublistId ? metadata.getAllSublistSubrecordFields(sublistId) || [] : metadata.subrecordFieldIds;
				subrecordFieldIds = subrecordFieldIds.reduce(function (p, c, i, a)
				{
					var subrecordFieldId = c;
					var subrecordCompatibilityMap = metadata.getFieldMetadata(sublistId, subrecordFieldId).subrecordCompatibilityMap;

					if (!!subrecordCompatibilityMap && subrecordCompatibilityMap.hasOwnProperty(fieldId))
					{
						p.push({
							subrecordFieldId: subrecordFieldId,
							fieldId: subrecordCompatibilityMap[fieldId]
						});
					}

					return p;
				}, []);

				return subrecordFieldIds[0] || null;
			}

			function getFieldValue(fieldId)
			{
				utilityFunctions.checkArgs([fieldId], ['name'], 'nlobjRecord.getFieldValue');
				var value;
				//get redirect
				var subrecordRedirect = getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					if (record.hasSubrecord(subrecordRedirect.subrecordFieldId))
					{
						var subrecord = record.doGetBodySubrecord(subrecordRedirect.subrecordFieldId, true);
						value = subrecord.getValueAsLegacyString(subrecordRedirect.fieldId);
					}
					else
						value = "";
				}
				else
				{
					value = record.getValueAsLegacyString(fieldId);
					if (fixNullEmptyBug() && record.isValidField(null, fieldId))
					{
						value = recordUtil.emptyIfNullOrUndefined(value);
					}
				}
				return value;
			}
			this.getFieldValue = wrapEmitLegacyError(getFieldValue);

			this.nlapiGetFieldValue = wrapEmitLegacyError(getFieldValue);

			function getFieldText(fieldId)
			{
				var returnText = "";
				var isMultiSelect = record.isFieldMultiSelect(null, fieldId);
				if (record.isFieldSelectType(null, fieldId) || isMultiSelect)
				{
					var value = record.getValue(fieldId);
					if (!utilityFunctions.isEmpty(value))
					{
						returnText = record.doGetTextValueForSelectFieldForInstance(null, fieldId, value, null, false, isMultiSelect);
					}
				}
				return returnText;
			}
			this.getFieldText = wrapEmitLegacyError(getFieldText);

			function getFieldValues(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getValueAsLegacyStringArray(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}

				return value;
			}
			this.getFieldValues = wrapEmitLegacyError(getFieldValues);

			function getFieldTexts(fieldId)
			{
				var value = null;
				if (record.isFieldMultiSelect(null, fieldId))
				{
					value = record.getText(fieldId);
					value = (value) ? value : (fixNullEmptyBug() ? [] : null);
				}
				return value;
			}
			this.getFieldTexts = wrapEmitLegacyError(getFieldTexts);

			function doSetFieldValue(fieldId, value, fireFieldChange, noSlaving)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));
				if (isInternal())
				{
					// set value without formatting
					record.doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, true, !shouldValidateField());
					record.getFieldState(fieldId).isParsed = false;
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);
					var fieldLevelMetadata = record.getFieldLevelMetadataForBodyField(fieldId);
					var parsedValue = recordUtil.parseValue(record.isValidBodyField(fieldId), fieldLevelMetadata, value);
					record.doSetValue(fieldId, parsedValue, fireFieldChange, noSlaving, undefined, undefined, !shouldValidateField());
				}
			}
			this.doSetFieldValue = doSetFieldValue;

			function setFieldValue(fieldId, value, fireFieldChange, noSlaving)
			{
				checkNotAbandoned();
				utilityFunctions.checkArgs([fieldId], ['name'], 'nlobjRecord.setFieldValue');
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var v1Subrecord = editSubrecord(subrecordRedirect.subrecordFieldId);
					v1Subrecord.doSetFieldValue(subrecordRedirect.fieldId, value, fireFieldChange, noSlaving);
				}
				else
				{
					doSetFieldValue(fieldId, value, fireFieldChange, noSlaving);
				}
			}
			this.setFieldValue = wrapEmitLegacyError(setFieldValue);

			function setFieldText(fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				if (record.isFieldSelectType(null, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}

					record.doSetText(fieldId, text, fireFieldChange, undefined, !shouldValidateField());
				}
			}
			this.setFieldText = wrapEmitLegacyError(setFieldText);

			function doSetFieldValues(fieldId, values, fireFieldChange, noSlaving)
			{
				if (record.isFieldMultiSelect(undefined, fieldId))
				{
					if (util.isArray(values))
					{
						values.forEach(function (value)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, value);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, values);
					}

					values = util.isArray(values) ? values : [values];
					values = recordUtil.formatArrayToStringType(values);
					setFieldValue(fieldId, values, fireFieldChange, noSlaving);
				}
			}
			this.doSetFieldValues = doSetFieldValues;

			function setFieldValues(fieldId, values, fireFieldChange, noSlaving)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;

				var subrecordRedirect = getSubrecordRedirect(null, fieldId);
				if (!!subrecordRedirect)
				{
					var v1Subrecord = editSubrecord(subrecordRedirect.subrecordFieldId);
					v1Subrecord.doSetFieldValues(subrecordRedirect.fieldId, values, fireFieldChange, noSlaving);
				}
				else
				{
					doSetFieldValues(fieldId, values, fireFieldChange, noSlaving);
				}
			}
			this.setFieldValues = wrapEmitLegacyError(setFieldValues);

			function setFieldTexts(fieldId, texts, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				if (record.isFieldMultiSelect(fieldId))
				{
					record.doSetTexts(fieldId, texts, fireFieldChange, undefined, !shouldValidateField());
				}
			}
			this.setFieldTexts = wrapEmitLegacyError(setFieldTexts);

			function calculateGetDateTimeWithTimeZone(dateTime, timeZone)
			{
				var context = invoker(reflet, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateGetDateTimeWithTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function calculateSetDateTimeWithNewTimeZone(dateTime, timeZone)
			{
				var context = invoker(reflet, "nlapiGetContext", []);
				if (dateTime && context.getPreference("TIMEZONE") !== timeZone)
				{
					//noinspection JSUnresolvedVariable
					dateTime = invoker(remoteApi, 'calculateSetDateTimeWithNewTimeZone', [dateTime, timeZone]);
				}
				return dateTime;
			}

			function getDateTimeValue(fieldId, timezone)
			{
				var dateTime = getFieldValue(fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timezone);
			}
			this.getDateTimeValue = wrapEmitLegacyError(getDateTimeValue);

			function setDateTimeValue(fieldId, value, timezone)
			{
				value = calculateSetDateTimeWithNewTimeZone(value, timezone);
				return setFieldValue(fieldId, value);
			}
			this.setDateTimeValue = wrapEmitLegacyError(setDateTimeValue);

			function _getSubrecordBackwardCompatibilityMap(sublistId)
			{
				return (record.getSublistMetadata(sublistId) || {}).backwardCompatibilityFieldNamesForSubrecord;
			}
			this._getSubrecordBackwardCompatibilityMap = wrapEmitLegacyError(_getSubrecordBackwardCompatibilityMap);

			function getLineItemValue(sublistId, fieldId, line_1)
			{
				var value;

				if ((record.getSublistFields(sublistId) || []).indexOf(fieldId) === -1)
				{
					var backwardCompatibilityMap = _getSubrecordBackwardCompatibilityMap(sublistId) || [];
					if (backwardCompatibilityMap.indexOf(fieldId) > -1)
						fieldId = fieldId + '_initialvalue';
				}

				var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
				var isCommitted = isNotCurrentLine(sublistId, lineInstanceId);
				value = record.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted);

				value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				return value;
			}
			this.getLineItemValue = wrapEmitLegacyError(getLineItemValue);

			function getLineItemText(sublistId, fieldId, line_1)
			{
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getLineItemTexts(sublistId, fieldId, line_1);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getSublistText(sublistId, fieldId, recordUtil.getZeroBasedIndex(line_1));
					}
				}
				return returnText;
			}
			this.getLineItemText = wrapEmitLegacyError(getLineItemText);

			function getLineItemValues(sublistId, fieldId, line_1)
			{
				var value = null;
				if(record.isFieldMultiSelect(sublistId, fieldId))
				{
					value = getLineItemValue(sublistId, fieldId, line_1);
					value = fixNullEmptyBug() ? recordUtil.emptyIfNullOrUndefined(value) : value;
				}
				return value;
			}
			this.getLineItemValues = wrapEmitLegacyError(getLineItemValues);

			function getLineItemTexts(sublistId, fieldId, line_1)
			{
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getSublistText(sublistId, fieldId, recordUtil.getZeroBasedIndex(line_1));
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getLineItemTexts = wrapEmitLegacyError(getLineItemTexts);

			function setLineItemValue(sublistId, fieldId, line_1, value)
			{
				if (record.isSublistValid(sublistId))
				{
					recordUtil.validateAgainstSqlInjection(fieldId, value);
					// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
					var autosetCurrentLine = record.isDynamic && getCurrentLineItemIndex(sublistId) === line_1 && record.isSublistAListMachine(sublistId);

					var subrecordRedirect = getSubrecordRedirect(sublistId, fieldId);
					var v1Subrecord;
					var fireFieldChange = false;

					value = recordUtil.emptyIfNullOrUndefined(value);
					if (record.getSublistMetadata(sublistId).displayOnly)
						utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);

					/* Special case setting fields on the next line for edit machines and UI object list machines (backward compatiblity) */
					var line_0 = recordUtil.getZeroBasedIndex(line_1);
					record.validateLineIndex(line_0, sublistId, true);
					var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					if (record.isSublistAnEditMachine(sublistId) && line_0 === record.doGetLineCount(sublistId))
					{
						record.doInsertLineForInstance(sublistId, lineInstanceId);
						lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					}

					if (!!subrecordRedirect)
					{
						v1Subrecord = editLineItemSubrecord(sublistId, subrecordRedirect.subrecordFieldId, line_1);
						v1Subrecord.doSetFieldValue(subrecordRedirect.fieldId, value, fireFieldChange);


						if (autosetCurrentLine)
						{
							var currentV1Subrecord = editCurrentLineItemSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
							currentV1Subrecord.doSetFieldValue(subrecordRedirect.fieldId, value, fireFieldChange);
						}
					}
					else
					{
						var fieldLevelMetadata = record.getFieldLevelMetadataForSublistField(sublistId, fieldId);
						var parsedValue = recordUtil.parseValue(record.isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
						var validatedValue = shouldValidateField() ? record.validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, parsedValue) : parsedValue;
						record.doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, true, validatedValue);
						// For list machine UI compatibility, autoset the current line whenever the line item value is set directly
						if (autosetCurrentLine)
							setCurrentLineItemValue(sublistId, fieldId, value, false);
					}
				}
			}
			this.setLineItemValue = wrapEmitLegacyError(setLineItemValue);


			function getCurrentLineItemValue(sublistId, fieldId)
			{
				var value;
				if ((record.getSublistFields(sublistId) || []).indexOf(fieldId) === -1)
				{
					var backwardCompatibilityMap = ((record.getSublistMetadata(sublistId) || {}).backwardCompatibilityFieldNamesForSubrecord || []);
					if (backwardCompatibilityMap.indexOf(fieldId) > -1)
						fieldId = fieldId + '_initialvalue';
				}
				var currentInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				value = record.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, currentInstanceId, false);
				value = recordUtil.emptyIfNullOrUndefined(value);
				return value;
			}
			this.getCurrentLineItemValue = wrapEmitLegacyError(getCurrentLineItemValue);

			function getCurrentLineItemText(sublistId, fieldId)
			{
				var returnText = "";
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (record.isFieldMultiSelect(sublistId, fieldId))
					{
						var values = getCurrentLineItemTexts(sublistId, fieldId);
						returnText = values.join(",");
					}
					else
					{
						returnText = record.getCurrentSublistText(sublistId, fieldId);
					}
				}
				return returnText;
			}
			this.getCurrentLineItemText = wrapEmitLegacyError(getCurrentLineItemText);

			function getCurrentLineItemValues(sublistId, fieldId)
			{
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					var value = getCurrentLineItemValue(sublistId, fieldId);
					return recordUtil.formatValueToArrayType(value);
				}
			}
			this.getCurrentLineItemValues = wrapEmitLegacyError(getCurrentLineItemValues);

			function getCurrentLineItemTexts(sublistId, fieldId)
			{
				var texts = null;
				if (record.isFieldMultiSelect(sublistId, fieldId))
				{
					texts = record.getCurrentSublistText(sublistId, fieldId);
					texts = (texts) ? texts : (fixNullEmptyBug() ? [] : null);
				}
				return texts;
			}
			this.getCurrentLineItemTexts = wrapEmitLegacyError(getCurrentLineItemTexts);

			function doSetCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange, noSlaving)
			{
				recordUtil.validateAgainstSqlInjection(fieldId, value);
				value = String(recordUtil.emptyIfNullOrUndefined(value));

				if (isInternal())
				{
					var currentInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
					if (!currentInstanceId && record.isMultilineEditable(sublistId))
					{
						record.warnAboutMLBCurrentIndexProblem("Internal Call is attempting to setCurrentSublistValueAsLegacyString on Multiline Enabled sublist but there is no current line index! Set IGNORED");
					}
					else
					{
						// set value without formatting
						var currentLineInstance = record.doGetCurrentSublistLineInstanceId(sublistId);
						record.doSetSublistBufferFieldValue(sublistId, fieldId, currentLineInstance, value, fireFieldChange, noSlaving, true, !shouldValidateField());
						record.getSublistFieldStateForInstance(sublistId, fieldId, currentLineInstance, false).isParsed = false;
					}
				}
				else
				{
					value = recordUtil.formatArrayToStringType(value);

					var fieldLevelMetadata = record.getFieldLevelMetadataForSublistField(sublistId, fieldId);
					var parsedValue = recordUtil.parseValue(record.isValidSublistField(sublistId, fieldId), fieldLevelMetadata, value);
					record.doSetSublistBufferValue(sublistId, fieldId, record.doGetCurrentSublistLineInstanceId(sublistId), parsedValue, fireFieldChange, noSlaving, undefined, undefined, !shouldValidateField());
				}
			}

			function setCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var subrecordRedirect = getSubrecordRedirect(sublistId, fieldId);
				if (!!subrecordRedirect)
				{
					var v1Subrecord = editCurrentLineItemSubrecord(sublistId, subrecordRedirect.subrecordFieldId);
					v1Subrecord.doSetFieldValue(subrecordRedirect.fieldId, value, fireFieldChange);
				}
				else
				{
					doSetCurrentLineItemValue(sublistId, fieldId, value, fireFieldChange);
				}
			}
			this.setCurrentLineItemValue = wrapEmitLegacyError(setCurrentLineItemValue);

			function setCurrentLineItemValues(sublistId, fieldId, values, fireFieldChange)
			{
				setCurrentLineItemValue(sublistId, fieldId, values != null ? values.join(String.fromCharCode(5)) : "", fireFieldChange);
			}
			this.setCurrentLineItemValues = wrapEmitLegacyError(setCurrentLineItemValues);

			function setCurrentLineItemText(sublistId, fieldId, text, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				if (record.isFieldSelectType(sublistId, fieldId))
				{
					if (util.isArray(text))
					{
						text.forEach(function (txt)
						{
							recordUtil.validateAgainstSqlInjection(fieldId, txt);
						});
					}
					else
					{
						recordUtil.validateAgainstSqlInjection(fieldId, text);
					}
					record.doSetSublistTextForInstance(sublistId, fieldId, record.doGetCurrentSublistLineInstanceId(sublistId), false, text, fireFieldChange, false, !shouldValidateField());
				}
			}
			this.setCurrentLineItemText = wrapEmitLegacyError(setCurrentLineItemText);


			function getCurrentLineItemDateTimeValue(sublistId, fieldId, timeZone)
			{
				var dateTime = getCurrentLineItemValue(sublistId, fieldId);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getCurrentLineItemDateTimeValue = wrapEmitLegacyError(getCurrentLineItemDateTimeValue);

			function setCurrentLineItemDateTimeValue(sublistId, fieldId, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setCurrentLineItemValue(sublistId, fieldId, dateTime);
			}
			this.setCurrentLineItemDateTimeValue = wrapEmitLegacyError(setCurrentLineItemDateTimeValue);

			function getLineItemDateTimeValue(sublistId, fieldId, line, timeZone)
			{
				var dateTime = getLineItemValue(sublistId, fieldId, line);
				return calculateGetDateTimeWithTimeZone(dateTime, timeZone);
			}
			this.getLineItemDateTimeValue = wrapEmitLegacyError(getLineItemDateTimeValue);

			function setLineItemDateTimeValue(sublistId, fieldId, lineNum, dateTime, timeZone)
			{
				dateTime = calculateSetDateTimeWithNewTimeZone(dateTime, timeZone);
				return setLineItemValue(sublistId, fieldId, lineNum, dateTime);
			}
			this.setLineItemDateTimeValue = wrapEmitLegacyError(setLineItemDateTimeValue);

			function getCurrentLineItemIndex(sublistId)
			{
				if (record.isSublistValid(sublistId) != null)
					return recordUtil.getOneBasedIndex(record.getCurrentSublistIndex(sublistId));
				else
					return null;
			}
			this.getCurrentLineItemIndex = wrapEmitLegacyError(getCurrentLineItemIndex);

			function lineItemIsChanged(type) {
				var isChanged = false;
				var currentInstanceId = record.doGetCurrentSublistLineInstanceId(type);
				(record.getSublistFields(type) || []).forEach(function (fld) {
					isChanged |= record.getSublistFieldStateForInstance(type, fld, currentInstanceId, false).isChanged;
				});
				return !!isChanged;
			}
			this.lineItemIsChanged = wrapEmitLegacyError(lineItemIsChanged);

			function getSublistType(sublistId) {
				return record.getSublistType(sublistId);
			}
			this.getSublistType = wrapEmitLegacyError(getSublistType);

			function getV1Sublist(sublistId)
			{
				var sublistLevelMetadata = record.getSublistMetadata(sublistId);
				return (sublistLevelMetadata != null) ? sublist.newInstanceOfV1Sublist({
					type: sublistLevelMetadata.nlobjSublistConstructorType,
					sublistState: record.getSublistState(sublistId),
					sublistFields: sublistLevelMetadata.fieldMetadata
				}, record) : null;
			}
			this.getV1Sublist = wrapEmitLegacyError(getV1Sublist);

			function getSublist(sublistId)
			{
				return getV1Sublist(sublistId);
			}
			this.getSublist = wrapEmitLegacyError(getSublist);

			function getLineItemCount(sublistId)
			{
				return record.doGetLineCount(sublistId);
			}
			this.getLineItemCount = wrapEmitLegacyError(getLineItemCount);

			function findLineItemValue(sublistId, fieldId, value)
			{
				var index = record.doFindSublistLineWithValue(sublistId, fieldId, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemValue = wrapEmitLegacyError(findLineItemValue);

			function findLineItemMatrixValue(options, fieldId, column_1, value)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var index = record.findMatrixSublistLineWithValue(options, fieldId, column_0, value);
				return recordUtil.getOneBasedIndex(index);
			}
			this.findLineItemMatrixValue = wrapEmitLegacyError(findLineItemMatrixValue);

			function getMatrixField(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderField(options, fieldId, column_0);
			}
			this.getMatrixField = wrapEmitLegacyError(getMatrixField);

			function getMatrixCount(options, fieldId)
			{
				return record.getMatrixHeaderCount(options, fieldId);
			}
			this.getMatrixCount = wrapEmitLegacyError(getMatrixCount);

			function getMatrixValue(options, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getMatrixHeaderValue(options, fieldId, column_0);
			}
			this.getMatrixValue = wrapEmitLegacyError(getMatrixValue);

			function setMatrixValue(options, fieldId, column_1, value, fireFieldChange)
			{
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.setMatrixHeaderValue(options, fieldId, column_0, value, !fireFieldChange);
			}
			this.setMatrixValue = wrapEmitLegacyError(setMatrixValue);


			function getLineItemMatrixField(sublistId, fieldId, line_1, column_1)
			{
				if(!column_1)
				{
					column_1 = line_1;
					line_1 = -1;
				}
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistField(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixField = wrapEmitLegacyError(getLineItemMatrixField);

			function getLineItemMatrixValue(sublistId, fieldId, line_1, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				var line_0 = recordUtil.getZeroBasedIndex(line_1);
				return record.getMatrixSublistValue(sublistId, fieldId, line_0, column_0);
			}
			this.getLineItemMatrixValue = wrapEmitLegacyError(getLineItemMatrixValue);

			function setLineItemMatrixValue(sublistId, fieldId, line_1, column_1, value)
			{

				if (record.isSublistValid(sublistId)) {

					recordUtil.validateAgainstSqlInjection(fieldId, value);
					var column_0 = recordUtil.validateAndGetZeroBasedIndex(column_1, 'setMatrixSublistValue', getMatrixCount(sublistId, fieldId));
					var line_0 = recordUtil.validateAndGetZeroBasedIndex(line_1, 'setMatrixSublistValue', getLineItemCount(sublistId));

					utilityFunctions.checkArgs( [sublistId, fieldId, line_0, column_0], ['sublistId', 'fieldId', 'line', 'column'], record.getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
					matrix.validateMatrixFieldAndLine.call(record, sublistId, fieldId, line_0);
					value = recordUtil.emptyIfNullOrUndefined(value);

					var matrixFieldName = matrix.getMatrixLineFieldName.call(record, sublistId, fieldId, column_1);
					var lineInstanceId = getInstanceIdFromLine(sublistId, line_0);
					record.doSetSublistValueForInstance(sublistId, matrixFieldName, lineInstanceId, true, value);
					if (record.isDynamic && line_1 === getCurrentLineItemIndex(sublistId) && record.isSublistAListMachine(sublistId))
						record.doSetSublistBufferValue(sublistId, matrixFieldName, lineInstanceId, value, false);
				}
			}
			this.setLineItemMatrixValue = wrapEmitLegacyError(setLineItemMatrixValue);

			function getCurrentLineItemMatrixValue(sublistId, fieldId, column_1)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				return record.getCurrentMatrixSublistValue(sublistId, fieldId, column_0);
			}
			this.getCurrentLineItemMatrixValue = wrapEmitLegacyError(getCurrentLineItemMatrixValue);

			function setCurrentLineItemMatrixValue(sublistId, fieldId, column_1, value, fireFieldChange)
			{
				var column_0 = recordUtil.getZeroBasedIndex(column_1);
				fireFieldChange = util.isBoolean(fireFieldChange) ? fireFieldChange : fireFieldChange || true;
				return record.setCurrentMatrixSublistValue(sublistId, fieldId, column_0, value, !fireFieldChange);
			}
			this.setCurrentLineItemMatrixValue = wrapEmitLegacyError(setCurrentLineItemMatrixValue);

			function selectNewLineItem(sublistId, ignoreLineInit)
			{
				return record.doSelectNewLine(sublistId, ignoreLineInit);
			}
			this.selectNewLineItem = wrapEmitLegacyError(selectNewLineItem);

			function selectLineItem(sublistId, line_1)
			{
				return record.doSelectLineForInstance(sublistId, getInstanceIdFromLine(sublistId, line_1));
			}
			this.selectLineItem = wrapEmitLegacyError(selectLineItem);

			function insertLineItem(sublistId, line_1, ignoreRecalc)
			{
				var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
				record.doInsertLineForInstance(sublistId, lineInstanceId, ignoreRecalc);
			}
			this.insertLineItem = wrapEmitLegacyError(insertLineItem);

			function removeLineItem(sublistId, line_1, ignoreRecalc)
			{
				var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
				record.doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc, !shouldValidateField());
			}
			this.removeLineItem = wrapEmitLegacyError(removeLineItem);

			function cancelLineItem(sublistId)
			{
				record.cancelLine(sublistId);
			}
			this.cancelLineItem = wrapEmitLegacyError(cancelLineItem);

			function commitLineItem(sublistId, ignoreRecalc)
			{
				if (record.commitLine(sublistId, ignoreRecalc) !== null) {
					var sublistState = record.getSublistState(sublistId);
					if (!sublistState.allowsNewLine)
						sublistState.updateBufferLineStateForInstance(record.doGetCurrentSublistLineInstanceId(sublistId));
				}
			}
			this.commitLineItem = wrapEmitLegacyError(commitLineItem);

			function doInsertSelectOption(fld, value, text, selected, isColumnOption)
			{
				try
				{
					fld.insertSelectOption(value, text, selected, isColumnOption);
				}
				catch (e)
				{
					if (e.name !== error.Type.SELECT_OPTION_ALREADY_PRESENT)
						throw e;
				}
			}

			function doRemoveSelectOption(fld, value, isColumnOption)
			{
				try
				{
					fld.removeSelectOption(value, isColumnOption);
				}
				catch (e)
				{
					if (e.name !== error.Type.SELECT_OPTION_NOT_FOUND)
						throw e;
				}
			}

			function insertLineItemOption(type, fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') === 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					doInsertSelectOption(fld, value, text, selected, true);
			}
			this.insertLineItemOption = wrapEmitLegacyError(insertLineItemOption);

			function removeLineItemOption(type, fldnam, value)
			{
				utilityFunctions.assertTrue(type != null && fldnam != null && fldnam.indexOf('custpage') === 0, 'SSS_INVALID_OPERATION');
				var fld = getLineItemField(type, fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						doRemoveSelectOption(fld, value, true);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {doRemoveSelectOption(fld, selectOption.getId(), true);});
				}
			}
			this.removeLineItemOption = wrapEmitLegacyError(removeLineItemOption);

			function insertSelectOption(fldnam, value, text, selected)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') === 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('insertSelectOption') && !fld.isPopup())
					doInsertSelectOption(fld, value, text, selected);
			}
			this.insertSelectOption = wrapEmitLegacyError(insertSelectOption);

			function removeSelectOption(fldnam, value)
			{
				utilityFunctions.assertTrue(fldnam != null && fldnam.indexOf('custpage') === 0, 'SSS_INVALID_OPERATION');
				var fld = getField(fldnam);
				if (fld && fld.hasOwnProperty('removeSelectOption') && !fld.isPopup())
				{
					if (value != null)
						doRemoveSelectOption(fld, value);
					else // remove all options
						(fld.getSelectOptions() || []).forEach(function (selectOption) {doRemoveSelectOption(fld, selectOption.getId());});
				}
			}
			this.removeSelectOption = wrapEmitLegacyError(removeSelectOption);

			function getField(fieldId)
			{
				return record.getCachedRecordFieldForInstance(undef, fieldId, undef, undef);
			}
			this.getField = wrapEmitLegacyError(getField);

			function getLineItemField(sublistId, fieldId, line_1)
			{
				var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
				var isCommitted = isNotCurrentLine(sublistId, lineInstanceId);

				return (!lineInstanceId) ? undef : record.getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}
			this.getLineItemField = wrapEmitLegacyError(getLineItemField);

			function getAllSublists()
			{
				return record.getSublists();
			}
			this.getAllSublists = wrapEmitLegacyError(getAllSublists);

			function getAllFields()
			{
				return record.getFields();
			}
			this.getAllFields = wrapEmitLegacyError(getAllFields);

			function getAllLineItemFields(sublistId)
			{
				return record.getSublistFields(sublistId);
			}
			this.getAllLineItemFields = wrapEmitLegacyError(getAllLineItemFields);

			function isDynamic()
			{
				return record.isDynamic;
			}
			this.isDynamic = wrapEmitLegacyError(isDynamic);

			function isChanged()
			{
				return record.getIsChanged();
			}
			this.isChanged = wrapEmitLegacyError(isChanged);

			function isInternal()
			{
				return record.isInternal();
			}
			this.isInternal = wrapEmitLegacyError(isInternal);

			function shouldValidateField()
			{
				return record.getIsInited() && !record.isInternal();
			}

			function getFieldDisabled(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisabled();
			}
			this.getFieldDisabled = wrapEmitLegacyError(getFieldDisabled);

			function setFieldDisabled(fieldId, disable)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisabled(disable);
			}
			this.setFieldDisabled = wrapEmitLegacyError(setFieldDisabled);

			function getFieldMandatory(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isMandatory();
			}
			this.getFieldMandatory = wrapEmitLegacyError(getFieldMandatory);

			function setFieldMandatory(fieldId, mandatory)
			{
				var field = getField(fieldId);
				if (field)
					field.setMandatory(mandatory);
			}
			this.setFieldMandatory = wrapEmitLegacyError(setFieldMandatory);

			function getFieldDisplay(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isDisplay();
			}
			this.getFieldDisplay = wrapEmitLegacyError(getFieldDisplay);

			function setFieldDisplay(fieldId, display)
			{
				var field = getField(fieldId);
				if (field)
					field.setDisplay(display);
			}
			this.setFieldDisplay = wrapEmitLegacyError(setFieldDisplay);

			function getFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					return field.isVisible(visible);
			}
			this.getFieldVisibility = wrapEmitLegacyError(getFieldVisibility);

			function setFieldVisibility(fieldId, visible)
			{
				var field = getField(fieldId);
				if (field)
					field.setVisible(visible);
			}
			this.setFieldVisibility = wrapEmitLegacyError(setFieldVisibility);

			function getFieldReadOnly(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.isReadOnly();
			}
			this.getFieldReadOnly = wrapEmitLegacyError(getFieldReadOnly);

			function setFieldReadOnly(fieldId, readonly)
			{
				var field = getField(fieldId);
				if (field)
					field.setReadOnly(readonly);
			}
			this.setFieldReadOnly = wrapEmitLegacyError(setFieldReadOnly);

			function getFieldLabel(fieldId)
			{
				var field = getField(fieldId);
				if (field)
					return field.getLabel();
			}
			this.getFieldLabel = wrapEmitLegacyError(getFieldLabel);

			function setFieldLabel(fieldId, label)
			{
				var field = getField(fieldId);
				if (field)
					field.setLabel(label);
			}
			this.setFieldLabel = wrapEmitLegacyError(setFieldLabel);

			function getLineItemDisplay(sublistId)
			{
				var sublistState = record.getSublistState(sublistId);
				return (sublistState) ? sublistState.isDisplay : false;
			}
			this.getLineItemDisplay = wrapEmitLegacyError(getLineItemDisplay);

			function setLineItemDisplay(sublistId, display)
			{
				var sublistState = record.getSublistState(sublistId);
				if (sublistState)
					sublistState.isDisplay = display;
			}
			this.setLineItemDisplay = wrapEmitLegacyError(setLineItemDisplay);

			function getInstanceIdFromLine(sublistId, line_1)
			{
				var lineInstanceId = null;
				if (line_1 == null || line_1 === -1)
				{
					lineInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
				}
				else
				{
					lineInstanceId = record.getLineInstanceId(sublistId, recordUtil.getZeroBasedIndex(line_1));
				}
				return lineInstanceId;
			}

			function isNotCurrentLine(sublistId, lineInstanceId)
			{
				return lineInstanceId !== record.doGetCurrentSublistLineInstanceId(sublistId);
			}

			function doGetSublistFieldState(sublistId, fieldId, line_1)
			{
				if (record.isSublistAnEditMachine(sublistId))
				{
					line_1 = -1; // for edit machine take only current line
				}

				var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
				var isCommitted = isNotCurrentLine(sublistId, lineInstanceId);

				if (lineInstanceId === null && record.isMultilineEditable(sublistId))
					return null;
				else
					return record.getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function getLineItemDisabled(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isDisabled : false;
			}
			this.getLineItemDisabled = wrapEmitLegacyError(getLineItemDisabled);

			function setLineItemDisabled(sublistId, fieldId, disabled, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isDisabled = disabled;
			}
			this.setLineItemDisabled = wrapEmitLegacyError(setLineItemDisabled);

			function getLineItemMandatory(sublistId, fieldId, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				return (fieldState) ? fieldState.isMandatory : false;
			}
			this.getLineItemMandatory = wrapEmitLegacyError(getLineItemMandatory);

			function setLineItemMandatory(sublistId, fieldId, mandatory, line_1)
			{
				var fieldState = doGetSublistFieldState(sublistId, fieldId, line_1);
				if (fieldState)
					fieldState.isMandatory = mandatory;
			}
			this.setLineItemMandatory = wrapEmitLegacyError(setLineItemMandatory);

			function getLineItemLabel(sublistId, fieldId)
			{
				var field = record.getCachedRecordFieldForInstance(sublistId, fieldId, record.doGetCurrentSublistLineInstanceId(sublistId), false);
				return field ? field.getLabel() : null;
			}
			this.getLineItemLabel = wrapEmitLegacyError(getLineItemLabel);

			function setLineItemLabel(sublistId, fieldId, label)
			{
				var field = record.getCachedRecordFieldForInstance(sublistId, fieldId, record.doGetCurrentSublistLineInstanceId(sublistId), false);
				if (field)
					field.setLabel(label);
			}
			this.setLineItemLabel = wrapEmitLegacyError(setLineItemLabel);

			function handleChangeCall(params)
			{
				record.handleChangeCall(params);
			}
			this.handleChangeCall = wrapEmitLegacyError(handleChangeCall);

			function triggerFieldChangeEvent(sublistId, fieldId, line_1, value, noSlaving)
			{
				var lineInstanceId, isCommitted;
				if (sublistId)
				{
					lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					isCommitted = isNotCurrentLine(sublistId, lineInstanceId);
				}
				record.triggerFieldChangeEvent(sublistId, fieldId, lineInstanceId, isCommitted, value, noSlaving);
			}
			this.triggerFieldChangeEvent = wrapEmitLegacyError(triggerFieldChangeEvent);

			function doSlaving(sublistId, fieldId, line_1, value, restrictField)
			{
				var lineInstanceId, isCommitted;
				if (sublistId)
				{
					lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					isCommitted = isNotCurrentLine(sublistId, lineInstanceId);
				}
				record.doSlaving(sublistId, fieldId, lineInstanceId, isCommitted, value, restrictField);
			}
			this.doSlaving = wrapEmitLegacyError(doSlaving);

			function createV1Subrecord(record, isAbandoned)
			{
				if (record == null)
				{
					return null;
				}
				var v1Subrecord = record.v1Subrecord;
				if (!v1Subrecord)
				{
					v1Subrecord = new RecordImplV1({
						record: record,
						isSubrecord: true,
						parentV1Record: isAbandoned ? undefined : that
					});
					if (!isAbandoned)
					{
						record.v1Subrecord = v1Subrecord;
					}
				}
				return v1Subrecord;
			}

			function removeV1Subrecord(record)
			{
				if (record == null)
				{
					return;
				}
				var v1Subrecord = record.v1Subrecord;
				if (v1Subrecord)
				{
					v1Subrecord.abandon();
					delete record.v1Subrecord;
				}
			}
			this.removeV1Subrecord = removeV1Subrecord;

			function createSubrecord(fieldId)
			{
				try
				{
					var subrecord;
					if (!record.doHasSubrecord(fieldId))
					{
						subrecord = record.doGetBodySubrecord(fieldId);
					}
					return createV1Subrecord(subrecord);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.createSubrecord = wrapEmitLegacyError(createSubrecord);

			function editSubrecord(fieldId)
			{
				try
				{
					var subrecord;
					if (record.doHasSubrecord(fieldId))
					{
						subrecord = record.doGetBodySubrecord(fieldId);
					}
					return createV1Subrecord(subrecord);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.editSubrecord = wrapEmitLegacyError(editSubrecord);

			function viewSubrecord(fieldId)
			{
				try
				{
					var subrecord;
					if (record.doHasSubrecord(fieldId))
					{
						subrecord = record.doGetBodySubrecord(fieldId, true);
					}
					return createV1Subrecord(subrecord, true);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.viewSubrecord = wrapEmitLegacyError(viewSubrecord);

			function removeSubrecord(fieldId)
			{
				try
				{
					if (record.doHasSubrecord(fieldId))
					{
						removeV1Subrecord(record.doGetBodySubrecord(fieldId));
						record.removeSubrecord(fieldId);
					}
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.removeSubrecord = wrapEmitLegacyError(removeSubrecord);

			function createCurrentLineItemSubrecord(sublistId, fieldId)
			{
				try
				{
					var subrecord;
					var currentInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
					if (!record.doHasSubrecordForInstance(sublistId, fieldId, currentInstanceId, false))
					{
						subrecord = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
					}
					return createV1Subrecord(subrecord);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.createCurrentLineItemSubrecord = wrapEmitLegacyError(createCurrentLineItemSubrecord);

			function editCurrentLineItemSubrecord(sublistId, fieldId)
			{
				try
				{
					var subrecord;
					var currentInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
					if (record.doHasSubrecordForInstance(sublistId, fieldId, currentInstanceId, false))
					{
						subrecord = record.doGetCurrentSublistSubrecord(sublistId, fieldId);
					}
					return createV1Subrecord(subrecord);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.editCurrentLineItemSubrecord = wrapEmitLegacyError(editCurrentLineItemSubrecord);

			function viewCurrentLineItemSubrecord(sublistId, fieldId)
			{
				try
				{
					var subrecord;
					var currentInstanceId = record.doGetCurrentSublistLineInstanceId(sublistId);
					if (record.doHasSubrecordForInstance(sublistId, fieldId, currentInstanceId, false))
					{
						subrecord = record.doGetCurrentSublistSubrecord(sublistId, fieldId, true);
					}
					return createV1Subrecord(subrecord, true);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.viewCurrentLineItemSubrecord = wrapEmitLegacyError(viewCurrentLineItemSubrecord);

			function removeCurrentLineItemSubrecord(sublistId, fieldId)
			{
				try
				{
					var currentInstanceId = getInstanceIdFromLine(sublistId, -1);
					if (record.doHasSubrecordForInstance(sublistId, fieldId, currentInstanceId, false))
					{
						removeV1Subrecord(record.doGetCurrentSublistSubrecord(sublistId, fieldId));
						record.removeCurrentSublistSubrecord(sublistId, fieldId);
					}
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.removeCurrentLineItemSubrecord = wrapEmitLegacyError(removeCurrentLineItemSubrecord);

			function editLineItemSubrecord(sublistId, fieldId, line_1)
			{
				try
				{
					var subrecord;
					var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					if (record.doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, false))
					{
						subrecord = record.doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, false);
					}
					return createV1Subrecord(subrecord);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}

			function viewLineItemSubrecord(sublistId, fieldId, line_1)
			{
				try
				{
					var subrecord;
					var lineInstanceId = getInstanceIdFromLine(sublistId, line_1);
					if (record.doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, false))
					{
						subrecord = record.doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, false, true);
					}
					return createV1Subrecord(subrecord, true);
				}
				catch (e)
				{
					if (e.name === error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD)
					{
						throw error.create({name: 'SSS_INVALID_FIELD_ON_SUBRECORD_OPERATION'});
					}
					throw e;
				}
			}
			this.viewLineItemSubrecord = wrapEmitLegacyError(viewLineItemSubrecord);

			function commit()
			{
				record.commit();
				abandon();
			}
			this.commit = wrapEmitLegacyError(commit);

			function cancel()
			{
				record.cancel();
				abandon();
			}
			this.cancel = wrapEmitLegacyError(cancel);
		}

		/**
		 *
		 * @param {object} options
		 * @param {RawRecord} options.record
		 * @param {boolean?} options.isSubrecord
		 * @param {RecordImplV1?} options.parentV1Record
		 * @returns {RecordImplV1}
		 */
		function create(options){
			return new RecordImplV1(options);
		}

		return { create: create };
	});
/**
 * SuiteScript scope
 *
 * @private
 * @module N/scope
 * @NApiVersion 2.x
 *
 */
define('N/scope',[], function(){
    var blacklist = ['blacklist'];

    // HIDE SCOPE loadCallback
    blacklist = blacklist.concat('error', 'parent', 'responseObj', 'scriptInfo');

    // HIDE SCOPE require.load
    blacklist = blacklist.concat('argList', 'context', 'getParentPath', 'loadCallback', 'method', 'moduleName',
        'pageMode', 'parentMap', 'parentPath', 'recordType', 'url');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('SuiteScriptModuleLoaderError', 'addModuleNameToDefineModuleList', 'define',
        'dependencyCheck', 'doLogExecution', 'forceSync', 'global', 'internals', 'isApiPath', 'isFilePathLike',
        'isModuleNameAlreadyDefined', 'log', 'makeServerCall', 'namesOfDefinedModules', 'old_define', 'p', 'require',
        'requirejs', 'serverCallAsync', 'serverCallSync', 'stripApiPath', 'toEmptyString', 'util');

    // HIDE SCOPE undefined
    blacklist = blacklist.concat('callURL', 'createNode', 'getGlobalScope', 'legacyCallURL', 'nlRequestId', 'nlapi');

    return function(){
        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, blacklist)());

        eval(function(blacklist){
            return !!blacklist && blacklist.map(function(v){ return 'var ' + v + ' = undefined;' ;}).join('');
        }.bind(null, arguments[0] && arguments[0].blacklist)());

        eval(function(whitelist){
            return !!whitelist && Object.keys(whitelist).map(function(v){
                    return 'var ' + v + ' = arguments[0].whitelist["' + v + '"];';
                }).join('');
        }.bind(null, arguments[0] && arguments[0].whitelist)());

        eval(function(libraries){
            return !!libraries && libraries.join(';');
        }.bind(null, arguments[0] && arguments[0].libraries)());

        return function(){
            return eval(arguments[0]);
        };
    };
});
/**
 * @private
 */
define('N/restricted/searchApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * @private
 */
define('N/internal/bridge',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript searchPaging module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/search/searchPaging
 * @NApiVersion 2.x
 *
 */
define('N/search/searchPaging',['N/internal/invoker', 'N/internal/bridge', 'N/error', 'N/nsobject', 'N/search/pagingUtil'],
function (invoker, api, error, nsobject, pagingUtil){
    function RemotePageRange(options)
    {
        var index = options.index,
            compoundKey = options.compoundKey,
            compoundLabel = options.compoundLabel;

        this.getIndex = function getIndex(){return index;};
        this.getCompoundKey = function getCompoundKey(){return compoundKey;};
        this.getCompoundLabel = function getCompoundLabel(){return compoundLabel;};
    }
    RemotePageRange.prototype = nsobject.getNewInstance();

    function RemotePage(options)
    {
        var data = options.data,
            pageRange = new RemotePageRange(options.pageRange),
            _isFirst = options.isFirst,
            _isLast = options.isLast;

        this.getData = function getData(){return data;};
        this.getPageRange = function getPageRange(){return pageRange};
        this.isFirst = function isFirst(){return _isFirst;};
        this.isLast = function isLast(){return _isLast;};
    }
    RemotePage.prototype = nsobject.getNewInstance();

    function RemotePagedData(options)
    {
        var recordType = options.recordType,
            searchId = options.searchId,
            filters = options.filters,
            columns = options.columns,
            settings = options.settings,
            totalRows = isNaN(options.totalRows) ? -1 : options.totalRows,
            pageSize = isNaN(options.pageSize) ? -1 : options.pageSize,
            pageRanges = Array.isArray(options.pageRanges) && options.pageRanges.map(function(v,i,a){return new RemotePageRange(v);}) || [];

        this.getPageSize = function getPageSize(){return pageSize;};
        this.getTotalRows = function getTotalRows(){return totalRows;};
        this.getPageRanges = function getTotalRows(){return pageRanges;};
        this.getPage = function getPage(index){
            var pageRange = pageRanges[index],
                pageCount = pageRanges.length;

            return new RemotePage(invoker(api, 'getSearchPage', [recordType, searchId, filters, columns, settings,
                pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                pageSize,
                pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                pageCount, null]));
        };
        this.getPagePromise = function getPagePromise(index)
        {
            return new Promise(function(resolve, reject){
                function callback(result, exception) {
                    if (exception)
                    {
                        reject(exception);
                    }
                    else
                    {
                        resolve(new RemotePage(result));
                    }
                }

                try
                {
                    var pageRange = pageRanges[index],
                        pageCount = pageRanges.length;

                    invoker(
                        api,
                        'getSearchPage',
                        [recordType, searchId, filters, columns, settings,
                            pageRange.getCompoundKey(), pageRange.getCompoundLabel(), pageRange.getIndex(),
                            pageSize,
                            pageRanges[0].getCompoundKey(), pageRanges[pageCount - 1].getCompoundKey(),
                            pageCount, null],
                        callback);
                }
                catch(e)
                {
                    reject(e);
                }
            });
        }
    }
    RemotePagedData.prototype = nsobject.getNewInstance();

    var SearchPaging = {};

    SearchPaging.create = function create(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            settings = options.settings,//options.searchDefinition.settings,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        var result = invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, settings, pageSize, null]);
        result.recordType = recordType;
        result.searchId = searchId;
        result.filters = filters;
        result.columns = columns;

        return new RemotePagedData(result);
    };

    SearchPaging.create.promise = function createPromise(options){
        var recordType = options.searchDefinition.searchType,
            searchId = options.searchDefinition.searchId,
            filters = options.filters,//options.searchDefinition.filters,
            columns = options.columns,//options.searchDefinition.columns,
            settings = options.settings,//options.searchDefinition.settings,
            pageSize = pagingUtil.regulatePageSize(options.pageSize);

        return new Promise(function(resolve, reject){
            function callback(result, exception) {
                if (exception)
                {
                    reject(exception);
                }
                else
                {
                    result.recordType = recordType;
                    result.searchId = searchId;
                    result.filters = filters;
                    result.columns = columns;
                    result.settings = settings;
                    resolve(new RemotePagedData(result));
                }
            }

            try
            {
                invoker(api, 'getSearchPages', [recordType, searchId, filters, columns, settings, pageSize, null], callback);
            }
            catch(e)
            {
                reject(e);
            }
        });
    };

    return SearchPaging;
});
/**
 * SuiteScript search object constructor
 *
 * @private
 * @module N/search/searchObject
 * @suiteScriptVersion 2.x
 *
 */
define('N/search/searchObject',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/nsobject', 'N/internal/invoker', 'N/search/searchPaging', 'N/pagination/paginationObject', 'N/utilityFunctions', 'N/environment'],
       function (searchApi, remoteApi, error, nsobject, invoker, searchPaging, paginationObject, utilityFunctions, environment)
       {
           var OPERATORS = Object.freeze({
                                             AFTER: 'after',
                                             ALLOF: 'allof',
                                             ANY: 'any',
                                             ANYOF: 'anyof',
                                             BEFORE: 'before',
                                             BETWEEN: 'between',
                                             CONTAINS: 'contains',
                                             DOESNOTCONTAIN: 'doesnotcontain',
                                             DOESNOTSTARTWITH: 'doesnotstartwith',
                                             EQUALTO: 'equalto',
                                             GREATERTHAN: 'greaterthan',
                                             GREATERTHANOREQUALTO: 'greaterthanorequalto',
                                             HASKEYWORDS: 'haskeywords',
                                             IS: 'is',
                                             ISEMPTY: 'isempty',
                                             ISNOT: 'isnot',
                                             ISNOTEMPTY: 'isnotempty',
                                             LESSTHAN: 'lessthan',
                                             LESSTHANOREQUALTO: 'lessthanorequalto',
                                             NONEOF: 'noneof',
                                             NOTAFTER: 'notafter',
                                             NOTALLOF: 'notallof',
                                             NOTBEFORE: 'notbefore',
                                             NOTBETWEEN: 'notbetween',
                                             NOTEQUALTO: 'notequalto',
                                             NOTGREATERTHAN: 'notgreaterthan',
                                             NOTGREATERTHANOREQUALTO: 'notgreaterthanorequalto',
                                             NOTLESSTHAN: 'notlessthan',
                                             NOTLESSTHANOREQUALTO: 'notlessthanorequalto',
                                             NOTON: 'noton',
                                             NOTONORAFTER: 'notonorafter',
                                             NOTONORBEFORE: 'notonorbefore',
                                             NOTWITHIN: 'notwithin',
                                             ON: 'on',
                                             ONORAFTER: 'onorafter',
                                             ONORBEFORE: 'onorbefore',
                                             STARTSWITH: 'startswith',
                                             WITHIN: 'within'
                                         });
	       var ARRAY_BASED_OPERATORS = [OPERATORS.ANYOF, OPERATORS.NONEOF, OPERATORS.ALLOF, OPERATORS.NOTALLOF];
	       var PERIOD_OPERATORS = Object.freeze({
		       ABS: "ABS",
		       REL: "REL"
	       });
           var SUMMARY_TYPES = Object.freeze({
                                                 GROUP: 'GROUP',
                                                 COUNT: 'COUNT',
                                                 SUM: 'SUM',
                                                 AVG: 'AVG',
                                                 MIN: 'MIN',
                                                 MAX: 'MAX'
                                             });
           var FUNCTIONS = Object.freeze({
                                             absoluteValue: '',
                                             ageInHours: '',
                                             ageInDays: '',
                                             ageInMonths: '',
                                             ageInWeeks: '',
                                             ageInYears: '',
                                             calendarWeek: '',
                                             day: '',
                                             month: '',
                                             negate: '',
                                             numberAsTime: '',
                                             percentOfTotal: '',
                                             quarter: '',
                                             rank: '',
                                             round: '',
                                             roundToHundredths: '',
                                             roundToTenths: '',
                                             weekOfYear: '',
                                             year: ''
                                         });
           var SORT = Object.freeze({
                                        ASC: 'ASC',
                                        DESC: 'DESC',
                                        NONE: 'NONE'
                                    });

           function applyValidationFunctionToArrayElement(array, func)
           {
               if (!util.isArray(array))
                   return false;
               for (var i = 0; i < array.length; ++i)
               {
                   if (!func(array[i]))
                       return false;
               }
               return true;
           }
           function resolveUndefined(obj)
           {
               return obj === undefined ? null : obj;
           }
           function resolveUndefinedForArguments(args)
           {
               return args.map(function (v, i, a){ return resolveUndefined(v); });
           }

	       function convertJsFiltersToJavaFilters(jsFilters)
	       {
		       var javaFilters = [];
		       for (var i = 0; jsFilters && i < jsFilters.length; i++)
		       {
			       var filterState = jsFilters[i].toJSON();

			       var useArray = filterState.operator && ARRAY_BASED_OPERATORS.indexOf(filterState.operator.toLowerCase()) > -1;
			       var firstValue = (util.isArray(filterState.values)) ? useArray ? filterState.values : filterState.values[0] : null;
			       var secondValue = (util.isArray(filterState.values) && !useArray) ? filterState.values[1] : null;
			       javaFilters[i] = invoker(searchApi, 'createSearchFilter', [filterState.name, filterState.join || null, filterState.operator, firstValue, secondValue]);

			       if (util.isString(filterState.formula))
				       javaFilters[i].setFormula(filterState.formula);
			       if (util.isString(filterState.summarytype))
				       javaFilters[i].setSummaryType(filterState.summarytype);
			       if (util.isBoolean(filterState.isor))
				       javaFilters[i].setOr(filterState.isor);
			       if (util.isBoolean(filterState.isnot))
				       javaFilters[i].setNot(filterState.isnot);
			       if (util.isNumber(filterState.leftparens))
				       javaFilters[i].setLeftParens(filterState.leftparens);
			       if (util.isNumber(filterState.rightparens))
				       javaFilters[i].setRightParens(filterState.rightparens);
		       }
		       return javaFilters;
	       }

	       function convertJsColumnsToJavaColumns(jsColumns)
	       {
		       var javaColumns = [];
		       for (var i = 0; jsColumns && i < jsColumns.length; i++)
		       {
			       var columnState = jsColumns[i].toJSON();

			       javaColumns[i] = invoker(searchApi, 'createSearchColumn', [columnState.name, columnState.join || null, columnState.summary || null]);

			       if (util.isString(columnState.label))
				       javaColumns[i].setLabel(columnState.label);
			       if (util.isString(columnState.sortdir) && columnState.sortdir !== SORT.NONE)
				       javaColumns[i].setSort(/*isDescending*/ columnState.sortdir === SORT.DESC);
			       if (util.isString(columnState.formula))
				       javaColumns[i].setFormula(columnState.formula);
			       if (util.isString(columnState['function']))
				       javaColumns[i].setFunction(columnState['function']);
			       if (util.isString(columnState.whenorderedby))
				       javaColumns[i].setWhenOrderedBy(columnState.whenorderedby, columnState.whenorderedbyjoin);
		       }
		       return javaColumns;
	       }

	       function convertJsSettingsToJavaSettings(jsSettings)
	       {
		       var javaSettings = [];
		       for (var i = 0; jsSettings && i < jsSettings.length; i++)
		       {
			       var settingState = jsSettings[i].toJSON();
			       javaSettings[i] = invoker(searchApi, 'createSearchSetting', [settingState.name, settingState.value]);

		       }
		       return javaSettings;
	       }

	       /**
            * Return a new instance of search.Search object.
            *
            * @classDescription Encapsulates a NetSuite search.
            * @constructor
            * @param {string} typeOrJavaSearch (optional)  the record type you are searching
            * @param {number} id  the internal ID of the search
            * @param {Array<Filter>} [filters] a single filter object or an array of filters used to
            *     filter the search
            * @param {Array<Column>|Array<string>} [columns]  columns to be returned from the search
            * @return {Search}
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER when provided filters contain a different type than search.Filter
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when provided columns contain a different type than search.Column
            *     or string 
	          * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING when provided filters contain a different type than search.Setting
	        *
            * @since 2015.2
            */
           function Search(typeOrJavaSearch, searchId, filters, columns, settings)
           {
               var that = this;
               var TYPE = 'search.Search';

               /* private vars */
               var javaSearch = !util.isString(typeOrJavaSearch) ? typeOrJavaSearch : undefined;
               var jsSearch;
               var _type = util.isString(typeOrJavaSearch) ? typeOrJavaSearch : null;
               var _searchId = searchId;
               var _filters;
               var _columns;
	           var _settings;
               var _title = null;
               var _scriptId = null;
               var _isPublic = false;
               var _package = null;
	           
	           /* helper method for loadSearch() */
               this._load = function load(callback)
               {
                   if(!javaSearch)
                       javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)], callback ? loadCallback : null);

                   if (!callback)
                       loadCallback(javaSearch);

                   function loadCallback(javaSearch, exception)
                   {
                       if (callback && exception)
                       {
                           callback(undefined, exception);
                           return;
                       }
                       jsSearch = invoker(remoteApi, 'transform', [javaSearch]);

                       _isPublic = jsSearch.ispublic;
                       _searchId = (jsSearch.searchId === undefined || jsSearch.searchId === null) ? null : parseInt(jsSearch.searchId, 10);
                       _scriptId = jsSearch.scriptid;
                       _package = jsSearch.packageId;
                       _type = jsSearch.type;
                       _filters = utilityFunctions.unmarshalArray(jsSearch, 'filter', Filter.unmarshalFilter);
                       _columns = utilityFunctions.unmarshalArray(jsSearch, 'column', Column.unmarshalColumn);
	                   _settings = utilityFunctions.unmarshalArray(jsSearch, 'setting', Setting.unmarshalSetting);
                       if (callback)
                           callback(that);
                   }
               };

               /**
                * Internal ID name of the record type on which a search is based.
                * @name Search#searchType
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchType', {
                   get: function ()
                   {
                       return _type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchType' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Internal ID of the search.
                * @name Search#searchId
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'searchId', {
                   get: function ()
                   {
                       return _searchId;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'searchId' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Filters for the search as an array of Filter objects.
                * @name Search#filters
                * @type {Array<Filter>}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER Invalid value for search filter type.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any filter to assign is of invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'filters', {
                   get: function ()
                   {
                       return _filters;
                   },
                   set: function (filters)
                   {
                       _filters = filters ? (util.isArray(filters) ? filters : [filters]) : null;
                       if (_filters !== null)
                       {
                           for (i = 0; i < _filters.length; i++)
                           {
                                if (util.isObject(_filters[i]) )
                                    _filters[i] = createFilter( _filters[i] )
                                else if (!(_filters[i] instanceof Filter))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'filters['+i+']', 'Filter' );
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawFilters', {
                   get: function ()
                   {
                       return Filter.marshalFilters(_filters);
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Use filter expressions as a shortcut to create filters (search.Filter).
                * @name Search#filterExpression
                * @type {Array<Object>}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER Invalid value for search filter type.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When filterExpression contains a member with invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'filterExpression', {
                   get: function ()
                   {
                       var rawFilters = Filter.marshalFilters(_filters);
                       var payload = invoker(remoteApi, 'buildSearchFilterExpression', [rawFilters]);
                       payload = invoker(remoteApi, 'transform', [payload]);
                       return Filter.unmarshalFilterExpression(payload);
                   },
                   set: function (filterExpression)
                   {
                       filterExpression = Filter.normalizeFilters(filterExpression);
                       utilityFunctions.assertTrue(!applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject), error.Type.WRONG_PARAMETER_TYPE, 'filterExpression', 'Filter');
                       _filters = Filter.parseFilterExpression(filterExpression);
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Columns to return for this search as an array of search.Column objects or a string array of column names.
                * @name Search#columns
                * @type {Array<Column>|Array<string>}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN when setting value of different type than search.Column or string
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any column to assign is of invalid type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return _columns;
                   },
                   set: function (columns)
                   {
                       _columns = columns ? (util.isArray(columns) ? columns : [columns]) : null;
                       if (_columns !== null)
                       {
                           for (var i = 0; i < _columns.length; i++)
                           {
                                if (util.isObject(_columns[i]))
                                    _columns[i] = createColumn( _columns[i] )
                                else if (util.isString(_columns[i]))
                                   _columns[i] = new Column(getNameFromColumn(_columns[i]), getJoinFromColumn(_columns[i]), null);
                               else if (!(_columns[i] instanceof Column))
                                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'columns['+i+']', 'Column' );

                               _columns[i]._setIndex(i + 1);
                           }
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, '_rawColumns', {
                   get: function ()
                   {
                       return Column.marshalColumns(_columns);
                   },
                   enumerable: false,
                   configurable: false
               });

	           /**
	            * Search settings for this search as an array of search.Setting objects or a string array of column names.
	            * @name Search#settings
	            * @type {Array<Setting>|Array<string>} (setter accepts also a single search.Setting or string)
	            * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	            * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	            * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When any setting to assign is of invalid type
	            *
	            * @since 2018.2
	            */
	           Object.defineProperty(this, 'settings', {
		           get: function ()
		           {
			           return _settings;
		           },
		           set: function (settings)
		           {
			           _settings = settings ? (util.isArray(settings) ? settings : [settings]) : null;
			           if (_settings !== null)
			           {
				           for (var i = 0; i < _settings.length; i++)
				           {
					           if (util.isObject(_settings[i]))
						           _settings[i] = createSetting( _settings[i] )
					           else if (util.isArray(_settings[i]) && _settings[i].length==2 && util.isString(_settings[i][0]) && util.isString(_settings[i][1]))
						           _settings[i] = new Setting(_settings[i][0], _settings[i][1]);
					           else if (!(_settings[i] instanceof Setting))
						           utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'settings['+i+']', 'Setting' );

				           }
			           }
		           },
		           enumerable: true,
		           configurable: false
	           });

	           Object.defineProperty(this, '_rawSettings', {
		           get: function ()
		           {
			           return Setting.marshalSettings(_settings);
		           },
		           enumerable: false,
		           configurable: false
	           });

               /**
                * Title for a saved search. Use this property to set the title for a search before you save it for the first time.
                * @name Search#title
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'title', {
                   get: function ()
                   {
                       return _title;
                   },
                   set: function (val)
                   {
                       _title = val;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Script ID for a saved search, starting with customsearch. If you do not set this property and then save the search, NetSuite generates a script ID for you.
                * @name Search#id
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return _scriptId;
                   },
                   set: function (val)
                   {
                       _scriptId = val;
                   },
                   enumerable: true,
                   configurable: false
               });

	           /**
	            * The application ID for this search.
	            * @name Search#package
	            * @type {string}
	            *
	            * @since 2019.2
	            */
	           Object.defineProperty(this, 'packageId', {
		           get: function ()
		           {
			           return _package;
		           },
		           set: function (val)
		           {
			           _package = val;
		           },
		           enumerable: true,
		           configurable: false
	           });

               /**
                * Value is true if the search is public, or false if it is not. By default, all searches created through search.create(options) are private.
                * @name Search#isPublic
                * @type {boolean}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'isPublic', {
                   get: function ()
                   {
                       return _isPublic;
                   },
                   set: function (val)
                   {
                       _isPublic = val;
                   },
                   enumerable: true,
                   configurable: false
               });

               function doSave (callback)
               {
                 var rawFilters = Filter.marshalFilters(_filters)
                 var rawColumns = Column.marshalColumns(_columns)
                 var rawSettings = Setting.marshalSettings(_settings)
                 return invoker(searchApi, 'nlapiSaveSearch',
                   [_title, _scriptId, _type, _searchId ? String(_searchId) : null, rawFilters, rawColumns, rawSettings, _isPublic, _package], callback)
               }

               /**
                * Saves a search created by search.create(options) or loaded with search.load(options). Returns the internal ID of the saved search.
                * @governance 5 units
                * @return {number} the internal search ID of the saved search
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required Search.title property not set on search.Search.
                * @throws {SuiteScriptError} NAME_ALREADY_IN_USE The Search.title property on search.Search is not unique.
                * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID The Search.id property on search.Search is not unique.
                *
                * @since 2015.2
                */
               this.save = function save()
               {
                   return parseInt(doSave(), 10);
               };

	           /**
	            * Asynchronously saves a search created by search.create(options) or loaded with search.load(options). Returns the internal ID of the saved search.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required Search.title property not set on search.Search.
	            * @throws {SuiteScriptError} NAME_ALREADY_IN_USE The Search.title property on search.Search is not unique.
	            * @throws {SuiteScriptError} SSS_DUPLICATE_SEARCH_SCRIPT_ID The Search.id property on search.Search is not unique.
	            *
	            * @since 2015.2
	            */
                   this.save.promise = function ()
                   {
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               doSave(callback)
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                       function callback(result, exception)
                           {
                           if (exception)
                               {
                               reject(exception)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(parseInt(result, 10));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise;
                   };

               /**
                * Runs an on-demand search created with search.create(options) or a search loaded with search.load(options), returning the results as a search.ResultSet.
                * @governance none
                * @return {ResultSet} the result set object
                *
                * @since 2015.2
                */
               this.run = function run()
               {
                   return new ResultSet(clone());
               };

               /**
                * Runs the current search and returns summary information about paginated results. Calling this method does not give you the result set or save the search.
                * @governance none
                * @return {SearchPagedData} PagedData object that allows user to page through the search result
                *
                * @since 2016.1
                */
               this.runPaged = function runPaged(options)
               {
                   var pageSize = options && options.pageSize;

                   var pagedData = new SearchPagedData({
                       delegate: searchPaging.create({
                                                         searchDefinition: that,
                                                         filters: Filter.marshalFilters(that.filters),
                                                         columns: Column.marshalColumns(that.columns),
	                                                     settings: Setting.marshalSettings(that.settings),
                                                         pageSize: pageSize
                                                     }),
                       searchDefinition: that
                   });
                   return new paginationObject.PagedData(pagedData);
               };

               /**
                * Runs the current search asynchronously and returns a search.PagedData Object.
                * @governance none
                * @return {Promise} A promise object returning a PagedData object that allows user to page through the search result
                *
                * @since 2016.1
                */
                   this.runPaged.promise = function runPaged(options)
                   {
                       var pageSize = options && options.pageSize;

                       return searchPaging.create.promise({
                                                              searchDefinition: that,
                                                              filters: Filter.marshalFilters(that.filters),
                                                              columns: Column.marshalColumns(that.columns),
															  settings: Setting.marshalSettings(that.settings),
                                                              pageSize: pageSize
                                                          }).then(function(value){
                           var pagedData = new SearchPagedData({
                               delegate: value,
                               searchDefinition: that
                           });
                           return new paginationObject.PagedData(pagedData);
                       });
                   };

               /**
                * Returns the object type name (search.Search)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       type: _type,
                       id: _searchId,
                       filters: _filters,
                       columns: _columns,
	                   settings: _settings,
                       title: _title,
                       scriptId: _scriptId,
                       isPublic: _isPublic,
	                   packageId: _package
                   };
               };

               /* private methods */
               function clone()
               {
                   var i;
                   var filtersCopy = [];
                   for (i = 0; _filters && i < _filters.length; ++i)
                       filtersCopy.push(_filters[i]._clone());

	               var settingsCopy = [];
	               for (i = 0; _settings && i < _settings.length; ++i)
		               settingsCopy.push(_settings[i]._clone());

                   var columnsCopy = [];
                   for (i = 0; _columns && i < _columns.length; ++i)
                       columnsCopy.push(_columns[i]._clone());
                   var clone = new Search(_type, _searchId, filtersCopy, columnsCopy, settingsCopy);
                   clone.title = _title;
                   clone.id = _scriptId;
                   clone.isPublic = _isPublic;
                   return clone;
               }

	           this.redirectToSearch = function redirectToSearch()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);
		           var javaSettings = convertJsSettingsToJavaSettings(_settings);

		           if (!javaSearch) {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns, javaSettings]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
			           }
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearch', []);
	           };

	           this.redirectToSearchResults = function redirectToSearchResults()
	           {
		           var javaFilters = convertJsFiltersToJavaFilters(_filters);
		           var javaColumns = convertJsColumnsToJavaColumns(_columns);
		           var javaSettings = convertJsSettingsToJavaSettings(_settings);

		           if (!javaSearch)
		           {
			           if (_searchId === -1 || searchId === '-1')
				           javaSearch = invoker(searchApi, 'nlapiCreateSearch', [_type, javaFilters, javaColumns, javaSettings]);
			           else
			           {
				           javaSearch = invoker(searchApi, 'nlapiLoadSearch', [_type, String(_searchId)]);
				           javaSearch.addFilters(javaFilters);
				           javaSearch.addColumns(javaColumns);
				           javaSearch.addSettings(javaSettings);
			           }
		           }
		           else
		           {
			           javaSearch.setFilters(javaFilters);
			           javaSearch.setColumns(javaColumns);
		           }

		           return invoker(javaSearch, 'setRedirectURLToSearchResults', []);
	           };

               // this ensures that the checks in filter/column setters are also executed upon construction
               this.filters = filters;
               this.columns = columns;
	           this.settings = settings;
           }
           Search.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Filter object.
            *
            * @classDescription Encapsulates a search filter used in a search.
            * @protected
            * @constructor
            * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
            * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR if an unknown operator is provided
            *
            * @since 2015.2
            */
           function Filter(name, join, operator, values)
           {
               var TYPE = 'search.Filter';

               //constructor logic
                utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.Filter');

               /* private instance vars */
               var _name = name;
               var _join = join;
               if (!util.isString(operator) || (!OPERATORS[operator.toUpperCase()] && !PERIOD_OPERATORS[operator.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SRCH_OPERATOR, operator + "", "[" + Object.keys(OPERATORS).join(", ") + "]");

               var _operator = operator;
               var _values = null;
               var formula = null;
               var summarytype = null;
               var isor = false;
               var isnot = false;
               var leftparens = 0;
               var rightparens = 0;

               addValue(values);

               /* private methods */
               function addValue(val)
               {
                   if (!_values)
                       _values = [];
                   if (util.isArray(val))
                   {
                       var hasEmptyString = false;
                       for (var i = 0; i < val.length; i++)
                       {
                           if (val[i] === '' && !hasEmptyString) {
                               _values.push('');
                               hasEmptyString = true;
                           }
                           else if (val[i] || val[i] === 0)
                               _values.push(val[i].toString());
                       }
                   }
                   else if (val !== null && val !== undefined)
                       _values.push(val.toString());

                   return _values;
               }

               /* public undocumented methods */
               this._clone = function _clone()
               {
                   var clone = new Filter(_name, _join, _operator, _values);
                   clone._unmarshal(this._marshal());
                   return clone;
               };
               this._unmarshal = function _unmarshal(filterJSON)
               {
                   formula = filterJSON.formula;
                   summarytype = filterJSON.summarytype;
                   isor = filterJSON.isor;
                   isnot = filterJSON.isnot;
                   leftparens = filterJSON.leftparens;
                   rightparens = filterJSON.rightparens;
               };
               this._marshal = function _marshal()
               {
                   var filterObject = {};
                   filterObject.name = _name;
                   filterObject.join = _join;
                   filterObject.operator = _operator;
                   filterObject.values = (!_values || _values.length === 0) ? null : _values;
                   filterObject.formula = formula;
                   filterObject.summarytype = summarytype;
                   filterObject.isor = isor;
                   filterObject.isnot = isnot;
                   filterObject.leftparens = leftparens;
                   filterObject.rightparens = rightparens;
                   return filterObject;
               };

               /**
                * Name or internal ID of the search field as a string.
                * @name Filter#name
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return _name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Join ID for the search filter as a string.
                * @name Filter#join
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return _join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join' );
                   },
                   enumerable: true,
                   configurable: false
               });
               /**
                * Operator used for the search filter.
                * @name Filter#operator
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'operator', {
                   get: function ()
                   {
                       return _operator;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'operator' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Summary type for the search filter.
                * @name Filter#summary
                * @type {string}
                * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_SUM when setting invalid summary type
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summarytype;
                   },
                   set: function (type)
                   {
                       if (type !== null)
                       {
                           if (!util.isString(type) || !SUMMARY_TYPES[type.toUpperCase()])
                               utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', JSON.stringify(Object.keys(SUMMARY_TYPES)));

                           summarytype = type.toUpperCase();
                       }
                       else
                       {
                           summarytype = null;
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Formula used by the search filter.
                * @name Filter#formula
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Returns the object type name (search.Filter)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: _name,
                       join: _join,
                       operator: _operator,
                       values: _values,
                       formula: formula,
                       summarytype: summarytype,
                       isor: isor,
                       isnot: isnot,
                       leftparens: leftparens,
                       rightparens: rightparens
                   };
               }
           }
           Filter.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for parse search filter expression -----*/
           Filter.parseFilterExpression = function (filterExpression, callback)
           {
               if (applyValidationFunctionToArrayElement(filterExpression, Filter.isFilterObject))
               {
                   if (callback)
                   {
                       callback(filterExpression);
                       return;
                   }
                   else
                   {
                       return filterExpression;
                   }
               }
               checkFilterExpression(filterExpression, 'filters');
               var marshaled = Filter.marshalFiltersOrExpression(filterExpression);
               if (!callback)
               {
                   var javaResult = invoker(remoteApi, 'parseSearchFilterExpression', [marshaled]);
                   return filterCallback(javaResult);
               }
               else
               {
                   invoker(remoteApi, 'parseSearchFilterExpression', [marshaled], filterCallback)
               }

               function filterCallback(javaResult)
               {
                   var nativeResult = invoker(remoteApi, 'transform', [javaResult]);
                   var result = [];
                   for (var i = 0; nativeResult && i < nativeResult.length; i++)
                   {
                       result.push(Filter.unmarshalFilter(nativeResult[i]));
                   }
                   if (callback)
                       callback(result);
                   else
                       return result;
               }
           };

           /*----- Helper function used for marshalling js search.Filter for Remote API -----*/
           Filter.marshalFiltersOrExpression = function (filtersOrExpression)
           {
               if (typeof filtersOrExpression === 'undefined' || filtersOrExpression === null)
                   return null;
                utilityFunctions.assertTrue(util.isArray(filtersOrExpression), error.Type.WRONG_PARAMETER_TYPE,filtersOrExpression,'Array');
                return utilityFunctions.arrayToMap(filtersOrExpression, function (elem)
               {
                   if (Filter.isFilterObject(elem))
                       return elem._marshal();
                   var container = {javaClass: "java.util.HashMap"};
                   if (util.isArray(elem))
                       container.arrayValue = Filter.marshalFiltersOrExpression(elem);
                   else
                       container.stringValue = elem;
                   return container;
               });
           };

           Filter.isFilterObject = function (obj)
           {
                return (obj instanceof Filter) || util.isObject(obj);
           };

           Filter.marshalFilters = function (filters)
           {
               filters = utilityFunctions.getAsArray(filters);
                utilityFunctions.assertArrayElementsOfSameType(filters, Filter, 'filters');

               /* add filter. */
               var rawFilters = [];
               for (var i = 0; filters && i < filters.length; i++)
               {
                   rawFilters.push(filters[i]._marshal());
               }
               return rawFilters;
           };

           Filter.unmarshalFilterExpression = function (mapArrayPayload)
           {
                return utilityFunctions.arrayToMap(mapArrayPayload, function (map)
               {
                   if (map.arrayValue != null)
                       return Filter.unmarshalFilterExpression(map.arrayValue);
                   if (map.stringValue != null)
                       return map.stringValue;
                   return Filter.unmarshalFilter(map);
               });
           };

           /*----- Helper function used for unmarshalling search.Filter from server. -----*/
           Filter.unmarshalFilter = function (filterJSON)
           {
               var filter = new Filter(filterJSON.name, filterJSON.join, filterJSON.operator, filterJSON.values);
               filter._unmarshal(filterJSON);
               return filter;
           };

           Filter.normalizeFilters = function (filters)
           {
               return (Filter.isFilterObject(filters) || isFilterExpressionArray(filters)) ? [filters] : (!filters ? null : filters);
           };

           /*----- Helper function to validate search filter expression (advanced search) -----*/
           function checkFilterExpression(array, name)
           {
               utilityFunctions.assertTrue(!array || applyValidationFunctionToArrayElement(array, isFilterExpTerm), error.Type.WRONG_PARAMETER_TYPE, name, 'Array');
           }

           function isFilterExpTerm(obj)
           {
               if (typeof obj === 'undefined' || !obj)
                   return false;
               if (util.isString(obj))
                   return /not|and|or/i.test(obj);
               if (isFilterExpressionArray(obj))
                   return true;
               return applyValidationFunctionToArrayElement(obj, isFilterExpTerm);
           }

           function isFilterExpressionArray(array)
           {
               return util.isArray(array) && array.length >= 3 && util.isString(array[0]) && util.isString(array[1]) && !/^not$/i.test(array[0]);
           }

	       /**
	        * Return a new instance of search.Setting object.
	        *
	        * @class Setting
	        * @classDescription Defines a search setting.
	        * @protected
	        * @constructor
	        *
	        * @since 2018.2
	        */
	       function Setting(name, value)
	       {
		       var TYPE = 'search.Setting';

		       //constructor logic
		       utilityFunctions.checkArgs([name, value], ['name', 'value'], 'search.Setting');

		       /* private instance vars */
		       var _name = name;
		       var _value = value;


		       /* public undocumented methods */
		       this._clone = function _clone()
		       {
			       var clone = new Setting(_name, _value);
			       clone._unmarshal(this._marshal());
			       return clone;
		       };
		       this._marshal = function _marshal()
		       {
			       var settingObject = {};
			       settingObject.name = _name;
			       settingObject.value = _value;
			       return settingObject;
		       };

		       /**
		        * The name of the search parameter.
		        * @name Setting#name
		        * @type {string}
		        * @readonly
		        * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
		        *
		        * @since 2018.2
		        */
		       Object.defineProperty(this, 'name', {
			       get: function ()
			       {
				       return _name;
			       },
			       set: function (val)
			       {
				       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name' );
			       },
			       enumerable: true,
			       configurable: false
		       });

		       /**
		        * The value of the search parameter.
		        * @name Setting#value
		        * @type {string}
		        * @readonly
		        * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
		        *
		        * @since 2018.2
		        */
		       Object.defineProperty(this, 'value', {
			       get: function ()
			       {
				       return _value;
			       },
			       set: function (val)
			       {
				       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'value' );
			       },
			       enumerable: true,
			       configurable: false
		       });

		       /**
		        * Returns the object type name (search.Setting)
		        * @governance none
		        * @return {string}
		        *
		        * @since 2018.2
		        */
		       this.toString = function toString()
		       {
			       return TYPE;
		       };

		       /**
		        * get JSON format of the object
		        * @governance none
		        * @return {Object}
		        *
		        * @since 2018.2
		        */
		       this.toJSON = function toJSON()
		       {
			       return {
				       name: _name,
				       value: _value
			       };
		       };

		       this._unmarshal = function _unmarshal(settingJSON)
		       {
			       _value = settingJSON.value;
		       };
	       }
	       Setting.prototype = nsobject.getNewInstance();

	       /* public static methods */
	       /*----- Helper function used for marshalling js search.Setting for Remote API -----*/
	       Setting.marshalSettings = function marshalSettings(settings)
	       {
		       settings = utilityFunctions.getAsArray(settings);
		       utilityFunctions.assertArrayElementsOfSameType(settings, Setting, 'settings');

		       /* add settings. */
		       var rawSettings = [];
		       for (var i = 0; settings && i < settings.length; i++)
		       {
			       rawSettings.push(settings[i]._marshal());
		       }
		       return rawSettings;
	       };
	       Setting.unmarshalSetting = function unmarshalSetting(settingJSON)
	       {
		       var opt = new Setting(settingJSON.name, settingJSON.value);
		       return opt;
	       };


	       /**
            * Return a new instance of search.Column object.
            *
            * @classDescription Encapsulates a single search column in a search.Search. Use the methods and properties available to the Column object to get or set Column properties.
            * @protected
            * @constructor
	        * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM if an unknown summary type is provided
	        * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
            *
            * @since 2015.2
            */
           function Column(name, join, summary)
           {
               var TYPE = 'search.Column';

               //constructor logic
                utilityFunctions.checkArgs([name], ['name'], 'search.Column');

               if (summary != null && (!util.isString(summary) || !SUMMARY_TYPES[summary.toUpperCase()]))
                    utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'summary', JSON.stringify(Object.keys(SUMMARY_TYPES)));

               /* private vars */
               var that = this;
               var type = null;
               var label = null;
               var functionid = null;
               var formula = null;
               var sortdir = SORT.NONE;
               var index = -1;
               var userindex = -1;
               var whenorderedby = null;
               var whenorderedbyjoin = null;
	           var whenorderedbyalias = null;

               /**
                * The name of the search column.
                * @name Column#name
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'name', {
                   get: function ()
                   {
                       return name;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'name');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The join ID for this search column.
                * @name Column#join
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'join', {
                   get: function ()
                   {
                       return join;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'join');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The summary type for this search column.
                * @name Column#summary
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'summary', {
                   get: function ()
                   {
                       return summary != null ? summary.toUpperCase() : null;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'summary');
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The formula used for this search column.
                * @name Column#formula
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'formula', {
                   get: function ()
                   {
                       return formula;
                   },
                   set: function (sformula)
                   {
                       formula = sformula;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The label used for this search column.
                * @name Column#label
                * @type {string}
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'label', {
                   get: function ()
                   {
                       return label;
                   },
                   set: function (slabel)
                   {
                       label = slabel;
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The function used in this search column.
                * @name Column#function
                * @type {string}
                * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN Unknown function is set.
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When assigning unsupported function is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'function', {
                   get: function ()
                   {
                       return functionid == null ? 'none' : functionid;
                   },
                   set: function (sfunctionid)
                   {
                       if (sfunctionid === 'none' || sfunctionid === null)
                           functionid = null;
                       else
                       {
                            utilityFunctions.assertTrue(sfunctionid && FUNCTIONS[sfunctionid] != null, error.Type.WRONG_PARAMETER_TYPE, sfunctionid, JSON.stringify(Object.keys(FUNCTIONS)));
                           functionid = sfunctionid;
                       }
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * The sort direction for this search column. Use values from the Sort enum.
                * @name Column#sort
                * @type {string}
                * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE When assigning unsupported direction is attempted
                * @since 2015.2
                */
               Object.defineProperty(this, 'sort', {
                   get: function ()
                   {
                       return sortdir;
                   },
                   set: function (direction)
                   {
                        utilityFunctions.assertTrue(direction && SORT[direction], error.Type.WRONG_PARAMETER_TYPE, direction, JSON.stringify(Object.keys(SORT)));
                       sortdir = SORT[direction];
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Returns the search column for which the minimal or maximal value should be found when returning the search.Column
                * value. For example, can be set to find the most recent or earliest date, or the largest or smallest amount for a
                * record, and then the search.Column value for that record is returned. Can only be used when summary type is MIN
                * or MAX.
                * @governance none
                * @param {Object} options  the options object
                * @param {string} options.name The name of the search column for which the minimal or maximal value should be found.
                * @param {string} options.join The join id for the search column.
                * @return {Column} this search column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name or join parameter is missing
                *
                * @since 2015.2
                */
               this.setWhenOrderedBy = function setWhenOrderedBy(options)
               {
                   var name = null, join = null;

                   if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join')))
                   {
                       name = options.name;
                       join = options.join;
                   }
                   else
                   {
                       name = options;
                       join = arguments[1];
                   }
                    utilityFunctions.checkArgs([name, join], ['name', 'join'], 'Column.setWhenOrderedBy');
                   whenorderedby = name;
                   whenorderedbyjoin = join;
                   return that;
               };

               /**
                * Returns the object type name (search.Column)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       'function': functionid,
                       formula: formula,
                       sortdir: sortdir,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin,
	                   whenorderedbyalias: whenorderedbyalias
                   };
               };

               /* public undocumented methods */
               this._setType = function _setType(sType) { type = sType; };
               this._getIndex = function _getIndex() { return index };
               this._setIndex = function _setIndex(nIndex)
               {
                   index = nIndex;
                   return that;
               };
               this._setUserIndex = function _setUserIndex(nUserIndex)
               {
                   userindex = nUserIndex;
                   return that;
               };
               this._clone = function _clone()
               {
                   var clone = new Column(name, join, summary);
                   clone._unmarshal(this._marshal());
                   clone._setIndex(index);
                   clone._setUserIndex(userindex);
                   return clone;
               };
               this._unmarshal = function _unmarshal(columnJSON)
               {
                   label = columnJSON.label;
                   type = columnJSON.type;
                   functionid = columnJSON.functionid;
                   formula = columnJSON.formula;
                   sortdir = columnJSON.sortdir ? columnJSON.sortdir : SORT.NONE;
                   whenorderedby = columnJSON.whenorderedby;
                   whenorderedbyjoin = columnJSON.whenorderedbyjoin;
	               whenorderedbyalias = columnJSON.whenorderedbyalias;
                   return that;
               };
               this._marshal = function _marshal()
               {
                   return {
                       name: name,
                       join: join,
                       summary: summary,
                       label: label,
                       type: type,
                       functionid: functionid,
                       formula: formula,
                       sortdir: sortdir === SORT.NONE ? null : sortdir,
                       index: index,
                       userindex: userindex,
                       whenorderedby: whenorderedby,
                       whenorderedbyjoin: whenorderedbyjoin,
	                   whenorderedbyalias: whenorderedbyalias
                   };
               };
           }

           Column.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*----- Helper function used for marshalling js search.Column for Remote API -----*/
           Column.marshalColumns = function marshalColumns(columns)
           {
               columns = utilityFunctions.getAsArray(columns);
                utilityFunctions.assertArrayElementsOfSameType(columns, Column, 'columns');

               /* add columns. */
               var rawColumns = [];
               for (var i = 0; columns && i < columns.length; i++)
               {
                   columns[i]._setUserIndex(i + 1);
                   rawColumns.push(columns[i]._marshal());
               }
               return rawColumns;
           };

           Column.unmarshalColumn = function unmarshalColumn(columnJSON)
           {
               var col = new Column(columnJSON.name, columnJSON.join, columnJSON.summary);
               return col._unmarshal(columnJSON);
           };

           function getNameFromColumn(column)
           {
	           var firstDotPosition = column.indexOf('.');
	           var lastDotPosition = column.lastIndexOf('.');

	           // excluded segment transaction column field using SuperId from parsing as it has a dot in the field name by default
	           if (firstDotPosition == lastDotPosition)
		           return firstDotPosition !== -1 && !isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition) ? column.substring(firstDotPosition + 1) : column;
	           else
		           return isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition)
			           ? column.substring(lastDotPosition + 1)
			           : column.substring(firstDotPosition + 1);
           }

           function getJoinFromColumn(column)
           {
	           var firstDotPosition = column.indexOf('.');
	           var lastDotPosition = column.lastIndexOf('.');

	           if (firstDotPosition == lastDotPosition)
		           return firstDotPosition !== -1 && !isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition) ? column.substring(0, firstDotPosition) : null;
	           else
		           return isSegmentTranColumnFieldUsingSuperId(column, firstDotPosition)
			           ? column.substring(0, lastDotPosition)
			           : column.substring(0, firstDotPosition);
           }

	       function isSegmentTranColumnFieldUsingSuperId(column, dotPosition)
	       {
		       return (column.substring(0, dotPosition).toLowerCase() === 'line') && (column.toLowerCase().indexOf('cseg') == dotPosition + 1);
	       }

           /**
            * Return a new instance of search.ResultSet object.
            *
            * @classDescription Encapsulation of a search result set.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function ResultSet(searchObject)
           {
               var TYPE = 'search.ResultSet';

               var search = searchObject;
               var FOR_EACH_RESULT_MAX_ROWS = 4000;
               var FOR_EACH_RESULT_MAX_ROWS_ERR_MSG = 'No more than ' + FOR_EACH_RESULT_MAX_ROWS + ' search results may be returned at one time from ResultSet.each(). Please revise your search criteria or modify the callback logic so that no more than ' + FOR_EACH_RESULT_MAX_ROWS + ' results are returned.';

               /**
                * List of columns contained in this result set.
                * @name ResultSet#columns
                * @type {Array<Column>}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return search.columns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_getResultset', {
                   get: function ()
                   {
                       var start = 0, end = 1000;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);
                       var rawSettings = Setting.marshalSettings(search.settings);
                       var javaResults = invoker(searchApi, 'nlapiSearchRange',
                         [search.searchType, search.id ? String(search.id) : null, rawFilters, rawColumns, rawSettings, start, end]);
                       return javaResults;
                   },
                   enumerable: false,
                   configurable: false
               });

               function getRange_postProcess(javaResults)
               {
                   var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                   return Result.extractResults(rawResults, search.columns, javaResults);
               }

               /**
                * Retrieve a slice of the search result set. Only 1000 results can be returned at a time. If there are fewer results
                * available than requested, then the array will be truncated.
                * @governance 10 units
                * @param {Object} options  the options object
                * @param {number} options.start  the index number of the first result to return, inclusive
                * @param {number} options.end  the index number of the last result to return, exclusive
                * @return {Array<Result>} the requested slice of the search result set
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when start or end parameters are missing
                *
                * @since 2015.2
                */
               this.getRange = function getRange()
               {
                   var start = null, end = null;
                   if (arguments[0] && (arguments[0].hasOwnProperty('start') || arguments[0].hasOwnProperty('end')))
                   {
                       start = arguments[0].start;
                       end = arguments[0].end;
                   }
                   else
                   {
                       start = arguments[0];
                       end = arguments[1];
                   }
                    utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                    utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                    utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                   if (start >= end)
                       return [];

                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);
                   var rawSettings = Setting.marshalSettings(search.settings);
                   var javaResults = invoker(searchApi, 'nlapiSearchRange',
                     [search.searchType, search.id ? String(search.id) : null, rawFilters, rawColumns, rawSettings, start, end]);
                   return getRange_postProcess(javaResults);
               };
                   this.getRange.promise = function ()
                   {
                       var args = arguments;
                       var myPromise = new Promise(function (resolve, reject)
                       {
                           try
                           {
                               var start = null, end = null;
                               if (args[0] && (args[0].hasOwnProperty('start') || args[0].hasOwnProperty('end')))
                               {
                                   start = args[0].start;
                                   end = args[0].end;
                               }
                               else
                               {
                                   start = args[0];
                                   end = args[1];
                               }
                               utilityFunctions.checkArgs([start, end], ['start', 'end'], 'ResultSet.getRange');

                               utilityFunctions.assertTrue(start >= 0, error.Type.SSS_INVALID_SEARCH_RESULT_INDEX);
                               utilityFunctions.assertTrue((end - start) <= 1000, error.Type.SSS_SEARCH_RESULT_LIMIT_EXCEEDED);
                               if (start >= end)
                                   resolve([]);

                               var rawFilters = Filter.marshalFilters(search.filters);
                               var rawColumns = Column.marshalColumns(search.columns);
                               invoker(searchApi, 'nlapiSearchRange',
                                 [search.searchType, search.id ? String(search.id) : null, rawFilters, rawColumns, start, end], callback);
                           }
                           catch (e)
                           {
                               reject(e);
                           }

                       function callback(result, exception)
                           {
                           if (exception)
                               {
                               reject(exception)
                               }
                               else
                               {
                                   try
                                   {
                                       resolve(getRange_postProcess(result));
                                   }
                                   catch (e)
                                   {
                                       reject(e);
                                   }
                               }
                           }
                       });
                       return myPromise
                   };

               /**
                * Calls the developer-defined callback function for every result in this set. The result set processed by each()
                * may have maximum 4000 rows. The callback function has the following signature: boolean callback(result.Result
                * result); If the return value of the callback is false, the iteration over results is stopped, otherwise it
                * continues. Note that the work done in the context of the callback function counts towards the governance of the
                * script that called it.
                * @governance 10 units
                * @param {Function} callback  the function called for each result in the result set
                * @return {void}
                * @since 2015.2
                */
               this.each = function each(callback)
               {
                   var remoteId = null;
                   var rawFilters = Filter.marshalFilters(search.filters);
                   var rawColumns = Column.marshalColumns(search.columns);
	               var rawSettings = Setting.marshalSettings(search.settings);
                   var returnedRowCount = 0;
                   var PAGE_SIZE = 500;  // number of search results per request
                   var continueIteration = true;
                   var start = 0;
                   try
                   {
                       while (continueIteration)
                       {
                           var javaResults = invoker(searchApi, 'nlapiContinueSearch',
                             [search.searchType, search.id ? String(search.id) : null, rawFilters, rawColumns, rawSettings, remoteId, start, start + PAGE_SIZE]);
                           var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                           var searchResults = Result.extractResults(rawResults, search.columns, javaResults);
                           if (searchResults == null || searchResults.length == 0)
                               break;

                           for (var i = 0; continueIteration && i < searchResults.length; i++)
                           {
                                utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                               continueIteration = callback(searchResults[i]);
                               returnedRowCount++;
                           }

                           var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                           if (!remoteId && unwrappedResults != null && unwrappedResults.length > 0)
                               remoteId = unwrappedResults[0].remoteid;

                           if (searchResults.length < PAGE_SIZE)
                               break;
                           start += PAGE_SIZE;
                       }
                   }
                   finally
                   {
                       invoker(searchApi, 'nlapiEndSearch', [String(remoteId)]);
                   }
               };

                   this.each.promise = function promise(callback)
                   {
                       var remoteId = null;
                       var rawFilters = Filter.marshalFilters(search.filters);
                       var rawColumns = Column.marshalColumns(search.columns);
	               var rawSettings = Setting.marshalSettings(search.settings);
                       var returnedRowCount = 0;
                       var PAGE_SIZE = 500;  // number of search results per request
                       var continueIteration = true;
                       var start = 0;

                       var myPromise = new Promise(
                               function (resolve, reject)
                               {
                                   var loop = function ()
                                   {
                                       return new Promise(function (resolveInner, rejectInner)
                                       {
                                           invoker(searchApi, 'nlapiContinueSearch',
                                             [search.searchType, search.id ? String(search.id) : null, rawFilters, rawColumns, rawSettings, remoteId, start, start + PAGE_SIZE], resolveInner);
                                       }).then(function (result)
                                               {
                                                   var rawResults = invoker(remoteApi, 'transform', [result]);
                                                   var searchResults = Result.extractResults(rawResults, search.columns);
                                                   if (searchResults == null || searchResults.length == 0)
                                                   {
                                                       return false;
                                                   }

                                                   for (var i = 0; continueIteration && i < searchResults.length; i++)
                                                   {
                                                       utilityFunctions.assertTrue(returnedRowCount < FOR_EACH_RESULT_MAX_ROWS, error.Type.SSS_SEARCH_FOR_EACH_LIMIT_EXCEEDED, FOR_EACH_RESULT_MAX_ROWS);
                                                       continueIteration = callback(searchResults[i]);
                                                       returnedRowCount++;
                                                   }

	                                               var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                                                   if (!remoteId && unwrappedResults != null && unwrappedResults.length > 0)
                                                       remoteId = unwrappedResults[0].remoteid;

                                                   if (searchResults.length < PAGE_SIZE)
                                                   {
                                                       return false;
                                                   }
                                                   start += PAGE_SIZE;
                                                   return true;
                                               })
                                               .then(function (keepGoing) { if (keepGoing) loop() })
                                               .then(undefined, function (reason) { reject(reason) });
                                   };

                                   loop().then(function ()
                                   {
                                   	    invoker(searchApi, 'nlapiEndSearch', [String(remoteId)]);
                                   	    resolve(true);
                                   });
                               }
                       );
                       return myPromise
                   }
               /**
                * Returns the object type name (search.ResultSet)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       columns: search.columns
                   };
               }
           }

           ResultSet.prototype = nsobject.getNewInstance();

           /**
            * Return a new instance of search.Result object.
            *
            * @classDescription Encapsulation of a search result.
            * @protected
            * @constructor
            *
            * @since 2015.2
            */
           function Result(type, id, rawValues, rawColumns, javaResult)
           {
               var TYPE = 'search.Result';

               /* index values by legacy key for performance - lazy loaded */
               var valuesByKey = {};
               var valuesByKeyMapPopulated = false;

               /* private methods */
               function getCellAttribute(nameOrColumn, join, summary, func, attribute)
               {
                   var cell = null;
                   if (util.isString(nameOrColumn))
                   {
	                   var name = nameOrColumn
                       populateValueByKeyMap();
                       cell = valuesByKey[getKey(name, join, summary, undefined, func)];
                   }
                   else if (nameOrColumn instanceof Column)
                   {
	                   var column = nameOrColumn;
                       if (column._getIndex() !== -1)
                           cell = rawValues[column._getIndex() - 1];
                       if (!cell)
                       {
                           populateValueByKeyMap();
                           cell = valuesByKey[getKey(column.name, column.join, column.summary, column.formula)]
                       }
                   }
                   return (cell != null && cell[attribute] != null) ? cell[attribute] : null;
               }

               function getKey(name, join, summary, formula, func)
               {
                   return (join ? join.toLowerCase() + '_' : '')
	                   + name.toLowerCase()
	                   + (summary ? '_' + summary.toLowerCase() : '')
	                   + (formula ? '_' + formula.toLowerCase() : '')
	                   + (func && func !== 'none' ? '_' + func.toLowerCase() : '');
               }

               function populateValueByKeyMap()
               {
                   if (!valuesByKeyMapPopulated)
                   {
                       // populate the map
                       for (var i = 0; rawValues != null && i < rawValues.length; i++)
                       {
	                       var name = rawColumns[i]['name'];
	                       var join = rawColumns[i]['join'];
	                       var summary = rawColumns[i]['summary'];
	                       var formula = rawColumns[i]['formula'];
	                       var func = rawColumns[i]['function'];
	                       var key;

	                       key = getKey(name, join, summary, formula, func);
	                       valuesByKey[key] = rawValues[i];

	                       key = getKey(name, join, summary, formula, null);
	                       if (valuesByKey[key] === undefined)
		                       valuesByKey[key] = rawValues[i];

	                       /*
	                        For backwards compatibility, we continue to support the ability to refer to a formula column via its
	                        non-unique name, for example 'formulatext'. If multiple formula columns of the same type are present,
	                        the last one will overwrite any previous values which is obviously odd. This behavior should not be
	                        ported to future major versions of this API.
	                        */
	                       if (func)
	                       {
		                       key = getKey(name, join, summary, null, func);
		                       valuesByKey[key] = rawValues[i];

		                       key = getKey(name, join, summary, null, null);
		                       if (valuesByKey[key] === undefined)
			                       valuesByKey[key] = rawValues[i];
	                       }
                       }
                       valuesByKeyMapPopulated = true;
                   }
               }

               /**
                * Record type of the result.
                * @name Result#recordType
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'recordType', {
                   get: function ()
                   {
                       return type;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'recordType' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * Record internal ID of the result.
                * @name Result#id
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'id', {
                   get: function ()
                   {
                       return id;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
                   },
                   enumerable: true,
                   configurable: false
               });

               /**
                * List of columns contained in this result.
                * @name Result#columns
                * @type {Array<Column>}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                *
                * @since 2015.2
                */
               Object.defineProperty(this, 'columns', {
                   get: function ()
                   {
                       return rawColumns;
                   },
                   set: function (val)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'columns' );
                   },
                   enumerable: true,
                   configurable: false
               });


               Object.defineProperty(this, '_saveToTemplateRenderer', {
                   get: function ()
                   {
                       return javaResult;
                   },
                   set: function (val)
                   {
                       return;
                   },
                   enumerable: false,
                   configurable: false
               });

               /**
                * Returns the value of a specified search return column. The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @governance none
                * @param {Column} column  The search result column from which to return a value.
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  The search return column name.
                * @param {string} [options.join] optional The join id for this search return column.
                * @param {Summary} [options.summary]  The summary type for this column.
                * @param {string} [options.func] Special function for the search column.
                * @return {string} string value of the search result column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
                *
                * @since 2015.2
                */
               this.getValue = function getValue(options)
               {
                   var name, join, summary, func;
                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func || options['function'];
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getValue');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'value');
               };

               /**
                * Returns the UI display name (i.e. the text value) of a specified search return column.
                * Note that this method is supported on select, image and document fields only.
                * The column may be specified in two ways:
                * 1) by providing a search.Column object
                * 2) by providing name, join and summary parameters
                * @governance none
                * @param {Column} column  The search result column from which to return a value.
                * - or -
                * @param {Object} options  the options object
                * @param {string} options.name  The search return column name.
                * @param {string} [options.join] optional The join id for this search return column.
                * @param {Summary} [options.summary]  The summary type for this column.
                * @param {string} [options.func] Special function for the search column.
                * @return {string} UI display name (text value) of the search result column
                *
                * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when name parameter is missing
                *
                * @since 2015.2
                */
               this.getText = function getText(options)
               {
                   var name, join, summary, func;

                   if(!!options && !util.isString(options))
                   {
                       name = options.name;
                       join = options.join;
                       summary = options.summary;
	                   func = options.func;
                   }
                   else
                   {
                       name = options;
                   }

                   if(options instanceof Column)
                   {
                       name = options;
                       join = undefined;
                       summary = undefined;
	                   func = undefined;
                   }

                    utilityFunctions.checkArgs([name], ['name'], 'Result.getText');

                   return getCellAttribute(name, join != null ? join : null, summary != null ? summary : null, func != null ? func : null, 'text');
               };

               /**
                * Returns the object type name (search.Result)
                * @governance none
                * @return {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance 0
                * @return {Object}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       recordType: type,
                       id: id,
                       values: this.getAllValues()
                   };
               };

               /* public undocumented methods */
               /*
                * Return all the result data in a simple object of the following form:
                * {
                *     foo: 'bar',
                *     name.join: 'othervalue',
                *     select: [{
                *         value: '123',
                *         text: 'Some UI text'
                *     }],
                *     multiselect1: [],
                *     multiselect2: [{
                *         value: '3',
                *         text: 'Green'
                *     },{
                *         value: '5',
                *         text: 'Pinkish yellow'
                *     }],
                *     'MAX(name2.join2)': '324'
                * }
                * This is used in the toJSON() method.
                */
               this.getAllValues = function getAllValues()
               {
                   var names = {};
                   function disabiguateName(name)
                   {
                       var retVal = name;
                       if (names[name])
                       {
                       		var postFix = names[name];
                       		names[name]++;
                       		retVal = retVal + "_" + postFix;
                       }
                       else
                       {
                           names[name]=1;
                       }
                       return retVal;
                   }
                   var results = {};
                   var name = null;
                   var join = null;
                   var sum = null;
	               var func = null;

                   for (var i = 0; rawColumns && i < rawColumns.length; i++)
                   {
                       name = rawColumns[i].name;
                       join = rawColumns[i].join;
                       sum = rawColumns[i].summary;
	                   func = rawColumns[i]['function'];
                       var nameJoin = (join ? join + '.' : '') + name;
                       if (sum)
                           nameJoin = sum + '(' + nameJoin + ')';
                       var isrectype = name.toLowerCase() === 'recordtype';
	                   var param = (util.isString(name) && name.length >= 7 && name.substr(0,7) === "formula") ? rawColumns[i] : {name: name, join: join, summary: sum, func: func};
                       var txt = isrectype ? null : this.getText(param);
                       var val = isrectype ? type : this.getValue(param);
                       nameJoin  = disabiguateName ( nameJoin )
                       if (txt !== null && val !== null && txt !== undefined && val !== undefined)
                       {
                           if (txt.length === 0 && val.length === 0) // multiselect with nothing chosen
                           {
                               results[nameJoin] = [];
                           }
                           else
                           {
                           	   var canaryOn = environment.isSearchCanaryOn();
                               var multival = canaryOn ? val.split(String.fromCharCode(5)) : val.split(',');
                               var multitxt = canaryOn ? txt.split(String.fromCharCode(5)) : txt.split(",");
                               if (multival.length === 1)
                               {
                                   val = [];
                                   val.push({value: multival[0], text: txt});
                                   results[nameJoin] = val;
                               }
                               else if (multival.length === multitxt.length) // parallel arrays match
                               {
                                   val = [];
                                   for (j = 0; j < multival.length; j++)
                                   {
                                       val.push({value: multival[j], text: multitxt[j]});
                                   }
                                   results[nameJoin] = val;
                               }
                               else // fallback
                               {
                                   results[nameJoin] = {value: val, text: txt};
                               }
                           }
                       }
                       else
                       {
                           results[nameJoin] = val;
                       }
                   }
                   return results;
               };
           }

           Result.prototype = nsobject.getNewInstance();

           /* public static methods */
           /*------------ Helper function used for unmarshalling search results from server. ------------*/
           Result.extractResults = function extractResults(rawResults, columns, javaResults)
           {
               var rows = [];
               var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
               if (unwrappedResults != null && unwrappedResults.length > 0)
               {
	               var recordTypeColumn = null;
	               var columnArray = utilityFunctions.getAsArray(columns)
	               if (columnArray != null)
		               recordTypeColumn = columnArray.filter(function(el) { return el.name === "recordtype"; })[0];
                   columns = unwrappedResults[0].columns;
                   for (var i = 0; columns != null && i < columns.length; i++)
                   {
                       var obj = null;
                       var col = columns[i];
                       if (col.userindex == -1)
                       {
                           obj = Column.unmarshalColumn(col);
                       }
                       else if (columnArray != null)
                       {
                           obj = columnArray[col.userindex - 1];
                       }
                       obj._setIndex(col.index);
                       obj._setType(col.type);
                       columns[i] = obj;
                   }

                   if (!!recordTypeColumn)
                   {
                       if (util.isArray(columns))
                       {
                           if (columns.filter(function(el) { return el.name === "recordtype"; }).length === 0)
                               columns.push(recordTypeColumn);
                       }
	                   else
	                   	    columns = [recordTypeColumn];
                   }
                   for (i = 0; i < unwrappedResults.length; i++)
                   {
                       rows[rows.length] = new Result(unwrappedResults[i].recordType, unwrappedResults[i].id, unwrappedResults[i].cells, columns, (javaResults && javaResults[i]) ? javaResults[i] : null)
                   }
               }
               return rows;
           };

            /**
             * @class SearchPageRange
             * @classDescription Defines the page range to contain the result set
             * @protected
             * @constructor
             *
             * @since 2015.2
             */
           function SearchPageRange(options)
           {
               var that = this;
               var delegate;

               if (options)
               {
                   delegate = options.delegate;
               }

                utilityFunctions.checkArgs([delegate], ['delegate'], 'PageRange');

               function getIndex()
               {
                   return invoker(delegate, 'getIndex');
               }
               function getCompoundKey()
               {
                   return invoker(delegate, 'getCompoundKey');
               }
               function getCompoundLabel()
               {
                   return invoker(delegate, 'getCompoundLabel');
               }

                /**
                 * @governance none
                 * @return {number}
                 *
                 * @since 2015.2
                 */
               this.getIndex = getIndex;

                /**
                 * @governance none
                 * @return {string}
                 *
                 * @since 2015.2
                 */
               this.getCompoundKey = getCompoundKey;

                /**
                 * @governance none
                 * @return {string}
                 *
                 * @since 2015.2
                 */
               this.getCompoundLabel = getCompoundLabel;
           }
           SearchPageRange.prototype = nsobject.getNewInstance();

	       /**
	        * Return a new instance of search.Page object.
	        *
	        * @class SearchPage
	        * @classDescription Encapsulates an individual search page containing a result set for a paginated search.
	        * @protected
	        * @constructor
	        *
	        * @since 2015.2
	        */
           function SearchPage(options)
           {
               var that = this;
               var delegate;
               var pagedData;
               var pageIndex;
               var data;

               if (options)
               {
                   delegate = options.delegate;
                   pagedData = options.pagedData;
                   pageIndex = options.pageIndex;
               }

                utilityFunctions.checkArgs([delegate, pagedData, pageIndex], ['delegate', 'pagedData', 'pageIndex'], 'Page');

	           /**
	            * The PagedData Object used to fetch this Page Object.
	            * @name Page#pagedData
	            * @type {PagedData}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pagedData', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData;
                   }
               });

	           /**
	            * The PageRange Object used to fetch this Page Object.
	            * @name SearchPage#pagedRange
	            * @type {SearchPageRange}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'pageRange', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return pagedData.pageRanges[pageIndex];
                   }
               });

	           /**
	            * The results from a paginated search.
	            * @name SearchPage#data
	            * @type {Array<Result>}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'data', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       var javaResults, rawResults;

                       if(!data){
                           javaResults = invoker(delegate, 'getData');
                           rawResults = invoker(remoteApi, 'transform', [javaResults]);

                           data = Result.extractResults(rawResults, pagedData.searchDefinition.columns, javaResults);
                       }

                       return data;
                   }
               });

	           /**
	            * Indicates whether the page is within the first range of the result set. Flags the start of the data collection.
	            * @name SearchPage#isFirst
	            * @type {boolean}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'isFirst', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isFirst');
                   }
               });

	           /**
	            * Indicates whether a page is within the last range of the result set. Flags the end of the data collection.
	            * @name SearchPage#isLast
	            * @type {boolean}
	            * @readonly
	            * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
	            *
	            * @since 2015.2
	            */
               Object.defineProperty(this, 'isLast', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'isLast');
                   }
               });

	           /**
	            * Method used to fetch the next segment of data (bounded by search.PageRange). Moves the current page to next range.
	            * @governance 5 units
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @return {void}
	            *
	            * @since 2015.2
	            */
               this.next = function next(){
                   var result;

                   if(that.isLast)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'next' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex + 1].getIndex());
                   }

                   return result;
               };

	           /**
	            * Method used to fetch the previous segment of data (bounded by search.PageRange). Moves the current page to previous range.
	            * @governance 5 units
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @return {void}
	            *
	            * @since 2015.2
	            */
               this.prev = function prev(){
                   var result;

                   if(that.isFirst)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'prev' );
                   }
                   else
                   {
                       result = pagedData.fetch(pagedData.pageRanges[pageIndex - 1].getIndex());
                   }

                   return result;
               };

	           /**
	            * Method used to asynchronously fetch the next segment of data (bounded by search.PageRange). Moves the current page to another range. The promise is complete when the data for this range is loaded or rejected.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            *
	            * @since 2015.2
	            */
                   this.next.promise = function nextPromise()
                   {
                       var result;

                       if (that.isLast)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: next.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex + 1].getIndex());
                       }

                       return result;
                   };

	           /**
	            * Method used to asynchronously fetch the previous segment of data (bounded by search.PageRange). Moves the current page to another range. The promise is complete when the data for this range is loaded or rejected.
	            * @governance 5 units
	            * @return {Promise}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is invalid, or when the page is the last page.
	            * @since 2015.2
	            */
                   this.prev.promise = function prevPromise()
                   {
                       var result;

                       if (that.isFirst)
                       {
                           result = Promise.reject(error.create({
                                                                    name: error.Type.INVALID_PAGE_RANGE,
                                                                    message: 'Invalid page range: prev.promise.',
                                                                    notifyOff: false
                                                                }));
                       }
                       else
                       {
                           result = pagedData.fetch.promise(pagedData.pageRanges[pageIndex - 1].getIndex());
                       }

                       return result;
                   };
               }
           SearchPage.prototype = nsobject.getNewInstance();

           function ReadonlySearch(delegate)
           {
               function cloneArrayOfFiltersOrColumnsOrSettings(o)
               {
                   var toRet = [];
                   if(o && util.isArray(o))
                   {
                       o.forEach(function(obj){
                           if(obj instanceof Filter || obj instanceof Column || obj instanceof Setting)
                                toRet.push(utilityFunctions.freezeObjectIfPossible(obj._clone()));
                       })
                   }
                    return utilityFunctions.freezeObjectIfPossible(toRet)
               }



               Object.defineProperty(this, 'searchType', {
                   get : function(){ return delegate.searchType; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'searchId', {
                   get : function(){ return delegate.searchId; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'title', {
                   get : function(){ return delegate.title },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'id', {
                   get : function(){ return delegate.id; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'isPublic', {
                   get : function(){ return delegate.isPublic; },
                   enumerable: true,
                   configurable: false
               });
               Object.defineProperty(this, 'columns', {
                   get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.columns); },
                   enumerable: true,
                   configurable: false
               });

               Object.defineProperty(this, 'filters', {
                   get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.filters); },
                   enumerable: true,
                   configurable: false
               });

	           Object.defineProperty(this, 'settings', {
		           get : function(){ return cloneArrayOfFiltersOrColumnsOrSettings(delegate.settings); },
		           enumerable: true,
		           configurable: false
	           });
               this.toJSON = delegate.toJSON;
               this.toString = function (){ return delegate.toString() + "(readonly)"; }
           }
           ReadonlySearch.prototype = nsobject.getNewInstance();

			/**
			 * @class SearchPagedData
			 * @classdesc Holds metadata for a paginated query.
			 * @protected
			 * @constructor
			 *
			 * @since 2015.2
			 */
           function SearchPagedData(options)
           {
               var that = this;
               var delegate, searchDefinition;
               var pageRanges = null;

               if (options)
               {
                   delegate = options.delegate;
                   searchDefinition = options.searchDefinition;
               }

                utilityFunctions.checkArgs([delegate, searchDefinition], ['delegate', 'searchDefinition'], 'PagedData');

               function doGetPage(index, callback)
               {
               	    return invoker(delegate, 'getPage', resolveUndefinedForArguments([index]), callback);
               }

	           /**
	            * This method retrieves the data within the specified page range.
	            * @governance 5 units
	            * @param {number} index The index of the page range that bounds the desired data.
	            * @return {Page}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	            *
	            * @since 2015.2
	            */
               function getPage(index)
               {
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                        utilityFunctions.throwSuiteScriptError(error.Type.INVALID_PAGE_RANGE, 'fetch' );
                   }

                   var page = new SearchPage({
                       delegate: doGetPage(index),
                       pagedData: that,
                       pageIndex: index
                   });
                   return new paginationObject.Page(page);
               }

	           /**
	            * This method asynchronously retrieves the data bounded by the pageRange parameter.
	            * @governance 5 units
	            * @param {number} index The index of the page range that bounds the desired data.
	            * @return {Page}
	            * @throws {SuiteScriptError} INVALID_PAGE_RANGE The page range is not valid.
	            *
	            * @since 2015.2
	            */
               function getPagePromise(index)
               {
                   var result;
                   if(index < 0 || index >= that.pageRanges.length)
                   {
                       result = Promise.reject(error.create({
                                                                name: error.Type.INVALID_PAGE_RANGE,
                                                                message: 'Invalid page range: fetch.promise.',
                                                                notifyOff: false
                                                            }));
                   }
                   else
                   {
	                   result = new Promise(function (resolve, reject)
	                   {
		                   try
		                   {
			                   doGetPage(index, callback);
		                   }
		                   catch (e)
		                   {
			                   reject(e);
		                   }

		                   function callback(result, exception)
		                   {
			                   if (exception)
			                   {
			                   	    reject(exception);
			                   }
			                   else
			                   {
				                   try
				                   {
				                   	    var page = new SearchPage({
					                        delegate: result,
					                        pagedData: that,
					                        pageIndex: index
				                        });
				                   	    resolve(new paginationObject.Page(page));
				                   }
				                   catch (e)
				                   {
					                   reject(e);
				                   }
			                   }
		                   }
	                   });
                   }

                   return result;
               }

                /**
                 * Maximum number of entries per page. Possible values are 5 - 1000 entries per page.
                 * @type {number}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
               Object.defineProperty(this, 'pageSize', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getPageSize');
                   }
               });

                /**
                 * The total number of results when Search.runPaged(options) was executed.
                 * @type {number}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 */
               Object.defineProperty(this, 'count', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       return invoker(delegate, 'getTotalRows');
                   }
               });

                /**
                 * The collection of SearchPageRange objects that divide the entire result set into smaller groups.
                 * @type {Array<SearchPageRange>}
                 * @readonly
                 * @throws {SuiteScriptError} READ_ONLY when setting the property is attempted
                 *
                 * @since 2015.2
                 */
               Object.defineProperty(this, 'pageRanges', {
                   configurable: false,
                   enumerable: true,
                   get: function ()
                   {
                       if(!pageRanges){
                           pageRanges = invoker(delegate, 'getPageRanges').map(function(v,i,a){
                               return new SearchPageRange({delegate: v});
                           });
                       }

                       return pageRanges;
                   }
               });

               this.searchDefinition = new ReadonlySearch(searchDefinition);
               this.fetch = getPage;
               this.fetch.promise = getPagePromise;
               }
           SearchPagedData.prototype = nsobject.getNewInstance();


           function createSearch(type, searchId, filters, columns, settings) {
               return new Search(type, searchId, filters, columns, settings);
           }

           function createFilter(options) {
               var name = null, join = null, operator = null, values = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('operator') || options.hasOwnProperty('values')))
               {
                   name = options.name;
                   join = options.join;
                   operator = options.operator;
                   values = options.values;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   operator = arguments[2];
                   values = arguments[3];
               }
               utilityFunctions.checkArgs([name, operator], ['name', 'operator'], 'search.createFilter');

               var filter = new Filter(name, join, operator, values);
               if (isOpts)
               {
                   if (options.formula)
                       filter.formula = options.formula;
                   if (options.summary)
                       filter.summary = options.summary;
               }
               return filter;
           }

	       function createSetting(options) {
		       var name = null, value = null;
		       if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value') ))
		       {
			       name = options.name;
			       value = options.value;
		       }
		       else
		       {
			       name = options;
			       value = arguments[1];
		       }
		       utilityFunctions.checkArgs([name, value], ['name', 'value'], 'search.createSetting');

		       var setting = new Setting(name, value);
		       return setting;
	       }

           function createColumn(options) {
               var name = null, join = null, summary = null;
               var isOpts = false;

               if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('join') || options.hasOwnProperty('summary')))
               {
                   name = options.name;
                   join = options.join;
                   summary = options.summary;
                   isOpts = true;
               }
               else
               {
                   name = options;
                   join = arguments[1];
                   summary = arguments[2];
               }
               utilityFunctions.checkArgs([name], ['name'], 'search.createColumn');

               var column = new Column(name, join ? join : null, summary ? summary : null);
               if (isOpts)
               {
                   if (options.formula)
                       column.formula = options.formula;
                   if (options.func)
	                   column['function'] = options.func;
                   else if (options['function'])
                       column['function'] = options['function'];
                   if (options.label)
                       column.label = options.label;
                   if (options.sort !== undefined)
                       column.sort = options.sort;
               }
               return column;
           }

           return {
               createSearch : createSearch,
               createFilter : createFilter,
	           createSetting : createSetting,
	           createColumn : createColumn,
               Filter : Filter,
               Column : Column,
	           Setting : Setting,
               Result : Result,
               /**
                * @enum {string}
                * @readonly
                */
               SUMMARY_TYPES : SUMMARY_TYPES,
               /**
                * @enum {string}
                * @readonly
                */
               OPERATORS: OPERATORS,
               /**
                * @enum {string}
                * @readonly
                */
               SORT: SORT,
               util : {
                   getNameFromColumn : getNameFromColumn,
                   getJoinFromColumn : getJoinFromColumn
               }
           }
       }
);

/**
 * SuiteScript module
 *
 * @private
 * @module N/restricted/creationFunctionWrapper
 * @NApiVersion 2.x
 *
 */
define('N/creationFunctionWrapper',[], function () {
    function ReflectiveSetterProxy(target) {
        return (function init(target) {
            if (!target || target === this)
                return target;
            var proxy = null;
            if (util.isFunction(target) && target.prototype && target.prototype.hasOwnProperty) {
                proxy = function () {
                    var targetFunction = target;
                    var retMe = targetFunction.apply(this, arguments);
                    var options = arguments[0];
                    for (var p in options)
                    {
                        if (options.hasOwnProperty(p))
                        {
                            var value = options[p];
                            if (retMe.hasOwnProperty(p) && !util.isFunction(retMe[p]) && retMe[p] != value)
                            {
                                try
                                {
                                    retMe[p] = value;
                                }
                                catch (err)
                                {
                                    if (err.name !== 'READ_ONLY_PROPERTY')
                                    {
                                        throw err;
                                    }
                                }
                            }
                        }
                    }
                    return retMe;
                };
                proxy.toString = function () {
                    return '';
                };
            }
            else if (Object.prototype.toString.call(target) === '[object Object]' && target.hasOwnProperty) {
                proxy = {};
                proxyObjChildren(target, proxy);
            }
            else
                proxy = target;

            function proxyObjChildren(target, proxy) {
                for (var p in target)
                    if (target.hasOwnProperty(p))
                        proxy[p] = init(target[p]);
            }
            return proxy;
        })(target);
    };
    function wrapFunction (f) {
        return new ReflectiveSetterProxy(f);
    }
    return Object.freeze({
        wrap : wrapFunction
    });
});
/**
 * SuiteScript search util module
 *
 * @private
 * @module N/search/searchUtil
 * @NApiVersion 2.x
 *
 */
define('N/search/searchUtil',['N/restricted/searchApi', 'N/restricted/remoteApiBridge', 'N/error', 'N/internal/invoker', 'N/search/searchObject', 'N/utilityFunctions', 'N/creationFunctionWrapper'],
        function (searchApi, remoteApi, error, invoker, searchObject, utilityFunctions, funcWrapper)
        {
            var Filter = searchObject.Filter;
            var Column = searchObject.Column;
            var Setting = searchObject.Setting;
            var Result = searchObject.Result;
            var searchUtilityFunctions = searchObject.util;

            //========================================================================

            function validateAndParseFilterExpression(options, callback)
            {
                var type = null,
                        filters = null;

                if (options)
                {
                    type = options.type;
                    filters = options.filters;
                }
                utilityFunctions.checkArgs([type], ['type'], 'search.create');
                invoker(searchApi, 'assertValidSearchType', [type]);

                return parseFilterExpression(filters, callback);
            }

            function parseFilterExpression(filters, callback)
            {
                filters = Filter.normalizeFilters(filters);

                return Filter.parseFilterExpression(filters, callback);
            }

            function doCreateSearch(options)
            {
                var columns = options.columns != null ? options.columns : null;
                var settings = options.settings || null;
                var result = searchObject.createSearch(options.type, -1, options.filters, columns, settings);
                if (options.title)
                    result.title = options.title;
                if (options.id)
                    result.id = options.id;
	            if (options.packageId)
		            result.packageId = options.packageId;
                return result;
            }

            // === load
            function doLoad(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.load');
                var type = (options && options.hasOwnProperty('type')) ? options.type : null;
                if (!!type)
                    invoker(searchApi, 'assertValidSearchType', [type]);

                var search = searchObject.createSearch(type, id, null, null);
                search._load(callback);
                return search;
            }

            // === delete

            function doDelete(options, callback)
            {
                var id = (options && options.hasOwnProperty('id')) ? options.id : options;
                utilityFunctions.checkArgs([id], ['id'], 'search.delete');
                var type = (options && options.hasOwnProperty('type')) ? options.type : null;
	            utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(type, 'options.type', util.isString)]);

                invoker(searchApi, 'nlapiDeleteSearch', [type, String(id)], callback);
            }

            // === searchRecord
            function doSearchRecord(options, callback)
            {
                var search = doCreateSearch(options);
                var filters = Filter.marshalFilters(search.filters);
                var columns = Column.marshalColumns(search.columns);
                var settings = Setting.marshalSettings(search.settings);
                return invoker(searchApi, 'nlapiSearchRecord', [search.searchType, String(search.id), filters, columns, settings], callback);
            }

            function doSearchRecord_postProcess(javaResults)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var columns = null;
                var unwrappedResults = utilityFunctions.unwrapArray(rawResults);
                if (unwrappedResults && unwrappedResults.length > 0 && unwrappedResults[0].columns)
                    columns = unwrappedResults[0].columns.map(Column.unmarshalColumn);
                var results = Result.extractResults(rawResults, columns);
                return results ? results : [];
            }

            // === searchDuplicates

            function doSearchDuplicates(options, callback)
            {
                var type = null, fields = null, id = 0;
                if (options)
                {
                    type = options.type;
                    fields = options.fields || null;
                    id = options.id || 0;
                }

                utilityFunctions.checkArgs([type], ['type'], 'search.duplicates');

                return invoker(searchApi, 'nlapiSearchDuplicate', [type, fields, id], callback);
            }

            function doSearchDuplicates_postProcess(javaResults)
            {
	            var rawResults = invoker(remoteApi, 'transform', [javaResults]);
	            var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === searchGlobal
            function doSearchGlobal(options, callback)
            {
                var keywords = (options && options.hasOwnProperty('keywords')) ? options.keywords : options;
                utilityFunctions.checkArgs([keywords], ['keywords'], 'search.global');

                return invoker(searchApi, 'nlapiSearchGlobal', [keywords], callback);
            }

            function doSearchGlobal_postProcess(javaResults)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResults = Result.extractResults(rawResults, null);
                return searchResults ? searchResults : [];
            }

            // === lookupFields

            function getLookupArgs(options)
            {
                var type = null, id = null, columns = null;

                if (options)
                {
                    type = options.type;
                    id = options.id;
                    columns = utilityFunctions.getAsArray(options.columns);
                }

                utilityFunctions.checkArgs([type, id, columns], ['type', 'id', 'columns'], 'search.lookupFields');
                return {type: type, id: id, columns: columns};
            }

            function getLookupSearchColumns(columns)
            {
                var searchColumns = [];
                for (var i = 0; i < columns.length; i++)
                    if (util.isString(columns[i]) && columns[i].toLowerCase() !== 'recordtype')
                        searchColumns[searchColumns.length] = searchObject.createColumn(searchUtilityFunctions.getNameFromColumn(columns[i]), searchUtilityFunctions.getJoinFromColumn(columns[i]), null);
                return searchColumns;
            }

	        function getPostProcessColumns(searchColumns, asksRecordType)
	        {
		        if (asksRecordType)
			        searchColumns[searchColumns.length] = searchObject.createColumn("recordtype", null, null);
		        return searchColumns;
	        }

            function doLookupFields(argObj, searchColumns, callback)
            {
                argObj.columns = Column.marshalColumns(searchColumns);
                return invoker(searchApi, 'nlapiLookupFields', [argObj.type, utilityFunctions.ensureInteger(argObj.id, "id"), argObj.columns], callback);
            }

            function doLookupFields_postProcess(javaResults, searchColumns)
            {
                var rawResults = invoker(remoteApi, 'transform', [javaResults]);
                var searchResult = Result.extractResults(rawResults, searchColumns);

                if (searchResult && searchResult.length > 0)
                    return searchResult[0].getAllValues();
                return {};
            }

            //========================================================================

            return {
                validateAndParseFilterExpression: validateAndParseFilterExpression,
                parseFilterExpression: parseFilterExpression,
                doCreateSearch: funcWrapper.wrap ( doCreateSearch ),
                doLoad: doLoad,
                doDelete: doDelete,
                doSearchRecord: doSearchRecord,
                doSearchRecord_postProcess: doSearchRecord_postProcess,
                doSearchDuplicates: doSearchDuplicates,
                doSearchDuplicates_postProcess: doSearchDuplicates_postProcess,
                doSearchGlobal: doSearchGlobal,
                doSearchGlobal_postProcess: doSearchGlobal_postProcess,
                getLookupArgs: getLookupArgs,
                getLookupSearchColumns: getLookupSearchColumns,
	            getPostProcessColumns: getPostProcessColumns,
                doLookupFields: doLookupFields,
                doLookupFields_postProcess: doLookupFields_postProcess,

                /**
                 * @return {Column}
                 */
                createColumn: funcWrapper.wrap ( searchObject.createColumn ),
                /**
                 * @return {Filter}
                 */
                createFilter: funcWrapper.wrap ( searchObject.createFilter ),
	            /**
	             * @return {Setting}
	             */
                createSetting: funcWrapper.wrap ( searchObject.createSetting),
                /**
                 * @enum
                 */
                OPERATORS: searchObject.OPERATORS,
                /**
                 * @enum
                 */
                SUMMARY_TYPES: searchObject.SUMMARY_TYPES,
                /**
                 * @enum
                 */
                SORT: searchObject.SORT
            }
        });

/**
 * SuiteScript search common module
 * Load the search module to create and run on-demand or saved searches and analyze and iterate through the search results.
 *
 * @module N/search
 * @suiteScriptVersion 2.x
 *
 */
define('N/search',['N/search/searchUtil', 'N/restricted/searchApi', 'N/internal/invoker', 'N/dynamicEnums'],
        function (searchUtil, api, invoker, dynamicEnums)
        {
            function createSearch(options)
            {
                var parsedFilters = searchUtil.validateAndParseFilterExpression(options)
                options.filters = parsedFilters;

                return searchUtil.doCreateSearch(options);
            }

            /**
             * Creates a new search asynchronously and returns it as a search.Search object.
             * @governance none
             * @param {Object} options  the options object
             * @param {string} options.type  The search type that you want to base the search on. Use the search.Type enum for this argument.
             * @param {Array<Filter>|Array<Object>} [options.filters] A single search.Filter object, an array of search.Filter objects, a search filter expression, or an array of search filter expressions.
             * @param {Array<Object>} [options.filterExpression] Search filter expression for the search as an array of expression objects.
             * @param {Array<Column>|Array<Object>} [options.columns] A single search.Column object or array of search.Column objects.
             * @param {string} [options.packageId] The application ID for this search.
             * @param {Array<Setting>|Array<Object>} [options.settings] Search settings for this search as a single search.Setting object or an array of search.Setting objects. Search settings let you specify search parameters that are typically available only in the UI. See Search.settings.
             * @param {string} [options.title] The name for a saved search. The title property is required to save a search with Search.save().
             * @param {string} [options.id] Script ID for a saved search. If you do not set the saved search ID, NetSuite generates one for you. See Search.id.
             * @param {boolean} [options.isPublic] Set to true to make the search public. Otherwise, set to false. If you do not set this parameter, it defaults to false.
             * @return {Promise}
             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
             *
             * @since 2015.2
             */
            createSearch.promise = function createSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.validateAndParseFilterExpression(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                options.filters = result;
                                resolve(searchUtil.doCreateSearch(options));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function loadSearch(options)
            {
                return searchUtil.doLoad(options);
            }

	        /**
	         * Loads an existing saved search asynchronously and returns it as a search.Search object. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	         * @governance 5 units
	         * @param {Object} options  the options object
	         * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	         * @param {string} options.type The search type of the saved search to load. Use a value from the search.Type enum for this parameter.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	         *
	         * @since 2015.2
	         */
            loadSearch.promise = function loadSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doLoad(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(result);
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function deleteSearch(options)
            {
                return searchUtil.doDelete(options);
            }

	        /**
	         * Deletes an existing saved search asynchronously and returns it as a search.Search object. The saved search can be created using the UI or created with search.create(options) and Search.save().
	         * @governance 5 units
	         * @param {Object} options  the options object
	         * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	         * @since 2015.2
	         */
            deleteSearch.promise = function deleteSearchPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doDelete(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve();
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function searchDuplicates(options)
            {
                var javaResults = searchUtil.doSearchDuplicates(options);
                return searchUtil.doSearchDuplicates_postProcess(javaResults);
            }

	        /**
	         * Performs a search for duplicate records asynchronously based on the Duplicate Detection configuration for the account.
	         * @governance 10 units
	         * @param {Object} options  the options object
	         * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	         * @param {Object} [options.fields] A set of key/value pairs used to detect duplicates. The keys are internal ID names of the fields used to detect duplicates.
	         * @param {number} [options.id] Internal ID of an existing record.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         *
	         * @since 2015.2
	         */
            searchDuplicates.promise = function searchDuplicatesPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doSearchDuplicates(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doSearchDuplicates_postProcess(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function searchGlobal(options)
            {
                var rawResults = searchUtil.doSearchGlobal(options);
                return searchUtil.doSearchGlobal_postProcess(rawResults);
            }

	        /**
	         * Performs a global search asynchronously against a single keyword or multiple keywords.
	         * @governance 10 units
	         * @param {Object} options  the options object
	         * @param {string} options.keywords Global search keywords string or expression.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         *
	         * @since 2015.2
	         */
            searchGlobal.promise = function searchGlobalPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            searchUtil.doSearchGlobal(options, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doSearchGlobal_postProcess(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            function lookupFields(options)
            {
                var lookupArgs = searchUtil.getLookupArgs(options);
                var asksRecordType = lookupArgs.columns.indexOf('recordtype') >= 0;
                var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                var javaResults = searchUtil.doLookupFields(lookupArgs, searchColumns);
                if (options.v1call)
                    api.chargeUsage("nlapiLookupFields_v1", options.type);
                return searchUtil.doLookupFields_postProcess(javaResults, searchUtil.getPostProcessColumns(searchColumns, asksRecordType));
            }

	        /**
	         * Performs a search asynchronously for one or more body fields on a record.
	         * @governance 1 unit
	         * @param {Object} options  the options object
	         * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	         * @param {string} options.id Internal ID for the record, for example 777 or 87.
	         * @param {string|Array<string>} options.columns Array of column/field names to look up, or a single column/field name. The columns parameter can also be set to reference joined fields.
	         * @return {Promise}
	         * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	         * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	         *
	         * @since 2015.2
	         */
            lookupFields.promise = function lookupFieldsPromise(options)
            {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            var lookupArgs = searchUtil.getLookupArgs(options);
                            var searchColumns = searchUtil.getLookupSearchColumns(lookupArgs.columns);
                            searchUtil.doLookupFields(lookupArgs, searchColumns, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(searchUtil.doLookupFields_postProcess(result, searchColumns));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            return Object.freeze({
	            /**
	             * Creates a new search and returns it as a search.Search object.
	             * The search can be modified and run as an on demand search with Search.run(), without saving it. Alternatively,
	             * calling Search.save() will save the search to the database, so it can be reused later in the UI or loaded with search.load(options).
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.type  The search type that you want to base the search on. Use the search.Type enum for this argument.
	             * @param {Filter|Array<Filter>|Array<Object>} [options.filters] A single search.Filter object, an array of search.Filter objects, a search filter expression, or an array of search filter expressions.
	             * @param {Array<Object>} [options.filterExpression] Search filter expression for the search as an array of expression objects.
	             * @param {Column|Array<Column>|Array<Object>} [options.columns] A single search.Column object or array of search.Column objects.
	             * @param {string} [options.packageId] The application ID for this search.
	             * @param {Setting|Array<Setting>|Array<Object>} [options.settings] Search settings for this search as a single search.Setting object or an array of search.Setting objects. Search settings let you specify search parameters that are typically available only in the UI. See Search.settings.
	             * @param {string} [options.title] The name for a saved search. The title property is required to save a search with Search.save().
	             * @param {string} [options.id] Script ID for a saved search. If you do not set the saved search ID, NetSuite generates one for you. See Search.id.
	             * @param {boolean} [options.isPublic] Set to true to make the search public. Otherwise, set to false. If you do not set this parameter, it defaults to false.
	             * @return {Search}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_FILTER_EXPR The options.filters parameter is not a valid search filter, filter array, or filter expression.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	             *
	             * @since 2015.2
	             */
	            create: createSearch,
	            /**
	             * Loads an existing saved search and returns it as a search.Search. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	             * @governance 5 units
	             * @param {Object} options  the options object
	             * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	             * @param {string} [options.type] The search type of the saved search to load. Use a value from the search.Type enum for this parameter. Required if the saved search to load uses a standalone search type, optional otherwise.
	             * @return {Search}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	             *
	             * @since 2015.2
	             */
	            load: loadSearch,
	            /**
	             * Deletes an existing saved search. The saved search could have been created using the UI or created with search.create(options) and Search.save().
	             * @governance 5 units
	             * @param {Object} options the options object
	             * @param {string} options.id Internal ID or script ID of a saved search. The script ID starts with customsearch. See Search.id.
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} INVALID_SEARCH Cannot find saved search with the saved search ID from options.id parameter.
	             * @return {void}
	             *
	             * @since 2015.2
	             */
	            'delete': deleteSearch,
	            /**
	             * Performs a search for duplicate records based on the account's duplicate detection configuration.
	             * @governance 10 units
	             * @param {Object} options  the options object
	             * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	             * @param {Object} [options.fields] A set of key/value pairs used to detect duplicates. The keys are internal ID names of the fields used to detect duplicates.
	             * @param {number} [options.id] Internal ID of an existing record.
	             * @return {Array<Result>}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             *
	             * @since 2015.2
	             */
	            duplicates: searchDuplicates,
	            /**
	             * Performs a global search against a single keyword or multiple keywords.
	             * @governance 10 units
	             * @param {Object} options  the options object
	             * @param {string} options.keywords Global search keywords string or expression.
	             * @return {Array<Result>}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             *
	             * @since 2015.2
	             */
	            global: searchGlobal,
	            /**
	             * Performs a search for one or more body fields on a record.
	             * @governance 1 unit
	             * @param {Object} options  the options object
	             * @param {string} options.type The search type that you want to check for duplicates. Use the search.Type enum for this parameter.
	             * @param {string} options.id Internal ID for the record, for example 777 or 87.
	             * @param {string|Array<string>} options.columns Array of column/field names to look up, or a single column/field name. The columns parameter can also be set to reference joined fields.
	             * @return {Object}
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN The options.columns parameter is not a valid column, string, or column or string array.
	             *
	             * @since 2015.2
	             */
	            lookupFields: lookupFields,

	            /**
	             * Creates a new search column as a search.Column object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name  Name of the search column.
	             * @param {string} [options.join]  Join ID for the search column.
	             * @param {string} [options.summary] Summary type for the column.
	             * @param {string} [options.formula] Formula used for the column.
	             * @param {string} [options.function] Special function for the search column.
	             * @param {string} [options.label] Label for the search column.
	             * @param {string} [options.sort] The sort order of the column.
	             * @return {Column} the created column object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_COLUMN_SUM The options.summary parameter is not a valid search summary type.
	             * @throws {SuiteScriptError} INVALID_SRCH_FUNCTN An unknown function is provided.
	             *
	             * @since 2015.2
	             */
	            createColumn: searchUtil.createColumn,

	            /**
	             * Creates a new search filter as a search.Filter object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name  Name or internal ID of the search field.
	             * @param {string} [options.join] Join ID for the search filter.
	             * @param {string} options.operator Operator used for the search filter. Use the search.Operator enum.
	             * @param {string|Date|Number|boolean|Array<string>|Array<Date>|Array<Number>} [options.values] Values to be used as filter parameters.
	             * @param {string} [options.formula] Formula used for this filter
	             * @param {Summary} [options.summary] Summary type for the search filter.
	             * @return {Filter} the created filter object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT Required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_OPERATOR Options.summary parameter is not a valid search summary type.
	             * @throws {SuiteScriptError} INVALID_SRCH_SUMMARY_TYP Options.operator parameter is not a valid operator type.
	             *
	             * @since 2015.2
	             */
	            createFilter: searchUtil.createFilter,

	            /**
	             * Creates a new search setting and returns it as a search.Setting object.
	             * @governance none
	             * @param {Object} options  the options object
	             * @param {string} options.name The name of the search parameter to set
	             * @param {string} options.value The value of the search parameter.
	             * @return {Setting} the created setting object
	             * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT A required parameter is missing.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING An unknown search parameter name is provided.
	             * @throws {SuiteScriptError} SSS_INVALID_SRCH_SETTING_VALUE An unsupported value is set for the provided search parameter name.
	             *
	             * @since 2015.2
	             */
	            createSetting: searchUtil.createSetting,

	            /**
	             * Enumeration that holds the values for search operators to use with the search.Filter.
	             * @enum {string}
	             * @readonly
	             */
	            Operator: searchUtil.OPERATORS,

	            /**
	             * Enumeration that holds the values for summary types used by the Column.summary or Filter.summary properties.
	             * @enum {string}
	             * @readonly
	             */
	            Summary: searchUtil.SUMMARY_TYPES,

	            /**
	             * Enumeration that holds the values for supported sorting directions used with search.createColumn(options).
	             * @enum {string}
	             * @readonly
	             */
	            Sort: searchUtil.SORT,
	            /*
                 * module enums
                 */
	            get Type()
	            {
		            if(!searchUtil.searchTypes)
			            searchUtil.searchTypes = dynamicEnums.searchTypes;
		            return searchUtil.searchTypes;
	            }
            });
        });
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/record/recordScriptingScope
 * @NApiVersion 2.x
 *
 */
define('N/record/recordScriptingScope',['N/restricted/remoteApiBridge', 'N/record/recordConstants', 'N/utilityFunctions', 'N/util/currencyUtility', 'N/util/date',
		'N/error', 'N/internal/invoker', 'N/internal/reflet', 'N/record/recordImplV1',
		'N/scope', 'N/msgRouter', 'N/search', 'N/search/searchUtil', 'N/util/callRecordScript',
		'N/util', 'N/contextSwitch', 'N/scriptLoader', 'N/resultObject'],
	function(remoteApi, constants, utilityFunctions, currencyutil, dateutil,
	         error, invoker, reflet, recordImpl,
	         jsScope, msgRouter, search, searchUtil, callRecordScriptMod,
	         util, contextSwitch, v2ScriptLoader, resultObject)
	{
		/**
		 * @readonly
		 * @enum {string}
		 */
		var CLIENT_EVENT  = Object.freeze({
			LOC_CONTEXT_ENTER: 'localizationContextEnter',
			LOC_CONTEXT_EXIT: 'localizationContextExit',
			PAGE_INIT_TRIGGER: 'pageInit',
			SAVE_RECORD_TRIGGER: 'saveRecord',
			LINE_INIT_TRIGGER: 'lineInit',
			VALIDATE_DELETE_TRIGGER: 'validateDelete',
			VALIDATE_INSERT_TRIGGER: 'validateInsert',
			VALIDATE_LINE_TRIGGER: 'validateLine',
			RECALC_TRIGGER: 'recalc',
			SUBLIST_CHANGED_TRIGGER: 'sublistChanged',
			POST_SOURCING_TRIGGER: 'postSourcing',
			VALIDATE_FIELD_TRIGGER: 'validateField',
			FIELD_CHANGED_TRIGGER: 'fieldChanged'
		});

		/**
		 * @readonly
		 * @enum {string}
		 */
		var RECORD_EVENT = Object.freeze({
			PAGE_INIT: 'pageInit',
			VALIDATE: 'validate',
			ON_CHANGE: 'onChange',
			SAVE: 'save',
			LINE_INIT: 'lineInit',
			LINE_COMMIT: 'lineCommit',
			POST_DELETE_LINE: 'postDeleteLine',
			VALIDATE_LINE: 'validateLine',
			VALIDATE_INSERT: 'validateInsert',
			VALIDATE_DELETE: 'validateDelete',
			RECALC: 'recalc',
			POST_SOURCING: 'postSourcing',
			LOC_CONTEXT_ENTER: 'localizationContextEnter',
			LOC_CONTEXT_EXIT: 'localizationContextExit'
		});

		var undef = undefined;

		var globalScope = (function() { return this; })();

		/* If this is > 0, it means the current script execution is occuring from within a client script. */
		var clientScriptInvocationDepthCount = 0;
		function isExecutionWithinAClientScript()
		{
			return clientScriptInvocationDepthCount > 0;
		}

		var create = utilityFunctions.thenableFunction(function create(options, isAsync)
		{
			return new Scope(options, isAsync).ensureInitialized();
		}, {
			isAsyncArgIndex: 1
		});

		/**
		 *
		 * @param {Object} options
		 * @param {Function} options.record function returns the core record
		 * @param {string} options.libraryScript just for NSN
		 * @param {string} options.staticScript just for NSN
		 * @param {string} options.uiFormScript just for NSN
		 * @param {boolean} options.shouldTriggerCustomFormLevelScript
		 * @param {object} options.formLevelScriptComponent
		 * @param {boolean} options.shouldTriggerCustomClientScript
		 * @param {object} options.clientScriptComponent
		 * @param {string} options.clientScriptComponent.libraryScript
		 * @param {*} options.clientScriptComponent.scriptList
		 * @param {Function} options.completePageInit
		 * @constructor
		 */
		function Scope(options, isAsyncConstructed)
		{
			var that = this;
			var coreRecord = options.record;

			if (!coreRecord.getIsNSERecord())
			{
				// script defined in NLRecord by internal NS developer
				var recordLibraryScript = options.libraryScript;
				var staticScript = options.staticScript;
				var uiFormScript = options.uiFormScript;
			}

			var internalInitCompleted = false;
			var recordInitialized = false;
			function completeInternalInit() {
				internalInitCompleted = true;
				if (typeof options.completeInternalInit === 'function')
					options.completeInternalInit();
			}
			function completePageInit() {
				recordInitialized = true;
				if (typeof options.completePageInit === 'function')
					options.completePageInit();
			}
			var initializeThenable;

			if (!coreRecord.getIsNSERecord())
			{
				// for backward compatiability UIFormScripts
				var NS;
				function uiFormScriptWrapper() { eval(uiFormScript); }

				(function evaluateUIFormScriptAndCleanUp(scope)	{
					if (coreRecord.getIsCurrentRecord()) {
						scope.NS = scope.NS || {};
						scope.NS.UI = (globalScope.NS || {}).UI;
						scope.location = {search: "?" + coreRecord.getValue("entryformquerystring")};
					}
					var triggerUiFormScriptWrapper = uiFormScriptWrapper.bind(scope);
					triggerUiFormScriptWrapper();
					NS = scope.NS;
					delete scope.NS;
					delete scope.location;
				})(this);

				// record for v1 scripting expected in staticScript togehter with parent for some slaving scripts
				var record = recordImpl.create({record: coreRecord});
				var parent = record;
				eval(staticScript);
				eval(recordLibraryScript);
			}
			else
			{
				function NLAlert(msg, ignoreServerSide) { alert(msg) }
				function alert(msg) { invoker(reflet, 'alert', [msg]); }
				function _confirm(msg) { return invoker(reflet, 'confirm', [msg]); }
				var confirm = coreRecord.getIsCurrentRecord() ? globalScope.confirm : _confirm;
				function debug(id, msg) { invoker(reflet, 'debug', [id, msg]); }
			}


			function recordScriptingScope() { eval(arguments[0]); }

			var callRecordScript;

			// form-level script information
			var shouldTriggerCustomFormLevelScript = options.shouldTriggerCustomFormLevelScript;
			var formLevelScript = options.formLevelScriptComponent ? options.formLevelScriptComponent.script : null;
			var formLevelScriptAllText = options.formLevelScriptComponent ? options.formLevelScriptComponent.libraryScript : null;

			// client script information
			var shouldTriggerCustomClientScript = options.shouldTriggerCustomClientScript;
			var clientScriptList = options.clientScriptComponent ? options.clientScriptComponent.scriptList : null;
			var clientScriptAllText = options.clientScriptComponent ? options.clientScriptComponent.libraryScript : null;

			// workflow-generated client script
			var workflowScript = options.workflowScript;

			var getV1ScopeSingleton = (function()
			{
				var v1Scope = null;

				return function getV1ScopeSingleton(libraries)
				{
					if (v1Scope === null)
					{
						var readOnly = coreRecord.getIsReadOnlyRecord();
						v1Scope = jsScope({
							blacklist: readOnly ? [] : getV1ApiBlackList(),
							whitelist: readOnly ? {} : utilityFunctions.addParameterToMap(utilityFunctions.addParameterToMap({}, getV1ApiGrayList()), getV1ApiWhiteList()),
							libraries: libraries || []
						});
					}
					return v1Scope;
				}
			}());

			/* Assemble a unified list of V1 and V2 scripts, in script precedence order (form script, if any, followed by client scripts). */
			var formAndClientScriptList = [];
			var formAndClientScriptAllTextList = {};

			if (shouldTriggerCustomFormLevelScript)
			{
				formAndClientScriptList.push(formLevelScript);
				formAndClientScriptAllTextList[formLevelScript.scriptId] = formLevelScriptAllText;
			}

			if (workflowScript)
			{
				var scriptId = 'workflowscript';
				var workflowScriptRepresentation = { version: workflowScript.version || '1.0', scriptId: scriptId};
				formAndClientScriptList.push(workflowScriptRepresentation);
				formAndClientScriptAllTextList['workflowscript'] = workflowScript;
			}

			if (shouldTriggerCustomClientScript)
			{
				for (var i = 0; i < clientScriptList.length; i++)
				{
					var clientScript = clientScriptList[i];
					formAndClientScriptList.push(clientScript);
					formAndClientScriptAllTextList[clientScript.scriptId] = clientScriptAllText[clientScript.scriptId];
				}
			}

			coreRecord.getLocaleContext().setupCallbacks({
				loadScriptsForLocale: loadScriptsForLocalePromise,
				localizationContextEnter: localizationContextEnter,
				localizationContextExit: localizationContextExit
			});

			//start async load of user scripts as early as possible
			var moduleKeeper = v2ScriptLoader.createModuleKeeper({
				systemId: coreRecord.getSystemId(),
				scriptList: formAndClientScriptList,
				localizationScriptLimit: coreRecord.getLocaleContext().localizedScriptLimit()
			});
			moduleKeeper.loadModules();
			moduleKeeper.loadModulesWithLocale(coreRecord.getLocaleContext().getTargetLocale());

			/* Put the scripts into their appropriate scopes, by version, in definition order (form script followed by client scripts). */
			{
				var v1Libraries = formAndClientScriptList.filter(function (script)
				{
					return script.version === '1.0';
				}).map(function (script)
				{
					return formAndClientScriptAllTextList[script.scriptId];
				});
				if (v1Libraries.length > 0) {
					// initialize v1 scope with libraries
					getV1ScopeSingleton(v1Libraries);
				}
			}

			function runInternalScript(scriptContent)
			{
				runInternalScriptAndReturnResult(scriptContent);
			}

			function runInternalScriptAndAssert(scriptContent, code)
			{
				try
				{
					var result = runInternalScriptAndReturnResult(scriptContent);
					_assertValidation(result, code);
					return result;
				}
				catch (e)
				{
					_handleError(e);
				}
			}

			/**
			 * @param {boolean} resultLegacy
			 * @param {V2RecordScriptOptions} optionsV2
			 * @param {String} errorMessage
			 */
			var runMergeAndAssertInternalScript = utilityFunctions.thenableFunction(function runMergeAndAssertInternalScript(resultLegacy, optionsV2, errorMessage)
			{
				optionsV2.legacyScript = resultLegacy;
				return runAndAssertInternalScript.thenable(optionsV2, errorMessage);
			});

			/**
			 * @param {boolean} resultLegacy
			 * @param {V2RecordScriptOptions} optionsV2 (in NSN it can be enhanced with legacyScript)
			 * @param {String} errorMessage
			 */
			var runAndAssertInternalScript = utilityFunctions.thenableFunction(function runAndAssertInternalScript(optionsV2, errorMessage)
			{
				return resultObject.create(function ()
				{
					return callRecordScript.thenable(optionsV2);
				}).then(function (result)
				{
					_assertValidation(result, errorMessage);
				})['catch'](function (e)
				{
					_handleError(e);
				});
			});

			/**
			 * @typedef {Object} V2RecordScriptOptions
			 * @property {String|null} eventName
			 * @property {String|null} fieldId
			 * @property {String|null} sublistId
			 * @property {String|null} lineInstanceId
			 * @property {{newValue :Object|null, currentValue: Object|null}|null} valueObject
			 * @property {Array<*>} arguments
			 */

			/**
			 * @param {String|null} eventName
			 * @param {String|null} fieldId
			 * @param {String|null} sublistId
			 * @param {String|null} lineInstanceId
			 * @param {Array<*>} callerArgs
			 * @param {{newValue :Object|null, currentValue: Object|null}|null} valueObject
			 * @returns V2RecordScriptOptions
			 */
			function getV2RecordScriptOptions(eventName, fieldId, sublistId, lineInstanceId, callerArgs, valueObject)
			{
				return {
					eventName: eventName,
					fieldId: fieldId,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					valueObject: valueObject,
					arguments: callerArgs
				};
			}

			function evaluateSlavingResponse(response)
			{
				var slaveValues;
				eval(response);
				return slaveValues;
			}

			this.evaluateSlavingResponse = evaluateSlavingResponse;

			function runInternalScriptAndReturnResult(scriptContent)
			{
				return contextSwitch.execute({scriptInfo: {}}, function ()
				{
					try
					{
						var toRet = eval(scriptContent);
						return toRet;
					}
					catch (e)
					{
						_handleError(e);
					}
				});
			}

			this.runInternalScriptAndReturnResult = runInternalScriptAndReturnResult;

			function runInternalScriptAndReturnBooleanResult(scriptContent)
			{
				return !!runInternalScriptAndReturnResult(scriptContent);
			}

			this.runInternalScriptAndReturnBooleanResult = runInternalScriptAndReturnBooleanResult;

			function _handleError(e)
			{
				var err = e;
				if (e instanceof Error)
				{
					if (e.userFacing !== undef && e.userFacing !== null) {
						err = error.create({name: e.name, message: e.message, cause: e, userFacing: e.userFacing});
					} else {
						err = error.create({name: e.name, message: e.message, cause: e});
					}
				}
				throw err;
				//TODO - notify error
			}

			function _assertValidation(result, code)
			{
				var allMessages = [];
				var errorObj;

				// check for legacy error messages
				try {
					invoker(reflet, 'checkWarningMessageInSession', []);
				} catch (e) {
					errorObj = e;
				}

				// validation script return value uses the extended contract
				if (utilityFunctions.isObject(result) && result.hasOwnProperty('valid'))
				{
					if (!result.valid)
					{
						// Rhino: (Array.prototype.concat([],[])).length === 1.0
						// Rhino: (Array.prototype.concat.call([],[])).length === 0 => call is required
						allMessages = Array.prototype.concat.call(errorObj && errorObj.message || [], result.messages || []);
						if (allMessages.length)
							errorObj = error.create({name: 'USER_ERROR', message: allMessages.join('\n')});
						else
							errorObj = utilityFunctions.isInternalErrorCode(code) ? utilityFunctions.createSuiteScriptError(code) : error.create({name: 'USER_ERROR', message: code});
						errorObj.validationDetail = result;
						throw errorObj;
					}
				}
				else if (!result)
				{
					if (!errorObj)
						errorObj = utilityFunctions.isInternalErrorCode(code) ? utilityFunctions.createSuiteScriptError(code) : error.create({name: 'USER_ERROR', message: code});
					throw errorObj;
				}
			}

			function _createArgumentsJSExpression(args)
			{
				var innerArgs = JSON.stringify(args);
				innerArgs = innerArgs.substr(1, innerArgs.length - 2);

				return '(' + innerArgs + ')';
			}

			function _getFieldScript(sublistId, fieldId, fieldscripttype)
			{
				var metadata = coreRecord.getMetadata().getFieldMetadata(sublistId, fieldId);
				return (metadata) ? utilityFunctions.returnEmptyIfNull(metadata.getFieldScript(fieldscripttype)) : '';
			}

			var _pageInit = utilityFunctions.thenableFunction(function _pageInit()
			{
				if (coreRecord.getIsNSERecord())
				{
					return resultObject.create(function ()
					{
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.PAGE_INIT, null, null, null, []));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.PAGE_INIT_TRIGGER, [coreRecord.id > 0 ? 'edit' : 'create']);
					});
				}
				else
				{
					var scriptToRun = 'function NLRecordScripting_pageInit() { page_init(); }; NLRecordScripting_pageInit();';
					runInternalScript(scriptToRun);
					return runClientScripts.thenable(CLIENT_EVENT.PAGE_INIT_TRIGGER, [coreRecord.id > 0 ? 'edit' : 'create']);
				}
			});

			function localizationContextEnter(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					resultObject.create(function ()
					{
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.LOC_CONTEXT_ENTER, null, null, null, args));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.LOC_CONTEXT_ENTER, args, null, {locale: locale, callback: resolve});
					});
				});
			}

			function localizationContextExit(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					resultObject.create(function ()
					{
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.LOC_CONTEXT_EXIT, null, null, null, args));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.LOC_CONTEXT_EXIT, args, null, {locale: locale, callback: resolve});
					});
				});
			}

			var _validateField = utilityFunctions.thenableFunction(function _validateField(sublistId, fieldId, lineInstanceId, matrixColumn, valueObject)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);
				var errorMessage = 'Field validation failed for field: ' + fieldId;

				if (!coreRecord.getIsNSERecord())
				{
					var validationFieldScript = _getFieldScript(sublistId, fieldId, 'validatefield');
					var resultLegacy = true;
					if (!utilityFunctions.isValEmpty(validationFieldScript))
					{
						var scriptDefinition =
							'function NLRecordScripting_validateField(type,fld,linenum,bucket) {\n' +
							' var valid = ' + validationFieldScript + ';\n' +
							' return valid;\n};\n';
						var args = [sublistId, fieldId];
						if (line_1 > 0)
							args.push(line_1);
						if (matrixColumn != -1)
							args.push(matrixColumn);
						var scriptInvoker = 'NLRecordScripting_validateField' + _createArgumentsJSExpression(args);
						var scriptToRun = scriptDefinition + scriptInvoker;
						resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
					}
					return resultObject.create(function ()
					{
						return runMergeAndAssertInternalScript.thenable(resultLegacy, getV2RecordScriptOptions(RECORD_EVENT.VALIDATE, fieldId, sublistId, lineInstanceId, [line_1, matrixColumn], valueObject), errorMessage);
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_FIELD_TRIGGER, [sublistId, fieldId, line_1, matrixColumn], errorMessage);
					});
				}
				else
				{
					return resultObject.create(function ()
					{
						return runAndAssertInternalScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.VALIDATE, fieldId, sublistId, lineInstanceId, [line_1, matrixColumn], valueObject), errorMessage);
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_FIELD_TRIGGER, [sublistId, fieldId, line_1, matrixColumn], errorMessage);
					});
				}
			});

			this.validateField = _validateField;

			function _canCreateSubrecord(sublistId, fieldId, lineInstanceId)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);
				var canCreateSubrecordScript = _getFieldScript(sublistId, fieldId, 'canCreateSubrecord');
				if (!utilityFunctions.isValEmpty(canCreateSubrecordScript))
				{
					var wrappedScript = '(function(type,fld,linenum){ ' + canCreateSubrecordScript + '})(type,fld,linenum);';
					var scriptDefinition = 'function NLRecordScripting_canCreateSubrecord(type,fld,linenum) { var is_valid = ' + wrappedScript + '; return is_valid; };\n';
					var args = [sublistId, fieldId];
					if (line_1 > 0)
					{
						args.push(line_1);
					}
					var scriptInvoker = 'NLRecordScripting_canCreateSubrecord' + _createArgumentsJSExpression(args);
					var scriptToRun = scriptDefinition + scriptInvoker;
					runInternalScriptAndAssert(scriptToRun, error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_CREATE_THIS_SUBRECORD);
				}
			}

			this.canCreateSubrecord = _canCreateSubrecord;

			var _fieldChange = utilityFunctions.thenableFunction(function _fieldChange(sublistId, fieldId, lineInstanceId, matrixColumn)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);

				if (!coreRecord.getIsNSERecord())
				{
					var fieldChangeScript = _getFieldScript(sublistId, fieldId, 'fieldchange');
					if (!utilityFunctions.isValEmpty(fieldChangeScript))
					{
						var scriptDefinition = 'function NLRecordScripting_fieldChange(type,fld,linenum,bucket) { ' + fieldChangeScript + ' }\n';
						var args = [sublistId, fieldId];
						if (line_1 > 0)
						{
							args.push(line_1);
						}
						if (matrixColumn !== -1)
						{
							args.push(matrixColumn);
						}
						var scriptInvoker = 'NLRecordScripting_fieldChange' + _createArgumentsJSExpression(args);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}
				}

				return resultObject.create(function ()
				{
					return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.ON_CHANGE, fieldId, sublistId, lineInstanceId, [line_1, matrixColumn]));
				}).then(function ()
				{
					return runClientScripts.thenable(CLIENT_EVENT.FIELD_CHANGED_TRIGGER, [sublistId, fieldId, line_1, matrixColumn]);
				});
			});

			this.fieldChange = _fieldChange;

			var _saveRecord = utilityFunctions.thenableFunction(function _saveRecord(ignoreMandatoryFields)
			{
				if (!coreRecord.getIsNSERecord())
				{
					var scriptDefinition =
						'function NLRecordScripting_saveRecord(ignoreMandatoryFields) {\n' +
						' return save_record(ignoreMandatoryFields, true);\n};\n';
					var scriptInvoker = 'NLRecordScripting_saveRecord(' + ignoreMandatoryFields + ')';
					var scriptToRun = scriptDefinition + scriptInvoker;
					var resultLegacy =  runInternalScriptAndReturnResult(scriptToRun);
					return resultObject.create(function ()
					{
						return runMergeAndAssertInternalScript.thenable(
							resultLegacy,
							getV2RecordScriptOptions(RECORD_EVENT.SAVE, null, coreRecord.getSublists(), null, []),
							error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD
						);
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.SAVE_RECORD_TRIGGER, [], error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD);
					});
				}
				else
				{
					return resultObject.create(function ()
					{
						return runAndAssertInternalScript.thenable(
							getV2RecordScriptOptions(RECORD_EVENT.SAVE, null, coreRecord.getSublists(), null, []),
							error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD
						);
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.SAVE_RECORD_TRIGGER, [], error.Type.FORM_VALIDATION_FAILED_YOU_CANNOT_SUBMIT_THIS_RECORD);
					});
				}
			});

			this.saveRecord = _saveRecord;

			function _getSublistScript(sublistId, scriptingTrigger, args)
			{
				var toRet = '';
				var sublistScripts = coreRecord.getMetadata().getSublistScripts(sublistId, scriptingTrigger);
				if (!utilityFunctions.isValEmpty(sublistScripts))
				{
					toRet = sublistScripts + args;
				}

				return toRet;
			}

			var _lineInit = utilityFunctions.thenableFunction(function _lineInit(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					if (!coreRecord.getIsNSERecord())
					{
						var lineInitScript = _getSublistScript(sublistId, 'lineinit', '()');
						if (!utilityFunctions.isValEmpty(lineInitScript))
						{
							var scriptDefinition = 'function NLRecordScripting_lineInit(type) { ' + lineInitScript + '; nlapiLineInit(type);};\n';
							var scriptInvoker = 'NLRecordScripting_lineInit' + _createArgumentsJSExpression([sublistId]);
							var scriptToRun = scriptDefinition + scriptInvoker;
							runInternalScript(scriptToRun);
						}
					}

					return resultObject.create(function ()
					{
						var lineInstanceId = coreRecord.doGetCurrentSublistLineInstanceId(sublistId);
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.LINE_INIT, null, sublistId, lineInstanceId, []));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.LINE_INIT_TRIGGER, [sublistId]);
					});
				}
			});

			this.lineInit = _lineInit;

			var _lineCommit = utilityFunctions.thenableFunction(function _lineCommit(sublistId, lineInstanceId)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);

				if (!coreRecord.getIsNSERecord())
				{
					var lineCommitScript = _getSublistScript(sublistId, 'linecommit', '(linenum)');
					if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(lineCommitScript)) {
						var scriptDefinition = 'function NLRecordScripting_lineCommit(type, linenum) { ' + lineCommitScript + '; nlapiLineCommit(type, linenum); };\n';
						var scriptInvoker = 'NLRecordScripting_lineCommit' + _createArgumentsJSExpression([sublistId, line_1]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}
				}

				return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.LINE_COMMIT, null, sublistId, lineInstanceId, [line_1]));
			});

			this.lineCommit = _lineCommit;

			var _postDeleteLine = utilityFunctions.thenableFunction(function _postDeleteLine(sublistId, lineInstanceId)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);

				if (!coreRecord.getIsNSERecord())
				{
					var postDeleteLineScript = _getSublistScript(sublistId, 'postdeleteline', '');
					if (coreRecord.isSublistAnEditMachine(sublistId) && !utilityFunctions.isValEmpty(postDeleteLineScript)) {
						//TODO: verify postDeleteLine path.
						var scriptDefinition = 'function NLRecordScripting_postDeleteLine(type, linenum) { var hndlr = ' + postDeleteLineScript + '; hndlr(linenum); };\n';
						var scriptInvoker = 'NLRecordScripting_postDeleteLine' + _createArgumentsJSExpression([sublistId, line_1]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						runInternalScript(scriptToRun);
					}
				}

				return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.POST_DELETE_LINE, null, sublistId, lineInstanceId, [line_1]));
			});

			this.postDeleteLine = _postDeleteLine;

			var _validateLine = utilityFunctions.thenableFunction(function _validateLine(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var lineInstanceId = coreRecord.doGetCurrentSublistLineInstanceId(sublistId)
					var errorMessage = 'Line validation failed for sublist: ' + sublistId;

					if (!coreRecord.getIsNSERecord())
					{
						var validationLineScript = _getSublistScript(sublistId, 'validateline', '()') || 'true';
						var scriptDefinition =
							'function NLRecordScripting_validateLine(type) {\n' +
							' var valid = ' + validationLineScript + ';\n' +
							' if (validationResultToBoolean(valid))\n' +
							'  valid = nlapiValidateLine(type, true);\n' +
							' return valid;\n};\n';
						var scriptInvoker = 'NLRecordScripting_validateLine' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
						return resultObject.create(function ()
						{
							return runMergeAndAssertInternalScript.thenable(resultLegacy, getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_LINE, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_LINE_TRIGGER, [sublistId], errorMessage);
						});
					}
					else
					{
						return resultObject.create(function ()
						{
							return runAndAssertInternalScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_LINE, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_LINE_TRIGGER, [sublistId], errorMessage);
						});
					}
				}
			});

			this.validateLine = _validateLine;

			var _validateInsert = utilityFunctions.thenableFunction(function _validateInsert(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var lineInstanceId = coreRecord.doGetCurrentSublistLineInstanceId(sublistId);
					var errorMessage = 'Line insert validation failed for sublist: ' + sublistId;

					if (!coreRecord.getIsNSERecord())
					{
						var validationInsertScript = _getSublistScript(sublistId, 'validateinsert', '()') || 'true';

						var scriptDefinition =
							'function NLRecordScripting_validateInsert(type) {\n' +
							' var valid = ' + validationInsertScript + ';\n' +
							' if (validationResultToBoolean(valid))\n' +
							'  valid = nlapiValidateInsert(type);\n' +
							' return valid;\n};\n';
						var scriptInvoker = 'NLRecordScripting_validateInsert' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
						return resultObject.create(function ()
						{
							return runMergeAndAssertInternalScript.thenable(resultLegacy, getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_INSERT, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_INSERT_TRIGGER, [sublistId], errorMessage);
						});
					}
					else
					{
						return resultObject.create(function ()
						{
							return runAndAssertInternalScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_INSERT, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_INSERT_TRIGGER, [sublistId], errorMessage);
						});
					}
				}
			});

			this.validateInsert = _validateInsert;

			var _validateDelete = utilityFunctions.thenableFunction(function _validateDelete(sublistId)
			{
				if (coreRecord.isSublistAnEditMachine(sublistId))
				{
					var errorMessage = 'Line delete validation failed for sublist: ' + sublistId;
					var lineInstanceId = coreRecord.doGetCurrentSublistLineInstanceId(sublistId);

					if (!coreRecord.getIsNSERecord())
					{
						var validationDeleteScript = _getSublistScript(sublistId, 'validatedelete', '()') || 'true';

						var scriptDefinition =
							'function NLRecordScripting_validateDelete(type) {\n' +
							' var valid = ' + validationDeleteScript + ';\n' +
							' if (validationResultToBoolean(valid))\n' +
							'  valid = nlapiValidateDelete(type);\n' +
							' return valid;\n};\n';
						var scriptInvoker = 'NLRecordScripting_validateDelete' + _createArgumentsJSExpression([sublistId]);
						var scriptToRun = scriptDefinition + scriptInvoker;
						var resultLegacy = runInternalScriptAndReturnResult(scriptToRun);
						return resultObject.create(function ()
						{
							return runMergeAndAssertInternalScript.thenable(resultLegacy, getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_DELETE, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_DELETE_TRIGGER, [sublistId], errorMessage);
						});
					}
					else
					{
						return resultObject.create(function ()
						{
							return runAndAssertInternalScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.VALIDATE_DELETE, null, sublistId, lineInstanceId, []), errorMessage);
						}).then(function ()
						{
							return runClientScripts.thenable(CLIENT_EVENT.VALIDATE_DELETE_TRIGGER, [sublistId], errorMessage);
						});
					}
				}
			});

			this.validateDelete = _validateDelete;

			var _recalc = utilityFunctions.thenableFunction(function _recalc(sublistId, localRecalc, options, ignoreRecalc)
			{
				var operation = (options || {}).operation || 'commit';

				if (!ignoreRecalc && (coreRecord.isSublistAnEditMachine(sublistId) || (localRecalc && !coreRecord.isSublistAnEditMachine(sublistId))))
				{
					if (!coreRecord.getIsNSERecord())
					{
						var recalcScript = _getSublistScript(sublistId, 'recalc', '');
						if (!utilityFunctions.isValEmpty(recalcScript)) {
							var scriptDefinition = 'function NLRecordScripting_recalc(type) { ' + recalcScript + '; nlapiRecalc(type, false, \'' + operation + '\'); };\n';
							var scriptInvoker = 'NLRecordScripting_recalc(\'' + sublistId + '\');';
							var scriptToRun = scriptDefinition + scriptInvoker;
							runInternalScript(scriptToRun);
						}
					}

					return resultObject.create(function ()
					{
						var lineInstanceId = coreRecord.doGetCurrentSublistLineInstanceId(sublistId);
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.RECALC, null, sublistId, lineInstanceId, [operation]));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.RECALC_TRIGGER, [sublistId, operation]);
					});
				}
			});

			this.recalc = _recalc;

			var _totaling = utilityFunctions.thenableFunction(function _totaling(sublistId, fieldId, options)
			{
				options = options || {};

				if (options.operation === "machinesourcing") {
					return callRecordScript.thenable(getV2RecordScriptOptions('_syncsublists_', null, null, null, [options]));
				}
				else if (sublistId) {
					var eventName = '_sync_' + sublistId + (fieldId ? '_' + fieldId : '');
					return callRecordScript.thenable(getV2RecordScriptOptions(eventName, fieldId || null, sublistId, null, [options]));
				}
			});

			this.totaling = _totaling;

			function _postSublistSourcing(postSourcingScript)
			{
				if (!coreRecord.getIsNSERecord())
					runInternalScript(postSourcingScript);
			}

			this.postSublistSourcing = _postSublistSourcing;

			var _postSourcing = utilityFunctions.thenableFunction(function _postSourcing(sublistId, fieldId, lineInstanceId)
			{
				var line_1 = coreRecord.getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId);

				if (!coreRecord.getIsNSERecord())
				{
					return runClientScripts.thenable(CLIENT_EVENT.POST_SOURCING_TRIGGER, [sublistId, fieldId, line_1]);
				}
				else
				{
					return resultObject.create(function ()
					{
						return callRecordScript.thenable(getV2RecordScriptOptions(RECORD_EVENT.POST_SOURCING, fieldId, sublistId, lineInstanceId, []));
					}).then(function ()
					{
						return runClientScripts.thenable(CLIENT_EVENT.POST_SOURCING_TRIGGER, [sublistId, fieldId, line_1]);
					});
				}
			});

			this.postSourcing = _postSourcing;
			
			var caresAboutReturn = [CLIENT_EVENT.SAVE_RECORD_TRIGGER, CLIENT_EVENT.VALIDATE_DELETE_TRIGGER, CLIENT_EVENT.VALIDATE_INSERT_TRIGGER, CLIENT_EVENT.VALIDATE_LINE_TRIGGER, CLIENT_EVENT.VALIDATE_FIELD_TRIGGER];
			var workflowTriggers = [CLIENT_EVENT.VALIDATE_FIELD_TRIGGER, CLIENT_EVENT.FIELD_CHANGED_TRIGGER, CLIENT_EVENT.POST_SOURCING_TRIGGER, CLIENT_EVENT.PAGE_INIT_TRIGGER, CLIENT_EVENT.SAVE_RECORD_TRIGGER];

			function doesTriggerCareAboutReturn(trigger)
			{
				return caresAboutReturn.indexOf(trigger) > -1;
			}

			function isWorkflowTrigger(trigger)
			{
				return workflowTriggers.indexOf(trigger) > -1;
			}

			// TODO: should be split into two - internal and client each running its own scope
			function runLegacyScript(script)
			{
				if (!coreRecord.getIsNSERecord())
				{
					var scope = getV1ScopeSingleton();
					return scope(script);
				}
			}

			this.runLegacyScript = runLegacyScript;

			function runWorkflowClientScript(trigger, args)
			{
				var scope = getV1ScopeSingleton();
				var script = "workflow_trigger" + _createArgumentsJSExpression([trigger].concat(args));
				return scope(script);
			}

			function stillLoadingScripts()
			{
				return moduleKeeper.isLoadingModules();
			}

			function loadScriptsForLocalePromise(locale)
			{
				return moduleKeeper.loadModulesWithLocale.promise(locale);
			}

			var runClientScripts = utilityFunctions.thenableFunction(function (trigger, args, errorMessage, options)
			{
				options = options || {};
				var locale = options.locale;
				var callback = util.isFunction(options.callback) ? options.callback : function noop() {};

				if ((trigger !== CLIENT_EVENT.PAGE_INIT_TRIGGER && !internalInitCompleted)
					|| ((trigger === CLIENT_EVENT.LOC_CONTEXT_ENTER || trigger === CLIENT_EVENT.LOC_CONTEXT_EXIT)
						&& (!recordInitialized || locale !== coreRecord.getLocaleContext().getTargetLocale())) // check for locale being actual because of setTimeout below
					)
				{
					callback({executed: false, locale: locale, trigger: trigger});
					return;
				}

				if ((!internalInitCompleted || (trigger === CLIENT_EVENT.LOC_CONTEXT_ENTER || trigger === CLIENT_EVENT.LOC_CONTEXT_EXIT)) && stillLoadingScripts()) {
					if (typeof setTimeout !== "undefined") {
						setTimeout(function() {
							return runClientScripts.thenable(trigger, args, errorMessage, options)
							['catch'](function (e) {
								coreRecord.emitError(e);
								return Promise.reject(e);
							});
						}, 0, trigger, args, errorMessage, options);
					}
					else
						throw new Error("Failed to load record customizations");
					return;
				}

				// at this time we know for sure internal init completed (including script loading) and we are running client scripts
				if (trigger === CLIENT_EVENT.PAGE_INIT_TRIGGER) {
					completeInternalInit();
				}

				return resultObject.create(function ()
				{
					return reallyRunClientScripts.thenable(trigger, args, errorMessage, locale);
				}).then(function ()
				{
				if (trigger === CLIENT_EVENT.PAGE_INIT_TRIGGER) {
					completePageInit();
				}

				if (callback)
					callback({executed: true, trigger: trigger, locale: locale});
				});
			});

			var reallyRunClientScripts = utilityFunctions.thenableFunction(function reallyRunClientScripts(trigger, args, errorMessage, locale)
			{
				var returnMatters = doesTriggerCareAboutReturn(trigger);

				if (workflowScript && util.isString(workflowScript) && isWorkflowTrigger(trigger))
				{
					var scriptResult = runWorkflowClientScript(trigger, args);
					returnMatters && _assertValidation(scriptResult, errorMessage);
				}

				return resultObject.create(function ()
				{
					if (formLevelScript)
					{
						return resultObject.create(function ()
						{
							return runClientScriptWithTracking.thenable(trigger, args, formLevelScript, locale);
						}).then(function (scriptResult)
						{
							returnMatters && _assertValidation(scriptResult, errorMessage);
						});
					}
				}).then(function () {
					if (clientScriptList) {
						return utilityFunctions.forEachThenable(clientScriptList, function (clientScript) {
							return resultObject.create(function () {
								return runClientScriptWithTracking.thenable(trigger, args, clientScript, locale);
							}).then(function (scriptResult) {
								returnMatters && _assertValidation(scriptResult, errorMessage);
							});
						});
					}
				});
			});

			var runClientScriptWithTracking = utilityFunctions.thenableFunction(function runClientScriptWithTracking(trigger, args, theScript, locale)
			{
				clientScriptInvocationDepthCount++;
				return resultObject.create(function ()
				{
					return runClientScript.thenable(trigger, args, theScript, locale);
				})['finally'](function ()
				{
					clientScriptInvocationDepthCount--;
					if (clientScriptInvocationDepthCount < 0)
						utilityFunctions.throwSuiteScriptError(error.Type.FAILED_AN_UNEXPECTED_ERROR_OCCURRED);
				});
			});

			var runClientScript = utilityFunctions.thenableFunction(function runClientScript(trigger, args, theScript, locale)
			{
				var module = moduleKeeper.getModuleObject(theScript);
				var version =  module.script.version || '1.0';
				var realTrigger = (version !== '1.0') && (trigger === CLIENT_EVENT.RECALC_TRIGGER) ? CLIENT_EVENT.SUBLIST_CHANGED_TRIGGER : trigger;
				var runMe = module.getTrigger(realTrigger);
				if (!module.shouldExecuteTrigger(locale, realTrigger) || !runMe)
				{
					return true;
				}

				return coreRecord.trackScript(function ()
				{
					if (trigger === CLIENT_EVENT.LOC_CONTEXT_ENTER)
					{
						module.activate();
					}

					var scriptFn, scriptArgs;
					if (version === '1.0')
					{
						scriptFn = getV1ScopeSingleton();
						scriptArgs = runMe + _createArgumentsJSExpression(args);
					}
					else
					{
						var currentRecord = coreRecord.proxy({scriptId: module.script.scriptId, bundleId: module.script.bundleId});
						scriptFn = runMe;
						scriptArgs = organizeArgs(currentRecord, trigger, args);
					}

					invoker(reflet, 'setupScript', [module.script]);

					var context = {
						record: coreRecord,
						scriptInfo: module.script,
						settleCallback: coreRecord.awaitScript(module.script.scriptId)
					};
					return contextSwitch.execute(context, function ()
					{
						var isValid = scriptFn(scriptArgs);
						if (version !== '1.0' && coreRecord.isNSE)
						{
							if (!utilityFunctions.isThenable(isValid))
							{
								throw new TypeError("require('" + module.script.scriptInfo + "')." + realTrigger + "() must return a promise");
							}
						}
						else
						{
							if (utilityFunctions.isThenable(isValid))
							{
								isValid = !!isValid;
							}
						}
						return isValid;
					});
				}).then(function (isValid)
				{
					if (trigger === CLIENT_EVENT.LOC_CONTEXT_EXIT)
					{
						module.deactivate();
					}
					return isValid;
				})['catch'](function (e)
				{
					var scriptInfo = invoker(reflet, 'getScript');
					util.extend(e, {csError: {trigger: trigger, scriptInfo: scriptInfo}});
					throw e;
				});
			});

			/**
			 * @param {String} trigger CLIENT_EVENT
			 * @param {Array<*>} args
			 * @returns {Object}
			 */
			function organizeArgs(exposedCurrentRecord, trigger, args)
			{
				function getZeroBasedIndex(idx)
				{
					if (isNaN(idx))
					{
						return idx;
					}
					else
					{
						idx = parseInt(idx, 10);
						return (idx < 0) ? idx : idx - 1;
					}
				}

				var returnMe;
				switch (trigger)
				{
					case CLIENT_EVENT.PAGE_INIT_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, mode: args[0]};
						break;

					case CLIENT_EVENT.SAVE_RECORD_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord};
						break;

					case CLIENT_EVENT.LINE_INIT_TRIGGER:
					case CLIENT_EVENT.VALIDATE_DELETE_TRIGGER:
					case CLIENT_EVENT.VALIDATE_INSERT_TRIGGER:
					case CLIENT_EVENT.VALIDATE_LINE_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0]};
						break;

					case CLIENT_EVENT.RECALC_TRIGGER:
						returnMe = {currentRecord: exposedCurrentRecord, sublistId: args[0], operation: args[1]};
						break;

					case CLIENT_EVENT.POST_SOURCING_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2])
						};
						break;

					case CLIENT_EVENT.VALIDATE_FIELD_TRIGGER:
					case CLIENT_EVENT.FIELD_CHANGED_TRIGGER:
						returnMe = {
							currentRecord: exposedCurrentRecord,
							sublistId: args[0],
							fieldId: args[1],
							line: getZeroBasedIndex(args[2]),
							column: getZeroBasedIndex(args[3])
						};
						break;
					case CLIENT_EVENT.LOC_CONTEXT_ENTER:
					case CLIENT_EVENT.LOC_CONTEXT_EXIT:
						returnMe = { currentRecord: exposedCurrentRecord, locale: args[0] };
						break;
					default:
						returnMe = {};
				}
				return returnMe;
			}

			(function initialize()
			{
				if (options.initCallback)
				{
					options.initCallback(that);
				}

				initializeThenable = resultObject.create(function ()
				{
					return callRecordScriptMod.create.thenable({
						context: coreRecord.getSystemId(),
						scope: recordScriptingScope,
						handlerModules: coreRecord.getEventHandlerModules(),
						scriptingContext: coreRecord.getScriptingContext(),
						statefulStoreProvider: function (handler, proxyOptions) {
							return coreRecord.getStatefulStoreProxyProvider(proxyOptions).proxy(handler);
						},
						isNSE: coreRecord.isNSE
					}, isAsyncConstructed);
				}).then(function (runRecordScript)
				{
					callRecordScript = runRecordScript.bind(coreRecord);
					Object.defineProperty(callRecordScript, 'thenable',  {value: runRecordScript.thenable.bind(coreRecord)});
					if (!options.noPageInit)
					{
						return _pageInit.thenable();
					}
					else
					{
						completeInternalInit();
						completePageInit();
					}
				}).then(function ()
				{
					return that;
				});
			})();

			this.ensureInitialized = function ensureInitialized()
			{
				return initializeThenable;
			};
		}

		return {
			create: create,
			isExecutionWithinAClientScript: isExecutionWithinAClientScript
		};
	}
);

/**
 * SuiteScript saveResult module
 *
 * @private
 * @module N/saveResult
 * @NApiVersion 2.x
 *
 */
define('N/saveResult',['N/notification','N/utilityFunctions'],
	function (notification, utilityFunctions)
	{

		var SEVERITY = Object.freeze({
			CONFIRMATION: notification.create(notification.Type.CONFIRMATION),
			INFORMATION: notification.create(notification.Type.INFORMATION),
			WARNING: notification.create(notification.Type.WARNING),
			ERROR: notification.create(notification.Type.ERROR)
		});

		/**
		 * @protected
		 * @constructor
		 */
		function SaveResult(options, result)
		{
			var that = this;

			Object.defineProperty(this, 'recordData', {
				get: function ()
				{
					return new RecordData(result['recordData']);
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'notifications', {
				get: function ()
				{
					return createArrayMessages(result.notifications);
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'proxy', {value: function () { return that; }});
		}

		function createArrayMessages(array)
		{
			var result = new Array();
			for(var i = 0; i < array.length; i++)
			{
				var oldMsg = array[i];
				result.push(new SaveMessage(oldMsg, isExpandedErrorMessage(oldMsg)));
			}
			return result;
		}

		/* Determines if the expanded message with stack trace and args should be rendered */
		function isExpandedErrorMessage(oldMsg)
		{
			return !utilityFunctions.isEmpty(oldMsg['errorStack']);
		}

		/**
		 * @protected
		 * @constructor
		 */
		function RecordData(recordData)
		{
			var that = this;

			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return recordData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'label', {
				get: function ()
				{
					return recordData.label;
				},
				enumerable: true,
				configurable: false
			});

			if (recordData.redirectUrl != null) {
				Object.defineProperty(this, 'redirectUrl', {
					get: function ()
					{
						return recordData.redirectUrl;
					},
					enumerable: true,
					configurable: false
				});
			}

			Object.defineProperty(this, 'proxy', {value: function () { return that; }});
		}

		/**
		 * @protected
		 * @constructor
		 */
		function SaveMessage(saveMessage, error)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return saveMessage.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'title', {
				get: function ()
				{
					return saveMessage.title;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'message', {
				get: function ()
				{
					return saveMessage.message;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'severity', {
				get: function ()
				{
					switch(saveMessage.type)
					{
						case notification.Type.INFORMATION:
							return SEVERITY.INFORMATION;
							break;
						case notification.Type.WARNING:
							return SEVERITY.WARNING;
							break;
						case notification.Type.ERROR:
							return SEVERITY.ERROR;
							break;

						default:
							return SEVERITY.CONFIRMATION;
							break;
					}
				},
				enumerable: true,
				configurable: false
			});

			if(error)
			{
				Object.defineProperty(this, 'name', {
					get: function ()
					{
						return saveMessage.name;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'errorStack', {
					get: function ()
					{
						return saveMessage.errorStack;
					},
					enumerable: true,
					configurable: false
				});

				Object.defineProperty(this, 'scriptMetadata', {
					get: function ()
					{
						return new ScriptMetadata(saveMessage.scriptMetadata);
					},
					enumerable: true,
					configurable: false
				});
			}
		}

		/**
		 * @protected
		 * @constructor
		 */
		function ScriptMetadata(scriptData)
		{
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return scriptData.id;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'type', {
				get: function ()
				{
					return scriptData.type;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function ()
				{
					return scriptData.internalId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'deployment', {
				get: function ()
				{
					return new Deployment(scriptData);
				},
				enumerable: true,
				configurable: false
			});

		}

		/**
		 * @protected
		 * @constructor
		 */
		function Deployment(scriptData) {
			Object.defineProperty(this, 'id', {
				get: function () {
					return scriptData.deploymentId;
				},
				enumerable: true,
				configurable: false
			});

			Object.defineProperty(this, 'internalId', {
				get: function () {
					return scriptData.deploymentInternalId;
				},
				enumerable: true,
				configurable: false
			});
		}


		return Object.freeze({
			create: function (options, results)
			{
				return Object.freeze(new SaveResult(options, results));
			}
		});

	});
/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript record definition common module
 *
 * @private
 * @module N/common/record/recordDefinition
 * @suiteScriptVersion 2.x
 *
 */
define(
	'N/common/record/recordDefinition',['N/record/clientRecordDefinitionBase',
	 'N/restricted/recordApi', 'N/restricted/remoteApiBridge', 'N/internal/invoker', 'N/record/recordConstants', 'N/utilityFunctions','N/error',
	 'N/field', 'N/record/metadata', 'N/record/recordStateController','N/record/recordField','N/record/matrix', 'N/record/sublist',
	 'N/common/record/line/lineDefinition',
	 'N/record/relatedRecord',
	 'N/util', 'N/util/formatter', 'N/util/slaving', 'N/totaling',
	 'N/record/modelController', 'N/record/recordUtilityFunctions', 'N/record/recordImplementation',
	 'N/record/subrecordUtilityFunctions', 'N/record/recordScriptingScope',
	 'N/common/record/recordDefinitionEvent', 'N/eventEmitter',
	 'N/common/record/recordActualWork', 'N/saveResult', 'N/fieldTypeConstants', 'N/contextSwitch', 'N/resultObject',
	 'N/recordMessage', 'N/internal/reflet', 'N/idConverterService'],
	function (clientRecordDefinitionBase,
			  apiBridge, remoteApi, invoker, constants, utilityFunctions, error,
			  field, metadata, recordStateController, recordfield, matrix, sublist,
			  lineDefinition,
			  relatedRecord,
			  util, formatter, slaving, totaling,
			  modelController, recordUtil, recordImplementation,
			  subrecordUtil, scope,
			  recordDefinitionEvent, eventEmitter,
			  recordBehaviorDelegateService, saveResult, fieldTypeConstants, contextSwitch, resultObject,
			  recordMessage, reflet, idConverterService
			  )
	{
		var undef = undefined;

		/** @typedef {ReadOnlyRecord|DeferredDynamicRecord|DynamicRecord} ProxyRecord */
		/** @typedef {ProxyRecord} Record */
		/** @typedef {ReadOnlySubrecord|DeferredDynamicSubrecord|DynamicSubrecord} ProxySubrecord */
		/** @typedef {ProxySubrecord|RawRecord} Subrecord */

		/**
		 * @typedef {Object} RecordConfig
		 * ------------ POPULATED IN RECORD TRANSFORMER ------------
		 * @property {boolean} isDynamic true if the record instance is a dynamic record
		 * @property {boolean} isReadOnly true if the record instance is read only instance
		 * @property {boolean} isSubrecord true if the record instance is a subrecord
		 * @property {boolean} isClientRecord TODO unused in JS
		 * @property {boolean} isNSE true if the record instance is NSE/NSX record TODO currently always false
		 * ------------ POPULATED ELSEWHERE (currentRecordBootstrap, domCurrentRecord, clone) ------------
		 * @property {boolean} [isCurrentRecord]
		 * @property {boolean} [isInteractive]
		 * @property {boolean} [noPageInit]
		 *
		 * @see RecordSerializationKey.java
		 */

		/**
		 * @typedef {Object} RecordPayload
		 * ------------ POPULATED IN RECORD TRANSFORMER ------------
		 * @property {number} id
		 * @property {RecordConfig} config (mostly record control flags)
		 * @property {Object} recordContext
		 * @property {Object} scriptingContext
		 * @property {Object} eventHandlerModules
		 * @property {{superScript:ScriptReferenceMetadata, formLevelScriptLibs:string[]}|null} [formLevelScriptMetadata]
		 * @property {string} [formLevelScriptPayload] - form script content
		 * @property {{superScriptList:ScriptReferenceMetadata, clientScriptLibs:string[]}} [clientScriptMetadata]
		 * @property {Object<string, string>} [clientScriptPayload] - scriptId:scriptContent
		 * @property {{macroMetadata: MacroMetadata[]}} macro
		 * @property {RecordMetadataObject} metadata (record metadata data used to populate the model controller)
		 * @property {RecordDataObject} data (record data used to populate the model)
		 * @property {string} recordUsage record mode (VIEW, CREATE, EDIT, TRANSFORM, COPY)
		 * --------- TAKEN FROM CHECKPOINT DURING RECORD CLONE ----------
		 * @property {RecordStateController} [state] (record state to use to pre-populate the model controller)
		 *
		 * @see RecordSerializationKey.java
		 */

		/**
		 * @typedef {{
		 * id: string,
		 * package: string,
		 * label: string,
		 * description: string,
		 * runtimeVersion: string,
		 * modulePath: string,
		 * attributes: object}} MacroMetadata
		 */

		/**
		 * @typedef {{
		 * version: string,
		 * scriptId: string,
		 * scriptInfo: string,
		 * parentModulePath: string?,
		 * isLibraryModule: boolean,
		 * locale: string?,
		 * excludeFromClientScriptExecution: boolean,
		 * amdConfig: string?,
		 * mediaHashCode: string?,
		 * timestamp: string?}} ScriptReferenceMetadata
		 */

		/**
		 * Primary object used to encapsulate a record object.
		 *
		 * @protected
		 * @alias RawRecord
		 *
		 * @param {Object} options
		 * @param {RecordPayload} options.recordObj (server-generated object holding the full metadata and data for a record type,
		 *                                           including all scripting and customization)
		 * @param {Object} options.parentLink
		 * @param {boolean} isAsyncConstructed
		 * @returns {RawRecord} client-side record implementation
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function Record(options, isAsyncConstructed)
		{
			var recordObj = util.extend({}, options.recordObj);

			var compressEvents = getInitializationParam(recordObj, 'compressEvents') !== false;

			var emitter = eventEmitter.create({
				eventTypes: Object.keys(recordDefinitionEvent.Type).map(function (v) { return recordDefinitionEvent.Type[v]; }),
				async: typeof setTimeout === 'function',
				insulated: true,
				preProcessor: compressEvents ? recordDefinitionEvent.eventCompress : recordDefinitionEvent.eventNoCompress
			});
			this.forwardModelControllerEvent = recordDefinitionEvent.forwardModelControllerEvent.bind(this, emitter);
			this.forwardRecordStateEvent = recordDefinitionEvent.forwardRecordStateEvent.bind(this, emitter);
			this.forwardMetadataEvent = recordDefinitionEvent.forwardMetadataEvent.bind(this, emitter);
			this.forwardRecordFieldEvent = recordDefinitionEvent.forwardRecordFieldEvent.bind(this, emitter);

			/** @type {DynamicRecordImpl|DeferredDynamicRecordImpl} */
			var implementation;
			var recordBehaviorDelegate = recordBehaviorDelegateService.create({delegate: this});

			var that = this;
			var initializeThenable;

			/** @type {Metadata} */
			var _metadata;
			/** @type {ModelController} */
			var _modelController;
			/** @type {RecordStateController} */
			var _state;
			var _recordRequestContext, _recordScriptingV1Scope, _formMetadata, _scriptingContext;
			var checkpoint;
			var isInited = false; // should be true once internal page init is complete
			var forceSyncSourcingFields = {};

			var parentLink = options.parentLink;
			var subrecord_isCommitted = false;

			var SUBRECORD_KEY_FIELDID_REGEX = /^(parent\.){1}\w+$/;

			var lineCache = {};

			var _statefulStores;

			function wrapMethod(method)
			{
				return recordDefinitionEvent.wrapEmitError({
					record: that,
					func: method,
					emitter: emitter
				});
			}

			var recordOptions = util.extend({id: recordObj.id, type: recordObj.metadata.type}, recordObj.config);

			clientRecordDefinitionBase.call(this, {
				recordOptions: recordOptions,
				defaultLocale: util.isString(recordObj.metadata.defaultLocale) ? JSON.parse(recordObj.metadata.defaultLocale) : recordObj.metadata.defaultLocale,
				dynamicData:  util.isString(recordObj.metadata.dynamicData) ? JSON.parse(recordObj.metadata.dynamicData) : recordObj.metadata.dynamicData,
				methodWrapper: wrapMethod
			}, isAsyncConstructed);

			/**
			 * Get record initialization parameter value
			 * @param {RecordPayload} recordObj
			 * @param {string} paramName
			 */
			function getInitializationParam(recordObj, paramName)
			{
				return recordObj && recordObj.config && recordObj.config.initialization && recordObj.config.initialization.params && recordObj.config.initialization.params[paramName];
			}

			function getLineObjectFromCache(sublistId, lineInstanceId, isCommitted)
			{
				var obj = lineCache;
				if (!obj[sublistId])
				{
					obj[sublistId] = {};
				}
				obj = obj[sublistId];

				if (!obj[lineInstanceId])
				{
					obj[lineInstanceId] = {};
				}
				obj = obj[lineInstanceId];

				if (!obj[isCommitted])
				{
					obj[isCommitted] = constructLineObject(sublistId, lineInstanceId, isCommitted);
				}
				obj = obj[isCommitted];

				return obj;
			}
			this.getLineObjectFromCache = getLineObjectFromCache;

			function getExistingLineObjectFromCache(sublistId, lineInstanceId) {
				var BUFFER_KEY = false, COMMITTED_KEY = true;
				var hasBufferLine = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, BUFFER_KEY);
				var hasCommittedLine = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, COMMITTED_KEY);
				// obj can have these keys: true (committed) or false (buffer)
				// creates three possible situations: (a) true & false both exist, (b) true exists, (c) false exists
				// a/c - if a buffer version exisits it should TRY to return it, depending on the sublist multiline editable status
				//       If the sublistId is multiline editable then ALWAYS return it.
				//       If the sublistId is NOT, then only return it if it's also the current line. Otherwise return the committed.
				//   b - there is only the committed version, so return that. No-one has tried to edit the existing line.

				var returnMe, lineState;

				if (hasBufferLine && (isMultilineEditable(sublistId) || doGetCurrentSublistLineInstanceId(sublistId) === lineInstanceId))
				{
					returnMe = getLineObjectFromCache(sublistId, lineInstanceId, BUFFER_KEY);
					lineState = hasCommittedLine ? "EDITED" : "NEW";
				}
				else if (hasCommittedLine)
				{
					returnMe = getLineObjectFromCache(sublistId, lineInstanceId, COMMITTED_KEY);
					lineState = "COMMITTED";
				}
				return {line: returnMe, state: lineState};
			}

			function removeLineObjectFromCache(sublistId, lineInstanceId)
			{
				if (!!sublistId)
				{
					if (!!lineInstanceId)
					{
						if (lineCache && lineCache[sublistId])
						{
							delete lineCache[sublistId][lineInstanceId];
						}
					}
					else
					{
						delete lineCache[sublistId];
					}
				}
				else
				{
					lineCache = {};
				}
			}

			function getSublistLineInstanceIds(sublistId, isCommitted)
			{
				return getModelController().getSublistLineInstanceIds(sublistId, isCommitted);
			}

			this.getSublistLineInstanceIds = getSublistLineInstanceIds;

			//TODO: consider moving to metadata on a per-record basis.
			var RECORD_SPECIFIC_SAVE_OPTIONS = {'timesheet': ['savesubmit']};

			function getRecordStateController() { return _state; }

			this.getRecordStateController = getRecordStateController;

			function setRecordStateController(state)
			{
				if (_state)
				{
					recordDefinitionEvent.forwardRecordStateEvents(that, true);
				}
				_state = state;
				recordDefinitionEvent.forwardRecordStateEvents(that);
			}

			this.setRecordStateController = setRecordStateController;

			function getMetadata() { return _metadata; }

			this.getMetadata = getMetadata;

			function setMetadata(metadata)
			{
				if (_metadata)
				{
					recordDefinitionEvent.forwardMetadataEvents(that, true);
				}
				_metadata = metadata;
				recordDefinitionEvent.forwardMetadataEvents(that);
			}

			function getFormMetadata() {
				return _formMetadata;
			}

			this.getFormMetadata = getFormMetadata;

			function setFormMetadata(formMetadata) {
				_formMetadata = formMetadata;
			}

			function getModelController() { return _modelController; }

			this.getModelController = getModelController;

			function setModelController(modelController)
			{
				if (_modelController)
				{
					recordDefinitionEvent.forwardModelControllerEvents({
						record: that,
						remove: true
					});
				}
				_modelController = modelController;
				recordDefinitionEvent.forwardModelControllerEvents({
					record: that
				});
			}

			this.setModelController = setModelController;

			function getCurrentRecordDelegate()
			{
				/** @typedef {Object} SlavingRecordDelegate */
				return {
					currentRecord: that,
					util: {
						isEditableSublist: isSublistAnEditMachine,
						isFieldMultiSelect: isFieldMultiSelect,
						setFieldNoSlaving: function setFieldNoSlaving(sublistId, fieldId, lineInstanceId, noSlaving)
						{
							var fieldState = !!sublistId ? getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, false) : getFieldState(fieldId);
							fieldState.ignoreSlaving = noSlaving;
						},
						getFieldOptions: getSelectOptionCache,
						cacheOptionText: function cacheOptionText(sublistId, fieldId, value, text) { getModelController().cacheSelectOptionText(sublistId, fieldId, value, text); },
						isMultilineEditable: isMultilineEditable,
						setFavorites: function (sublistId, fieldId, favorites) {
							//TODO: implement me for NEW UI (e.g. emit some UI event containing the favorites
						},
					}
				};
			}

			//TODO remove
			function getHack()
			{
				return that;
			}

			this.getHack = getHack;

			this.isInteractive = true;

			utilityFunctions.addReadOnlyProperty(this, 'formMetadata', getFormMetadata);

			/**
			 * Query of the record
			 * @name RawRecord#query
			 * @type {string}
			 * @readonly
			 * @throws READ_ONLY when setting the property is attempted
			 */
			utilityFunctions.addReadOnlyProperty(this, 'query', getQuery);

			function getRecordRequestContext() { return _recordRequestContext; }

			this.getRecordRequestContext = getRecordRequestContext;

			function setRecordRequestContext(recordRequestContext) { _recordRequestContext = recordRequestContext; }

			function getRecordScriptingScope() { return _recordScriptingV1Scope; }

			function setRecordScriptingScope(scope) { _recordScriptingV1Scope = scope; }

			this.getRecordScriptingScope = getRecordScriptingScope;

			function emitError(e)
			{
				emitter.emit({type: recordDefinitionEvent.Type.ERROR, record: that, error: e});
			}

			this.emitError = emitError;

			function getId() { return that.id; }

			this.getId = getId;

			function getRecordType() { return that.type; }

			this.getRecordType = getRecordType;

			function getIsSubrecord() { return that.isSubrecord; }

			this.getIsSubrecord = getIsSubrecord;

			function getIsReadOnlyRecord(proxyOptions) { return that.isReadOnly || (proxyOptions || that).isReadOnly; }

			this.getIsReadOnlyRecord = getIsReadOnlyRecord;

			function getIsDynamicRecord() { return that.isDynamic; }

			this.getIsDynamicRecord = getIsDynamicRecord;

			function getIsCurrentRecord() { return that.isCurrentRecord; }

			this.getIsCurrentRecord = getIsCurrentRecord;

			function getIsInteractive(proxyOptions) { return (proxyOptions || that).isInteractive; }

			this.getIsInteractive = getIsInteractive;

			function getIsAsync(proxyOptions) { return (proxyOptions || that).isAsync; }

			this.getIsAsync = getIsAsync;

			function getIsNSERecord() { return that.isNSE; }

			this.getIsNSERecord = getIsNSERecord;

			function getRecordUsage() { return recordObj.recordUsage; }

			this.getRecordUsage = getRecordUsage;

			function isNewRecord() { return that.isNew; }

			this.isNewRecord = isNewRecord;

			function setIsInited() { isInited = true; }

			function getIsInited() { return isInited; }

			this.getIsInited = getIsInited;

			function shouldValidateFieldPermissions()
			{
				return implementation.shouldValidateFieldPermissions();
			}

			this.shouldValidateFieldPermissions = shouldValidateFieldPermissions;

			function isInternal(proxyOptions)
			{
				var scriptId = (proxyOptions || that).scriptId;
				return scriptId == null || scriptId === 'internal';
			}

			this.isInternal = isInternal;

			function getIsChanged()
			{
				return _state.isChanged;
			}
			this.getIsChanged = getIsChanged;

			function clearIsChanged()
			{
				_state.getAllFields().forEach(function (fieldId)
				{
					_state.getFieldState(fieldId).isChanged = false;
				});
				_state.getAllSublists().forEach(function (sublistId)
				{
					var sublistState = _state.getSublistState(sublistId);
					var isCommitted = true;
					sublistState.getLineInstanceIds(isCommitted).forEach(function (lineInstanceId)
					{
						sublistState.getAllLineFieldsForInstance(lineInstanceId, isCommitted).forEach(function (fieldId)
						{
							sublistState.getFieldStateForInstance(fieldId, lineInstanceId, isCommitted).isChanged = false;
						});
					});
					sublistState.isChanged = false;
				});
				_state.isChanged = false;
			}

			function getLineInstanceId(sublistId, line)
			{
				return implementation.getLineInstanceId(sublistId, line);
			}
			this.getLineInstanceId = getLineInstanceId;

			function getMissingArgumentErrorMessageFillerValue(methodName)
			{
				return 'Record' + '.' + methodName;
			}

			this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

			function isWithinValidLineRange(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < doGetAllLineCount(sublistId);
			}

			function isWithinValidLineRangeForFieldOnly(sublistId, line)
			{
				var lineNumberIndex = parseInt(line, 10);
				return 0 <= lineNumberIndex && lineNumberIndex < (doGetAllLineCount(sublistId) + (isMultilineEditable(sublistId) ? 0 : 1));

			}

			function validateTextApi(isTextApi, fieldState, methodName, suggestedMethod)
			{
				implementation.validateTextApi(isTextApi, fieldState, methodName, suggestedMethod);
			}

			this.validateTextApi = validateTextApi;

			function isMultilineEditable(sublistId)
			{
				return !!sublistId ? (doGetSublist(sublistId) || {}).isMultilineEditable : false;
			}
			this.isMultilineEditable = isMultilineEditable;

			function validateLineIndex(lineNumberIndex, sublistId, allowNewLineForOldWay)
			{
				var isMLB = isMultilineEditable(sublistId);
				var upperBoundExclusive = doGetAllLineCount(sublistId) + ((!!allowNewLineForOldWay && !isMLB) ? 1 : 0);
				if (isMLB && lineNumberIndex === 0 && upperBoundExclusive === 0)
					warnAboutMLBCurrentIndexProblem("ValidateLineIndex failure on all 0s.\nLikely sign that a selectNewLine should be called instead!\nProbably assuming a new line + selectLine on line 0.");

				implementation.validateLineIndex(lineNumberIndex, 0, upperBoundExclusive);
			}
			this.validateLineIndex = validateLineIndex;

			function validateLineInstanceId(sublistId, lineInstanceId, isCommitted, allowFallback)
			{
				var lineInstanceExists = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, isCommitted);
				if (!lineInstanceExists && allowFallback) {
					lineInstanceExists = getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, !isCommitted);
				}
				recordUtil.assertValidSublistOperation(lineInstanceExists);
			}

			function getNoCopyToDefaultMapForSublist(sublistId)
			{
				var sublistMetadata = getSublistMetadata(sublistId);
				var noCopyToDefaultMap = {};
				if (!!sublistMetadata)
				{
					var noCopyList = sublistMetadata.noCopyFields || [];
					noCopyList.forEach(function (fieldId) { noCopyToDefaultMap[fieldId] = sublistMetadata.defaultValue[fieldId];});
				}
				return noCopyToDefaultMap;
			}

			function getSublistMetadata(sublistId)
			{
				return _metadata.getSublistMetadata(sublistId);
			}

			this.getSublistMetadata = getSublistMetadata;

			function getSublistType(sublistId)
			{
				return _metadata.getSublistType(sublistId);
			}

			this.getSublistType = getSublistType;

			function isSublistAnEditMachine(sublistId)
			{
				return getSublistType(sublistId) === 'edit';
			}

			this.isSublistAnEditMachine = isSublistAnEditMachine;

			function isSublistEditable(sublistId)
			{
				return getSublistMetadata(sublistId) && getSublistMetadata(sublistId).isEditable;
			}

			this.isSublistEditable = isSublistEditable;

			function isAllowedToMoveLines(sublistId)
			{
				return getSublistMetadata(sublistId) && getSublistMetadata(sublistId).isAllowedToMoveLines;
			}
			this.isAllowedToMoveLines = isAllowedToMoveLines;

			function isSublistAListMachine(sublistId)
			{
				return getSublistType(sublistId) === 'list';
			}

			this.isSublistAListMachine = isSublistAListMachine;

			// TODO should be refactored out and utilize recordBehaviorDelegate
			function isValidField(sublistId, fieldId)
			{
				var isValid = false;
				if (!!sublistId)
				{
					isValid = isValidSublistField(sublistId, fieldId);
				}
				else
				{
					isValid = isValidBodyField(fieldId);
				}
				return isValid;
			}

			this.isValidField = isValidField;

			function isValidBodyField(fieldId)
			{
				return _metadata.isValidField(fieldId);
			}

			this.isValidBodyField = isValidBodyField;

			function isValidSublistField(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			this.isValidSublistField = isValidSublistField;

			function getSublistState(sublistId)
			{
				return getRecordStateController().getSublistState(sublistId);
			}

			this.getSublistState = getSublistState;

			function getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var sublistState = getSublistState(sublistId);

				if (sublistState)
				{
					var shouleBeModelInvalidated = sublistState.willCallOfGetFieldStateForInstanceCauseUpdateOfBuffer(lineInstanceId, isCommitted);
					var fieldState = sublistState.getFieldStateForInstance(fieldId, lineInstanceId, isCommitted);
					if (shouleBeModelInvalidated)
					{
						getModelController().invalidateSublistRecordCacheForInstance(sublistId, lineInstanceId);
					}

					return fieldState;
				}

				return null;
			}

			this.getSublistFieldStateForInstance = getSublistFieldStateForInstance;

			function setSublistIsChanged(sublistId, value)
			{
				getSublistState(sublistId).isChanged = value;
				return that;
			}

			function getFieldState(fieldId)
			{
				return _state.getFieldState(fieldId);
			}

			this.getFieldState = getFieldState;

			function hasFieldValueOrFieldExisted(fieldId)
			{
				return getModelController().hasFieldValue(fieldId) || _metadata.isValidField(fieldId);
			}

			function hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				return isSublistFieldExisted(sublistId, fieldId) ||
					getModelController().hasSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			function isSublistFieldExisted(sublistId, fieldId)
			{
				return _metadata.isValidSublistField(sublistId, fieldId);
			}

			function isSublistValid(sublistId)
			{
				return _metadata.isValidSublist(sublistId);
			}

			this.isSublistValid = isSublistValid;

			function getFieldLevelMetadataForBodyField(fieldId)
			{
				return _metadata.getFieldMetadata(undef, fieldId);
			}

			this.getFieldLevelMetadataForBodyField = getFieldLevelMetadataForBodyField;

			function getFieldLevelMetadataForSublistField(sublistId, fieldId)
			{
				return _metadata.getFieldMetadata(sublistId, fieldId);
			}

			this.getFieldLevelMetadataForSublistField = getFieldLevelMetadataForSublistField;

			function extractInforFromFieldLevelMetadata(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return {
					fieldId: fieldId,
					sublistId: sublistId,
					radioSet: !!fieldLevelMetadata ? fieldLevelMetadata.radioSet : undef,
					hasBlankString: !!fieldLevelMetadata ? fieldLevelMetadata.hasBlankString : undef,
					blankString: !!fieldLevelMetadata ? fieldLevelMetadata.blankString : undef,
					supplementedOptions: !!fieldLevelMetadata ? fieldLevelMetadata.supplementedOptions : undef
				};
			}

			this.extractInforFromFieldLevelMetadata = extractInforFromFieldLevelMetadata;

			function getFieldType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.type : null;
			}

			function isFieldNumeric(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isNumeric : null;
			}

			function isFieldCurrency(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata ? fieldLevelMetadata.isCurrency : null;
			}

			function isFieldTime(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === fieldTypeConstants.Type.TIME;
			}

			this.isFieldTime = isFieldTime;

			function isFieldTimeTrack(sublistId, fieldId)
			{
				return getFieldType(sublistId, fieldId) === fieldTypeConstants.Type.TIMETRACK;
			}

			this.isFieldTime = isFieldTimeTrack;

			function isFieldMultiSelect(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.MULTISELECT;
			}
			this.isFieldMultiSelect = isFieldMultiSelect;

			function isFieldSelectType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldTypeConstants.isSelectType(fieldLevelMetadata.type);
			}

			this.isFieldSelectType = isFieldSelectType;

			function isFieldCheckbox(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.CHECKBOX;
			}

			this.isFieldCheckbox = isFieldCheckbox;

			function isFieldRadio(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.RADIO;
			}

			this.isFieldRadio = isFieldRadio;

			function isFieldRateType(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldTypeConstants.isRateType(fieldLevelMetadata.type);
			}

			this.isFieldRateType = isFieldRateType;

			function isFieldSubrecordField(sublistId, fieldId)
			{
				var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE;
			}

			function getSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.slavingMetadata : null;
			}

			this.getSlavingMetadata = getSlavingMetadata;

			function getClientSlavingMetadata(sublistId, fieldId)
			{
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);
				return metadata ? metadata.clientSlavingMetadata : null;
			}

			this.getClientSlavingMetadata = getClientSlavingMetadata;

			function withForceSyncSourcing(sublistId, fieldId, forceSyncSourcing, callback)
			{
				if (sublistId == null) sublistId = '';
				if (forceSyncSourcingFields[sublistId] == null) forceSyncSourcingFields[sublistId] = {};
				if (forceSyncSourcingFields[sublistId][fieldId] == null) forceSyncSourcingFields[sublistId][fieldId] = 0;

				if (forceSyncSourcing)
				{
					forceSyncSourcingFields[sublistId][fieldId]++;
				}
				return resultObject.create(function ()
				{
					return callback();
				})['finally'](function ()
				{
					if (forceSyncSourcing)
					{
						forceSyncSourcingFields[sublistId][fieldId]--;
					}
				});
			}

			this.withForceSyncSourcing = withForceSyncSourcing;

			function isSyncSourcingForced(sublistId, fieldId)
			{
				if (sublistId == null) sublistId = '';
				return !!(forceSyncSourcingFields[sublistId] && forceSyncSourcingFields[sublistId][fieldId]);
			}

			this.isSyncSourcingForced = isSyncSourcingForced;

			function getMacroMetadata()
			{
				return typeof recordObj.macro !== 'undefined' && recordObj.macro.macroMetadata || [];
			}
			this.getMacroMetadata = getMacroMetadata;

			function setScriptingContext(scriptingContext) {
				_scriptingContext = scriptingContext;
			}

			function getScriptingContext() {
				return _scriptingContext || {};
			}

			/*
			 * provide scripting context for records
			 * getScriptContext is only in recordDefinition.js and not in dynamicrecord.js.So it is only visible inside NetSuite.
			 */
			this.getScriptingContext = getScriptingContext;

			function getEventHandlerModules() {
				return recordObj.eventHandlerModules || [];
			}

			/*
			 * provide scripting context for records
			 */
			this.getEventHandlerModules = getEventHandlerModules;

			var removeField = utilityFunctions.thenableFunction(function removeField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeField'));
				doRemoveField(idConverterService.convertBodyFieldId(that, fieldId));
				return that;
			});

			/**
			 * remove body field data
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 */
			this.removeField = wrapMethod(removeField);

			function doRemoveField(fieldId)
			{
				if (hasFieldValueOrFieldExisted(fieldId))
				{
					getModelController().removeFieldValue(fieldId);
					_state.removeFieldState(fieldId);
					subrecord_updateFieldState(true);
				}
			}

			this.doRemoveField = doRemoveField;

			function getFields()
			{
				var allFields = {};
				var bodyfields = getModelController().getBodyFieldIds();
				if (util.isArray(bodyfields))
				{
					bodyfields.forEach(function (fieldId) { allFields[fieldId] = true; });
				}

				var fieldNames = _metadata.fieldIds;

				if (util.isArray(fieldNames))
                {
                	if (getIsNSERecord())
                	{
		                fieldNames.forEach(function (fieldId) { allFields[fieldId] = true; });
	                }
                	else
                	{
		                fieldNames.forEach(function (fieldId)
		                {
			                if (isFieldSubrecordField(undef, fieldId))
			                {
				                delete allFields[fieldId];
			                }
			                else
			                {
				                allFields[fieldId] = true;
			                }
		                });
	                }
                }

				var uniqueFieldIds = [];
				recordUtil.forEachProperty(allFields, function (fieldId) { uniqueFieldIds[uniqueFieldIds.length] = fieldId; });
				return uniqueFieldIds;
			}

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @governance none
			 * @return {Array<string>}
			 *
			 * @since 2015.2
			 */
			this.getFields = getFields;

			function getSublists()
			{
				return _metadata.sublistIds;
			}

			/**
			 * return array of names of all sublists
			 * @governance none
			 * @return {Array<string>}
			 *
			 * @since 2015.2
			 */
			this.getSublists = getSublists;

			function getValue(options)
			{
				return recordBehaviorDelegate.getValue(options);
			}

			/**
			 * Returns the value of a field. Gets a numeric value for rate and ratehighprecision fields.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setText
			 *
			 * @since 2015.2
			 */
			this.getValue = getValue;

			function getParsedValueForBodyField(fieldId, delegator)
			{
				return implementation.getParsedValueForBodyField(fieldId, delegator);
			}

			this.getParsedValueForBodyField = getParsedValueForBodyField;

			function getParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var returnValue = doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var fs = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				var fieldLevelMetadata = getFieldLevelMetadataForSublistField(sublistId, fieldId);
				var isCheckbox = fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.CHECKBOX;

				if ((fs && !fs.isParsed) || (isCheckbox && returnValue === ''))
				{
					var parsedValue = recordUtil.parseValue(isValidSublistField(sublistId, fieldId), fieldLevelMetadata, returnValue);
					getModelController()
						.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, parsedValue, isCommitted);
					fs.isParsed = true;

					returnValue = parsedValue;
				}
				return returnValue;
			}

			function doGetValue(fieldId)
			{
				var hasFieldExisted = hasFieldValueOrFieldExisted(fieldId);

				if (getIsNSERecord() && !hasFieldExisted && (typeof console !== 'undefined' && console.warn)) {
					console.warn("getValue for field '" + fieldId + "' failed. Field does not exist.");
				}

				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(undef, fieldId)
				};

				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(
					getModelController().getFieldValue(fieldId), //get value of previously set value or default NSN=undefined/NSX=null
					metadata,
					getIsNSERecord()
				);
			}

			this.doGetValue = doGetValue;

			function setParsedValueAndUpdateFieldState(fieldId, value, fieldState)
			{
				getModelController().setParsedValueForBodyField(fieldId, value);
				fieldState.isParsed = true;
			}

			this.setParsedValueAndUpdateFieldState = setParsedValueAndUpdateFieldState;

			function setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted)
			{
				getModelController()
					.setParsedValueForSublistFieldForInstance(sublistId, lineInstanceId, fieldId, value, isCommitted);
			}

			this.setParsedValueForSublistFieldForInstance = setParsedValueForSublistFieldForInstance;

			var setValue = utilityFunctions.thenableFunction(function setValue(options, value, proxyOptions, isAsync)
			{
				var fieldId, fireFieldChange = true, noSlaving = false, forceSyncSourcing = false, fireSlavingSync = false;
				if (value !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setValue'));
				utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setValue'));
				fieldId = idConverterService.convertBodyFieldId(that, fieldId);
				recordUtil.validateAgainstSqlInjection(fieldId, value);

				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				return withForceSyncSourcing(undefined, fieldId, forceSyncSourcing, function ()
				{
					return doSetValue.thenable(fieldId, value, fireFieldChange, noSlaving, getIsInteractive(proxyOptions), undefined, undefined, isAsync);
				}).then(function ()
				{
					return that;
				});
			}, {
				proxyOptionsArgIndex: 2,
				isAsyncArgIndex: 3
			});

			/**
			 * set value of the field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @param {number|Date|string|Array|boolean} options.value The value to set the field to.
			 * @param {boolean} [options.ignoreFieldChange=false] Ignore the field change script
			 * @param {boolean} [options.forceSyncSourcing=false] force synchronous sourcing
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.setValue = wrapMethod(setValue);

			var doSetValue = utilityFunctions.thenableFunction(function doSetValue(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting, isAsync)
			{
				return resultObject.create(function ()
				{
					return implementation.doSetValue.thenable(fieldId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting, isAsync);
				}).then(function ()
				{
					getFieldState(fieldId).useTextApi = false;
				});
			}, {
				isAsyncArgIndex: 7
			});

			this.doSetValue = doSetValue;

			var validateAndFormatFieldValueForInstance = utilityFunctions.thenableFunction(function validateAndFormatFieldValueForInstance(sublistId, fieldId, lineInstanceId, value, isInteractive, allowPercentage, isAsync)
			{
				return implementation.validateAndFormatFieldValueForInstance.thenable(sublistId, fieldId, lineInstanceId, value, isInteractive, allowPercentage, isAsync);
			}, {
				isAsyncArgIndex: 6
			});

			this.validateAndFormatFieldValueForInstance = validateAndFormatFieldValueForInstance;

			var doSetFieldValue = utilityFunctions.thenableFunction(function doSetFieldValue(fieldId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation, isAsync)
			{
				var preSetObject = constructPreSetObject(undef, fieldId, getValueObjectForValidation(fieldId, value),
					fireFieldChange, noSlaving, noValidation);
				return recordBehaviorDelegateService.preDoSetValueForInstance.thenable(that, preSetObject, undef, undef, isAsync).then(function() {
					internalSetFieldValue(fieldId, value, valueIsFormattedAsString);
					var postSetObject = constructPostSetObject(undef, fieldId, getValueAsLegacyString(fieldId),
						fireFieldChange, noSlaving, noValidation);
					return recordBehaviorDelegateService.postDoSetValueForInstance.thenable(that, postSetObject, undef, undef, isAsync);
				});
			}, {
				isAsyncArgIndex: 6
			});

			this.doSetFieldValue = doSetFieldValue;

			function internalSetFieldValue(fieldId, value, valueIsFormattedAsString)
			{
				var newThingObject = getSetFieldMetadata(undef, fieldId);
				newThingObject.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, newThingObject);
				getModelController().setFieldValue(fieldId, valueObject);
				var fieldState = getFieldState(fieldId);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
			}

			this.internalSetFieldValue = internalSetFieldValue;

			var preSetFieldValueForInstance = utilityFunctions.thenableFunction(function preSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, valueObject, fireFieldChange, noSlaving, noValidation, isAsync)
			{
				return implementation.preSetFieldValueForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, valueObject, fireFieldChange, noSlaving, noValidation, isAsync);
			}, {
				isAsyncArgIndex: 8
			});

			this.preSetFieldValueForInstance = preSetFieldValueForInstance;

			var postSetFieldValueForInstance = utilityFunctions.thenableFunction(function postSetFieldValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation, isAsync)
			{
				return implementation.postSetFieldValueForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, dbValue, fireFieldChange, noSlaving, noValidation, isAsync);
			}, {
				isAsyncArgIndex: 8
			});

			this.postSetFieldValueForInstance = postSetFieldValueForInstance;

			var doSlaving = utilityFunctions.thenableFunction(function doSlaving(sublistId, fieldId, lineInstanceId, isCommitted, value, restrictField, isAsync)
			{
				return implementation.doSlaving.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, restrictField, isAsync);
			}, {
				isAsyncArgIndex: 6
			});

			this.doSlaving = doSlaving;

			var sendSlavingRequest = utilityFunctions.thenableFunction(function sendSlavingRequest(slavingMetadata, masterFieldInfo, isAsync)
			{
				var slavingRequest = slaving.getQueryRequest(slavingMetadata, masterFieldInfo, getCurrentRecordDelegate());
				if (!slavingRequest)
				{
					return;
				}
				slavingRequest.payload.newslaving = 'T';
				slavingRequest.payload.isCurrentRecord = getIsCurrentRecord();

				return resultObject.create(function ()
				{
					return (isAsync ? invoker.promise : invoker)(remoteApi, 'sendSlavingRequest', [getRecordType(), slavingRequest.url, slavingRequest.payload], null /* callback */, false /* parseResult */);
				}).then(function (response)
				{
					if (!utilityFunctions.isValEmpty(response))
					{
						return _recordScriptingV1Scope.evaluateSlavingResponse(response);
					}
				});
			}, {
				isAsyncArgIndex: 2
			});

			this.sendSlavingRequest = sendSlavingRequest;

			var applySlaveValues = utilityFunctions.thenableFunction(function applySlaveValues(slaveValues, isAsync)
			{
				return contextSwitch.execute({scriptInfo: {}}, function ()
				{
					return resultObject.create(function ()
					{
						if (slaveValues['machinesData'])
						{
							return applySlaveMachineResults.thenable(slaveValues['machinesData']);
						}
					}).then(function ()
					{
						return slaving.processSlavingValues.thenable(slaveValues['fields'], getCurrentRecordDelegate(), isAsync);
					}).then(function ()
					{
						if (util.isFunction(slaveValues['aspectScript']))
						{
							slaveValues['aspectScript'].call();
						}
					});
				});
			}, {
				isAsyncArgIndex: 1
			});

			this.applySlaveValues = applySlaveValues;

			var applySlaveMachineResults = utilityFunctions.thenableFunction(function applySlaveMachineResults(machineData)
			{
				for (var sublistId in machineData)
				{
					var sublistData = machineData[sublistId].data;
					var sublistMetadata = machineData[sublistId].metadata;
					var sublistSlaveScript = machineData[sublistId].metadata[0];
					var modelController = getModelController();
					modelController.clearSublistData(sublistId, isMultilineEditable(sublistId));
					sublistData.forEach(function (sublistLineData, index)
					{
						var lineInstanceId = modelController.insertSublistLineForInstance(sublistId, getLineInstanceId(sublistId, index), true);
						sublistLineData.forEach(function (fieldValue, index)
						{
							var fieldMetadata = sublistMetadata[index + 1];
							var fieldId = fieldMetadata.name;
							var val = (typeof fieldValue === 'object') ? fieldValue.value : fieldValue;

							modelController.setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, {
								value: val,
								legacyStringValue: val
							}, true);
							if (typeof fieldValue === 'object' && (fieldValue.hasOwnProperty('options') || fieldMetadata.hasOwnProperty('defaultOptions')))
							{
								var options = fieldMetadata.hasOwnProperty('defaultOptions') ? fieldMetadata.defaultOptions : fieldValue.options;

								if (options.length > 0)
								{
									var selectOptions = getSelectOptionCache().get(sublistId, fieldId, lineInstanceId, true, false);
									selectOptions = util.isArray(selectOptions) ? selectOptions : [];

									options.forEach(function (option)
									{
										selectOptions.push({
											text: option[1],
											id: option[0]
										});
									});

									getSelectOptionCache().put(sublistId, fieldId, lineInstanceId, true, false, selectOptions);
								}
							}
						});
					});

					doResetSublistState(sublistId);
					triggerMachinePostSourcing(sublistSlaveScript);
					if (getSublistState(sublistId))
					{
						getSublistState(sublistId).isChanged = true;
					}
				}
				if (Object.keys(machineData).length > 0) {
					if (getIsCurrentRecord()) {
						Promise.resolve().then(function() { return triggerTotalingScript.thenable(null, null, {operation: "machinesourcing", sublists: Object.keys(machineData)}); });
					}
					else {
						return triggerTotalingScript.thenable(null, null, {operation: "machinesourcing", sublists: Object.keys(machineData)});
					}
				}
			});

			this.awaitScript = function awaitScript()
			{
				if (getIsNSERecord() || typeof setTimeout === 'undefined')
				{
					return;
				}

				var modelController = getModelController();
				var serial, timeoutId;

				function settleScript()
				{
					modelController.removeFromScriptSet(serial);
					clearTimeout(timeoutId);
				}

				serial = modelController.addToScriptSet();
				timeoutId = setTimeout(settleScript, 60000);

				return settleScript;
			};

			this.trackScript = function trackScript(callback)
			{
				return resultObject.create(function ()
				{
					return getIsNSERecord() ? getModelController().trackScript(callback) : callback();
				});
			};

			function doResetSublistState(sublistId)
			{
				_state.addSublist(sublistId, getModelController, getIsNSERecord());
			}

			function triggerMachinePostSourcing(postSourcingScript)
			{
				implementation.triggerMachinePostSourcing(postSourcingScript);
			}

			var triggerCustomPostSourcingScript = utilityFunctions.thenableFunction(function triggerCustomPostSourcingScript(sublistId, fieldId, lineInstanceId)
			{
				return implementation.triggerCustomPostSourcingScript.thenable(sublistId, fieldId, lineInstanceId);
			});

			this.triggerCustomPostSourcingScript = triggerCustomPostSourcingScript;


			var getText = utilityFunctions.thenableFunction(function getText(options, isAsync)
			{
				return recordBehaviorDelegate.getText.thenable(options, isAsync);
			}, {
				isAsyncArgIndex: 1
			});

			/**
			 * get value of the field in text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.getText = getText;

			var doGetText = utilityFunctions.thenableFunction(function doGetText(fieldId, delegator, isAsync)
			{
				return implementation.doGetText.thenable(fieldId, delegator, isAsync);
			}, {
				isAsyncArgIndex: 2
			});

			this.doGetText = doGetText;

			var doGetTextValueForSupplementedSelectFieldForInstance = utilityFunctions.thenableFunction(function doGetTextValueForSupplementedSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, isCommitted, isMultiSelect, isAsync)
			{
				var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!!select.getSelectOptions)
				{
					return resultObject.create(function ()
					{
						return (isAsync ? select.getSelectOptions.promise : select.getSelectOptions)();
					}).then(function (opts)
					{
						var values = util.isArray(value) ? value : [value];
						var results = values.map(function(value) {
							var matchingOption = opts.filter(function (v) { return v.getId() === value; })[0];
							return matchingOption && matchingOption.getText();
						})
						return isMultiSelect ? results.join(String.fromCharCode(5)) : results[0];
					});
				}
			}, {
				isAsyncArgIndex: 6
			});

			this.doGetTextValueForSupplementedSelectFieldForInstance = doGetTextValueForSupplementedSelectFieldForInstance;

			var doGetTextValueForSelectFieldForInstance = utilityFunctions.thenableFunction(function doGetTextValueForSelectFieldForInstance(sublistId, fieldId, value, lineInstanceId, isCommitted, isMultiSelect, isAsync)
			{
				var result = getModelController().getSelectOptionTextFromCache(sublistId, fieldId, value);
				return resultObject.create(function ()
				{
					if (result.indexOf(undefined) !== -1)
					{
						var select = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
						return querySelectTextFromServer.thenable(value, select, isMultiSelect, isAsync).then(function (serverResult)
						{
							if (serverResult != null)
							{
								serverResult = serverResult.split(String.fromCharCode(5));
								serverResult.forEach(function (text, i) { if (text) result[i] = utilityFunctions.unescape(text); });
								getModelController().cacheSelectOptionText(sublistId, fieldId, value, result);
							}
							return result;
						});
					}
					return result;
				}).then(function (result)
				{
					return result.join(String.fromCharCode(5));
				});
			}, {
				isAsyncArgIndex: 6
			});

			this.doGetTextValueForSelectFieldForInstance = doGetTextValueForSelectFieldForInstance;

			var querySelectTextFromServer = utilityFunctions.thenableFunction(function querySelectTextFromServer(value, select, isMultiSelect, isAsync)
			{
				var callback = null;
				var shouldParseResult = false;
				var requestParam = select.getRequestParam();
				requestParam.push(value);
				return (isAsync ? invoker.promise : invoker)(remoteApi, isMultiSelect ? 'getMultiSelectTextValue' : 'getSelectTextValue', requestParam, callback, shouldParseResult);
			}, {
				isAsyncArgIndex: 3
			});

			var setText = utilityFunctions.thenableFunction(function setText(options, text, proxyOptions, isAsync)
			{
				var fieldId, fireFieldChange = true, forceSyncSourcing = false, fireSlavingSync = false, noSlaving = false;
				if (text !== undef || (options !== undef && options.fieldId === undef && typeof options === 'string'))
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					text = options.text;
					fireFieldChange = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChange;
					noSlaving = util.isBoolean(options.noslaving) ? options.noslaving : noSlaving;
					fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
					forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setText'));
				utilityFunctions.checkArgsDefined([text], ['text'], getMissingArgumentErrorMessageFillerValue('setText'));
				fieldId = idConverterService.convertBodyFieldId(that, fieldId);
				text = recordUtil.emptyIfNullOrUndefined(text);
				recordUtil.validateAgainstSqlInjection(fieldId, text);

				if (!forceSyncSourcing)
				{
					forceSyncSourcing = fireSlavingSync;
				}
				return withForceSyncSourcing(undefined, fieldId, forceSyncSourcing, function ()
				{
					return doSetText.thenable(fieldId, text, fireFieldChange, noSlaving, undefined, getIsInteractive(proxyOptions), isAsync);
				}).then(function ()
				{
					return that;
				});
			}, {
				proxyOptionsArgIndex: 2,
				isAsyncArgIndex: 3
			});

			/**
			 * set value of the field by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId The internal ID of a standard or custom body field.
			 * @param {string} options.text ----- The text or texts to change the field value to.
			 *    If the field type is multiselect: - This parameter accepts an array of string values. - This parameter accepts a
			 *     null value. Passing in null deselects all currentlsy selected values. If the field type is not multiselect: this
			 *     parameter accepts only a single string value.
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.setText = wrapMethod(setText);

			var doSetText = utilityFunctions.thenableFunction(function doSetText(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isInteractive, isAsync)
			{
				return implementation.doSetText.thenable(fieldId, text, fireFieldChange, noSlaving, noValidationAndFormatting, isInteractive, isAsync);
			}, {
				isAsyncArgIndex: 6
			});

			this.doSetText = doSetText;

			var doSetTexts = utilityFunctions.thenableFunction(function doSetTexts(fieldId, texts, fireFieldChange, noSlaving, noValidation, isAsync)
			{
				var sublistId = undef;
				var lineInstanceId = null;
				var isCommitted = true;
				var rf = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				return resultObject.create(function ()
				{
					return (isAsync ? rf.validateSelectFieldByText.promise : rf.validateSelectFieldByText)(texts);
				}).then(function (values)
				{
					return doSetFieldValue.thenable(fieldId, values, fireFieldChange, noSlaving, undef, noValidation, isAsync);
				});
			}, {
				isAsyncArgIndex: 5
			});

			this.doSetTexts = doSetTexts;

			function findSublistLineWithValue(options, fieldId, value)
			{
				var sublistId;
				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
				utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
				return doFindSublistLineWithValue(sublistId, fieldId, value);
			}

			/**
			 * return the line number for the first occurrence of a field value in a sublist and return -1 if not found
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId The internal ID of the sublist.
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or field is missing
			 *
			 * @since 2015.2
			 */
			this.findSublistLineWithValue = findSublistLineWithValue;

			function doFindSublistLineWithValue(sublistId, fieldId, value)
			{
				var isCommitted = !(getIsDynamicRecord() && isMultilineEditable(sublistId));
				var lineInstanceIds = getSublistLineInstanceIds(sublistId, isCommitted);
				for (var i = 0; i < lineInstanceIds.length; i++)
				{
					var foundValue = doGetSublistValueForInstance(sublistId, fieldId, lineInstanceIds[i], isCommitted);
					//purposefully left == so that string/number matches occur for backwards compatibility
					if (value == foundValue || ('F' === foundValue && value === false) || ('T' === foundValue && value === true))
					{
						return getLineIndexFromInstanceId(sublistId, lineInstanceIds[i]);
					}
				}
				return -1;
			}

			this.doFindSublistLineWithValue = doFindSublistLineWithValue;

			function getSublistValue(options, fieldId, line)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistValue'));
				var value = undef;
				var lineInstanceId = getLineInstanceId(sublistId, line);
				validateLineInstanceId(sublistId, lineInstanceId, true, false);
				if (isWithinValidLineRange(sublistId, line)) {
					var fieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true);
					validateTextApi(false, fieldState, 'setSublistText', 'getSublistText');
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, true);
					value = lineDefinitionObject.getParsedValueForBodyField(fieldId);
				}
				return value;
			}

			/**
			 * return value of a sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked after using setSublistText
			 *
			 * @since 2015.2
			 */
			this.getSublistValue = getSublistValue;

			function doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator)
			{
				return implementation.doGetParsedSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator);
			}

			this.doGetParsedSublistValueForInstance = doGetParsedSublistValueForInstance;

			function doGetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var hasFieldExisted = hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, isCommitted);

				if (getIsNSERecord() && !hasFieldExisted && (typeof console !== 'undefined' && console.warn)) {
					console.warn("getValue for sublist:field '" + sublistId + ":" + fieldId + "' failed. Field does not exist.");
				}

				var metadata = {
					hasFieldExisted: hasFieldExisted,
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId)
				};

				return recordBehaviorDelegateService.handleMultiSelectAndVirtualFieldForReturnValue(
					getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted),
					metadata,
					getIsNSERecord()
				);
			}

			this.doGetSublistValueForInstance = doGetSublistValueForInstance;


			var setSublistValue = utilityFunctions.thenableFunction(function setSublistValue(options, fieldId, line, value)
			{
				var converted = convertSublistFieldOptionIds(options, fieldId);
				return implementation.setSublistValue.thenable(converted.options, converted.fieldId, line, value);
			});

			/**
			 * set the value of a sublist field (available for deferred dynamic only)
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 *
			 * @since 2015.2
			 */
			this.setSublistValue = wrapMethod(setSublistValue);

			/** @deprecated - only referenced in RecordServerUtil.js which is likely not related to the client record but rather the Java record */
			var doSetSublistValue = utilityFunctions.thenableFunction(function doSetSublistValue(sublistId, fieldId, line, value)
			{
				var lineInstanceId = getLineInstanceId(sublistId, line);
				return doSetSublistCommittedValue.thenable(sublistId, fieldId, lineInstanceId, value);
			});
			this.doSetSublistValue = doSetSublistValue;

			var doSetSublistCommittedValue = utilityFunctions.thenableFunction(function doSetSublistCommittedValue(sublistId, fieldId, lineInstanceId, value)
			{
				if (isSublistValid(sublistId))
				{
					var valueObject = recordBehaviorDelegateService.createObjectToDoSetSublistValue(value, getSetFieldMetadata(sublistId, fieldId));
					getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, true);
					recordBehaviorDelegateService.postDoSetSublistValueForInstance(that, sublistId, fieldId, lineInstanceId, true);
					return resultObject.create(function ()
					{
						return triggerTotalingScript.thenable(sublistId, fieldId, {lineInstanceId: lineInstanceId, lineIndex: getLineIndexFromInstanceId(sublistId, lineInstanceId), operation: 'setSublistValue'});
					}).then(function ()
					{
						getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true).useTextApi = false;
					});
				}
			});

			var doSetSublistValueForInstance = utilityFunctions.thenableFunction(function doSetSublistValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted, value, fireFieldChange, isInteractive, allowPercentage, noValidationAndFormatting, isAsync)
			{
				if (!isCommitted)
				{
					return doSetSublistBufferValue.thenable(sublistId, fieldId, lineInstanceId, value, fireFieldChange, false, isInteractive, allowPercentage, noValidationAndFormatting, isAsync);
				}
				else
				{
					return doSetSublistCommittedValue.thenable(sublistId, fieldId, lineInstanceId, value);
				}
			}, {
				isAsyncArgIndex: 9
			});

			this.doSetSublistValueForInstance = doSetSublistValueForInstance;

			function getSetFieldMetadata(sublistId, fieldId)
			{
				//TODO
				return {
					isValidField: isValidField(sublistId, fieldId),
					isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
					isSelect: isFieldSelectType(sublistId, fieldId),
					isRadio: isFieldRadio(sublistId, fieldId),
					isNumeric: isFieldNumeric(sublistId, fieldId),
					isCurrency: isFieldCurrency(sublistId, fieldId),
					type: getFieldType(sublistId, fieldId)
				};
			}

			this.getSetFieldMetadata = getSetFieldMetadata;

			var getSublistText = utilityFunctions.thenableFunction(function getSublistText(options, fieldId, line, isAsync)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistText'));
				var value = undef;
				var lineInstanceId = getLineInstanceId(sublistId, line);
				validateLineInstanceId(sublistId, lineInstanceId, true, false);
				if (isWithinValidLineRange(sublistId, line))
				{
					var fieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, true);
					validateTextApi(true, fieldState, 'setSublistValue', 'getSublistValue');
					var lineDefinitionObject = getLineObjectFromCache(sublistId, lineInstanceId, true);
					value = lineDefinitionObject.doGetText.thenable(fieldId, undefined, isAsync);
				}
				return value;
			}, {
				isAsyncArgIndex: 3
			});

			/**
			 * return value of a sublist field in text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {string}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 * @throws {SuiteScriptError} SSS_INVALID_API_USAGE if invoked prior using setSublistText
			 *
			 * @since 2015.2
			 */
			this.getSublistText = getSublistText;

			var doGetSublistTextForInstance = utilityFunctions.thenableFunction(function doGetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, delegator, isAsync)
			{
				return implementation.doGetSublistTextForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, delegator, isAsync);
			}, {
				isAsyncArgIndex: 5
			});

			this.doGetSublistTextForInstance = doGetSublistTextForInstance;

			var setSublistText = utilityFunctions.thenableFunction(function setSublistText(options, fieldId, line, text, isAsync)
			{
				var converted = convertSublistFieldOptionIds(options, fieldId);
				return implementation.setSublistText.thenable(converted.options, converted.fieldId, line, text, isAsync);
			}, {
				isAsyncArgIndex: 4
			});

			/**
			 * set the value of a sublist field in text representation (available for deferred dynamic only)
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @param {string} options.text
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, fieldId, or line is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id, field id, or line number
			 *
			 * @since 2015.2
			 */
			this.setSublistText = wrapMethod(setSublistText);

			var doSetSublistTextForInstance = utilityFunctions.thenableFunction(function doSetSublistTextForInstance(sublistId, fieldId, lineInstanceId, isCommitted, text, fireFieldChange, noSlaving, noValidationAndFormatting, isInteractive, isAsync)
			{
				return resultObject.create(function ()
				{
					if (!isCommitted)
					{
						var metadata = {
							isMultiSelect: isFieldMultiSelect(sublistId, fieldId),
							isSelect: isFieldSelectType(sublistId, fieldId),
							isRadio: isFieldRadio(sublistId, fieldId),
							radioSet: getRadioSet(fieldId),
							isValidField: isValidField(sublistId, fieldId)
						};
						return resultObject.create(function ()
						{
							return recordBehaviorDelegateService.convertTextToValueForSetText.thenable(that, sublistId, fieldId, lineInstanceId, text, metadata, isCommitted, isAsync);
						}).then(function (value)
						{
							if (metadata.isMultiSelect || metadata.isSelect || metadata.isRadio)
							{
								return doSetSublistBufferFieldValue.thenable(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, metadata.isRadio, noValidationAndFormatting, isAsync);
							}
							else
							{
								return doSetSublistValueForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, fireFieldChange, isInteractive, true, noValidationAndFormatting, isAsync);
							}
						});
					}
					else
					{
						return doSetSublistValueForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, text);
					}
				}).then(function ()
				{
					getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted).useTextApi = true;
				});
			}, {
				isAsyncArgIndex: 9
			});

			this.doSetSublistTextForInstance = doSetSublistTextForInstance;

			function getLineCount(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getLineCount'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				return doGetLineCount(sublistId);
			}

			/**
			 * return line count of sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.getLineCount = getLineCount;

			function doGetLineCount(sublistId)
			{
				return isSublistValid(sublistId) ? getModelController().getSublistLineCount(sublistId, false) : -1;
			}
			this.doGetLineCount = doGetLineCount;

			// TODO: consider having this instead of doGetLineCount
			function doGetAllLineCount(sublistId)
			{
				return isSublistValid(sublistId) ? getModelController().getSublistLineCount(sublistId, getIsDynamicRecord() && isMultilineEditable(sublistId)) : -1;
			}

			function getLineInstanceIds(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getLineInstanceIds'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				return getSublistLineInstanceIds(sublistId, true);
			}
			this.getLineInstanceIds = getLineInstanceIds;

			var insertLine = utilityFunctions.thenableFunction(function insertLine(options, line)
			{
				var sublistId, beforeLineInstanceId, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					beforeLineInstanceId = options.beforeLineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}

				utilityFunctions.checkMutuallyExclusiveArguments(line, beforeLineInstanceId, 'line', 'beforeLineInstanceId');
				utilityFunctions.checkAtLeastOneArgumentIsDefined([line, beforeLineInstanceId], ['line', 'beforeLineInstanceId'], getMissingArgumentErrorMessageFillerValue('insertLine'));

				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('insertLine'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));

				if (line != null)
				{
					validateLineIndex(line, sublistId, true);
					beforeLineInstanceId = getLineInstanceId(sublistId, line);
				}

				return resultObject.create(function ()
				{
					return doInsertLineForInstance.thenable(sublistId, beforeLineInstanceId, ignoreRecalc);
				}).then(function (lineObj)
				{
					return isMultilineEditable(sublistId) ? lineObj : that;
				});
			});

			/**
			 * insert a sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.beforeLineInstanceId
			 * @param {boolean} [ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and beforeLineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and beforeLineInstanceId
			 *     are missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable or before exists and before is an instanceId that does not point to a line in the sublist.
			 *
			 * @since 2015.2
			 */
			this.insertLine = wrapMethod(insertLine);

			var doInsertLineForInstance = utilityFunctions.thenableFunction(function doInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				if (ignoreRecalc === undef)
				{
					ignoreRecalc = false;
				}

				if (isSublistAnEditMachine(sublistId))
				{
					var isDynamic = getIsDynamicRecord();
					var isCommitted = !(isMultilineEditable(sublistId) && isDynamic);
					if (beforeLineInstanceId != null) // null when NEW LINE
						validateLineInstanceId(sublistId, beforeLineInstanceId, isCommitted, isDynamic);
					var beforeLineIndex = getLineIndexFromInstanceId(sublistId, beforeLineInstanceId);
					return resultObject.create(function ()
					{
						return preInsertLineForInstance.thenable(sublistId, beforeLineInstanceId);
					}).then(function ()
					{
						var lineInstanceId = insertSublistLineForInstance(sublistId, getLineInstanceId(sublistId, beforeLineIndex), isCommitted);
						return resultObject.create(function ()
						{
							return postInsertLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc);
						}).then(function ()
						{
							return resultObject.create(function ()
							{
								if (getIsNSERecord()) //Change just for NSE (NSE has always MLB). On MLB we need to call init line here
									return getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, triggerLineInitScript.thenable, that, [sublistId]);
							}).then(function ()
							{
								setSublistIsChanged(sublistId, true);
								return getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
							})
						});
					});
				}
				return null;
			});

			this.doInsertLineForInstance = doInsertLineForInstance;

			function insertSublistLineForInstance(sublistId, beforeLineInstanceId, isCommitted)
			{
				var lineInstanceId = getModelController().insertSublistLineForInstance(sublistId, beforeLineInstanceId, isCommitted);
				getSublistState(sublistId).insertLineForInstance(lineInstanceId, isCommitted);
				subrecord_updateFieldState(true);
				return lineInstanceId;
			}

			var preInsertLineForInstance = utilityFunctions.thenableFunction(function preInsertLineForInstance(sublistId, beforeLineInstanceId)
			{
				return implementation.preInsertLineForInstance.thenable(sublistId, beforeLineInstanceId);
			});

			var postInsertLineForInstance = utilityFunctions.thenableFunction(function postInsertLineForInstance(sublistId, beforeLineInstanceId, ignoreRecalc)
			{
				return implementation.postInsertLineForInstance.thenable(sublistId, beforeLineInstanceId, ignoreRecalc);
			});

			var moveLine = utilityFunctions.thenableFunction(function moveLine(options, from, to) {
				var sublistId = util.isObject(options) && util.isString(options.sublistId) ? options.sublistId : options;
				if (sublistId == null || !util.isString(sublistId))
					sublistId = undefined;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('moveLine'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				if (!isSublistValid(sublistId))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
				if (!isAllowedToMoveLines(sublistId))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES);
				else {
					if (util.isObject(options) && (options.fromInstanceId != undefined || options.toInstanceId != undefined)) {
						utilityFunctions.checkArgs([options.fromInstanceId, options.toInstanceId], ['fromInstanceId', 'toInstanceId'], getMissingArgumentErrorMessageFillerValue('moveLine'));
						var isMLB = isMultilineEditable(sublistId);
						validateLineInstanceId(sublistId, options.fromInstanceId, !isMLB, isMLB);
						validateLineInstanceId(sublistId, options.toInstanceId,  !isMLB, isMLB);
						doMoveLineByInstanceId(sublistId, options.fromInstanceId, options.toInstanceId);
					}
					else {
						if (util.isObject(options) && !util.isNumber(from))
							from = options.from;
						utilityFunctions.checkArgs([from], ['from'], getMissingArgumentErrorMessageFillerValue('moveLine'));
						if (util.isObject(options) && !util.isNumber(to))
							to = options.to;
						utilityFunctions.checkArgs([to], ['to'], getMissingArgumentErrorMessageFillerValue('moveLine'));
						if (isNaN(from) || isNaN(to))
							utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
						validateLineIndex(from, sublistId, false);
						validateLineIndex(to, sublistId, false);
						doMoveLineByIndex(sublistId, from, to);
					}
				}
				return that;
			});

			/**
			 * Move one line to desired location.
			 * You can address both lines either by Line Instance IDs or both by Indexes.
			 * Order of all other lines is preserved.
			 * Line indexes between original and final position are shifted by one.
			 * @param {Object|string} options (sublistId)
			 * @param {string} options.sublistId
			 * @param {number} options.from (0-based index)
			 * @param {number} options.to (0-based index)
			 * @param {string} options.fromInstanceId (line instance ID)
			 * @param {string} options.toInstanceId (line instance ID)
			 * @param {number} from (0-based index)
			 * @param {number} to (0-based index)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, from or to is missing
			 * @throws {SuiteScriptError} SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES if machine doesn't support line moving
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line indexes are invalid
			 */
			this.moveLine = wrapMethod(moveLine);

			function doMoveLineByInstanceId(sublistId, fromInstanceId, toInstanceId)
			{
				getModelController().moveSublistLine(sublistId, fromInstanceId, toInstanceId);
			}

			function doMoveLineByIndex(sublistId, fromIndex, toIndex) {
				var fromInstanceId = getLineInstanceId(sublistId, fromIndex);
				var toInstanceId = getLineInstanceId(sublistId, toIndex);
				if (!fromInstanceId || !toInstanceId)
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SUBLIST_OPERATION);
				else
					doMoveLineByInstanceId(sublistId, fromInstanceId, toInstanceId);
			}

			var makeCopyForInstance = utilityFunctions.thenableFunction(function makeCopyForInstance(sublistId, lineInstanceId, isCommitted, isAsync)
			{
				var modelController = getModelController();
				var isMLB = isMultilineEditable(sublistId);

				if (!isMLB && !modelController.isSelectedLineCommittable(lineInstanceId))
				{
					return that; // return if the line cannot be committed, TODO: add promise to line copy
				}

				return resultObject.create(function ()
				{
					if (!isMLB)
					{
						return commitLineAndSelectNew.thenable(sublistId, lineInstanceId, undefined, isAsync);
					}
				}).then(function ()
				{
					var lineToCopy = modelController.getSublistLineForInstance(sublistId, lineInstanceId, isCommitted);
					var noCopyToDefaultMap = getNoCopyToDefaultMapForSublist(sublistId);
					var newLineId = isMLB
						? modelController.makeCopyForInstance(sublistId, lineToCopy, true, noCopyToDefaultMap)
						: modelController.updateNewLineBufferWithCopy(sublistId, lineToCopy, noCopyToDefaultMap, false);
					getSublistState(sublistId).cloneLineStateToLineCopy(lineInstanceId, isCommitted, newLineId);
					return isMLB ? getLineObjectFromCache(sublistId, newLineId, isCommitted) : that;
				});
			}, {
				isAsyncArgIndex: 3
			});

			this.makeCopyForInstance = makeCopyForInstance;

			var copyLine = utilityFunctions.thenableFunction(function copyLine(options, isAsync)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("copyLine"));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				var currInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				var isCommitted = !isMultilineEditable(sublistId);

				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId) && (currInstanceId != null));

				return makeCopyForInstance.thenable(sublistId, currInstanceId, isCommitted, isAsync);
			}, {
				isAsyncArgIndex: 1
			});

			/**
			 * Commits and copies the currently selected line into a new line, which will be the new selected line.
			 *
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or not editable
			 */
			this.copyLine = wrapMethod(copyLine);

			function doResetCommittedLineForInstance(sublistId, lineInstanceId, data)
			{
				if (!isMultilineEditable(sublistId))
					getModelController().resetSublistCommittedLineForInstance(sublistId, lineInstanceId, data);
			}

			this.doResetCommittedLineForInstance = doResetCommittedLineForInstance;

			var removeLine = utilityFunctions.thenableFunction(function removeLine(options, line)
			{
				var sublistId, lineInstanceId, ignoreRecalc = false;
				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					lineInstanceId = options.lineInstanceId;
					ignoreRecalc = options.ignoreRecalc || false;
				}
				utilityFunctions.checkMutuallyExclusiveArguments(line, lineInstanceId, 'line', 'lineInstanceId');
				utilityFunctions.checkAtLeastOneArgumentIsDefined([line, lineInstanceId], ['line', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('removeLine'));

				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('removeLine'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				recordUtil.assertValidSublistOperation(isSublistAnEditMachine(sublistId));

				if (line != null)
				{
					validateLineIndex(line, sublistId, false);
					return doRemoveLineForInstance.thenable(sublistId, getLineInstanceId(sublistId, line), ignoreRecalc);
				}
				else
				{
					return doRemoveLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc);
				}
			});

			/**
			 * remove a sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {string} options.lineInstanceId
			 * @param {boolean} [options.ignoreRecalc=false] options.ignoreRecalc ignore recalc scripting
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or line index is invalid or if machine is not
			 *     editable
			 *
			 * @since 2015.2
			 */
			this.removeLine = wrapMethod(removeLine);

			var doRemoveLineForInstance = utilityFunctions.thenableFunction(function doRemoveLineForInstance(sublistId, lineInstanceId, ignoreRecalc, noValidation)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					if (!getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, true))
					{
						// committed line does not exist
						validateLineInstanceId(sublistId, lineInstanceId, false, false);
						return functionallyCancelLineForInstance.thenable(sublistId, lineInstanceId);
					}
					else
					{
						return resultObject.create(function ()
						{
							return implementation.removeSublistLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc, noValidation);
						}).then(function (removedLineIndex)
						{
							return implementation.postRemoveLineForInstance.thenable(sublistId, removedLineIndex);
						}).then(function ()
						{
							setSublistIsChanged(sublistId, true);
						});
					}
				}
			});
			this.doRemoveLineForInstance = doRemoveLineForInstance;

			var doRemoveSublistLineForInstance = utilityFunctions.thenableFunction(function doRemoveSublistLineForInstance(sublistId, lineInstanceId, ignoreRecalc)
			{
				var removedLineIndex = getModelController().removeSublistLineForInstance(sublistId, lineInstanceId);
				return resultObject.create(function ()
				{
					if (removedLineIndex !== -1) {
						getSublistState(sublistId).removeLineForInstance(lineInstanceId);
						subrecord_updateFieldState(true);
						removeLineObjectFromCache(sublistId, lineInstanceId);
						return getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, getLineInstanceId(sublistId, removedLineIndex), triggerRecalcScript.thenable, that, [sublistId, false, {operation: 'remove'}, ignoreRecalc]);
					}
				}).then(function ()
				{
					return removedLineIndex;
				});
			});

			this.doRemoveSublistLineForInstance = doRemoveSublistLineForInstance;

			/**
			 * return the line number of current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {number}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			function getCurrentSublistIndex(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("getCurrentSublistIndex"));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				var currentLineInstance = doGetCurrentSublistLineInstanceId(sublistId);
				return currentLineInstance ? getLineIndexFromInstanceId(sublistId, currentLineInstance) : -1;
			}

			this.getCurrentSublistIndex = getCurrentSublistIndex;

			function doGetCurrentSublistLineInstanceId(sublistId)
			{
				return getModelController().getSublistSelectedLineInstanceId(sublistId);
			}

			this.doGetCurrentSublistLineInstanceId = doGetCurrentSublistLineInstanceId;

			/**
			 * select line
			 *
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {number} options.line
			 * @param {String} options.lineInstanceId
			 * @return {Line} [requested line object]
			 * @throws {SuiteScriptError} MUTUALLY_EXCLUSIVE_ARGUMENTS if both line and lineInstanceId are provided
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or both line and lineInstanceId are
			 *     missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or line index
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			var selectLine = utilityFunctions.thenableFunction(function selectLine(options, line)
			{
				if (line !== undef)
				{
					options = idConverterService.convertSublistId(that, options);
				}
				else if (options !== undef && options !== null)
				{
					options = idConverterService.convertOptionIds(that, options);
				}

				return implementation.selectLine.thenable(options, line);
			});

			this.selectLine = wrapMethod(selectLine);

			var doSelectLineForInstance = utilityFunctions.thenableFunction(function doSelectLineForInstance(sublistId, lineInstanceId)
			{
				var modelController = getModelController();
				return resultObject.create(function ()
				{
					if (!lineInstanceId || lineInstanceId !== doGetCurrentSublistLineInstanceId(sublistId))
					{
						var isMBL = isMultilineEditable(sublistId);
						validateLineInstanceId(sublistId, lineInstanceId, true, isMBL);
						if (isMBL && modelController.lineInstanceIsNewLine(sublistId, lineInstanceId))
						{
							modelController.updateCurrentLineToANewLine_MLB(sublistId, lineInstanceId);
						}
						else
						{
							lineInstanceId = handleSelectSublistLine(sublistId, lineInstanceId);

							//Change just for NSE (NSE has always MLB). MLB lineInit is always called on add/insert we don't need to call it again
							if (!getIsNSERecord())
								return triggerLineInitScript.thenable(sublistId);
						}
					}
				}).then(function ()
				{
					return getLineObjectFromCache(sublistId, lineInstanceId, false);
				});
			});

			this.doSelectLineForInstance = doSelectLineForInstance;

			function handleSelectSublistLine(sublistId, lineInstanceId)
			{
				var modelController = getModelController();
				var isMLB = isMultilineEditable(sublistId);
				var currentLineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				if (!isMLB && currentLineInstanceId) {
					if (getSublistState(sublistId).isLineInsertedForInstance(currentLineInstanceId, true)) {
						doRemoveSublistLineForInstance(sublistId, currentLineInstanceId);
					}
					getSublistState(sublistId).removeSublistLineState(currentLineInstanceId, false);
				}
				var selectedLineInstanceId = modelController.selectSublistLineForInstance(sublistId, lineInstanceId, isMLB);
				if (getSublistState(sublistId).updateBufferLineStateForInstance(selectedLineInstanceId))
				{
					getModelController().invalidateSublistRecordCacheForInstance(sublistId, selectedLineInstanceId);
				}
				subrecord_updateFieldState(true);
				return selectedLineInstanceId;
			}

			var selectNewLine = utilityFunctions.thenableFunction(function selectNewLine(options)
			{
				options = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("selectNewLine"));
				options = idConverterService.convertSublistId(that, options);
				return implementation.selectNewLine.thenable(options);
			});

			/**
			 * select a new line at the end of sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} [new line object]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or sublist is not editable
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.selectNewLine = wrapMethod(selectNewLine);

			var doSelectNewLine = utilityFunctions.thenableFunction(function doSelectNewLine(sublistId, ignoreLineInit)
			{
				ignoreLineInit = ignoreLineInit || false;

				if (isSublistAnEditMachine(sublistId))
				{
					if(isMultilineEditable(sublistId))
					{
						// selectNewLine = addNewLine + selectLine
						return resultObject.create(function ()
						{
							return doAddNewLine.thenable(sublistId, ignoreLineInit);
						}).then(function (lineObj)
						{
							getModelController().updateCurrentLineToANewLine_MLB(sublistId, lineObj.instanceId);
							return lineObj;
						});
					}
					else
					{
						var lineInstanceId = handleSelectNewSublistLine(sublistId);
						return resultObject.create(function ()
						{
							if (!ignoreLineInit)
							{
								return triggerLineInitScript.thenable(sublistId);
							}
						}).then(function ()
						{
							return getLineObjectFromCache(sublistId, lineInstanceId, false);
						});
					}
				}
				return null;
			});

			this.doSelectNewLine = doSelectNewLine;

			function handleSelectNewSublistLine(sublistId)
			{
				var modelController = getModelController();
				var isMLB = isMultilineEditable(sublistId);
				var currentLineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				if (!modelController.lineInstanceIsLastNewLine_MLB(sublistId, currentLineInstanceId)) {
					if (!isMLB && currentLineInstanceId) {
						if (getSublistState(sublistId).isLineInsertedForInstance(currentLineInstanceId, true)) {
							doRemoveSublistLineForInstance(sublistId, currentLineInstanceId);
						}
						getSublistState(sublistId).removeSublistLineState(currentLineInstanceId, false);
					}
					currentLineInstanceId = modelController.selectNewSublistLine(sublistId, _metadata.getSublistDefaultValue(sublistId), isMLB);
					if (getSublistState(sublistId).updateBufferLineStateForInstance(currentLineInstanceId))
					{
						getModelController().invalidateSublistRecordCacheForInstance(sublistId, currentLineInstanceId);
					}
					subrecord_updateFieldState(true);
				}
				return currentLineInstanceId;
			}

			function validateGetLineOperation(sublistId, isCommitted)
			{
				utilityFunctions.assertTrue(isSublistValid(sublistId), error.Type.INVALID_SUBLIST_OPERATION);
				utilityFunctions.assertTrue(isCommitted || getIsDynamicRecord(), error.Type.INVALID_SUBLIST_OPERATION);
			}

			var getLine = utilityFunctions.thenableFunction(function getLine(options)
			{
				var sublistId;
				var lineInstanceId;
				var isCommitted;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					lineInstanceId = options.lineInstanceId;
					isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				}
				utilityFunctions.checkArgs([sublistId, lineInstanceId], ['sublistId', 'lineInstanceId'], getMissingArgumentErrorMessageFillerValue('getLine'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				validateGetLineOperation(sublistId, isCommitted);

				// Update once everything is calm and settled. Safer this way than updating all old APIs.
				validateLineInstanceId(sublistId, lineInstanceId, isCommitted, !isCommitted && getIsDynamicRecord());
				return getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
			});

			this.getLine = wrapMethod(getLine);



			var getLinesIterator = utilityFunctions.thenableFunction(function getLinesIterator(options)
			{
				var sublistId;
				var isCommitted;

				if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				}
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLinesIterator'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				validateGetLineOperation(sublistId, isCommitted);
				// Update once everything is calm and settled. Safer this way than updating all old APIs.
				var result = {
					each: function (func)
					{
						var instanceIds = getSublistLineInstanceIds(sublistId, isCommitted);
						instanceIds.forEach(function(lineInstanceId) {
							var lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
							func(lineObj);
						});
					},
					next: (function ()
					{
						var index = 0;
						var done = false;
						var instanceIds = getSublistLineInstanceIds(sublistId, isCommitted);

						return function ()
						{
							var lineInstanceId, lineObj;
							var result = {done: done};
							if (!done)
							{
								done = !(index < instanceIds.length);
								if (!done)
								{
									lineInstanceId = instanceIds[index];
									lineObj = getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
									index += 1;
									result.value = lineObj;
								}
							}
							result.done = done;
							return result;
						};
					})()
				};

				return Object.freeze(result);
			});

			this.getLinesIterator = wrapMethod(getLinesIterator);

			/**
			 * return an array of sublist lines in a sorted order
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {boolean?} options.currentState
			 * @param {boolean?} options.isCommitted
			 * @param {(string|Array)} options.orderBy
			 * @return {Array} array of line objects
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION if ascending is missing or undefined or not a
			 *     boolean when orderBy is an array.
			 * @restriction only available in readonly record
			 */
			var getLines = utilityFunctions.thenableFunction(function getLines(options, proxyOptions) {
				if (options === undef || options === null)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "getLines", "options");
				}

				var sublistId = options.sublistId;
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLines'));
				sublistId = idConverterService.convertSublistId(that, sublistId);

				var orderBy = options.orderBy;

				utilityFunctions.checkMutuallyExclusiveArguments(options.isCommitted, options.currentState, 'isCommitted', 'currentState');
				var isCommitted = util.isBoolean(options.isCommitted) ? options.isCommitted : false;
				if (getIsReadOnlyRecord(proxyOptions))
				{
					// force set isCommitted to true in ReadOnlyRecords.
					isCommitted = true;
				}
				var currentState = util.isBoolean(options.currentState) ? options.currentState : false;

				validateGetLineOperation(sublistId, isCommitted);

				var lineInstanceIds = getSublistLineInstanceIds(sublistId, isCommitted);
				var lines = lineInstanceIds.map(function (lineInstanceId) {
					var lineObj = null;
					if (currentState)
					{
						var linePkg = getExistingLineObjectFromCache(sublistId, lineInstanceId);
						if (!!linePkg.line)
						{
							lineObj = linePkg.line;
							lineObj._state = linePkg.state;
						}
						return lineObj;
					}
					else
					{
						return getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
					}
				});

				if (orderBy === undef || orderBy === null)
					return lines; // return non-sorted version
				else
					return doSortingForLines(lines, orderBy, sublistId, proxyOptions);
			}, {
				proxyOptionsArgIndex: 1
			});
			this.getLines = wrapMethod(getLines);


			function doSortingForLines(lines, orderBy, sublistId, proxyOptions) {

				if (!getIsReadOnlyRecord(proxyOptions))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				}
				if (!(util.isString(orderBy) || util.isArray(orderBy)))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
				}

				// multiple field sort not yet supported
				var sortFieldId = util.isString(orderBy) ? orderBy : (util.isArray(orderBy) && orderBy.length === 1) ? orderBy[0].fieldId : null;
				if (!sortFieldId) {
					return lines; // return non-sorted version
				}

				var sortFieldType = _metadata.getFieldMetadata(sublistId, sortFieldId).type;
				var sortAscending = (util.isArray(orderBy) && orderBy.length === 1 && typeof orderBy[0].ascending !== 'undefined') ? orderBy[0].ascending : true;
				if (!util.isBoolean(sortAscending)) {
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
				}

				lines.sort(getSortFunction(sortFieldType, sortFieldId, sortAscending));
				return lines;
			}

			/*
			 * This is a helper function that returns a sorter for the given fieldType, fieldId and order
			 */
			var getSortFunction = (function () {
				var TEXT_API = 'getText';
				var VALUE_API = 'getValue';

				function lineSorter(apiCall, comparator, fieldType, fieldId, order, line1, line2) {
					return order * comparator(line1[apiCall](fieldId), line2[apiCall](fieldId), fieldType);
				}

				var sortFunctions = {};
				sortFunctions[fieldTypeConstants.Type.TEXT]             = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.TEXTAREA]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.EMAIL]            = lineSorter.bind(null, TEXT_API,  formatter.comparators.emailComaparator);
				sortFunctions[fieldTypeConstants.Type.DOCUMENT]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);

				sortFunctions[fieldTypeConstants.Type.INTEGER]          = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.POSINTEGER]       = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.DYNAMICPRECISION]     = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.FLOAT]            = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.POSFLOAT]         = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.NONNEGFLOAT]      = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.RATE]             = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.RATEHIGHPRECISION]= lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.PERCENT]          = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.CURRENCY]         = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.CURRENCY2]        = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);
				sortFunctions[fieldTypeConstants.Type.PHONE]            = lineSorter.bind(null, VALUE_API, formatter.comparators.fieldTypeBasedComparator);

				sortFunctions[fieldTypeConstants.Type.SELECT]           = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);
				sortFunctions[fieldTypeConstants.Type.CHECKBOX]         = lineSorter.bind(null, TEXT_API,  formatter.comparators.textComparator);

				sortFunctions[fieldTypeConstants.Type.TIME]             = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);
				sortFunctions[fieldTypeConstants.Type.TIMETRACK]        = lineSorter.bind(null, VALUE_API, formatter.comparators.numberComparator);

				sortFunctions[fieldTypeConstants.Type.DATE]             = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.MMYYDATE]         = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.DATETIME]         = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.DATETIMETZ]       = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);
				sortFunctions[fieldTypeConstants.Type.TIMEOFDAY]        = lineSorter.bind(null, VALUE_API, formatter.comparators.dateComparator);

				return (
					function getSortFunctionsByFieldType(fieldType, fieldId, ascOrder) {
						var order = !!ascOrder ? 1 : -1;
						if (sortFunctions[fieldType]) {
							return sortFunctions[fieldType].bind(null, fieldType, fieldId, order);
						}
						else {
							//field type isn't supported yet.
							utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
						}
					}
				);
			})();

			var doAddNewLine = utilityFunctions.thenableFunction(function doAddNewLine(sublistId, ignoreLineInit)
			{
				var isCommitted = false;

				if (!isMultilineEditable(sublistId))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);

				if (isSublistAnEditMachine(sublistId))
				{
					var lineInstanceId = getModelController().addNewSublistLine(sublistId, _metadata.getSublistDefaultValue(sublistId));
					getSublistState(sublistId).updateBufferLineStateForInstance(lineInstanceId);
					return resultObject.create(function ()
					{
						if (!ignoreLineInit) {
							return getModelController().runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, triggerLineInitScript.thenable, that, [sublistId]);
						}
					}).then(function ()
					{
						return getLineObjectFromCache(sublistId, lineInstanceId, isCommitted);
					});
				}
				return null;
			});
			this.doAddNewLine = doAddNewLine;

			/**
			 * Creates a new line to the specified sublist and adds it to the end of the sublist sequentially.
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Line} the Line object that was created.
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 */
			var addNewLine = utilityFunctions.thenableFunction(function addNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("addLine"));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				return implementation.addNewLine.thenable(sublistId);
			});
			this.addNewLine = wrapMethod(addNewLine);

			var cancelLine = utilityFunctions.thenableFunction(function cancelLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("cancelLine"));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				var currentInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				validateLineInstanceId(sublistId, currentInstanceId, false, false); // should we allow fallback in this case?
				return resultObject.create(function ()
				{
					return implementation.cancelLineForInstance.thenable(sublistId, currentInstanceId);
				}).then(function ()
				{
					return postCancelLine.thenable(sublistId, currentInstanceId);
				});
			});

			/**
			 * cancel the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId is invalid or if machine is not editable
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.cancelLine = wrapMethod(cancelLine);

			var cancelLineForInstance = utilityFunctions.thenableFunction(function cancelLineForInstance(sublistId, lineInstanceId)
			{
				return implementation.cancelLineForInstance.thenable(sublistId, lineInstanceId);
			});
			this.cancelLineForInstance = cancelLineForInstance;

			var functionallyCancelLineForInstance = utilityFunctions.thenableFunction(function functionallyCancelLineForInstance(sublistId, lineInstanceId)
			{
				return resultObject.create(function ()
				{
					return doCancelLineForInstance.thenable(sublistId, lineInstanceId, true);
				}).then(function ()
				{
					return postCancelLine.thenable(sublistId, lineInstanceId);
				});
			});

			var doCancelLineForInstance = utilityFunctions.thenableFunction(function doCancelLineForInstance(sublistId, lineInstanceId, originNotCancel)
			{
				if (isSublistAnEditMachine(sublistId))
				{
					abandonSublisBufferSubrecords(sublistId, lineInstanceId);
					return resultObject.create(function ()
					{
						if (!isMultilineEditable(sublistId) && getSublistState(sublistId).isLineInsertedForInstance(lineInstanceId, true))
						{
							return doRemoveSublistLineForInstance.thenable(sublistId, lineInstanceId);
						}
						else
						{
							getSublistState(sublistId).removeSublistLineState(lineInstanceId, false);
						}
					}).then(function ()
					{
						getModelController().cancelSublistLineForInstance(sublistId, lineInstanceId, originNotCancel);
						subrecord_updateFieldState(true);
					});
				}
			});

			this.doCancelLineForInstance = doCancelLineForInstance;

			var postCancelLine = utilityFunctions.thenableFunction(function postCancelLine(sublistId, lineInstanceId)
			{
				var lineObj;
				if(!isMultilineEditable(sublistId)) {

					if (getModelController().isSublistLineInstanceIdValid(sublistId, lineInstanceId, true))
					{
						lineObj = doSelectLineForInstance.thenable(sublistId, lineInstanceId);
					}
					else
					{
						lineObj = doSelectNewLine.thenable(sublistId);
					}
				}
				return lineObj;
			});

			var commitLine = utilityFunctions.thenableFunction(function commitLine(options, ignoreRecalc, isAsync)
			{
				var modelController = getModelController();
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue("commitLine"));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				ignoreRecalc = !!options && options.hasOwnProperty('ignoreRecalc') ? options.ignoreRecalc : ignoreRecalc;
				var lineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				var isCommittable = modelController.isSelectedLineCommittable(lineInstanceId);
				return resultObject.create(function ()
				{
					if (isCommittable)
					{
						if (isMultilineEditable(sublistId))
							return commitLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc, isAsync);
						else
							return commitLineAndSelectNew.thenable(sublistId, lineInstanceId, ignoreRecalc, isAsync);
					}
				}).then(function ()
				{
					return that;
				})
			}, {
				isAsyncArgIndex: 2
			});

			/**
			 * commit the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId is missing or undefined
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.commitLine = wrapMethod(commitLine);

			var commitLineAndSelectNew = utilityFunctions.thenableFunction(function commitLineAndSelectNew(sublistId, lineInstanceId, ignoreRecalc, isAsync)
			{
				return resultObject.create(function ()
				{
					return commitLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc, isAsync);
				}).then(function ()
				{
					if (isSublistAnEditMachine(sublistId))
					{
						return selectNewLine.thenable(sublistId);
					}
				});
			}, {
				isAsyncArgIndex: 3
			});

			this.commitLineAndSelectNew = commitLineAndSelectNew;

			var commitLineForInstance = utilityFunctions.thenableFunction(function commitLineForInstance(sublistId, lineInstanceId, ignoreRecalc, isAsync)
			{
				return implementation.commitLineForInstance.thenable(sublistId, lineInstanceId, ignoreRecalc, isAsync);
			}, {
				isAsyncArgIndex: 3
			});

			this.commitLineForInstance = commitLineForInstance;

			var doCommitLineForInstance = utilityFunctions.thenableFunction(function doCommitLineForInstance(sublistId, lineInstanceId, ignoreRecalc, isAsync)
			{
				if (isSublistEditable(sublistId))
				{
					var modelController = getModelController();
					return resultObject.create(function ()
					{
						if (that.getIsNSERecord()) {
							return checkMandatory.thenable(that, sublistId, lineInstanceId);
						}
					}).then(function ()
					{
						return modelController.runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, triggerValidateLineScript.thenable, that, [sublistId, lineInstanceId]);
					}).then(function ()
					{
						return commitBufferedSublistSubrecordsForInstance.thenable(sublistId, lineInstanceId);
					}).then(function ()
					{
						getSublistState(sublistId).commitLineForInstance(lineInstanceId);
						return modelController.commitSublistLineForInstance.thenable(sublistId, lineInstanceId, isMultilineEditable(sublistId), isAsync);
					}).then(function ()
					{
						subrecord_updateFieldState(true);
						return modelController.runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, triggerRecalcScript.thenable, that, [sublistId, false, {operation: 'commit'}, ignoreRecalc]);
					}).then(function ()
					{
						return triggerTotalingScript.thenable(sublistId, null, {lineInstanceId: lineInstanceId, lineIndex: getLineIndexFromInstanceId(sublistId, lineInstanceId), operation: 'commit'});
					}).then(function ()
					{
						if (isSublistAnEditMachine(sublistId))
						{
							return modelController.runFunctionWhileSilentlySelectingLine.thenable(sublistId, lineInstanceId, triggerLineCommitScriptForInstance.thenable, that, [sublistId, lineInstanceId]);
						}
					});
				}
			}, {
				isAsyncArgIndex: 3
			});

			this.doCommitLineForInstance = doCommitLineForInstance;

			function constructLineObject(sublistId, lineInstanceId, isCommitted)
			{
				var lineObj;
				var lineOptions = {
					unproxiedRecord: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					fromBuffer: !isCommitted,
					isReadOnly: getIsReadOnlyRecord() || (getIsDynamicRecord() && isCommitted)
				};
				lineObj = new lineDefinition(lineOptions);
				return lineObj;
			}

			function constructPreSetObject(sublistId, fieldId, valueObject, fireFieldChange, noSlaving, noValidation)
			{
				return {
					sublistId: sublistId,
					fieldId: fieldId,
					valueObject: valueObject,
					fireFieldChange: fireFieldChange,
					noSlaving: noSlaving,
					noValidation: noValidation
				};
			}

			function constructPostSetObject(sublistId, fieldId, dbValue, fireFieldChange, noSlaving, noValidation)
			{
				return {
					sublistId: sublistId,
					fieldId: fieldId,
					dbValue: dbValue,
					fireFieldChange: fireFieldChange,
					noSlaving: noSlaving,
					noValidation: noValidation
				};
			}

			function getCurrentSublistValue(options, fieldId)
			{
				return implementation.getCurrentSublistValue(convertCurrentLineInputToOptions(options, fieldId), undef);
			}

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistValue = getCurrentSublistValue;

			var setCurrentSublistValue = utilityFunctions.thenableFunction(function setCurrentSublistValue(options, fieldId, value, proxyOptions, isAsync)
			{
				var converted = convertSublistFieldOptionIds(options, fieldId);
				return implementation.setCurrentSublistValue.thenable(converted.options, converted.fieldId, value, proxyOptions, isAsync);
			}, {
				proxyOptionsArgIndex: 3,
				isAsyncArgIndex: 4
			});

			/**
			 * set the value for field in the current selected line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.value
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 *
			 * @since 2015.2
			 */
			this.setCurrentSublistValue = wrapMethod(setCurrentSublistValue);

			var doSetSublistBufferValue = utilityFunctions.thenableFunction(function doSetSublistBufferValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, isInteractive, allowPercentage, noValidationAndFormatting, isAsync)
			{
				validateIfSublistIdEditableAndInstanceIdValid(sublistId, lineInstanceId, false);
				return resultObject.create(function ()
				{
					value = recordUtil.emptyIfNullOrUndefined(value);
					if (isFieldMultiSelect(sublistId, fieldId))
						value = recordUtil.formatValueToArrayType(value);
					else if (isFieldRadio(sublistId, fieldId))
						value = String(value);
					return noValidationAndFormatting ? value : validateAndFormatFieldValueForInstance.thenable(sublistId, fieldId, lineInstanceId, value, isInteractive, allowPercentage, isAsync);
				}).then(function (validatedValue)
				{
					var valueIsFormattedAsString = false;
					return doSetSublistBufferFieldValue.thenable(sublistId, fieldId, lineInstanceId, validatedValue, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidationAndFormatting, isAsync);
				}).then(function ()
				{
					getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, false).useTextApi = false;
				});
			}, {
				isAsyncArgIndex: 9
			});

			this.doSetSublistBufferValue = doSetSublistBufferValue;

			function validateIfSublistIdEditableAndInstanceIdValid(sublistId, instanceId, isCommitted)
			{
				var sublistMetadata = getSublistMetadata(sublistId);

				recordUtil.assertValidSublistOperation(sublistMetadata !== null);
				if (sublistMetadata.displayOnly)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.INVALID_SCRIPT_OPERATION_ON_READONLY_SUBLIST_FIELD, sublistId);
				}
				validateLineInstanceId(sublistId, instanceId, isCommitted, getIsDynamicRecord());
			}

			this.validateIfSublistIdEditableAndInstanceIdValid = validateIfSublistIdEditableAndInstanceIdValid;

			var doSetSublistBufferFieldValue = utilityFunctions.thenableFunction(function doSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, fireFieldChange, noSlaving, valueIsFormattedAsString, noValidation, isAsync)
			{
				var preSetObject = constructPreSetObject(sublistId, fieldId, getValueObjectForValidationForInstance(sublistId, fieldId, lineInstanceId, false, value), fireFieldChange, noSlaving, noValidation);
				return recordBehaviorDelegateService.preDoSetValueForInstance.thenable(that, preSetObject, lineInstanceId, false, isAsync).then(function () {
					internalSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, valueIsFormattedAsString);
					var postSetObject = constructPostSetObject(sublistId, fieldId, getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, false),
						fireFieldChange, noSlaving, noValidation);
					return recordBehaviorDelegateService.postDoSetValueForInstance.thenable(that, postSetObject, lineInstanceId, false, isAsync);
				});
			}, {
				isAsyncArgIndex: 8
			});

			this.doSetSublistBufferFieldValue = doSetSublistBufferFieldValue;

			function internalSetSublistBufferFieldValue(sublistId, fieldId, lineInstanceId, value, valueIsFormattedAsString)
			{
				var relevantMetadata = getSetFieldMetadata(sublistId, fieldId);
				relevantMetadata.valueIsFormattedAsString = valueIsFormattedAsString;
				var valueObject = recordBehaviorDelegateService.createObjectToDoSetValue(value, relevantMetadata);
				getModelController().setSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, valueObject, false);
				var fieldState = getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, false);
				fieldState.isParsed = !valueIsFormattedAsString;
				fieldState.isChanged = true;
			}

			this.internalSetSublistBufferFieldValue = internalSetSublistBufferFieldValue;

			var getCurrentSublistText = utilityFunctions.thenableFunction(function getCurrentSublistText(options, fieldId, isAsync)
			{
				return implementation.getCurrentSublistText.thenable(convertCurrentLineInputToOptions(options, fieldId), undef, isAsync);
			}, {
				isAsyncArgIndex: 2
			});

			/**
			 * return the value for field in the current selected line by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {(number|Date|string|Array|boolean)}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if invalid sublist id or field id
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistText = getCurrentSublistText;

			var setCurrentSublistText = utilityFunctions.thenableFunction(function setCurrentSublistText(options, fieldId, text, proxyOptions, isAsync)
			{
				var converted = convertSublistFieldOptionIds(options, fieldId);
				return implementation.setCurrentSublistText.thenable(converted.options, converted.fieldId, text, proxyOptions, isAsync);
			}, {
				proxyOptionsArgIndex: 3,
				isAsyncArgIndex: 4
			});

			/**
			 * set the value for field in the current selected line by text representation
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {(number|Date|string|Array|boolean)} options.text
			 * @param {boolean} [options.ignoreFieldChange=false] ignore field change script and slaving event if set to true
			 * @return {Record} same record, for chaining
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} A_SCRIPT_IS_ATTEMPTING_TO_EDIT_THE_1_SUBLIST_THIS_SUBLIST_IS_CURRENTLY_IN_READONLY_MODE_AND_CANNOT_BE_EDITED_CALL_YOUR_NETSUITE_ADMINISTRATOR_TO_DISABLE_THIS_SCRIPT_IF_YOU_NEED_TO_SUBMIT_THIS_RECORD
			 *     if user tries to edit readonly sublist field
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.setCurrentSublistText = wrapMethod(setCurrentSublistText);

			function overwriteSublistState(clonedSublistState, sourceSublistState)
			{
				clonedSublistState.isDisplay = sourceSublistState.isDisplay;
				clonedSublistState.isChanged = sourceSublistState.isChanged;
				clonedSublistState.isHidden = sourceSublistState.isHidden;

				sourceSublistState.getLineInstanceIds(true).forEach(function (instanceId)
				{
					var lineFields = sourceSublistState.getAllLineFieldsForInstance(instanceId, true) || [];
					lineFields.forEach(function (fieldId)
					{
						overwriteFieldState(clonedSublistState.getFieldStateForInstance(fieldId, instanceId, true), sourceSublistState.getFieldStateForInstance(fieldId, instanceId, true));
					});
				});

				return clonedSublistState;
			}

			function overwriteSublistsState(sink, source)
			{
				source.getAllSublists().forEach(function (sublistId)
				{
					overwriteSublistState(sink.getSublistState(sublistId), source.getSublistState(sublistId));
				});

				return sink;
			}

			function overwriteFieldState(clonedFieldState, sourceFieldState)
			{
				clonedFieldState.useTextApi = sourceFieldState.useTextApi;
				clonedFieldState.isParsed = sourceFieldState.isParsed;
				clonedFieldState.isMandatory = sourceFieldState.isMandatory;
				clonedFieldState.isHidden = sourceFieldState.isHidden;
				clonedFieldState.isDisabled = sourceFieldState.isDisabled;
				clonedFieldState.isVisible = sourceFieldState.isVisible;
				clonedFieldState.isDisplay = sourceFieldState.isDisplay;
				clonedFieldState.isReadOnly = sourceFieldState.isReadOnly;
				clonedFieldState.ignoreSlaving = sourceFieldState.ignoreSlaving;
				clonedFieldState.isChanged = sourceFieldState.isChanged;
				clonedFieldState.label = sourceFieldState.label;
				clonedFieldState.id = sourceFieldState.id;

				return clonedFieldState;
			}

			function overwriteFieldsState(clonedRecordStateController, sourceRecordStateController)
			{
				sourceRecordStateController.getAllFields().forEach(function (fieldId)
				{
					overwriteFieldState(clonedRecordStateController.getFieldState(fieldId), sourceRecordStateController.getFieldState(fieldId));
				});

				return clonedRecordStateController;
			}

			function overwriteRecordState(clonedRecordStateController, sourceRecordStateController)
			{
				overwriteFieldsState(clonedRecordStateController, sourceRecordStateController);
				overwriteSublistsState(clonedRecordStateController, sourceRecordStateController);

				return clonedRecordStateController;
			}

			function createCheckpoint()
			{
				var clonedMetadata = getMetadata().clone();
				var clonedFormMetadata = util.extend({}, getFormMetadata());
				var clonedData = getModelController().clone();
				var statefulStores = getStatefulStores();
				clonedData.setParsedValueForBodyField(recordUtil.STATEFUL_STORE, statefulStores ? JSON.stringify(statefulStores) : null);
				var clonedState = overwriteRecordState(recordStateController.create({
					metadata: clonedMetadata,
					getModelController: function () { return clonedData; },
					getIsNSERecord: getIsNSERecord
				}), getRecordStateController());
				var clonedRecordContext = util.extend({}, getRecordRequestContext());

				return {
					metadata: clonedMetadata,
					formMetadata: clonedFormMetadata,
					data: clonedData,
					state: clonedState,
					recordContext: clonedRecordContext
				};
			}

			var clone = utilityFunctions.thenableFunction(function clone(isCommitted, isAsync)
			{
				var checkpoint = createCheckpoint();

				var clonedRecordObj = util.extend({}, recordObj);
				clonedRecordObj.config = util.extend(util.extend({}, recordObj.config), {noPageInit: true});
				clonedRecordObj.metadata = checkpoint.metadata;
				clonedRecordObj.formMetadata = checkpoint.formMetadata;
				clonedRecordObj.data = checkpoint.data;
				clonedRecordObj.state = checkpoint.state;
				clonedRecordObj.recordContext = checkpoint.recordContext;
				clonedRecordObj.initCallback = undefined;

				var clonedParentLink = util.extend({}, parentLink);
				clonedParentLink.isCommitted = isCommitted;

				return Record.create.thenable({
					recordObj: clonedRecordObj,
					parentLink: clonedParentLink
				}, isAsync);
			}, {
				isAsyncArgIndex: 1
			});

			this.clone = clone;

			/* synchronization */
			/*
			 * synchronize the line removal;
			 * @param {RawRecord} record
			 * @return {RawRecord} same record, for chaining
			 */
			var synchronization_removelines = utilityFunctions.thenableFunction(function synchronization_removelines(dynamicRecord)
			{
				var sublists = getModelController().getSublists();
				return utilityFunctions.forEachThenable(sublists, function (sublistId)
				{
					var sublistState = getSublistState(sublistId);
					if (!sublistState && shouldValidateFieldPermissions())
					{
						utilityFunctions.throwSuiteScriptError(error.Type.WS_NO_PERMISSIONS_TO_SET_VALUE, sublistId);
					}
					if (!sublistState || !sublistState.isChanged)
					{
						return;
					}

					var sysIdToLineInstanceIdMap = {};
					getSublistLineInstanceIds(sublistId, true).forEach(function (lineInstanceId)
					{
						if (sublistState.isLineInsertedForInstance(lineInstanceId, true))
						{
							return;
						}
						var sysId = doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, lineInstanceId, true);
						sysIdToLineInstanceIdMap[sysId] = lineInstanceId;
					});

					var dynamicSublistState = dynamicRecord.getSublistState(sublistId);
					return utilityFunctions.forEachThenable(dynamicRecord.getSublistLineInstanceIds(sublistId, true), function (dynamicInstanceId)
					{
						if (dynamicSublistState && dynamicSublistState.isLineInsertedForInstance(dynamicInstanceId, true))
						{
							return;
						}
						var dynamicSysId = dynamicRecord.doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, dynamicInstanceId, true);
						var lineInstanceId = sysIdToLineInstanceIdMap[dynamicSysId];
						if (!lineInstanceId)
						{
							return dynamicRecord.doRemoveLineForInstance.thenable(sublistId, dynamicInstanceId);
						}
					});
				});
			});

			/**
			 * synchronize this record to a record in args
			 * @param {RawRecord?} record
			 * @returns {RawRecord} record
			 */
			var synchronize = utilityFunctions.thenableFunction(function synchronize(record, isAsync)
			{
				var deferredDynamicRecordState = getRecordStateController();

				return resultObject.create(function ()
				{
					if (!record) // synchronize self
					{
						var newRecordObj = util.extend({}, recordObj);
						newRecordObj.config = util.extend(util.extend({}, recordObj.config), {isDynamic: true});
						return resultObject.create(function ()
						{
							return Record.create.thenable({'recordObj': newRecordObj, parentLink: null}, isAsync);
						}).then(function (newRecord)
						{
							record = newRecord;
						});
					}
				}).then(function ()
				{
					//1a body field changes
					var sysIdsUpdated = false;
					var sorted_bodyFields = _metadata.sortedFields;
					return utilityFunctions.forEachThenable(sorted_bodyFields, function (fieldId)
					{
						var fieldLevelMetadata = _metadata.getFieldMetadata(null, fieldId);
						var isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE;
						var fieldState = deferredDynamicRecordState.getFieldState(fieldId);
						var fieldChanged = !!fieldState && fieldState.isChanged;

						if (isSubrecordField)
						{
							if (!sysIdsUpdated)
							{
								record.internalSetFieldValue(subrecordUtil.SYS_ID, doGetValue(subrecordUtil.SYS_ID));
								sysIdsUpdated = true;
							}

							var deferredSubrecord = getModelController().getSubrecord(fieldId);

							return resultObject.create(function ()
							{
								if (fieldChanged)
								{
									return record.doRemoveSubrecord.thenable(fieldId, isAsync);
								}
							}).then(function ()
							{
								if (!!deferredSubrecord)
								{
									return resultObject.create(function ()
									{
										return record.doGetBodySubrecord.thenable(fieldId, undefined, undefined, isAsync);
									}).then(function (subrecord)
									{
										return deferredSubrecord.synchronize.thenable(subrecord, isAsync);
									}).then(function (subrecord)
									{
										return subrecord.commit.thenable(isAsync);
									});
								}
							});
						}
						else
						{
							if (fieldChanged)
							{
								if (fieldState.useTextApi)
								{
									return resultObject.create(function ()
									{
										return getText.thenable(fieldId, isAsync);
									}).then(function (text)
									{
										return record.setText.thenable(fieldId, text, undefined, isAsync);
									});
								}
								else
								{
									return record.setValue.thenable(fieldId, getValue(fieldId), undefined, isAsync);
								}
							}
						}
					});
				}).then(function ()
				{
					//1b non standard field changes
					var fields = deferredDynamicRecordState.getAllFields();
					return utilityFunctions.forEachThenable(fields, function (fieldId)
					{
						var fieldLevelMetadata = _metadata.getFieldMetadata(undef, fieldId);
						var fieldState = deferredDynamicRecordState.getFieldState(fieldId);
						var fieldChanged = !!fieldState && fieldState.isChanged;

						if (fieldLevelMetadata == null && fieldChanged)
						{
							if (fieldState.useTextApi)
							{
								return resultObject.create(function ()
								{
									return getText.thenable(fieldId, isAsync);
								}).then(function (text)
								{
									return record.setText.thenable(fieldId, text, undefined, isAsync);
								});
							}
							else
							{
								return record.setValue.thenable(fieldId, getValue(fieldId), undefined, isAsync);
							}
						}
					});
				}).then(function ()
				{
					//2 Remove any pre-existing sublist lines changed by the script/program/client
					return synchronization_removelines.thenable(record);
				}).then(function ()
				{
					//3 Apply sublists` changes in the order they naturally occur in the record. Apply sublist field changes based on
					// dependency graph and logical order
					var sublists = _metadata.sortedSublists;
					return utilityFunctions.forEachThenable(sublists, function (sublistId)
					{
						var sublistState = deferredDynamicRecordState.getSublistState(sublistId);
						var sublistMetadata = _metadata.getSublistMetadata(sublistId);
						if (!sublistState || !sublistState.isChanged || !sublistMetadata)
						{
							return;
						}

						var dynamicSublistState = record.getSublistState(sublistId);
						var sysIdToDynamicLineInstanceIdMap = {};
						record.getSublistLineInstanceIds(sublistId, true).forEach(function (dynamicLineInstanceId)
						{
							if (dynamicSublistState && dynamicSublistState.isLineInsertedForInstance(dynamicLineInstanceId, true))
							{
								return;
							}
							var dynamicSysId = record.doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, dynamicLineInstanceId, true);
							sysIdToDynamicLineInstanceIdMap[dynamicSysId] = dynamicLineInstanceId;
						});

						var previousInstanceId = null;
						return utilityFunctions.forEachThenable(getSublistLineInstanceIds(sublistId, true), function (defferredLineInstanceId, deferredDynamicRecordLineNum)
						{
							var sysId = doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, defferredLineInstanceId, true);
							var dynamicLineInstanceId = sysIdToDynamicLineInstanceIdMap[sysId];
							var dynamicRecordLineCount = record.doGetLineCount(sublistId);
							if (dynamicLineInstanceId)
							{
								if (!sublistState.isLineChangedForInstance(defferredLineInstanceId, true))
								{
									return;
								}
								var lineObjPromise = record.doSelectLineForInstance.thenable(sublistId, dynamicLineInstanceId);
							}
							else
							{
								var nextInstanceId = record.getLineInstanceId(sublistId, record.getLineIndexFromInstanceId(sublistId, previousInstanceId) + 1);
								lineObjPromise = record.doInsertLineForInstance.thenable(sublistId, nextInstanceId, sublistMetadata.isRecalcDeferred);
							}

							return lineObjPromise.then(function (lineObj)
							{
								var currentInstanceId = lineObj.instanceId;
								//TODO: update subrecord "thereWereRecordsToUpdate"
								var sys_id = doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, defferredLineInstanceId, true);
								if (!utilityFunctions.isValEmpty(sys_id))
								{
									record.internalSetSublistBufferFieldValue(sublistId, subrecordUtil.SYS_ID, currentInstanceId, sys_id);
								}
								// 3a : set any changed/submitted fields on the line
								var sysIdsUpdated = false;
								var sortedFields = sublistMetadata.sortedFields;
								return utilityFunctions.forEachThenable(sortedFields, function (fieldId)
								{
									var fieldLevelMetadata = _metadata.getFieldMetadata(sublistId, fieldId);
									var isSubrecordField = !!fieldLevelMetadata && fieldLevelMetadata.type === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE;
									var fieldState = sublistState.getFieldStateForInstance(fieldId, defferredLineInstanceId, true);
									var fieldChanged = !!fieldState && fieldState.isChanged;
									if (isSubrecordField)
									{
										if (!sysIdsUpdated)
										{
											record.internalSetSublistBufferFieldValue(sublistId, subrecordUtil.SYS_ID, currentInstanceId, doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_ID, defferredLineInstanceId, true));
											record.internalSetSublistBufferFieldValue(sublistId, subrecordUtil.SYS_PARENT_ID, currentInstanceId, doGetSublistValueForInstance(sublistId, subrecordUtil.SYS_PARENT_ID, defferredLineInstanceId, true));
											sysIdsUpdated = true;
										}

										var deferredSubrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, defferredLineInstanceId, true);

										return resultObject.create(function ()
										{
											if (fieldChanged)
											{
												return record.doRemoveSublistSubrecordForInstance.thenable(sublistId, fieldId, currentInstanceId, false, isAsync);
											}
										}).then(function ()
										{
											if (!!deferredSubrecord)
											{
												return resultObject.create(function ()
												{
													return record.doGetCurrentSublistSubrecord.thenable(sublistId, fieldId, undefined, isAsync);
												}).then(function (subrecord)
												{
													return deferredSubrecord.synchronize.thenable(subrecord, isAsync);
												}).then(function (subrecord)
												{
													return subrecord.commit.thenable(isAsync);
												});
											}
										});
									}
									else
									{
										if (fieldChanged)
										{
											if (fieldState.useTextApi)
											{
												return resultObject.create(function ()
												{
													return getSublistText.thenable(sublistId, fieldId, deferredDynamicRecordLineNum, isAsync);
												}).then(function (text)
												{
													return record.doSetSublistTextForInstance.thenable(sublistId, fieldId, currentInstanceId, false, text, undefined, undefined, undefined, undefined, isAsync);
												});
											}
											else
											{
												var value = getSublistValue(sublistId, fieldId, deferredDynamicRecordLineNum);
												return record.doSetSublistBufferValue.thenable(sublistId, fieldId, currentInstanceId, value, undefined, undefined, undefined, undefined, undefined, isAsync);
											}
										}
									}
								}).then(function ()
								{
									var backwardCompatibilityFieldNames = sublistMetadata.backwardCompatibilityFieldNamesForSubrecord;
									var sublistFields = sublistState.getAllFields();
									return utilityFunctions.forEachThenable(sublistFields, function (fieldId)
									{
										var defferedFieldState = sublistState.getFieldStateForInstance(fieldId, defferredLineInstanceId, true);
										if (backwardCompatibilityFieldNames.indexOf(fieldId) == -1 &&
											sublistMetadata.getFieldMetadata(fieldId) == null &&
											defferedFieldState && defferedFieldState.isChanged)
										{
											if (defferedFieldState.useTextApi)
											{
												return resultObject.create(function ()
												{
													return getSublistText.thenable(sublistId, fieldId, deferredDynamicRecordLineNum, isAsync);
												}).then(function (text)
												{
													return record.doSetSublistTextForInstance.thenable(sublistId, fieldId, currentInstanceId, false, text, undefined, undefined, undefined, undefined, isAsync);
												});
											}
											else
											{
												var value = getSublistValue(sublistId, fieldId, deferredDynamicRecordLineNum);
												return record.doSetSublistBufferValue.thenable(sublistId, fieldId, currentInstanceId, value, false, undefined, undefined, undefined, undefined, isAsync);
											}
										}
									});
								}).then(function ()
								{
									return record.commitLineAndSelectNew.thenable(sublistId, currentInstanceId, sublistMetadata.isRecalcDeferred, isAsync);
								}).then(function ()
								{
									var linesAddedInThisIteration = record.doGetLineCount(sublistId) - dynamicRecordLineCount;

									// In some cases when a line is committed, more that one line is added to the
									// machine.  For example, when an item group is set on a line, its members
									// are expanded.
									// We need to account for this by incrementing the dynamic record line number by the
									// number of lines beyond one.
									if (linesAddedInThisIteration > 1)
									{
										currentInstanceId = record.getLineInstanceId(sublistId, record.getLineIndexFromInstanceId(sublistId, currentInstanceId) + linesAddedInThisIteration - 1);
									}

									previousInstanceId = currentInstanceId;
								});
							});
						}).then(function ()
						{
							if (sublistMetadata.isRecalcDeferred)
							{
								return record.triggerRecalcScript.thenable(sublistId, false, {operation: 'batchcommit'});
							}
						});
					});
				}).then(function ()
				{
					return record;
				});
			}, {
				isAsyncArgIndex: 1
			});

			this.synchronize = synchronize;

			function getQuery()
			{
				return slaving.cleanupQueryURL(_metadata.queryUrl);
			}

			function save(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				/* It's not allowed to save the current record from within a client script. */
				if (getIsCurrentRecord() && scope.isExecutionWithinAClientScript())
				{
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);
				}
				/* Synchronous save not allowed on NSE (asynchronous) record */
				if (getIsNSERecord())
				{
					utilityFunctions.throwSuiteScriptError(error.Type.YOU_HAVE_ATTEMPTED_AN_UNSUPPORTED_ACTION);
				}

				var argList = doSave(options, false);
				var result = invoker(remoteApi, 'submitDynamicClientRecord', argList);
				try
				{
					return returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10);
				}
				finally
				{
					abandonBodySubrecords();
				}
			}

			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {number} id of submitted record
			 *
			 * @since 2015.2
			 */
			this.save = wrapMethod(utilityFunctions.thenableFunction(function(options, isAsync)
			{
				return (isAsync ? promiseToSave : save)(options, false);
			}, {
				isAsyncArgIndex: 1
			}));

			/*
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Object} contains id of submitted record
			 */
			this.saveAndFetch = wrapMethod(utilityFunctions.thenableFunction(function(options, isAsync)
			{
				return (isAsync ? promiseToSave : save)(options, true);
			}, {
				isAsyncArgIndex: 1
			}));

			function promiseToSave(options, returnFetchedObject)
			{
				options = options || {};
				if (returnFetchedObject)
				{
					options.returnLabel = true;
					options.returnMessage = true;
				}
				else
					delete options.isFormSave; // allow this only in saveAndFetch (which is only available in interactive mode)

				function preSubmitDynamicClientRecord(promiseCallbacks)
				{
					var submitArguments;
					return resultObject.create(function () 
					{
						return doSave.thenable(options, true);
					}).then(function (argList) 
					{
						submitArguments = argList;
						return getIsNSERecord() ? serverMandatorinessCheck.thenable(that, returnFetchedObject) : null;
					}).then(function (result)
					{
						return result ? result : invoker.promise(remoteApi, 'submitDynamicClientRecord', submitArguments);
					}).then(function (result) 
					{
						abandonBodySubrecords();
						return returnFetchedObject ? saveResult.create(options, result) : parseInt(result.recordData.id, 10);
					}).then(promiseCallbacks.resolve, promiseCallbacks.reject);
				}

				return getModelController().getPendingSavePromise({delegateFunction: preSubmitDynamicClientRecord});
			}

			// noinspection SillyAssignmentJS
			/**
			 * save record updates to the system
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} id of submitted record
			 *
			 * @since 2015.2
			 */
			this.save.promise = this.save.promise;

			/*
			 * Save record updates to the system and return object with additional information about the saved record.
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {boolean} [options.enableSourcing=false] enable sourcing during record update
			 * @param {boolean} [options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 * @return {Promise} Object containing id of submitted record
			 */
			// noinspection SillyAssignmentJS
			this.saveAndFetch.promise = this.saveAndFetch.promise;

			var doSave = utilityFunctions.thenableFunction(function doSave(options, isAsync)
			{
				options = options || {};
				var submitOptions = {
					enablesourcing: options['enableSourcing'] === true,
					disabletriggers: options['disableTriggers'] === true,
					ignoremandatoryfields: options['ignoreMandatoryFields'] === true,
					returnlabel: options['returnLabel'] === true,
					returnmessage: options['returnMessage'] !== false,
					failOnAfterSubmitScriptError: options['returnMessage'] === false
				};
				if (options.hasOwnProperty('isFormSave'))
					submitOptions.isFormSave = options.isFormSave === true;

				handleRecordSpecificSaveOptions(getRecordType(), options, submitOptions);

				var dynamicRecordToBeSubmitted;

				return resultObject.create(function ()
				{
					return getIsDynamicRecord() ? that : synchronize.thenable(undefined, isAsync);
				}).then(function (record)
				{
					dynamicRecordToBeSubmitted = record;
					return dynamicRecordToBeSubmitted.commitSubrecords.thenable(isAsync);
				}).then(function ()
				{
					if (dynamicRecordToBeSubmitted.getIsNSERecord()) {
						return fullMandatorinessCheck.thenable(dynamicRecordToBeSubmitted);
					}
				}).then(function ()
				{
					dynamicRecordToBeSubmitted.getModelController().setSaveRecordScriptTriggered();
					return dynamicRecordToBeSubmitted.triggerSaveRecordScript.thenable(submitOptions.ignoremandatoryfields);
				}).then(function ()
				{
					dynamicRecordToBeSubmitted.getModelController().unsetSaveRecordScriptTriggered();
					var data = dynamicRecordToBeSubmitted.getRecordData();
					return [getRecordType(), data.fields, data.sublists, submitOptions];
				});
			}, {
				isAsyncArgIndex: 1
			});

			function handleRecordSpecificSaveOptions(recType, options, submitOptions)
			{
				var possibleSaveOptions = RECORD_SPECIFIC_SAVE_OPTIONS[recType];
				if (utilityFunctions.isObject(options) && util.isArray(possibleSaveOptions))
				{
					for (var i = 0; i < possibleSaveOptions.length; i++)
					{
						var thisPossibleOption = possibleSaveOptions[i];
						if (options.hasOwnProperty(thisPossibleOption))
						{
							submitOptions[thisPossibleOption] = options[thisPossibleOption];
						}
					}
				}
			}

			var commitSubrecords = utilityFunctions.thenableFunction(function commitSubrecords(isAsync)
			{
				var bodyFields = getModelController().getBodyFieldIds();
				return utilityFunctions.forEachThenable(bodyFields, function (fieldId)
				{
					var subrecord = getModelController().getSubrecord(fieldId);
					if (subrecord)
					{
						return subrecord.commit.thenable(isAsync);
					}
				});
			}, {
				isAsyncArgIndex: 0
			});

			this.commitSubrecords = commitSubrecords;

			/**
			 * commit buffered sublist subrecord
			 * @param {string} sublistId
			 * @param {string} lineInstanceId
			 */
			var commitBufferedSublistSubrecordsForInstance = utilityFunctions.thenableFunction(function commitBufferedSublistSubrecordsForInstance(sublistId, lineInstanceId, isAsync)
			{
				var sublistLineFieldIds = getModelController().getSublistLineFieldIds(sublistId, lineInstanceId, false);
				return utilityFunctions.forEachThenable(sublistLineFieldIds, function (fieldId)
				{
					var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, false);
					if (subrecord)
					{
						return subrecord.commit.thenable(isAsync);
					}
				});
			}, {
				isAsyncArgIndex: 2
			});

			function abandonBodySubrecords()
			{
				var bodyFields = getModelController().getBodyFieldIds();
				bodyFields.forEach(function (fieldId)
				{
					var subrecord = getModelController().getSubrecord(fieldId);
					if (subrecord)
					{
						subrecord.abandon();
					}
				});
			}

			function abandonSublisBufferSubrecords(sublistId, lineInstanceId)
			{
				var sublistLineFieldIds = getModelController().getSublistLineFieldIds(sublistId, lineInstanceId, false);
				sublistLineFieldIds.forEach(function (fieldId)
				{
					var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, false);
					if (subrecord)
					{
						subrecord.abandon();
					}
				});
			}

			var checkMandatory = utilityFunctions.thenableFunction(function checkMandatory(record, sublistId, lineInstanceId)
			{
				var isCommitted = !lineInstanceId;
				return resultObject.create(function () {
					var missing;
					if (sublistId) {
						missing = record.getBlankMandatorySublistFields.thenable(sublistId, lineInstanceId, !lineInstanceId);
					} else {
						missing = record.getBlankMandatoryBodyFields.thenable();
					}
					return missing;
				}).then(function (missing) {
					if (sublistId) { // get first violating line, if any
						lineInstanceId = Object.keys(missing)[0];
						missing = lineInstanceId ? missing[lineInstanceId] : null;
					}
					if (missing && missing.length)
					{
						var createAndThrow = utilityFunctions.thenableFunction(function() {
							var errorObj = utilityFunctions.createSuiteScriptError(error.Type.MISSING_MANDATORY_FIELDS, missing.join(', '));
							errorObj.validationDetail = {
								valid: false,
								fields: missing.map(function(v) { return {id: v}; }),
								messages: [errorObj.message]
							}
							if (sublistId)
								errorObj.validationDetail.sublistId = sublistId;
							if (lineInstanceId)
								errorObj.validationDetail.lineId = lineInstanceId;
							throw errorObj;
						});
						return recordDefinitionEvent.wrapEmitValidationError({
							record: record,
							sublistId: sublistId,
							lineInstanceId: lineInstanceId,
							isCommitted: isCommitted,
							func: createAndThrow,
							emitter: emitter
						}).thenable();
					}
				})
			});

			var fullMandatorinessCheck = utilityFunctions.thenableFunction(function fullMandatorinessCheck(record)
			{
				return utilityFunctions.forEachThenable(getSublists(), function (sublistId)
				{
					return checkMandatory.thenable(record, sublistId, null);
				}).then(function ()
				{
					return checkMandatory.thenable(record);
				});
			});

			var serverMandatorinessCheck = utilityFunctions.thenableFunction(function serverMandatorinessCheck(record, returnFetchedObject)
			{
				return resultObject.create(function()
				{
					return doServerMandatorinessCheck.thenable(record, '');
				}).then(function(result) {
					if (result.length > 0) {
						var errorObj = utilityFunctions.createSuiteScriptError(error.Type.SERVER_SIDE_VALIDATION_FAILED, result.join('\n'));
						if (returnFetchedObject)
							return {recordData: {}, notifications: [{message: errorObj.message, title: errorObj.name, type: 3}]};
						throw errorObj;
					}
					return null;
				});
			});

			var doServerMandatorinessCheck = utilityFunctions.thenableFunction(function doServerMandatorinessCheck(record, prefix)
			{
				var res = [];
				var missing = record.getBlankMandatoryBodyFields(true);
				if (missing.length)
				{
					res.push(prefix + 'body: ' + missing.join(', '));
				}
				var bodySubrecords = record.getBodySubrecords();
				Object.keys(bodySubrecords).forEach(function(fieldId) {
					var subRes = doServerMandatorinessCheck(bodySubrecords[fieldId], prefix + fieldId + '.');
					Array.prototype.push.apply(res, subRes);
				})
				var sublists = record.getSublists();
				sublists.forEach(function(sublistId) {
					var missing = record.getBlankMandatorySublistFields(sublistId, null, true, true);
					Object.keys(missing).forEach(function(lineInstanceId) {
						var idx = record.getLineIndexFromInstanceId(sublistId, lineInstanceId, true);
						res.push(prefix + sublistId + '.' + idx + ': ' + missing[lineInstanceId].join(', '));
					});
					var lineInstanceIds = record.getSublistLineInstanceIds(sublistId, true);
					lineInstanceIds.forEach(function(lineInstanceId) {
						var sublistSubrecords = record.getSublistSubrecords(sublistId, lineInstanceId, true);
						Object.keys(sublistSubrecords).forEach(function (fieldId) {
							var idx = record.getLineIndexFromInstanceId(sublistId, lineInstanceId, true);
							var subRes = doServerMandatorinessCheck(sublistSubrecords[fieldId], prefix + sublistId + '.' + idx + '.' + fieldId + '.');
							Array.prototype.push.apply(res, subRes);
						})
					});
				})
				return res;
			});

			function getRecordData()
			{
				var CREATE = 'CREATE', EDIT = 'EDIT', VIEW = 'VIEW';

				var body = {},
					sublists = {},
					mainFieldNames = getFields(),
					sublistNames = _metadata.sublistIds;

				mainFieldNames.forEach(function (fieldId)
				{
					var value = getValueAsLegacyString(fieldId);
					if (value !== undef)
					{
						body[fieldId] = recordUtil.emptyIfNullOrUndefined(value);
					}
				});

				var subrecordData = getModelController().getSubrecordDataForSubmission();
				if (subrecordData)
				{
					Object.keys(subrecordData).forEach(function (v)
					{
						sublists[v] = subrecordData[v];
						body['next' + v + 'idx'] = String(subrecordData[v].size + 1);
					});
				}

				sublistNames.forEach(function (sublistId)
				{
					var sublistData = {};
					sublistData.fields = _metadata.getAllSublistFields(sublistId);
					if (sublistData.fields.length > 0) // skip sublist without field information
					{
						if (subrecordData)
						{
							sublistData.fields.splice(0, 0, subrecordUtil.SYS_PARENT_ID, subrecordUtil.SYS_ID, subrecordUtil.SYS_OP);
						}
						sublistData.size = doGetLineCount(sublistId);
						sublistData.data = doGetLineCount(sublistId) > 0 ? [] : null;
						for (var ln = 0; ln < doGetLineCount(sublistId); ln++)
						{
							var lineInstanceId = getLineInstanceId(sublistId, ln);

							var sublistLine = sublistData.fields.map(function (fieldId)
							{
								if (fieldId === subrecordUtil.SYS_OP)
								{
									var operation = EDIT;
									if (!getSublistState(sublistId).isLineChangedForInstance(lineInstanceId, true))
									{
										operation = VIEW;
									}
									if (getSublistState(sublistId).isLineInsertedForInstance(lineInstanceId, true))
									{
										operation = CREATE;
									}
									return operation;
								}
								return recordUtil.emptyIfNullOrUndefined(getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, true));
							});

							sublistData.data[ln] = sublistLine;
						}

						sublists[sublistId] = sublistData;
					}
				});

				if (getStatefulStores()) {
					body[recordUtil.STATEFUL_STORE] = JSON.stringify(getStatefulStores());
				}

				return {fields: body, sublists: sublists};
			}

			this.getRecordData = getRecordData;

			function handleChangeCall(params)
			{
				if (getIsDynamicRecord())
				{
					var sysId = doGetValue(subrecordUtil.SYS_ID),
						sysParentId = doGetValue(subrecordUtil.SYS_PARENT_ID);
					var context = getRecordRequestContext();
					params = utilityFunctions.addParameterToMap(context, params);
					params.recordmode = 'dynamic';

					if (getIsCurrentRecord() && getIsInteractive() && !getIsSubrecord())
					{
						// let UI handle the change
						var event = {type: recordDefinitionEvent.Type.HANDLE_CHANGE_CALL, record: that, params: params};
						emitter.emit(event);
						return;
					}

					//noinspection JSUnresolvedVariable
					var nsrecord = invoker(remoteApi, 'handleChangeCall', [getRecordType(), getId(), params, true /*isClientRecord*/]);

					// reset Record Metadata and Data
					setRecordRequestContext(nsrecord.recordContext);
					setScriptingContext(nsrecord.scriptingContext);
					_statefulStores = {}; // for now, the desired behavior is that changeCall erases the record scripting storage

					setMetadata(metadata.create(nsrecord.metadata));
					setModelController(modelController.create({
						metadata: _metadata,
						data: nsrecord.data,
						getIsNSERecord: getIsNSERecord
					}));
					setRecordStateController(recordStateController.create({
						metadata: _metadata,
						getModelController: getModelController,
						getIsNSERecord: getIsNSERecord
					}));

					internalSetFieldValue(subrecordUtil.SYS_ID, sysId, true, false);
					internalSetFieldValue(subrecordUtil.SYS_PARENT_ID, sysParentId, true, false);

					scope.create.thenable({
						record: that,
						libraryScript: getMetadata().libraryScript,
						staticScript: getMetadata().staticScript,
						uiFormScript: getMetadata().uiFormScript,
						workflowScript: getMetadata().workflowScript,
						initCallback: setRecordScriptingScope,
						completeInternalInit: completeInternalInit,
						completePageInit: completePageInit
					}, false).then(function() {
						recordDefinitionEvent.emitUpdateAll(emitter, that);
					});
				}
			}

			this.handleChangeCall = handleChangeCall;

			function callRestrictedMethod(options)
			{
				options = options || {};
				utilityFunctions.checkArgs([options.token, options.methodName], ['token', 'methodName'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));

				if (options.token != null && options.token === recordObj.token)
				{
					this[options.methodName].apply(this, options.args || []);
				}
			}

			this.callRestrictedMethod = wrapMethod(callRestrictedMethod);

			this.runLegacyScript = function runLegacyScript(script)
			{
				return _recordScriptingV1Scope.runLegacyScript(script);
			};

			/* Subrecord APIs */
			function subrecord_init()
			{
				checkpoint = createCheckpoint();
			}

			function subrecord_updateFieldState(isChanged)
			{
				var subrecordSublistState = getSubrecordSublistState();
				if (subrecordSublistState != null)
				{
					subrecordSublistState.isChanged = isChanged;
				}
				var subrecordFieldState = getSubrecordFieldState();
				if (subrecordFieldState != null)
				{
					subrecordFieldState.isChanged = isChanged;
				}
			}

			function getSubrecordSublistState()
			{
				return parentLink && parentLink.record.getSublistState(parentLink.sublistId);
			}

			this.getSubrecordSublistState = getSubrecordSublistState;

			function getSubrecordFieldState()
			{
				var subrecordSublistState = getSubrecordSublistState();

				if (subrecordSublistState)
				{
					var shouleBeModelInvalidated = subrecordSublistState.willCallOfGetFieldStateForInstanceCauseUpdateOfBuffer(parentLink.lineInstanceId, parentLink.isCommitted);
					var fieldState = subrecordSublistState.getFieldStateForInstance(parentLink.fieldId, parentLink.lineInstanceId, parentLink.isCommitted);
					if (shouleBeModelInvalidated)
					{
						getModelController().invalidateSublistRecordCacheForInstance(parentLink.sublistId, parentLink.lineInstanceId);
					}

					return fieldState;
				}

				return null;
			}

			this.getSubrecordFieldState = getSubrecordFieldState;

			var subrecord_commit = utilityFunctions.thenableFunction(function subrecord_commit(isAsync)
			{
				return resultObject.create(function ()
				{
					return subrecord_validate.thenable(isAsync);
				}).then(function ()
				{
					var wasChanged = getIsChanged() || (isNewRecord() && !subrecord_isCommitted);

					clearIsChanged();
					subrecord_isCommitted = true;
					subrecord_init();

					if (wasChanged)
					{
						subrecord_triggerSubrecordUpdateEventOnParent();
					}
				});
			}, {
				isAsyncArgIndex: 0
			});

			var subrecord_cancel = utilityFunctions.thenableFunction(function subrecord_cancel()
			{
				var wasChanged = getIsChanged();

				setMetadata(checkpoint.metadata);
				setFormMetadata(checkpoint.formMetadata);
				setModelController(checkpoint.data);
				setRecordStateController(checkpoint.state);
				setRecordRequestContext(checkpoint.recordContext);
				subrecord_init();

				if (wasChanged)
				{
					recordDefinitionEvent.emitUpdateAll(emitter, that, recordDefinitionEvent.Origin.CANCEL);
					subrecord_triggerSubrecordUpdateEventOnParent();
				}
			});

			function subrecord_triggerSubrecordUpdateEventOnParent()
			{
				parentLink.record.triggerSubrecordEvent(recordDefinitionEvent.Type.UPDATE_SUBRECORD, parentLink.sublistId, parentLink.fieldId, parentLink.lineInstanceId, that, parentLink.isCommitted);
			}

			function triggerSubrecordEvent(type, sublistId, fieldId, lineInstanceId, subrecord, isCommitted)
			{
				implementation.triggerSubrecordEvent(type, sublistId, fieldId, lineInstanceId, subrecord, isCommitted);
			}

			this.triggerSubrecordEvent = triggerSubrecordEvent;

			function doTriggerSubrecordEvent(type, sublistId, fieldId, lineInstanceId, subrecord, isCommitted)
			{
				recordDefinitionEvent.emitSubrecordEvent(emitter, type, that, sublistId, fieldId, subrecord, lineInstanceId, isCommitted);
			}

			this.doTriggerSubrecordEvent = doTriggerSubrecordEvent;

			//TODO move to subrecord wrapper
			function subrecord_abandon()
			{
				if (parentLink)
				{
					parentLink.record.getModelController().invalidateSublistSubrecordForInstance(parentLink.sublistId, parentLink.fieldId, parentLink.lineInstanceId, parentLink.isCommitted);
					parentLink = null;
					internalSetFieldValue(subrecordUtil.SYS_PARENT_ID, null);
				}
			}

			//TODO move to subrecord wrapper
			function subrecord_isAbandoned()
			{
				return !parentLink;
			}

			var subrecord_validate = utilityFunctions.thenableFunction(function subrecord_validate(isAsync)
			{
				if (getIsChanged() || (isNewRecord() && !subrecord_isCommitted))
				{
					return resultObject.create(function ()
					{
						if (that.getIsNSERecord()) {
							return fullMandatorinessCheck.thenable(that);
						}
					}).then(function ()
					{
						return triggerSaveRecordScript.thenable(false);
					}).then(function ()
					{
						return subrecord_triggerPostValidationEventOnParent.thenable(isAsync);
					});
				}
			}, {
				isAsyncArgIndex: 0
			});

			var subrecord_triggerPostValidationEventOnParent = utilityFunctions.thenableFunction(function subrecord_triggerPostValidationEventOnParent(isAsync)
			{
				var subrecordParent = parentLink.record;
				var subrecordSublistId = parentLink.sublistId;
				var subrecordFieldId = parentLink.fieldId;
				var lineInstanceId;
				var value;

				if (!subrecordSublistId)
				{
					value = subrecordParent.getValue(subrecordFieldId);
				}
				else
				{
					lineInstanceId = subrecordParent.doGetCurrentSublistLineInstanceId(subrecordSublistId);
					value = subrecordParent.getCurrentSublistValue(subrecordSublistId, subrecordFieldId);
				}

				return subrecordParent.triggerFieldChangeEvent.thenable(subrecordSublistId, subrecordFieldId, lineInstanceId, false, String(value), false, isAsync);
			}, {
				isAsyncArgIndex: 0
			});

			function doGetSubrecordInitialParamsInfo(sublistId, fieldId)
			{
				var fieldMetadata = _metadata.getFieldMetadata(sublistId, fieldId),
					initialParams = fieldMetadata.subrecordInitialParameters || [];

				return initialParams;
			}

			function getSystemId()
			{
				return getModelController().getSystemId();
			}

			this.getSystemId = getSystemId;

			function doGetSubrecordInitialParamsForInstance(field, lineInstanceId, isCommitted, isReadOnly)
			{
				var result = {_subrecord_api: true},
					sublistId = field.getSublistName(),
					fieldId = field.getName(),
					initialParams = doGetSubrecordInitialParamsInfo(sublistId, fieldId);

				initialParams.forEach(function (v)
				{
					var param = v.param,
						path = v.path.split('.'),
						mandatory = v.mandatory,
						value = path.length === 1 && path[0] || null;

					if (path.length > 1)
					{
						if (!!sublistId)
						{
							if (path.length === 2)
							{
								value = getModelController()
									.getSublistLineValueAsLegacyStringForInstance(sublistId, path[1], lineInstanceId, isCommitted);
							}
							else
							{
								value = doGetValue(path[2]);
							}
						}
						else
						{
							value = doGetValue(path[1]);
						}
					}

					if (mandatory || value !== undef && value !== null && value !== '')
					{
						result[param] = value;
					}
				});

				if (isReadOnly)
				{
					result.recordmode = 'view';
				}
				else if (getIsDynamicRecord())
				{
					result.recordmode = 'dynamic';
				}
				if (recordObj.isInteractive && getIsCurrentRecord())
				{
					result.withFormMetadata = true;
				}

				return result;
			}

			var doGetSubrecordFromServerForInstance = utilityFunctions.thenableFunction(function doGetSubrecordFromServerForInstance(field, id, lineInstanceId, isCommitted, isReadOnly, isAsync)
			{
				var sublistId, fieldId, type, initialParams;

				if (field === null || field.getType() !== fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, field.getName());
				}
				else
				{
					sublistId = field.getSublistName();
					fieldId = field.getName();
					type = field.getSubrecordType();
					initialParams = doGetSubrecordInitialParamsForInstance(field, lineInstanceId, isCommitted, isReadOnly);
					var parentSystemId = getModelController().getParentSystemIdForInstance(sublistId, lineInstanceId, isCommitted);
					var parentLink = {
						record: that,
						sublistId: sublistId,
						fieldId: fieldId,
						lineInstanceId: lineInstanceId,
						isCommitted: isCommitted
					};

					var isCreate = !id;
					var method = isCreate ? 'createRecord' : 'loadRecord';
					var params = isCreate ? [type, initialParams] : [type, String(id), initialParams];

					if (isCreate) {
						delete initialParams.id;
						triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId);
					}
					return resultObject.create(function () {
						return (isAsync ? invoker.promise : invoker)(apiBridge, method, params);
					}).then(function (nsrecord) {
						nsrecord.config.isCurrentRecord = getIsCurrentRecord();
						nsrecord.config.initialization = {
							method: method,
							params: util.extend(isCreate ? {} : {id: String(id)}, {
								type: type,
								defaults: initialParams
							})
						};
						nsrecord.data.bodyField.sys_parentid = [parentSystemId];

						return Record.create.thenable({
							recordObj: nsrecord,
							parentLink: parentLink
						}, isAsync);
					}).then(function (result) {
						if (isCreate) {
							triggerSubrecordEvent(recordDefinitionEvent.Type.CREATE_SUBRECORD, sublistId, fieldId, lineInstanceId, result, parentLink.isCommitted);
						}
						return result;
					});
				}
			}, {
				isAsyncArgIndex: 5
			});

			function hasSubrecord(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('hasSubrecord'));
				return doHasSubrecord(idConverterService.convertBodyFieldId(that, fieldId));
			}

			/**
			 * return a value indicating if the field has a subrecord
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {boolean}
			 *
			 * @since 2015.2
			 */
			this.hasSubrecord = hasSubrecord;

			function doHasSubrecord(fieldId)
			{
				return doHasSubrecordForInstance(undef, fieldId, undef, true);
			}

			this.doHasSubrecord = doHasSubrecord;

			var getSubrecord = utilityFunctions.thenableFunction(function getSubrecord(options, proxyOptions, isAsync)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getSubrecord'));
				return doGetBodySubrecord.thenable(idConverterService.convertBodyFieldId(that, fieldId), getIsReadOnlyRecord(), proxyOptions, isAsync);
			}, {
				proxyOptionsArgIndex: 1,
				isAsyncArgIndex: 2
			});

			/**
			 * get the subrecord for the associated field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Subrecord} [client-side subrecord implementation]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 *
			 * @since 2015.2
			 */
			this.getSubrecord = wrapMethod(getSubrecord);

			/**
			 * get the subrecord for the associated field
			 * @function Record#getSubrecord.promise
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Promise<Record>} [client-side subrecord implementation]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 * @throws {SuiteScriptError} FIELD_1_IS_NOT_A_SUBRECORD_FIELD if field is not a subrecord field
			 * @throws {SuiteScriptError} FIELD_1_IS_DISABLED_YOU_CANNOT_APPLY_SUBRECORD_OPERATION_ON_THIS_FIELD if field is disable
			 *
			 * @since 2015.2
			 */

			var removeSubrecord = utilityFunctions.thenableFunction(function removeSubrecord(options, isAsync)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('removeSubrecord'));

				fieldId = idConverterService.convertBodyFieldId(that, fieldId);

				if (!hasFieldValueOrFieldExisted(fieldId))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				return resultObject.create(function ()
				{
					return doRemoveSubrecord.thenable(fieldId, isAsync);
				}).then(function ()
				{
					return that;
				});
			}, {
				isAsyncArgIndex: 1
			});

			/**
			 * remove the subrecord for the associated field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.removeSubrecord = wrapMethod(removeSubrecord);

			function performSubrecordRemoval(fieldId)
			{
				var isCommitted = true;
				var sublistId = undef;
				var lineInstanceId = null;
				doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				getModelController().removeFieldValue(fieldId);
			}

			this.performSubrecordRemoval = performSubrecordRemoval;

			var doRemoveSubrecord = utilityFunctions.thenableFunction(function doRemoveSubrecord(fieldId, isAsync)
			{
				var sublistId = undef;
				performSubrecordRemoval(fieldId);
				var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
				if (!!subrecordKeyFieldId)
				{
					var keyFieldId = subrecordKeyFieldId[0];
					var value = '';
					var fireFieldChanged = true;
					var noSlaving = false;
					return doSetFieldValue.thenable(keyFieldId, value, fireFieldChanged, noSlaving, undefined, undefined, isAsync);
				}
			}, {
				isAsyncArgIndex: 1
			});

			this.doRemoveSubrecord = doRemoveSubrecord;

			function doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				if (getModelController().hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
				{
					var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					if (!!subrecord)
					{
						subrecord.abandon();
					}
					getModelController().clearSubrecordCacheForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					triggerSubrecordEvent(recordDefinitionEvent.Type.REMOVE_SUBRECORD, sublistId, fieldId, lineInstanceId, null, isCommitted);
				}
			}

			var doRemoveSublistSubrecordForInstance = utilityFunctions.thenableFunction(function doRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, isAsync)
			{
				doRemoveSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				return postRemoveSublistSubrecordForInstance.thenable(sublistId, fieldId, lineInstanceId, isCommitted, isAsync);
			}, {
				isAsyncArgIndex: 4
			});

			this.doRemoveSublistSubrecordForInstance = doRemoveSublistSubrecordForInstance;

			var postRemoveSublistSubrecordForInstance = utilityFunctions.thenableFunction(function postRemoveSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, isAsync)
			{
				var value = null;
				if (!isCommitted)
				{
					var fireFieldChanged = true;
					return resultObject.create(function ()
					{
						return doSetSublistBufferValue.thenable(sublistId, fieldId, lineInstanceId, value, fireFieldChanged, undefined, undefined, undefined, undefined, isAsync);
					}).then(function ()
					{
						var subrecordKeyFieldId = getSubrecordKeyFieldId(sublistId, fieldId);
						if (!!subrecordKeyFieldId)
						{
							return doSetSublistBufferValue.thenable(sublistId, subrecordKeyFieldId[0], lineInstanceId, '', fireFieldChanged, undefined, undefined, undefined, undefined, isAsync);
						}
					});
				}
				else
				{
					return doSetSublistCommittedValue.thenable(sublistId, fieldId, lineInstanceId, value);
				}
			}, {
				isAsyncArgIndex: 4
			});

			function getSubrecordKeyFieldId(sublistId, fieldId)
			{
				var subrecordKeyFieldId = doGetSubrecordInitialParamsInfo(sublistId, fieldId).reduce(function (p, c)
				{
					return p || (c.param === 'id' && c.path) || null;
				}, null);

				return SUBRECORD_KEY_FIELDID_REGEX.test(subrecordKeyFieldId) && subrecordKeyFieldId.split('.').slice(-1) || null;
			}

			function hasSublistSubrecord(options, fieldId, line)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));
				validateLineIndex(line, sublistId, false);
				var lineInstanceId = getLineInstanceId(sublistId, line);
				return doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, true);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord
			 * @governance 0
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {boolean}
			 *
			 * @since 2015.2
			 */
			this.hasSublistSubrecord = hasSublistSubrecord;

			function doHasSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				return getModelController().hasSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.doHasSubrecordForInstance = doHasSubrecordForInstance;

			var getSublistSubrecord = utilityFunctions.thenableFunction(function getSublistSubrecord(options, fieldId, line, proxyOptions, isAsync)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistSubrecord'));
				return implementation.getSublistSubrecord.thenable(sublistId, fieldId, line, proxyOptions, isAsync);
			}, {
				proxyOptionsArgIndex: 3,
				isAsyncArgIndex: 4
			});

			/**
			 * get the subrecord for the associated sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Subrecord} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */
			this.getSublistSubrecord = wrapMethod(getSublistSubrecord);

			/**
			 * get the subrecord for the associated sublist field
			 * @function Record#getSublistSubrecord.promise
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Promise<Record>} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */

			var doGetBodySubrecord = utilityFunctions.thenableFunction(function doGetBodySubrecord(fieldId, isReadOnly, proxyOptions, isAsync)
			{
				var subrecord, field, id;
				var sublistId = undef;
				var lineInstanceId = null;
				var isCommitted = true;

				field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				if ((isReadOnly || getIsReadOnlyRecord(proxyOptions)) && !hasSubrecord(fieldId))
				{
					return null;
				}

				subrecord = _modelController.getSubrecord(fieldId);
				if (!subrecord)
				{
					id = _modelController.getFieldValue(fieldId);
					subrecord = resultObject.create(function ()
					{
						return doGetSubrecordFromServerForInstance.thenable(field, id, lineInstanceId, isCommitted, isReadOnly, isAsync);
					}).then(function (subrecord)
					{
						if (!isReadOnly)
						{
							getModelController().cacheSubrecord(fieldId, subrecord);
						}
						return subrecord;
					});
				}
				return subrecord;
			}, {
				isAsyncArgIndex: 3
			});

			this.doGetBodySubrecord = doGetBodySubrecord;


			var tryToGetSublistSubrecord = utilityFunctions.thenableFunction(function tryToGetSublistSubrecord(sublistId, fieldId, lineInstanceId, isCommitted, isReadOnly, isAsync)
			{
				var subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (!subrecord && !isCommitted)
				{
					subrecord = getModelController().doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, !isCommitted);
					if (subrecord)
					{
						return resultObject.create(function ()
						{
							return subrecord.clone.thenable(isCommitted, isAsync);
						}).then(function (subrecord)
						{
							if (!isReadOnly)
							{
								getModelController().cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
							}
							return subrecord;
						});
					}
				}
				return subrecord;
			}, {
				isAsyncArgIndex: 5
			});

			var doGetSublistSubrecordForInstance = utilityFunctions.thenableFunction(function doGetSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, isReadOnly, proxyOptions, isAsync)
			{
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);

				if ((isReadOnly || getIsReadOnlyRecord(proxyOptions)) && !hasSublistSubrecord(sublistId, fieldId, getLineIndexFromInstanceId(sublistId, lineInstanceId, isCommitted)))
				{
					return null;
				}

				return resultObject.create(function ()
				{
					return tryToGetSublistSubrecord.thenable(sublistId, fieldId, lineInstanceId, isCommitted, isReadOnly, isAsync);
				}).then(function (subrecord)
				{
					if (!subrecord)
					{
						var id = getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
						return resultObject.create(function ()
						{
							return doGetSubrecordFromServerForInstance.thenable(field, id, lineInstanceId, isCommitted, isReadOnly, isAsync);
						}).then(function (subrecord)
						{
							if (!isReadOnly)
							{
								getModelController()
									.cacheSublistSubrecordForInstance(sublistId, fieldId, lineInstanceId, isCommitted, subrecord);
							}
							return subrecord;
						});
					}
					return subrecord;
				});
			}, {
				isAsyncArgIndex: 6
			});

			this.doGetSublistSubrecordForInstance = doGetSublistSubrecordForInstance;

			var removeSublistSubrecord = utilityFunctions.thenableFunction(function removeSublistSubrecord(options, fieldId, line, isAsync)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('removeSublistSubrecord'));

				var lineInstanceId = getLineInstanceId(sublistId, line);
				if (!hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, true))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				return resultObject.create(function ()
				{
					return doRemoveSublistSubrecordForInstance.thenable(sublistId, fieldId, lineInstanceId, true, isAsync);
				}).then(function ()
				{
					return that;
				});
			}, {
				isAsyncArgIndex: 3
			});

			/**
			 * remove the subrecord for the associated sublist field
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.removeSublistSubrecord = wrapMethod(removeSublistSubrecord);


			function hasCurrentSublistSubrecord(options, fieldId)
			{
				options = convertCurrentLineInputToOptions(options, fieldId)
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('hasCurrentSublistSubrecord'));
				return doHasSubrecordForInstance(sublistId, fieldId, doGetCurrentSublistLineInstanceId(sublistId), false);
			}

			/**
			 * return a value indicating if the associated sublist field has a subrecord on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {boolean}
			 *
			 * @since 2015.2
			 */
			this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

			var getCurrentSublistSubrecord = utilityFunctions.thenableFunction(function getCurrentSublistSubrecord(options, fieldId, isAsync)
			{
				options = convertCurrentLineInputToOptions(options, fieldId)
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistSubrecord'));
				return doGetCurrentSublistSubrecord.thenable(sublistId, fieldId, getIsReadOnlyRecord(), isAsync);
			}, {
				isAsyncArgIndex: 2
			});

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Subrecord} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistSubrecord = wrapMethod(getCurrentSublistSubrecord);

			/**
			 * get the subrecord for the associated sublist field on the current line
			 * @function Record#getCurrentSublistSubrecord.promise
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Promise<Record>} [client-side subrecord implementation]
			 *
			 * @since 2015.2
			 */

			var doGetCurrentSublistSubrecord = utilityFunctions.thenableFunction(function doGetCurrentSublistSubrecord(sublistId, fieldId, isReadOnly, isAsync)
			{
				var isCommitted = false;
				var modelController = getModelController();
				var lineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				var field = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				subrecordUtil.validateIfSummaryField(field, fieldId);
				var subrecord = modelController.doGetSubrecordForInstance(sublistId, fieldId, lineInstanceId, false);

				if (lineInstanceId && !subrecord)
				{
					var currentSubrecordId = modelController.getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, false);
					var committedSubrecordId = modelController.getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, true);
					var isSameSubrecordReference = !modelController.lineInstanceIsNewLine(sublistId, lineInstanceId) && (currentSubrecordId == committedSubrecordId);

					return resultObject.create(function ()
					{
						if (modelController
								.hasNewlyCommittedSublistSubrecord(modelController
									.getSublistSystemIdForInstance(sublistId, lineInstanceId, false), fieldId) && isSameSubrecordReference)
						{
							return tryToGetSublistSubrecord.thenable(sublistId, fieldId, lineInstanceId, isCommitted, isReadOnly, isAsync);
						}
					}).then(function (subrecord)
					{
						if (!subrecord)
						{
							return resultObject.create(function ()
							{
								return doGetSubrecordFromServerForInstance.thenable(field, currentSubrecordId, lineInstanceId, isCommitted, isReadOnly, isAsync);
							}).then(function (subrecord)
							{
								if (!isReadOnly)
								{
									getModelController().setCurrentSublistSubrecord(sublistId, fieldId, subrecord); // TODO: this has potential to blow if the line changes before the async request completes, should be done using the instanceId instead
								}
								return subrecord;
							});
						}
						return subrecord;
					});
				}

				return subrecord;
			}, {
				isAsyncArgIndex: 3
			});

			this.doGetCurrentSublistSubrecord = doGetCurrentSublistSubrecord;

			var removeCurrentSublistSubrecord = utilityFunctions.thenableFunction(function removeCurrentSublistSubrecord(options, fieldId, isAsync)
			{
				options = convertCurrentLineInputToOptions(options, fieldId)
				var sublistId = options.sublistId;
				fieldId = options.fieldId;

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('removeCurrentSublistSubrecord'));

				var lineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				if (!hasSublistLineValueOrSublistFieldExisted(sublistId, fieldId, lineInstanceId, false))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
				}

				return resultObject.create(function ()
				{
					return doRemoveSublistSubrecordForInstance.thenable(sublistId, fieldId, lineInstanceId, false, isAsync);
				}).then(function ()
				{
					return that;
				});
			}, {
				isAsyncArgIndex: 2
			});

			/**
			 * remove the subrecord for the associated sublist field on the current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.removeCurrentSublistSubrecord = wrapMethod(removeCurrentSublistSubrecord);

			/* Record Scripting */
			var triggerLineInitScript = utilityFunctions.thenableFunction(function triggerLineInitScript(sublistId)
			{
				return implementation.triggerLineInitScript.thenable(sublistId);
			});

			var triggerLineCommitScriptForInstance = utilityFunctions.thenableFunction(function triggerLineCommitScriptForInstance(sublistId, lineInstanceId)
			{
				return implementation.triggerLineCommitScript.thenable(sublistId, lineInstanceId);
			});

			this.triggerLineCommitScriptForInstance = triggerLineCommitScriptForInstance;

			var triggerValidateLineScript = utilityFunctions.thenableFunction(function triggerValidateLineScript(sublistId, lineInstanceId)
			{
				return recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					isCommitted: false,
					func: implementation.triggerValidateLineScript,
					emitter: emitter
				}).thenable(sublistId);
			});

			var triggerValidateInsertScript = utilityFunctions.thenableFunction(function triggerValidateInsertScript(sublistId, lineInstanceId)
			{
				return recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					isCommitted: false,
					func: implementation.triggerValidateInsertScript,
					emitter: emitter
				}).thenable(sublistId);
			});

			this.triggerValidateInsertScript = triggerValidateInsertScript;

			var triggerValidateDeleteScript = utilityFunctions.thenableFunction(function triggerValidateDeleteScript(sublistId, lineInstanceId)
			{
				return recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					isCommitted: false,
					func: implementation.triggerValidateDeleteScript,
					emitter: emitter
				}).thenable(sublistId);
			});

			this.triggerValidateDeleteScript = triggerValidateDeleteScript;

			var triggerValidateFieldScript = utilityFunctions.thenableFunction(function triggerValidateFieldScript(sublistId, field, lineInstanceId, isCommitted, valueObject)
			{
				var lineItemMatrixFieldMetadata = sublistId && matrix.parseMatrixLineField.call(that, field, sublistId) || null;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || field;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				return recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					func: implementation.triggerValidateFieldScript,
					sublistId: sublistId,
					lineInstanceId: lineInstanceId,
					isCommitted: isCommitted,
					fieldId: fieldId,
					emitter: emitter
				}).thenable(sublistId, fieldId, lineInstanceId, matrixColumn, valueObject);
			});

			this.triggerValidateFieldScript = triggerValidateFieldScript;

			var triggerFieldChangeEvent = utilityFunctions.thenableFunction(function triggerFieldChangeEvent(sublistId, fieldId, lineInstanceId, isCommitted, value, noSlaving, isAsync)
			{
				return implementation.triggerFieldChangeEvent.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, noSlaving, isAsync);
			}, {
				isAsyncArgIndex: 6
			});

			this.triggerFieldChangeEvent = triggerFieldChangeEvent;

			var triggerFieldChangeScript = utilityFunctions.thenableFunction(function triggerFieldChangeScript(sublistId, field, lineInstanceId)
			{
				var lineItemMatrixFieldMetadata = sublist && matrix.parseMatrixLineField.call(that, field, sublistId) || null;
				var matrixColumn = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.column || -1;
				var fieldId = !!lineItemMatrixFieldMetadata && lineItemMatrixFieldMetadata.fieldname || field;
				return implementation.triggerFieldChangeScript.thenable(sublistId, fieldId, lineInstanceId, matrixColumn);
			});

			this.triggerFieldChangeScript = triggerFieldChangeScript;

			function triggerCanCreateSubrecordScriptForInstance(sublistId, fieldId, lineInstanceId)
			{
				implementation.triggerCanCreateSubrecordScript(sublistId, fieldId, lineInstanceId);
			}

			var triggerSaveRecordScript = utilityFunctions.thenableFunction(function triggerSaveRecordScript(ignoreMandatoryFields)
			{
				return recordDefinitionEvent.wrapEmitValidationError({
					record: that,
					func: implementation.triggerSaveRecordScript,
					emitter: emitter
				}).thenable(ignoreMandatoryFields);
			});

			this.triggerSaveRecordScript = triggerSaveRecordScript;

			var triggerRecalcScript = utilityFunctions.thenableFunction(function triggerRecalcScript(sublistId, localRecalc, options, ignoreRecalc)
			{
				return implementation.triggerRecalcScript.thenable(sublistId, localRecalc, options, ignoreRecalc);
			});

			this.triggerRecalcScript = triggerRecalcScript;

			var triggerTotalingScript = utilityFunctions.thenableFunction(function triggerTotalingScript(sublistId, fieldId, options)
			{
				return implementation.triggerTotalingScript.thenable(sublistId, fieldId, options);
			});
			this.triggerTotalingScript = triggerTotalingScript;

			function getValueObjectForValidation(fieldId, newValue)
			{
				if (!getIsNSERecord()) return null;
				return { newValue: newValue, currentValue: getModelController().getFieldValue(fieldId) };
			}
			this.getValueObjectForValidation = getValueObjectForValidation;

			function getValueObjectForValidationForInstance(sublistId, fieldId, lineInstanceId, isCommitted, newValue)
			{
				if (!getIsNSERecord()) return null;
				return { newValue: newValue, currentValue: getModelController().getSublistLineValueForInstance(sublistId, fieldId, lineInstanceId, isCommitted) };
			}

			this.getValueObjectForValidationForInstance = getValueObjectForValidationForInstance;

			function getValueAsLegacyString(fieldId)
			{
				return getModelController().getValueAsLegacyString(fieldId);
			}

			this.getValueAsLegacyString = getValueAsLegacyString;

			function getValueAsLegacyStringArray(fieldId)
			{
				return recordUtil.formatValueToArrayType(getValueAsLegacyString(fieldId));
			}

			this.getValueAsLegacyStringArray = getValueAsLegacyStringArray;

			function getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				return getModelController()
					.getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			this.getSublistLineValueAsLegacyStringForInstance = getSublistLineValueAsLegacyStringForInstance;

			function getSublistLineValueAsLegacyStringArray(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				return recordUtil.formatValueToArrayType(getSublistLineValueAsLegacyStringForInstance(sublistId, fieldId, lineInstanceId, isCommitted));
			}

			this.getSublistLineValueAsLegacyStringArray = getSublistLineValueAsLegacyStringArray;

			function getFieldValue(fieldId) // probably used in currencyUtility.js
			{
				return recordUtil.emptyIfNullOrUndefined(getValueAsLegacyString(fieldId));
			}
			this.getFieldValue = getFieldValue;

			/* Sublist APIs */

			function getSublist(options)
			{
				var sublistId = options;
				if (options !== undef && options !== null && !util.isString(options))
				{
					sublistId = options.sublistId;
				}
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getSublist'));
				return doGetSublist(idConverterService.convertSublistId(that, sublistId));
			}

			/**
			 * returns the specified sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Sublist} [requested sublist]
			 *
			 * @since 2015.2
			 */
			this.getSublist = getSublist;

			function doGetSublist(sublistId)
			{
				function createSublist(type, state, fields)
				{
					var _sublist = sublist.create({
						type: type,
						sublistState: state,
						sublistFields: fields
					}, that);

					return _sublist;
				}

				var sublistLevelMetadata = getSublistMetadata(sublistId);
				var jsSublist = (sublistLevelMetadata != null)
					? createSublist(sublistLevelMetadata.nlobjSublistConstructorType, _state.getSublistState(sublistId), sublistLevelMetadata.fieldMetadata)
					: null;

				return jsSublist;
			}

			function getSublistFields(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', getMissingArgumentErrorMessageFillerValue('getSublistFields'));
				sublistId = idConverterService.convertSublistId(that, sublistId);
				var allSublistFields = null;

				var sublistfields = _metadata.getAllSublistFields(sublistId);
				if (sublistfields)
				{
					allSublistFields = [];
					var setOfSublistFields = {};
					/* by current line data */
					var sublistData = getModelController().getSublistLineFieldIds(sublistId, doGetCurrentSublistLineInstanceId(sublistId), false);

					sublistData.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });

					/* by metadata line data */
					sublistfields.forEach(function (fieldId) { setOfSublistFields[fieldId] = ''; });

					allSublistFields = Object.keys(setOfSublistFields);
				}

				return allSublistFields;
			}

			/**
			 * return array of names of all fields in a sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @return {Array}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.sublistId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.getSublistFields = getSublistFields;

			/* Field APIs */
			function getField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', getMissingArgumentErrorMessageFillerValue('getField'));
				return doGetFieldForInstance(null, idConverterService.convertBodyFieldId(that, fieldId), null, true);
			}

			/**
			 * return field object from record
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.fieldId is missing or undefined
			 *
			 * @since 2015.2
			 */
			this.getField = getField;

			/**
			 *
			 * @param {string|null} sublistId
			 * @param {string} fieldId
			 * @param {string|null} lineInstanceId
			 * @param {boolean} isCommitted
			 * @returns {Field|null}
			 */
			function doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var returnedField;
				if (getModelController().hasUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted))
				{
					returnedField = getModelController().getUserFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				}
				else
				{
					var recordField = getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					returnedField = recordField ? field.create(recordField, that) : null;
					getModelController().cacheUserFieldForInstance(sublistId, fieldId, lineInstanceId, returnedField, isCommitted);
				}
				return returnedField;
			}

			this.doGetFieldForInstance = doGetFieldForInstance;

			function getSublistField(options, fieldId, line)
			{
				options = convertLineInputToOptions(options, fieldId, line);
				var sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistField'));

				var isCommitted = true;
				recordUtil.assertValidSublistOperation(isWithinValidLineRangeForFieldOnly(sublistId, line));
				var lineInstanceId = getLineInstanceId(sublistId, line);
				if (getModelController().lineInstanceIsNewLine(sublistId, lineInstanceId) && isValidSublistField(sublistId, fieldId)) {
					isCommitted = false;
				}
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
			}

			/**
			 * return field object from record's sublist
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @param {number} options.line
			 * @return {Field} [requested field]
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if line number is invalid
			 *
			 * @since 2015.2
			 */
			this.getSublistField = getSublistField;

			function getCurrentSublistField(options, fieldId)
			{
				options = convertCurrentLineInputToOptions(options, fieldId)
				var sublistId = options.sublistId;
				fieldId = options.fieldId;

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistField'));
				var lineInstanceId = doGetCurrentSublistLineInstanceId(sublistId);
				return doGetFieldForInstance(sublistId, fieldId, lineInstanceId, false);
			}

			/**
			 * return field object from record's sublist current line
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId
			 * @param {string} options.fieldId
			 * @return {Field}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId or fieldId is missing
			 * @restriction only available in dynamic record
			 *
			 * @since 2015.2
			 */
			this.getCurrentSublistField = getCurrentSublistField;

			/**
			 * get cached RecordField object
			 * @param {string|null} sublistId
			 * @param {string} fieldId
			 * @param {string|null} lineInstanceId
			 * @param {boolean} isCommitted
			 * @return {RecordField}
			 */
			function getCachedRecordFieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var recordField = getModelController().getRecordfieldForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
				if (recordField != null)
				{
					if (!!sublistId && !!lineInstanceId)
					{
						if (recordField.getLineInstanceId() !== lineInstanceId)
						{
							if (typeof console !== 'undefined' && console.warn)
								console.warn('instanceId mismatch for cached field ','(sublistId: ', sublistId, 'fieldId: ', fieldId, 'isCommitted: ', isCommitted, ')', 'actual: ', recordField.getLineInstanceId(), 'expected: ', lineInstanceId);
							recordField = null;
						}
						if (recordField.getIsCommitted() !== !!isCommitted)
						{
							if (typeof console !== 'undefined' && console.warn)
								console.warn('isCommitted mismatch for cached field ','(sublistId: ', sublistId, 'fieldId: ', fieldId, 'lineInstanceId: ', lineInstanceId, ')', 'actual: ', recordField.getIsCommitted(), 'expected: ', isCommitted);
							recordField = null;
						}
					}
				}
				if (recordField == null)
				{
					var fieldConstructorObject = getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, isCommitted);
					if (fieldConstructorObject)
					{
						recordField = recordfield.create(fieldConstructorObject);
						recordDefinitionEvent.forwardRecordFieldEvents(that, recordField);
						getModelController()
							.cacheRecordFieldForInstance(sublistId, fieldId, lineInstanceId, recordField, isCommitted);
					}
					else
					{
						recordField = null;
					}
				}
				return recordField;
			}

			this.getCachedRecordFieldForInstance = getCachedRecordFieldForInstance;

			function flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId)
			{
				getModelController().flushBufferCacheForFieldStateUpdate(sublistId, fieldId, lineInstanceId);
			}

			this.flushBufferCacheForFieldStateUpdate = flushBufferCacheForFieldStateUpdate;

			var updateSelectOptions = utilityFunctions.thenableFunction(function updateSelectOptions(sublistId, fieldId, lineInstanceId, opts, value, text, selected, isAsync)
			{
				var isCommitted = !getModelController().isSublistLineInstanceIdSelected(sublistId, lineInstanceId);
				getModelController().cacheSelectOptionsForInstance(sublistId, fieldId, lineInstanceId, opts, isCommitted);
				getModelController().cacheSelectOptionText(sublistId, fieldId, value, text);
				if (selected)
				{
					if (isFieldMultiSelect(sublistId, fieldId))
					{
						value = (sublistId ? getCurrentSublistValue(sublistId, fieldId) : doGetValue(fieldId)).concat([value]);
					}
					//Fire event even if the value is not changed for the case that a selected option was removed, but the value stays
					var modelEvent = {
						type: 'FIELD_VALUE_CHANGE',
						fieldId: fieldId,
						newValue: value
					};

					if (!!sublistId)
					{
						modelEvent.sublistId = sublistId;
						modelEvent.lineId = lineInstanceId;
						modelEvent.useLineBuffer = true;
						recordDefinitionEvent.forwardModelControllerEvent(emitter, modelEvent);
						return doSetSublistBufferValue.thenable(sublistId, fieldId, lineInstanceId, value, true, undefined, undefined, undefined, undefined, isAsync); // TODO: should this really fire FC the else branch ignores it??
					}
					else
					{
						recordDefinitionEvent.forwardModelControllerEvent(emitter, modelEvent);
						return doSetValue.thenable(fieldId, value, undefined, undefined, undefined, undefined, undefined, isAsync);
					}
				}
			}, {
				isAsyncArgIndex: 7
			});

			function getFieldConstructorObjectForInstance(sublistId, fieldId, lineInstanceId, isCommitted)
			{
				var fieldObj = null;
				var metadata = _metadata.getFieldMetadata(sublistId, fieldId);

				if (metadata != null)
				{
					var fieldState = !!sublistId ? getSublistFieldStateForInstance(sublistId, fieldId, lineInstanceId, isCommitted) : getFieldState(fieldId);
					/**
					 * @typedef {object} FieldObject
					 * @property {FieldState} fieldState
					 * @property {FieldLevelMetadata} metadata
					 * @property {RawRecord} record
					 * @property {boolean} isRecordDynamic
					 * @property {boolean} isCurrentRecord
					 * @property {string} sublistId
					 * @property {boolean} isCommitted
					 * @property {string} lineInstanceId
					 * @property {RecordFunctions} recordFunctions
					 */
					fieldObj = {
						fieldState: fieldState,
						metadata: metadata,
						record: that,
						isRecordDynamic: getIsDynamicRecord(),
						isCurrentRecord: getIsCurrentRecord(),
						sublistId: sublistId,
						isCommitted: isCommitted,
						lineInstanceId: lineInstanceId,
						/**
						 * @typedef {object} RecordFunctions
						 * @property {function} getRadioSet
						 * @property {function} getQueryRequest
						 * @property {function} isInternal
						 * @property {function:OptionCacheDelegate} getFieldOptions
						 * @property {function} updateSelectOptions
						 */
						recordFunctions:
						{
							getRadioSet: getRadioSet,
							getQueryRequest: getQueryRequest,
							isInternal: isInternal,
							getFieldOptions: getSelectOptionCache,
							updateSelectOptions: updateSelectOptions
						}
					};
				}
				return fieldObj;
			}

			function getLineIndexFromInstanceId(sublistId, lineInstanceId)
			{
				var lineIndex = getModelController().getSublistLineIndexForInstance(sublistId, lineInstanceId);
				return lineIndex;
			}
			this.getLineIndexFromInstanceId = getLineIndexFromInstanceId;

			function getOneBasedLineIndexFromInstanceId(sublistId, lineInstanceId)
			{
				return recordUtil.getOneBasedIndex(getLineIndexFromInstanceId(sublistId, lineInstanceId));
			}
			this.getOneBasedLineIndexFromInstanceId = getOneBasedLineIndexFromInstanceId;

			function getQueryRequest()
			{
				var req = slaving.cleanupQueryURL(_metadata.queryUrl);
				if (getIsCurrentRecord())
				{
					req.payload.isCurrentRecord = true;
				}
				return req;
			}

			function getRadioSet(fieldId)
			{
				var metadata = _metadata.getFieldMetadata(null, fieldId);
				return (metadata) ? metadata.radioSet : null;
			}

			/**
			 *
			 * @returns {OptionCacheDelegate}
			 */
			function getSelectOptionCache()
			{
				var selectOptionCache = getModelController().getSelectOptionCache();

				/** @typedef {Object} OptionCacheDelegate */
				var result = {
					/** @member OptionCacheDelegate#commitFromSublistBufferToSublist */
					commitFromSublistBufferToSublist: selectOptionCache.commitFromSublistBufferToSublist,
					/** @member OptionCacheDelegate#fields */
					fields: selectOptionCache.fields,
					/**
					 * @member OptionCacheDelegate#get
					 * get cached options
					 * @param {string} sublistId
					 * @param {string} fieldId
					 * @param {string} lineInstanceId
					 * @param {boolean} isCommitted
					 * @param {boolean} forColumn
					 * @returns {Array<SelectOption>}
					 */
					get: function (sublistId, fieldId, lineInstanceId, isCommitted, forColumn) {
						// TODO: we can get the committed info from the recordField, but we would have to make sure that committed/uncommitted is then synchronize similarly to other field caches, defaulting to true for now
						return selectOptionCache.get(sublistId, fieldId, forColumn ? 'COLUMNOPTIONS' : lineInstanceId, true);
					},
					/** @member OptionCacheDelegate#getSublist */
					getSublist: selectOptionCache.getSublist,
					/** @member OptionCacheDelegate#getSublistBuffer */
					getSublistBuffer: selectOptionCache.getSublistBuffer,
					/** @member OptionCacheDelegate#has */
					has: selectOptionCache.has,
					/** @member OptionCacheDelegate#invalidate */
					invalidate: selectOptionCache.invalidate,
					/** @member OptionCacheDelegate#invalidateSublist */
					invalidateSublist: selectOptionCache.invalidateSublist,
					/** @member OptionCacheDelegate#migrateFromSublistToSublistBuffer */
					migrateFromSublistToSublistBuffer: selectOptionCache.migrateFromSublistToSublistBuffer,
					/**
					 * put cached options
					 * @member OptionCacheDelegate#put
					 * @param {string} sublistId
					 * @param {string} fieldId
					 * @param {string} lineInstanceId
					 * @param {boolean} isCommitted
					 * @param {boolean} forColumn
					 * @param {Array<SelectOption>} newOptions
					 * @param {*?} action
					 * @param {*?} data
					 * @return {void}
					 */
					put: function (sublistId, fieldId, lineInstanceId, isCommitted, forColumn, newOptions, action, data)
					{
						var cacheKey = forColumn ? 'COLUMNOPTIONS' : lineInstanceId;
						// TODO: we can get the committed info from the recordField, but we would have to make sure that committed/uncommitted is then synchronize similarly to other field caches, defaulting to true for now
						if (!action && !selectOptionCache.has(sublistId, fieldId, cacheKey, true))
						{
							action = 'init';
							data = newOptions;
						}
						selectOptionCache.put(sublistId, fieldId, cacheKey, newOptions, true);
						recordDefinitionEvent.emitUpdateFieldOptions(emitter, that, sublistId, fieldId, lineInstanceId, isCommitted, action, data);
					},
					/** @member OptionCacheDelegate#removeLine */
					removeLine: selectOptionCache.removeLine
				};
				return result;
			}

			function warnAboutMLBCurrentIndexProblem(msg)
			{
				if (typeof console !== 'undefined' && console.warn)
					console.warn(msg);
			}
			this.warnAboutMLBCurrentIndexProblem = warnAboutMLBCurrentIndexProblem;

			/**
			 * set the value for the associated header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @param {boolean} [options.ignoreFieldChange] Ignore the field change script (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setMatrixHeaderValue = wrapMethod(utilityFunctions.thenableFunction(function setMatrixHeaderValue(options, fieldId, column, value, ignoreFieldChange, isAsync)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.setMatrixHeaderValue.thenable.call(that, converted.options, converted.fieldId, column, value, ignoreFieldChange, isAsync);
			}, {
				isAsyncArgIndex: 5
			}));

			/**
			 * get the value for the associated header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderValue = wrapMethod(utilityFunctions.thenableFunction(function getMatrixHeaderValue(options, fieldId, column)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getMatrixHeaderValue.call(that, converted.options, converted.fieldId, column);
			}));

			/**
			 * set the value for the associated field in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @param {string} options.value the value to set it to
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in deferred dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setMatrixSublistValue = wrapMethod(utilityFunctions.thenableFunction(function setMatrixSublistValue(options, fieldId, linenum, column, value)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.setMatrixSublistValue.thenable.call(that, converted.options, converted.fieldId, linenum, column, value);
			}));

			/**
			 * get the value for the associated field in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.line the line number for the field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getMatrixSublistValue = wrapMethod(utilityFunctions.thenableFunction(function getMatrixSublistValue(options, fieldId, linenum, column)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getMatrixSublistValue.call(that, converted.options, converted.fieldId, linenum, column);
			}));

			/**
			 * get the field for the specified header in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderField = wrapMethod(utilityFunctions.thenableFunction(function getMatrixHeaderField(options, fieldId, column, proxyOptions)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getMatrixHeaderField.call(that, converted.options, converted.fieldId, column, proxyOptions);
			}, {
				proxyOptionsArgIndex: 3
			}));

			/**
			 * get the field for the specified sublist in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.column the column number for the field
			 * @param {number} options.line the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {Field} [requested field]
			 *
			 * @since 2015.2
			 */
			this.getMatrixSublistField = wrapMethod(utilityFunctions.thenableFunction(function getMatrixSublistField(options, fieldId, linenum, column, proxyOptions)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getMatrixSublistField.call(that, converted.options, converted.fieldId, linenum, column, proxyOptions);
			}, {
				proxyOptionsArgIndex: 4
			}));

			/**
			 * returns the line number of the first line that contains the specified value in the specified column of the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @param {number} options.value the column number for the field
			 * @param {number} options.column the line number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.findMatrixSublistLineWithValue = wrapMethod(utilityFunctions.thenableFunction(function findMatrixSublistLineWithValue(options, fieldId, column, value)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.findMatrixSublistLineWithValue.call(that, converted.options, converted.fieldId, column, value);
			}));

			/**
			 * returns the number of columns for the specified matrix.
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId the id of the matrix field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @return {number}
			 *
			 * @since 2015.2
			 */
			this.getMatrixHeaderCount = wrapMethod(utilityFunctions.thenableFunction(function getMatrixHeaderCount(options, fieldId)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getMatrixHeaderCount.call(that, converted.options, converted.fieldId);
			}));

			/**
			 * set the value for the line currently selected in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @param {string} options.value - the value to set it to
			 * @param {boolean} options.ignoreFieldChange (optional) - Ignore the field change script (default false)
			 * @param {boolean} options.fireSlavingSync (optional) - Flag to perform slaving synchronously (default false)
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {Record} same record, for chaining
			 *
			 * @since 2015.2
			 */
			this.setCurrentMatrixSublistValue = wrapMethod(utilityFunctions.thenableFunction(function setCurrentMatrixSublistValue(options, fieldId, column, value, ignoreFieldChange, isAsync)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.setCurrentMatrixSublistValue.thenable.call(that, converted.options, converted.fieldId, column, value, ignoreFieldChange, isAsync);
			}, {
				isAsyncArgIndex: 5
			}));

			/**
			 * get the value for the line currently selected in the matrix
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.sublistId - the id of sublist in which the matrix is in.
			 * @param {string} options.fieldId - the id of the matrix field
			 * @param {number} options.column - the column number for the field
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any required values are missing
			 * @restriction only available in dynamic record
			 * @return {number|Date|string}
			 *
			 * @since 2015.2
			 */
			this.getCurrentMatrixSublistValue = wrapMethod(utilityFunctions.thenableFunction(function getCurrentMatrixSublistValue(options, fieldId, column)
			{
				var converted = convertMatrixSublistFieldOptionIds(options, fieldId);
				return matrix.getCurrentMatrixSublistValue.call(that, converted.options, converted.fieldId, column);
			}));

			function sourcingAndOnChangeHandler(name, fn, options, isAsync, proxyOptions)
			{
				if (!isInternal(proxyOptions))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);

				var fieldId = (options || {}).fieldId;
				utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue(name));
				var sublistId = options.sublistId || null;
				var line = options.line != null ? options.line : -1;
				var fieldSpec = options.fieldSpec;

				var masterValue;
				if (!sublistId)
				{
					masterValue = doGetValue(fieldId);
				}
				else
				{
					var instanceId = (line === -1) ? doGetCurrentSublistLineInstanceId(sublistId) : getLineInstanceId(sublistId, line);
					var isCommitted = instanceId !== doGetCurrentSublistLineInstanceId(sublistId);
					masterValue = doGetSublistValueForInstance(sublistId, fieldId, instanceId, isCommitted);
				}
				return fn(sublistId, fieldId, instanceId, isCommitted, masterValue, fieldSpec, isAsync);
			}

			this.sourceField = utilityFunctions.thenableFunction(function sourceField(options, isAsync, proxyOptions)
			{
				return sourcingAndOnChangeHandler('sourceField', function (sublistId, fieldId, lineInstanceId, isCommitted, value, fieldSpec, isAsync)
				{
					return doSlaving.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, fieldSpec, isAsync);
				}, options, isAsync, proxyOptions);
			}, {
				isAsyncArgIndex: 1,
				proxyOptionsArgIndex: 2
			});

			this.fireOnChange = utilityFunctions.thenableFunction(function fireOnChange(options, isAsync, proxyOptions)
			{
				return sourcingAndOnChangeHandler('fireOnChange', function (sublistId, fieldId, lineInstanceId, isCommitted, value, fieldSpec, isAsync)
				{
					return triggerFieldChangeEvent.thenable(sublistId, fieldId, lineInstanceId, isCommitted, value, false, isAsync);
				}, options, isAsync, proxyOptions);
			}, {
				isAsyncArgIndex: 1,
				proxyOptionsArgIndex: 2
			});

			var getBlankMandatorySublistFields = utilityFunctions.thenableFunction(function getBlankMandatorySublistFields(sublistId, lineInstanceId, isCommitted, useDefaultState)
			{
				utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getBlankMandatorySublistFields'));
				if (!isSublistValid(sublistId))
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
				isCommitted = false !== isCommitted;
				var ss = getSublistState(sublistId);
				var res = {};
				var lineIds = lineInstanceId == null ? ss.getLineInstanceIds(isCommitted) : (Array.isArray(lineInstanceId) ? lineInstanceId : [lineInstanceId]);
				for (var j = 0; j < lineIds.length; j++)
				{
					var lineId = lineIds[j];
					var mandatoryFields = ss.getMandatoryFields(lineId, isCommitted, useDefaultState);
					for (var i = 0; i < mandatoryFields.length; i++) {
						var isEmpty;
						if (getFieldType(sublistId, mandatoryFields[i]) === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE) {
							isEmpty = !doHasSubrecordForInstance(sublistId, mandatoryFields[i], lineId, isCommitted);
						} else {
							var val = doGetSublistValueForInstance(sublistId, mandatoryFields[i], lineId, isCommitted);
							isEmpty = val == null || val === '';
						}
						if (isEmpty) {
							res[lineId] = res[lineId] || [];
							res[lineId].push(mandatoryFields[i]);
						}
					}
				}
				return res;
			});
			this.getBlankMandatorySublistFields = getBlankMandatorySublistFields;

			var getBlankMandatoryBodyFields = utilityFunctions.thenableFunction(function getBlankMandatoryBodyFields(useDefaultState)
			{
				var fields = _metadata.fieldIds;
				var res = [];
				for (var i = 0; i < fields.length; i++) {
					var state = _state.getFieldState(fields[i]);
					if (useDefaultState ? state.isDefaultMandatory : state.isMandatory) {
						var isEmpty;
						if (getFieldType(null, fields[i]) === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE) {
							isEmpty = !doHasSubrecord(fields[i]);
						} else {
							var val = doGetValue(fields[i]);
							isEmpty = val == null || val === '';
						}
						if (isEmpty) {
							res.push(fields[i]);
						}
					}
				}
				return res;
			});
			this.getBlankMandatoryBodyFields = getBlankMandatoryBodyFields;

			var getSublistSubrecords = function getSublistSubrecords(sublistId, lineInstanceId, isCommitted)
			{
				var sublistMetadata = _metadata.getSublistMetadata(sublistId);
				var fields = sublistMetadata.sortedFields;
				var res = {};
				for (var i = 0; i < fields.length; i++) {
					if (getFieldType(sublistId, fields[i]) === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && doHasSubrecordForInstance(sublistId, fields[i], lineInstanceId, isCommitted)) {
						res[fields[i]] = doGetSublistSubrecordForInstance(sublistId, fields[i], lineInstanceId, isCommitted, true);
					}
				}
				return res;
			}
			this.getSublistSubrecords = getSublistSubrecords;

			var getBodySubrecords = function getBodySubrecords()
			{
				var fields = _metadata.fieldIds;
				var res = {};
				for (var i = 0; i < fields.length; i++) {
					if (getFieldType(null, fields[i]) === fieldTypeConstants.Type.SUBRECORD_FIELD_TYPE && doHasSubrecord(fields[i])) {
						res[fields[i]] = doGetBodySubrecord(fields[i], true);
					}
				}
				return res;
			}
			this.getBodySubrecords = getBodySubrecords;

			/**
			 * Return the storage object to be used for stateful record scripting (allows to transfer values between record
			 * scripting hooks)
			 * @param {Object} proxyOptions
			 * @returns {RawStatefulStore}
			 */
			var getStatefulStoreProxyProvider = function getStatefulStoreProxyProvider(proxyOptions) {
				return recordUtil.getStatefulStoreProxyProvider(_statefulStores, proxyOptions);
			}
			this.getStatefulStoreProxyProvider = getStatefulStoreProxyProvider;

			/**
			 * @return {object|null}
			 */
			var getStatefulStores = function getStatefulStores() {
				return Object.keys(_statefulStores).length ? _statefulStores : null;
			}
			this.getStatefulStores = getStatefulStores;

			/*
			 * This callback type is called `eventCallback` and is displayed as a global symbol.
			 * @callback requestCallback
			 * @param {Object} event
			 */
			/*
			 * Start listening to events
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.on = function on(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('on'));
				emitter.on({
					types: types,
					listener: listener
				});
				return that;
			};
			/*
			 * Stop listening to events
			 * @param {Object} options
			 * @param {Array<string>} options.types [required]
			 * @param {eventCallback} options.listener [required]
			 * @return {Object} record
			 */
			this.off = function off(options)
			{
				var types = options.types,
					listener = options.listener;

				utilityFunctions.checkArgs([types, listener], ['types', 'listener'], getMissingArgumentErrorMessageFillerValue('off'));
				emitter.off({
					types: types,
					listener: listener
				});
				return that;
			};

			function toString() { return constants.RECORD_UNDERLYING_IMPL_NAME.CLIENT_DYNAMIC_RECORD; }

			this.toString = toString;

			function toJSON()
			{
				var data = getModelController().getData();
				return {
					id: that.id,
					type: that.type,
					isDynamic: that.isDynamic,
					fields: data.body,
					sublists: data.sublists
				};
			}

			this.toJSON = toJSON;

			function completeInternalInit()
			{
				setIsInited();
			}

			function completePageInit()
			{
				clearIsChanged();
				if (getIsSubrecord())
				{
					subrecord_init();
				}
				var event = {type: recordDefinitionEvent.Type.RECORD_INITIALIZED, record: that};
				emitter.emit(event);
				implementation.triggerLocalizationContextChange();
			}

			var _recordMessage;

			if (getIsCurrentRecord()) {
				_recordMessage = recordMessage.createWithListener({listenerType: recordMessage.Type.NONE, emitter: emitter});
			} else {
				_recordMessage = recordMessage.createWithListener({listenerType: recordMessage.Type.AUTOCONFIRM});
			}

			this.getRecordMessage = function ()
			{
				return _recordMessage;
			};

			/**
			 * @typedef {Object} LineInput
			 * @property {string} sublistId
			 * @property {string} fieldId
			 * @property {number} line
			 */

			/**
			 * @param {Object|string} options | sublistId
			 * @param {string}fieldId
			 * @param {number} line
			 * @returns {LineInput}
			 */
			function convertLineInputToOptions(options, fieldId, line)
			{
				if (fieldId !== undef && line !== undef)
					options= {sublistId : options, fieldId: fieldId, line: line};

				return idConverterService.convertOptionIds(that, options);
			}

			/**
			 * @typedef {Object} CurrentLineInput
			 * @property {string} sublistId
			 * @property {string} fieldId
			 */

			/**
			 * @param {Object|string} options | sublistId
			 * @param {string} fieldId
			 * @returns {CurrentLineInput}
			 */
			function convertCurrentLineInputToOptions(options, fieldId)
			{
				if (fieldId !== undef)
					options = {sublistId: options, fieldId: fieldId};

				return idConverterService.convertOptionIds(that, options);
			}

			/**
			 * @typedef {Object} SublistFieldOption
			 * @property {Object|string} options
			 * @property {string} fieldId
			 */

			/**
			 * @param {Object|string} options
			 * @param {string} fieldId
			 * @returns {SublistFieldOption}
			 */
			function convertSublistFieldOptionIds(options, fieldId)
			{
				if (util.isObject(options))
				{
					return {
						options: idConverterService.convertOptionIds(that, options),
						fieldId: fieldId
					}
				}
				else
				{
					return {
						options: idConverterService.convertSublistId(that, options),
						fieldId: idConverterService.convertSublistFieldId(that, options, fieldId)
					}
				}
			}

			/**
			 * @typedef {Object} SublistFieldOption
			 * @property {Object|string} options
			 * @property {string} fieldId
			 */

			/**
			 * @param {Object|string} options
			 * @param {string} fieldId
			 * @returns {SublistFieldOption}
			 */
			function convertMatrixSublistFieldOptionIds(options, fieldId)
			{
				if (util.isObject(options))
				{
					if (options.hasOwnProperty('sublistId'))
						options.sublistId = idConverterService.convertSublistId(that, options.sublistId);

					if (options.hasOwnProperty('sublistId') && options.hasOwnProperty('fieldId'))
						options.fieldId = idConverterService.convertMatrixSublistFieldId(that, options.sublistId, options.fieldId);

					return {
						options: options,
						fieldId: fieldId
					}
				}
				else
				{
					return {
						options: idConverterService.convertSublistId(that, options),
						fieldId: idConverterService.convertMatrixSublistFieldId(that, options, fieldId)
					}
				}
			}

			/**
			 * Convert fieldId how is defined in metadata
			 * @param {string} fieldId
			 * @returns {string}
			 */
			this.convertFieldId = function (fieldId)
			{
				return idConverterService.convertBodyFieldId(that, fieldId);
			}

			if (getIsSubrecord())
			{
				this.validate = wrapMethod(subrecord_validate);
				this.commit = wrapMethod(subrecord_commit);
				this.cancel = wrapMethod(subrecord_cancel);
				this.abandon = subrecord_abandon;
				this.isAbandoned = subrecord_isAbandoned;
			}

			(function processOptions(options)
			{
				implementation = recordImplementation.create(getIsDynamicRecord(), that);

				setRecordRequestContext(options.recordContext);
				setScriptingContext(options.scriptingContext);
				setMetadata(metadata.isInstance(options.metadata)
					? options.metadata
					: metadata.create(options.metadata));

				var formMetadata = options.formMetadata;
				if (!formMetadata && options.data.bodyField && options.data.bodyField['__formmetadatapayload']) {
					formMetadata = JSON.parse(options.data.bodyField['__formmetadatapayload']);
					delete options.data.bodyField['__formmetadatapayload'];
				}
				setFormMetadata(formMetadata);

				var shouldTriggerCustomFormLevelScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.formLevelScriptPayload;
				var formLevelScriptComponent = shouldTriggerCustomFormLevelScript ? {
					libraryScript: options.formLevelScriptPayload,
					script: options.formLevelScriptMetadata.superScript
				} : {};

				var shouldTriggerCustomClientScript = getIsCurrentRecord() && getIsDynamicRecord() && !!options.clientScriptPayload;
				var clientScriptComponent = shouldTriggerCustomClientScript ? {
					libraryScript: options.clientScriptPayload,
					scriptList: options.clientScriptMetadata.superScriptList,
					pageMode: options.pageInitMode // TODO: FIXME this param is missing in the ClientScriptDAO and is not propagated via transformer
				} : {};

				setModelController(
					modelController.isInstance(options.data) ?
						options.data :
						modelController.create({
							metadata: _metadata,
							data: options.data,
							getIsNSERecord: getIsNSERecord
						})
				);

				_statefulStores = JSON.parse(_modelController.getFieldValue(recordUtil.STATEFUL_STORE) || "null") || {};

				setRecordStateController(
					recordStateController.isInstance(options.state) ?
						options.state :
						recordStateController.create({
							metadata: _metadata,
							getModelController: getModelController,
							getIsNSERecord: getIsNSERecord
						})
				);

				/* This lets us establish currentRecord before pageInit() is called, making it possible to use currentRecord
				 * module from within pageInit(). */
				if (recordObj.initCallback)
				{
					recordObj.initCallback(that);
				}

				initializeThenable = resultObject.create(function ()
				{
					return scope.create.thenable({
						record: that,
						libraryScript: getMetadata().libraryScript,
						staticScript: getMetadata().staticScript,
						uiFormScript: getMetadata().uiFormScript,
						workflowScript: getMetadata().workflowScript,
						shouldTriggerCustomFormLevelScript: shouldTriggerCustomFormLevelScript,
						formLevelScriptComponent: formLevelScriptComponent,
						shouldTriggerCustomClientScript: shouldTriggerCustomClientScript,
						clientScriptComponent: clientScriptComponent,
						initCallback: setRecordScriptingScope,
						noPageInit: !getIsDynamicRecord() || options.config.noPageInit,
						completeInternalInit: completeInternalInit,
						completePageInit: completePageInit
					}, false);
				}).then(function ()
				{
					return that;
				});
			}(recordObj));

			this.ensureInitialized = function ensureInitialized()
			{
				return initializeThenable;
			}

			return that;
		}

		Record.create = utilityFunctions.thenableFunction(function create(options, isAsync)
		{
			return new Record(options, isAsync).ensureInitialized();
		}, {
			isAsyncArgIndex: 1
		});

		return Record;
	});

/**
 * SuiteScript record service module (Client Side)
 *
 * @private
 * @module N/record/recordService
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordService',['N/common/record/recordDefinition', 'N/util', 'N/utilityFunctions', 'N/resultObject', 'N/currentRecordService'],
	function (recordDefinition, util, utilityFunctions, resultObject, currentRecordService)
	{

		var create = utilityFunctions.thenableFunction(function create(rawRecordOrCreateOptions, isNewRecord, isAsync)
		{
			/* Make a copy of the args, as we will make changes to our copy. */
			var recordOptions = util.extend({}, rawRecordOrCreateOptions);

			return resultObject.create(function ()
			{
				/* Create a dynamic, deferred-dynamic, or read-only record instance. */
				return create_raw.thenable(recordOptions, isNewRecord, isAsync);
			}).then(function (record)
			{
				var proxyOptions = util.extend({isInteractive: false}, recordOptions.config);
				return record.proxy(proxyOptions);
			});
		}, {
			isAsyncArgIndex: 2
		});

		var create_raw = utilityFunctions.thenableFunction(function create_raw(recordOptions, isNewRecord, isAsync)
		{
			if (recordOptions.config.isCurrentRecord)
			{
				/* This will set our currentRecord from within the record creation code, right before pageInit() is called.
				 * That allows currentRecord module to be used inside of pageInit(). */
				recordOptions.initCallback = function initCallback(recordBeingCreated)
				{
					currentRecordService.set(recordBeingCreated);
				};
			}

			return recordDefinition.create.thenable({recordObj: recordOptions}, isAsync);
		}, {
			isAsyncArgIndex: 2
		});


		return Object.freeze({
			create: create,
			create_raw: create_raw
		});
	});




/**
 * SuiteScript record util module
 *
 * @private
 * @module N/record/recordUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/record/recordUtil',['N/record/recordService', 'N/utilityFunctions', 'N/record/recordConstants', 'N/util', 'N/resultObject'],
	function (recordService, utilityFunctions, constants, util, resultObject)
	{
		var undef = undefined;

		// ==================== HELPERS ====================

		function getEventsParam(options)
		{
			var result = {};
			result.compress = !!options && typeof options.compressEvents !== 'undefined' ? !!options.compressEvents : true;

			return result;
		}

		// ==================== CREATE ====================

		function getCreateParams(options, isAsync)
		{
			var type, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isAsync) ? 'create.promise' : 'create';
			utilityFunctions.checkArgs([type], ['type'], moduleName);
			return {type: type, defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		var doCreateRecord_raw = utilityFunctions.thenableFunction(function doCreateRecord_raw(createArgs, nsrecord, isAsync)
		{
			return resultObject.create(function ()
			{
				if (nsrecord.config)
				{
					nsrecord.config.initialization = {
						method: 'createRecord',
						params: createArgs
					};

					if (!isAsync)
					{
						nsrecord.config.initialization.remoteId = nsrecord.remoteId;
					}
				}

				return recordService.create_raw.thenable(nsrecord, undefined, isAsync);
			}).then(function (record)
			{
				utilityFunctions.assertTrue(createArgs.type.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
				return record;
			});
		}, {
			isAsyncArgIndex: 2
		});

		// ==================== COPY ====================

		function getCopyParams(options, isAsync)
		{
			var type, id, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isAsync) ? 'copy.promise' : 'copy';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, compressEvents: events.compress};
		}

		function validateCopyRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase()
				|| (type.toLowerCase() === 'customer' && /(prospect|lead|customer)/
					.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		var doCopyRecord_raw = utilityFunctions.thenableFunction(function doCopyRecord_raw(copyArgs, nsrecord, isAsync)
		{
			return resultObject.create(function ()
			{
				if (nsrecord.config)
				{
					nsrecord.config.initialization = {
						method: 'copyRecord',
						params: copyArgs
					};

					if (!isAsync)
					{
						nsrecord.config.initialization.remoteId = nsrecord.remoteId;
					}
				}

				return recordService.create_raw.thenable(nsrecord, undefined, isAsync);
			}).then(function (record)
			{
				validateCopyRecord(copyArgs.type, record);
				return record;
			});
		}, {
			isAsyncArgIndex: 2
		});

		// ==================== LOAD ====================

		function getLoadParams(options, isAsync)
		{
			var type, id, defaultValues, isCurrent,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
				isCurrent = options.isCurrent || false;
			}
			var moduleName = (isAsync) ? 'load.promise' : 'load';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id), defaults: defaultValues, current: isCurrent, compressEvents: events.compress};
		}

		function validateLoadRecord(type, record)
		{
			utilityFunctions.assertTrue(type.toLowerCase() === record.type.toLowerCase() ||
				(type.toLowerCase() === 'assemblyitem' && /.*assemblyitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'inventoryitem' && /.*inventoryitem/.test(record.type.toLowerCase())) ||
				(type.toLowerCase() === 'customer' && /(prospect|lead|customer)/.test(record.type.toLowerCase())), 'SSS_RECORD_TYPE_MISMATCH');
		}

		var doLoadRecord_raw = utilityFunctions.thenableFunction(function doLoadRecord_raw(loadArgs, nsrecord, isAsync)
		{
			return resultObject.create(function ()
			{
				if (nsrecord.config)
				{
					nsrecord.config.initialization = {
						method: 'loadRecord',
						params: loadArgs
					};

					if (!isAsync)
					{
						nsrecord.config.initialization.remoteId = nsrecord.remoteId;
					}
				}

				return recordService.create_raw.thenable(nsrecord, undefined, isAsync);
			}).then(function (record)
			{
				validateLoadRecord(loadArgs.type, record);
				return record;
			});
		}, {
			isAsyncArgIndex: 2
		});

		// ==================== TRANSFORM ====================

		function getTransformParams(options, isAsync)
		{
			var fromType, fromId, toType, defaultValues,
				events = getEventsParam(options);

			if (options !== undef && options !== null)
			{
				fromType = options.fromType;
				fromId = options.fromId;
				toType = options.toType;
				defaultValues = options.isDynamic ? {recordmode: 'dynamic'} : {};
				util.extend(defaultValues, options.defaultValues || {});
			}
			var moduleName = (isAsync) ? 'transform.promise' : 'transform';
			utilityFunctions.checkArgs([fromType, fromId, toType], ['fromType', 'fromId', 'toType'], moduleName);
			return {
				type: fromType,
				id: String(fromId),
				transformType: toType,
				defaults: defaultValues,
				compressEvents: events.compress
			};
		}

		var doTransformRecord_raw = utilityFunctions.thenableFunction(function doTransformRecord_raw(transformArgs, nsrecord, isAsync)
		{
			return resultObject.create(function ()
			{
				if (nsrecord.config)
				{
					nsrecord.config.initialization = {
						method: 'transformRecord',
						params: transformArgs
					};

					if (!isAsync)
					{
						nsrecord.config.initialization.remoteId = nsrecord.remoteId;
					}
				}

				return recordService.create_raw.thenable(nsrecord, undefined, isAsync);
			}).then(function (record)
			{
				utilityFunctions.assertTrue(transformArgs.transformType.toLowerCase() === record.type.toLowerCase(), 'SSS_RECORD_TYPE_MISMATCH');
				return record;
			});
		}, {
			isAsyncArgIndex: 2
		});

		// ==================== DELETE ====================

		function getDeleteParams(options, isAsync)
		{
			var type, id;
			if (options !== undef && options !== null)
			{
				type = options.type;
				id = options.id;
			}
			var moduleName = (isAsync) ? 'delete.promise' : 'delete';
			utilityFunctions.checkArgs([type, id], ['type', 'id'], moduleName);
			return {type: type, id: String(id)};
		}

		function doDeleteRecord(recordId)
		{
			return parseInt(recordId, 10);
		}

		// ==================== SUBMIT FIELDS ====================
		function getSubmitFieldsParams(option, isAsync)
		{
			option = option || {};
			var type = option.type, id = option.id, values = option.values, options = option.options;
			var moduleName = (isAsync) ? 'submitFields.promise' : 'submitFields';
			utilityFunctions.checkArgs([type, id, values], ['type', 'id', 'values'], moduleName);

			var submitOptions = {
				enablesourcing: (utilityFunctions.isObject(options) && options['enableSourcing'] === true) ? true : false,
				disabletriggers: (utilityFunctions.isObject(options) && options['disableTriggers'] === true) ? true : false,
				ignoremandatoryfields: (utilityFunctions.isObject(options) && options['ignoreMandatoryFields'] === true) ? true : false
			};

			var flds = [], vals = [];
			for (var field in values)
			{
				if (values.hasOwnProperty(field))
				{
					flds[flds.length] = field;
					vals[vals.length] = values[field];
				}
			}
			flds = flds.length > 0 ? flds : null;
			vals = vals.length > 0 ? vals : null;
			return [type, id, flds, vals, submitOptions];
		}

		function doSubmitFields(submitResponse)
		{
			return parseInt(submitResponse, 10);
		}

		// ==================== ATTACH ====================
		function getAttachParams(options, isAsync)
		{
			var record = options.record, to = options.to, attributes = options.attributes || null;
			var moduleName = (isAsync) ? 'attach.promise' : 'attach';
			utilityFunctions.checkArgs([record, to], ['record', 'to'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				toType = options.to.type, toId = (options.to.id) ? String(options.to.id) : null;
			utilityFunctions.checkArgs([recordType, recordId, toType, toId], ['record.type', 'record.id', 'to.type', 'to.id'], moduleName);
			return [recordType, recordId, toType, toId, attributes];
		}

		// ==================== DETACH ====================
		function getDetachParams(options, isAsync)
		{
			var record = options.record, from = options.from, attributes = options.attributes || null;
			var moduleName = (isAsync) ? 'detach.promise' : 'detach';
			utilityFunctions.checkArgs([record, from], ['record', 'from'], moduleName);

			var recordType = options.record.type, recordId = options.record.id,
				fromType = options.from.type, fromId = options.from.id;
			utilityFunctions.checkArgs([recordType, recordId, fromType, fromId], ['record.type', 'record.id', 'from.type', 'from.id'], moduleName);
			return [recordType, recordId, fromType, fromId, attributes];
		}

		return Object.freeze({
			getCreateParams: getCreateParams,
			doCreateRecord_raw: doCreateRecord_raw,

			getCopyParams: getCopyParams,
			doCopyRecord_raw: doCopyRecord_raw,

			getLoadParams: getLoadParams,
			doLoadRecord_raw: doLoadRecord_raw,

			getTransformParams: getTransformParams,
			doTransformRecord_raw: doTransformRecord_raw,

			getDeleteParams: getDeleteParams,
			doDeleteRecord: doDeleteRecord,
			getSubmitFieldsParams: getSubmitFieldsParams,
			doSubmitFields: doSubmitFields,
			getAttachParams: getAttachParams,
			getDetachParams: getDetachParams
		});
	});

/**
 * SuiteScript record implementation common module.
 *
 * Implements the 4 primary methods that can create a record, and offers both a proxied and raw (unproxied) variant of each.
 *
 * @private
 * @module N/record/recordImpl
 * @suiteScriptVersion 2.x
 *
 */
define('N/record/recordImpl',['N/restricted/recordApi', 'N/internal/invoker', 'N/record/recordUtil', 'N/utilityFunctions', 'N/resultObject'],
	function (api, invoker, recordUtil, utilityFunctions, resultObject)
	{
		function getProxyOptions(options)
		{
			var proxyOptions = {isInteractive: false};
			return options ? util.extend(proxyOptions, options) : proxyOptions;
		}

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		var createRecord = utilityFunctions.thenableFunction(function createRecord(options, isAsync)
		{
			return resultObject.create(function ()
			{
				return createRecord_raw.thenable(options, isAsync);
			}).then(function (rawRecord)
			{
				return rawRecord.proxy(getProxyOptions(options));
			});
		}, {
			isAsyncArgIndex: 1
		});

		var createRecord_raw = utilityFunctions.thenableFunction(function createRecord_raw(options, isAsync)
		{
			var createArgs = recordUtil.getCreateParams(options, isAsync);
			return resultObject.create(function ()
			{
				return (isAsync ? invoker.promise : invoker)(api, 'createRecord', [createArgs.type, createArgs.defaults]);
			}).then(function (nsrecord)
			{
				return recordUtil.doCreateRecord_raw.thenable(createArgs, nsrecord, isAsync);
			});
		}, {
			isAsyncArgIndex: 1
		});


		var copyRecord = utilityFunctions.thenableFunction(function copyRecord(options, isAsync)
		{
			return resultObject.create(function ()
			{
				return copyRecord_raw.thenable(options, isAsync);
			}).then(function (rawRecord)
			{
				return rawRecord.proxy(getProxyOptions(options));
			});
		}, {
			isAsyncArgIndex: 1
		});

		var copyRecord_raw = utilityFunctions.thenableFunction(function copyRecord_raw(options, isAsync)
		{
			var copyArgs = recordUtil.getCopyParams(options, isAsync);
			return resultObject.create(function ()
			{
				return (isAsync ? invoker.promise : invoker)(api, 'copyRecord', [copyArgs.type, copyArgs.id, copyArgs.defaults]);
			}).then(function (nsrecord)
			{
				return recordUtil.doCopyRecord_raw.thenable(copyArgs, nsrecord, isAsync);
			});
		}, {
			isAsyncArgIndex: 1
		});


		var loadRecord = utilityFunctions.thenableFunction(function loadRecord(options, isAsync)
		{
			return resultObject.create(function ()
			{
				return loadRecord_raw.thenable(options, isAsync);
			}).then(function (rawRecord)
			{
				return rawRecord.proxy(getProxyOptions(options));
			});
		}, {
			isAsyncArgIndex: 1
		});

		var loadRecord_raw = utilityFunctions.thenableFunction(function loadRecord_raw(options, isAsync)
		{
			var loadArgs = recordUtil.getLoadParams(options, isAsync);
			return resultObject.create(function ()
			{
				return (isAsync ? invoker.promise : invoker)(api, 'loadRecord', [loadArgs.type, loadArgs.id, loadArgs.defaults]);
			}).then(function (nsrecord)
			{
				return recordUtil.doLoadRecord_raw.thenable(loadArgs, nsrecord, isAsync);
			});
		}, {
			isAsyncArgIndex: 1
		});


		var transformRecord = utilityFunctions.thenableFunction(function transformRecord(options, isAsync)
		{
			return resultObject.create(function ()
			{
				return transformRecord_raw.thenable(options, isAsync);
			}).then(function (rawRecord)
			{
				return rawRecord.proxy(getProxyOptions(options));
			});
		}, {
			isAsyncArgIndex: 1
		});

		var transformRecord_raw = utilityFunctions.thenableFunction(function transformRecord_raw(options, isAsync)
		{
			var transformArgs = recordUtil.getTransformParams(options, isAsync);
			return resultObject.create(function ()
			{
				return (isAsync ? invoker.promise : invoker)(api, 'transformRecord', [transformArgs.type, transformArgs.id, transformArgs.transformType, transformArgs.defaults]);
			}).then(function (nsrecord)
			{
				return recordUtil.doTransformRecord_raw.thenable(transformArgs, nsrecord, isAsync);
			});
		}, {
			isAsyncArgIndex: 1
		});


		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		var deleteRecord = utilityFunctions.thenableFunction(function deleteRecord(options, isAsync)
		{
            var deleteArgs = recordUtil.getDeleteParams(options, isAsync);
        	return resultObject.create(function ()
	        {
	        	return (isAsync ? invoker.promise : invoker)(api, 'nlapiDeleteRecord', [deleteArgs.type, deleteArgs.id, null]);
	        }).then(function (recordID)
	        {
	        	return recordUtil.doDeleteRecord(recordID);
	        });
		}, {
			isAsyncArgIndex: 1
		});


		var submitFields = utilityFunctions.thenableFunction(function submitFields(options, isAsync)
		{
            var argList = recordUtil.getSubmitFieldsParams(options, isAsync);
        	return resultObject.create(function ()
	        {
                return (isAsync ? invoker.promise : invoker)(api, 'nlapiSubmitField', argList);
	        }).then(function (submitResponse)
	        {
	        	return recordUtil.doSubmitFields(submitResponse);
	        });
		}, {
			isAsyncArgIndex: 1
		});


		var attachRecord = utilityFunctions.thenableFunction(function attachRecord(options, isAsync)
		{
            var argList = recordUtil.getAttachParams(options, isAsync);
			return (isAsync ? invoker.promise : invoker)(api, 'nlapiAttachRecord', argList);
		}, {
			isAsyncArgIndex: 1
		});


		var detachRecord = utilityFunctions.thenableFunction(function detachRecord(options, isAsync)
		{
			var argList = recordUtil.getDetachParams(options, isAsync);
			return (isAsync ? invoker.promise : invoker)(api, 'nlapiDetachRecord', argList);
		}, {
			isAsyncArgIndex: 1
		});


		return Object.freeze({
			create: createRecord,
			create_raw: createRecord_raw,

			load: loadRecord,
			load_raw: loadRecord_raw,

			copy: copyRecord,
			copy_raw: copyRecord_raw,

			transform: transformRecord,
			transform_raw: transformRecord_raw,

			'delete': deleteRecord,

			submitFields: submitFields,

			attach: attachRecord,

			detach: detachRecord
		});
	}
);

/**
 * SuiteScript record common module
 *
 * @module N/record
 * @suiteScriptVersion 2.x
 *
 */
define('N/record',['N/restricted/recordApi', 'N/internal/invoker', 'N/record/recordImpl', 'N/record/recordUtil', 'N/record/recordEvent', 'N/dynamicEnums'],
	function (api, invoker, recordImpl, recordUtil, recordEvent, dynamicEnums)
	{
		var recordTypes;

		// ==================== OPERATIONS THAT RETURN A RECORD ====================

		function createRecord(options) { return recordImpl.create(options); }
		createRecord.promise = function createRecordPromise(options) { return recordImpl.create.promise(options); };

		function loadRecord(options) { return recordImpl.load(options); }
		loadRecord.promise = function loadRecordPromise(options) { return recordImpl.load.promise(options); };

		function copyRecord(options) { return recordImpl.copy(options); }
		copyRecord.promise = function copyRecordPromise(options) { return recordImpl.copy.promise(options); };

		function transformRecord(options) { return recordImpl.transform(options); }
		transformRecord.promise = function transformRecordPromise(options) { return recordImpl.transform.promise(options); };


		// ==================== OPERATIONS THAT DO NOT RETURN A RECORD ====================

		function deleteRecord(options) { return recordImpl['delete'](options); }
		deleteRecord.promise = function deleteRecordPromise(options) { return recordImpl['delete'].promise(options); };

		function submitFields(options) { return recordImpl.submitFields(options); }
		submitFields.promise = function submitFieldsPromise(options) { return recordImpl.submitFields.promise(options); };

		function attachRecord(options) { return recordImpl.attach(options); }
		attachRecord.promise = function attachRecordPromise(options) { return recordImpl.attach.promise(options); };

		function detachRecord(options) { return recordImpl.detach(options); }
		detachRecord.promise = function detachRecordPromise(options) { return recordImpl.detach.promise(options); };


		return Object.freeze({
			Event: recordEvent.Type,

			/**
			 * Create a new record object based on provided type
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type record type
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type is missing
			 *
			 * @since 2015.2
			 */
			create: createRecord,

			/**
			 * Load an existing nlobjRecord from the database based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance to be loaded.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is loaded in dynamic mode.
			 * @param {Object} [options.defaultValues] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			load: loadRecord,

			/**
			 * Copy a record object based on provided type, id
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance being copied.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			copy: copyRecord,

			/**
			 * Transform a record into another type (i.e. salesOrder -> invoice -or- opportunity -> estimate)
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.fromType The record type of the existing record instance being transformed.
			 * @param {number|string} options.fromId The internal ID of the existing record instance being transformed.
			 * @param {string} options.toType The record type of the record returned when the transformation is complete.
			 * @param {boolean} [options.isDynamic=false] Determines whether the new record is created in dynamic mode.
			 * @param {Object} [options.defaultValues] Name-value pairs containing default values of fields in the new record. By default, this value is empty.
			 * @return {Record}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options.type or options.id is missing
			 *
			 * @since 2015.2
			 */
			transform: transformRecord,

			/**
			 * Delete a record object based on provided type, id and return the id of deleted record
			 *
			 * @governance 20 units for transactions, 4 for custom records, 10 for all other records
			 *
			 * @param {Object} options
			 * @param {string} options.type The record type.
			 * @param {number|string} options.id The internal ID of the existing record instance to be deleted.
			 * @return {number} recordId
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			'delete': deleteRecord,

			/**
			 * Updates and submits one or more body fields on an existing record in NetSuite, and returns the internal ID of the parent record. When you use this method, you do not need to load or submit the parent record.
			 *
			 * @governance 10 units for transactions, 2 for custom records, 5 for all other records
			 * @restriction only supported for records and fields where DLE (Direct List Editing) is supported
			 *
			 * @param {Object} options
			 * @param {string} options.type When working with an instance of a standard NetSuite record type, set this value by using the record.Type enum. When working with an instance of a custom record type, set this value by using the custom record typeâs string ID.
			 * @param {number|string} options.id The internal ID of the existing record instance in NetSuite.
			 * @param {Object} options.values The ID-value pairs for each field you want to edit and submit.
			 * @param {Object} [options.options] additonal flags for submission
			 * @param {boolean} [options.options.enablesourcing=true] enable sourcing during record update
			 * @param {boolean} [options.options.ignoreMandatoryFields=false] ignore mandatory field during record submission
			 *
			 * @return {number} id of submitted record
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
			 *
			 * @since 2015.2
			 */
			submitFields: submitFields,

			/**
			 * Attaches a record to another record.
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be attached
			 * @param {Object} options.record.type The type of record to attach.
			 * @param {number|string} options.record.id The internal ID of the record to attach.
			 * @param {Object} options.to The record that the options.record gets attached to.
			 * @param {string} options.to.type The record type of the record to attach to.
			 * @param {number|string} options.to.id The id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or to (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			attach: attachRecord,

			/**
			 * detach record from another record
			 *
			 * @governance 10 units
			 *
			 * @param {Object} options
			 * @param {Object} options.record record to be detached
			 * @param {Object} options.record.type The type of record to be detached.
			 * @param {number|string} options.record.id The id of the record to be detached
			 * @param {Object} options.from The destination record where options.record will be detached from
			 * @param {string} options.from.type The type of the destination
			 * @param {number|string} options.from.id The id of the destination
			 * @param {Object} [options.attributes=null] name/value pairs containing attributes
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if any of record or from (and their type and id) are missing
			 *
			 * @since 2015.2
			 */
			detach: detachRecord,

			/*
			 * module enums
			 */
			get Type()
			{
				if (!recordTypes)
				{
					recordTypes = dynamicEnums.recordTypes;
				}
				return recordTypes;
			}
		});
	}
);

/**
 * SuiteScript currentField module
 *
 * @private
 * @module N/currentRecord/currentField
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentField',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/fieldUtil', 'N/eventEmitter', 'N/runtime', 'N/record/fieldBase', 'N/fieldTypeConstants'],
	function(nsobject, error, utilityFunctions, fieldUtil, eventEmitter, runtime, fieldBase, fieldTypeConstants) {

	/**
	 * Return a wrapped nlobjField used for accessing and manipulating the fields on the current record
	 * @alias CurrentRecordField
	 *
	 * @classDescription Encapsulation of fields on the currentRecord
	 * @return {CurrentRecordField}
	 * @constructor
	 *
	 * @since 2015.2
	 */
    function nlobjFieldCurrentRecordField(fieldObj)
    {
        /**
         * Return label of the field
         * @name CurrentRecordField#label
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'label', {
            get: function ()
            {
                return fieldObj.getLabel();
            },
            set: function (label)
            {
                var sublistId = fieldObj.getSubList();
                if (!sublistId)
                {
                    setLabel(fieldObj.getName() + "_fs", label);
                    fieldObj.label = label;
                }
                else
                {
                    if (hasMachine(sublistId))
                    {
                        var mch = eval( String(sublistId) + '_machine');
                        var fldnam = fieldObj.getName();
                        var possibleLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam));
                        var useDisplay = false;
                        if (possibleLabel === "")
                        {
                            // If the existing column is hidden, we won't display it. Go see if the _display version exists.

                            var displayLabel = mch.getFormElementLabel(mch.getArrayPosition(fldnam + "_display"));
                            if (displayLabel !== "" && displayLabel !== undefined)
                            {
                                // update the object, then the actual value on the machine, then update the array that is used to initialize the objects
                                fieldObj.label = label;
                                mch.setFormElementLabel(fldnam + "_display", label);
                                window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                                window.lineitemFieldlabelArray[sublistId][fldnam + "_display"] = label;
                            }
                            // if it still a hidden field (or doesn't exist), then don't do anything.
                        }
                        else if (possibleLabel !== undefined)
                        {
                            fieldObj.label = label;
                            mch.setFormElementLabel(fldnam, label);
                            window.lineitemFieldlabelArray[sublistId][fldnam] = label;
                        }
                    }
                    else
                    {
                        // No implementation for list machines.
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return id of the field
         * @name CurrentRecordField#id
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'id', {
            get: function ()
            {
                return fieldObj.getName();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return type of the field
         * @name CurrentRecordField#type
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'type', {
            get: function ()
            {
                return fieldObj.getType();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return sublist Id of the field, undefined if not applicable
         * @name CurrentRecordField#sublistId
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'sublistId', {
            get: function ()
            {
                return fieldObj.getSubList();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is mandatory
         * @name CurrentRecordField#isMandatory
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isMandatory', {
            get: function ()
            {
                return !!fieldObj.isMandatory();
            },
            set: function (required)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    if (nsapiIsInternal() || /cust(entity|item|body|column|record|itemnumber|page|event).+/.test(fldnam))
                        setRequired(getFormElement(form, getFieldName(fldnam)), required);
                    fieldObj.required = required;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Disabled
         * @name CurrentRecordField#isDisabled
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisabled', {
            get: function ()
            {
                return !!fieldObj.isDisabled();
            },
            set: function (val)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    disableField(getFormElement(form, getFieldName(fldnam)), val);
                    if (typeof(ftabs) == 'undefined' || ftabs[getFieldName(fldnam)] == null || ftabs[getFieldName(fldnam)] == "main")
                        nsDisabledFields[fldnam] = val;
                }
                else
                {
                    var fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam));
                    if (fld == null)
                        fld = getFormElement(document.forms[sublist.toLowerCase() + '_form'], getFieldName(fldnam) + fieldObj.getLine())
                    disableField(fld, val);
                }
                fieldObj.disabled = val;
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is a Popup
         * @name CurrentRecordField#isPopup
         * @readonly
         * @throws READ_ONLY when setting the property is attempted
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isPopup', {
            get: function ()
            {
                return !!fieldObj.isPopup();
            },
            set: function (val)
            {
                utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' );
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Displayed (false means, unlike Visible, the space where it used to be is also not visible)
         * @name CurrentRecordField#isDisplay
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
            get: function ()
            {
                return !!fieldObj.isDisplay();
            },
            set: function (show)
            {
                var sublist = fieldObj.getSubList();
                var fldnam = fieldObj.getName();
                if (!sublist)
                {
                    showFieldAndLabel(fldnam + "_fs", show)
                    if (typeof(ftabs) != 'undefined')
                    {
                        var tabName = ftabs[getFieldName(fldnam)];
                        ns_tabUtils.updateTabVisibility(tabName);
                    }
                    fieldObj.display = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is Visible (false means, unlike Display, the space where it used to be is still there, just the field itself is not visible)
         * @name CurrentRecordField#isVisible
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isVisible', {
            get: function ()
            {
                return !!fieldObj.isVisible();
            },
            set: function (show)
            {
                if (!fieldObj.getSubList())
                {
                    setFieldAndLabelVisibility(fieldObj.getName() + "_fs", show);
                    fieldObj.visible = show;
                }
            },
            enumerable: true,
            configurable: false
        });

        /**
         * Return whether the field is ReadOnly
         * @name CurrentRecordField#isReadOnly
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isReadOnly', {
            get: function ()
            {
                return !!fieldObj.isReadOnly();
            },
            set: function (val)
            {
                if (!fieldObj.getSubList())
                {
                    var fldnam = fieldObj.getName();
                    var form = typeof(ftabs) != 'undefined' && ftabs[getFieldName(fldnam)] != null ? document.forms[ftabs[getFieldName(fldnam)] + '_form'] : document.forms['main_form'];
                    var fld = getFormElement(form, getFieldName(fldnam));
                    if (fld != null)
                    {
                        if (fieldObj.getType() !== "textarea")
                        {
                            utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' );
                        }
                        else
                        {
                            setFieldReadOnly(fld, val);
                            fieldObj.readonly = !!fld.readOnly;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: false
        });

	    if (fieldTypeConstants.isSelectType(fieldObj.getType()))
	    {
		    this.getSelectOptions = getSelectOptions;
		    this.insertSelectOption = insertSelectOption;
		    this.removeSelectOption = removeSelectOption;
	    }

	    /**
	     * Returns a list of available options on a select field. This API can be used on both standard and custom select fields. Only the first 1,000 available options will be returned by this API. Does nothing if this field is not a select/multiselect
	     * @param {string} [filter] Will not filter if not present.
	     * @param {string} [filteroperator] Supported operators are contains | is | startswith. If not specified, defaults to the contains operator.
	     * @return {Array}
	     *
	     */
        function getSelectOptions(filter, filteroperator)
        {
	        if (utilityFunctions.isObject(filter))
	        {
		        filteroperator = filter.operator;
		        filter = filter.filter;
	        }

            var sOptions = [];
            var uiField = fieldObj.getUIField();
            var dropdown = (fieldObj.getType() === "select") ? getDropdown(uiField) : getMultiDropdown(uiField);
            if (dropdown)
            {
                var optionValues = dropdown.valueArray;
                var optionTexts = dropdown.textArray;
                var filterfunction = null;
                if (!!filter)
                {
                    filteroperator = filteroperator || "contains";
                    if (filteroperator === "is")
                    {
                        filterfunction = function (v) { return ("" + v).length === filter.length && ("" + v).search(new RegExp(filter, "i")) === 0; };
                    }
                    else if (filteroperator === "startswith")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) === 0; }
                    }
                    else if (filteroperator === "contains")
                    {
                        filterfunction = function (v) { return ("" + v).search(new RegExp(filter, "i")) !== -1;}
                    }
                }
                for (var i = 0; i < optionValues.length; i++)
                {
                    if ((filterfunction === null) || filterfunction(optionTexts[i]))
                        sOptions[sOptions.length] = {
                            value: optionValues[i],
                            text: optionTexts[i]
                        };
                }
            }
            return sOptions;
        }

	    var isPrefixedWithCustPage = fieldUtil.isPrefixedWithCustPage(fieldObj.getName());

	    var selectOptionError;
	    if (!isPrefixedWithCustPage)
	    {
		    selectOptionError = utilityFunctions.throwSuiteScriptError;
	    }
	    else if (typeof console !== 'undefined' && console.warn)
	    {
		    selectOptionError = function ()
		    {
			    try
			    {
				    utilityFunctions.throwSuiteScriptError.apply(this, arguments);
			    }
			    catch (e)
			    {
				    console.warn(e);
			    }
		    }
	    }
	    else
	    {
		    selectOptionError = function () {};
	    }

	    function isInternal()
	    {
		    var scriptId = runtime.getCurrentScript().id;
		    return scriptId == null || scriptId === 'internal';
	    }

	    function checkUpdateSelectOptions()
	    {
		    if (!isInternal() && !isPrefixedWithCustPage)
		    {
			    selectOptionError(error.Type.SSS_INVALID_UI_OBJECT_TYPE);
			    return false;
		    }
		    if (fieldObj.isPopup())
		    {
			    selectOptionError(error.Type.SSS_NOT_YET_SUPPORTED, "update popup select options");
		    	return false;
		    }
		    return true;
	    }

        var localSelectOptions = {};

	    /**
	     * Inserts a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value a unique value for the added select option
	     * @param {string} options.text the display name of the added select option
	     * @param {string} [options.isSelected=false] if true, sets this option to be the default selected option.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function insertSelectOption(options, text)
	    {
		    var value,
			    selected = false,
			    undef = undefined,
			    eventToken;

		    if (text !== undef)
		    {
			    value = options;
		    }
		    else if (options !== undef && options !== null)
		    {
			    value = options.value;
			    text = options.text;
			    selected = options.isSelected || false;
			    eventToken = options._eventToken;
		    }

		    return eventEmitter.callWithToken(eventToken, function ()
		    {
			    if (!checkUpdateSelectOptions())
			    	return;
			    utilityFunctions.checkArgsPresent([value, text], ['value', 'text'], 'CurrentRecordField.insertSelectOption');
			    value = String(value);

			    var uiField = fieldObj.getUIField();
			    if (getIndexForValue(uiField, value) !== -1)
			    {
				    selectOptionError(error.Type.SELECT_OPTION_ALREADY_PRESENT, value);
			    }
			    addSelectOption(window.document, uiField, text, value, selected, window);

			    localSelectOptions[value] = true;
		    });
	    }

	    /**
	     * Removes a select option to a select/multiselect field added via script.
	     *
	     * @restriction This API can only be used if this field is a select/multiselect and was added via the UI Objects API (e.g. Suitelets or beforeLoad user events)
	     *
	     * @param {Object} options
	     * @param {string} options.value the value of the select option to be removed, or null to delete all options.
	     * @throws SSS_INVALID_UI_OBJECT_TYPE when attempting to use this on a field not added via the UI Objects API
	     */
	    function removeSelectOption(options)
	    {
		    var undef = undefined,
			    value,
		        eventToken;

		    if (options !== undef && options !== null && options.value !== undef)
		    {
			    value = options.value;
			    eventToken = options._eventToken;
		    }
		    else
		    {
			    value = options;
		    }

		    return eventEmitter.callWithToken(eventToken, function ()
		    {
			    if (!checkUpdateSelectOptions())
				    return;
			    if (!isPrefixedWithCustPage)
				    utilityFunctions.checkArgsDefined([value], ['value'], 'CurrentRecordField.removeSelectOption');

			    var uiField = fieldObj.getUIField();

			    if (value !== null)
			    {
				    value = String(value);

				    var allowRemove = localSelectOptions[value] || isPrefixedWithCustPage || isInternal();
				    if (!allowRemove || getIndexForValue(uiField, value) === -1) {
					    selectOptionError(error.Type.SELECT_OPTION_NOT_FOUND, value);
				    }

				    delete localSelectOptions[value];
				    deleteOneSelectOption(uiField, value);
			    }
			    else
			    {
				    deleteAllSelectOptions(uiField, window);
			    }
		    });
	    }
    }

    function pojsoCurrentRecordField(fieldObj)
    {
        var internalField = {};

        Object.defineProperty(this, 'label', {
            get: function(){ return fieldObj.label; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'label' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function(){ return fieldObj.name; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function(){ return fieldObj.type; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'type' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function(){ return fieldObj.machinename; },
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'sublistId' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function(){ return fieldObj.required;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isMandatory' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function(){ return fieldObj.isDisabled;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisabled' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function(){ return fieldObj.isPopup;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isPopup' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function(){ return fieldObj.isDisplay;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isDisplay' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function(){ return fieldObj.isVisible;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isVisible' ); },
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function(){ return fieldObj.readonly;},
            set: function(value){ utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isReadOnly' ); },
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = fieldObj.getSelectOptions;
	    this.insertSelectOption = fieldObj.insertSelectOption;
	    this.removeSelectOption = fieldObj.removeSelectOption;
    }
    /*
     noSlaving
     isDisabled
     isPopup
     isDisplay
     isVisible
     */


	/**
	 * Return a wrapped nlobjField used for accessing and manipulating the fields on the current record
	 * @alias CurrentRecordField
	 *
	 * @classDescription Encapsulation of fields on the currentRecord
	 * @return {CurrentRecordField}
	 * @constructor
	 *
	 * @since 2015.2
	 */
    function CurrentRecordField(fieldObj, record)
    {
        var that = this,
                internalField = fieldObj instanceof nlobjField ? new nlobjFieldCurrentRecordField(fieldObj) : new pojsoCurrentRecordField(fieldObj);

        Object.defineProperty(this, 'label', {
            get: function () { return internalField.label;},
            set: function (value) { internalField.label = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'id', {
            get: function () { return internalField.id;},
            set: function (value) { internalField.id = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'type', {
            get: function () { return internalField.type;},
            set: function (value) { internalField.type = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'sublistId', {
            get: function () { return internalField.sublistId;},
            set: function (value) { internalField.sublistId = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isMandatory', {
            get: function () { return internalField.isMandatory;},
            set: function (value) { internalField.isMandatory = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisabled', {
            get: function () { return internalField.isDisabled;},
            set: function (value) { internalField.isDisabled = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isPopup', {
            get: function () { return internalField.isPopup;},
            set: function (value) { internalField.isPopup = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isDisplay', {
            get: function () { return internalField.isDisplay;},
            set: function (value) { internalField.isDisplay = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isVisible', {
            get: function () { return internalField.isVisible;},
            set: function (value) { internalField.isVisible = value;},
            enumerable: true,
            configurable: false
        });
        Object.defineProperty(this, 'isReadOnly', {
            get: function () { return internalField.isReadOnly;},
            set: function (value) { internalField.isReadOnly = value;},
            enumerable: true,
            configurable: false
        });
        this.getSelectOptions = internalField.getSelectOptions;
	    this.insertSelectOption = internalField.insertSelectOption;
	    this.removeSelectOption = internalField.removeSelectOption;
        this.toJSON = function ()
        {
            return {
                id: that.id,
                label: that.label,
                type: that.type,
                sublistId: that.sublistId,
                isMandatory: that.isMandatory,
                isDisabled: that.isDisabled,
                isPopup: that.isPopup,
                isDisplay: that.isDisplay,
                isVisible: that.isVisible,
                isReadOnly: that.isReadOnly
            };
        };
        this.toString = function ()
        {
            return "currentRecordField";
        };
        fieldBase.call(this, record);
    }
    CurrentRecordField.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordField);

    return Object.freeze({
        /**
         * return a new instance of field object
         * @param {Object} fieldObj
         * @returns {CurrentRecordField}
         */
        create: function(fieldObj, record)
        {
            return !fieldObj ? null : new CurrentRecordField(fieldObj, record);
        },
    });
});

/**
 * SuiteScript currentSublist module
 *
 * @private
 * @module N/currentRecord/currentSublist
 * @NApiVersion 2.x
 *
 */
define('N/currentRecord/currentSublist',['N/nsobject', 'N/error', 'N/utilityFunctions', 'N/currentRecord/currentField', 'N/record/sublistBase', 'N/record/columnBase'],
	function(nsobject, error, utilityFunctions, field, sublistBase, columnBase) {
    var SUBLIST_TYPE = Object.freeze({
        INLINE_EDITOR : 'inlineeditor',
        EDITOR : 'editor',
        STATIC_LIST : 'staticlist',
        LIST: 'list'
    });

    /**
     * Return a wrapped nlobjSublist used for accessing and manipulating the sublists on the current record
     * @alias CurrentRecordSublist
     * @classDescription Encapsulation of sublists on the currentRecord
     * @return {CurrentRecordSublist}
     * @constructor
     *
     * @since 2015.2
     */
    function CurrentRecordSublist(sublistObj, record)
    {
        /**
         * The id of the sublist
         * @type {string}
         * @since 2015.2
         */
        this.id = sublistObj.getName();

        /**
         * The type of the sublist
         * @type {string}
         * @since 2015.2
         */
        this.type = sublistObj.getType();

        /**
         * Whether the sublist is displayed or not.
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isDisplay', {
        	get: function() { return sublistObj.isDisplay(); },
	        set: function(val)
	        {
	        	nlapiSetLineItemDisplay(sublistObj.getName(), val);
	        },
	        configurable: true,
	        enumerable: true
        });

	    /**
	     * Whether the sublist is NOT multi-line enabled (it should never be from this context.)
	     * @type {boolean}
	     * @since 2018.2
	     */
	    this.isMultilineEditable = false;

        /**
         * Whether the sublist has been changed or not.
         * For List machines, it will return true when ANY field has changed
         * For Edit machines, once any line change is committed to the hidden fields of the machine.
         * @type {string}
         * @since 2015.2
         */
        Object.defineProperty(this, 'isChanged', {
        	get: function() { return wasMachineChanged(sublistObj.getName()); },
	        configurable: true,
	        enumerable: true
        });

        /**
         * @typedef {CurrentSublistColumn}
         */

        /**
         * @param {Object} options
         * @returns {CurrentSublistColumn}
         */
        this.getColumn = function(options)
        {
            var fieldId;
            if (utilityFunctions.isObject(options))
            	fieldId = options.fieldId;
            else
            	fieldId = options;
            var returnMe = null;

            utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSublist.getColumn');
            var fieldInfo = nlapiGetLineItemField(sublistObj.getName(), fieldId);
            if (fieldInfo !== null)
            {
                /** @type {CurrentSublistColumn} */
                returnMe = {}
                returnMe.id = fieldInfo.name;
                returnMe.type = fieldInfo.type;
                Object.defineProperty(returnMe, 'label', {
                	get: function()
	                {
	                	return fieldInfo.label;
	                },
	                set: function(newLabel)
	                {
						var actualField = fieldInfo ? field.create(fieldInfo, record) : null;
						actualField.label = newLabel;
	                },
	                configurable: true,
	                enumerable: true
                });
                returnMe.sublistId = sublistObj.getName();
                Object.defineProperty(returnMe, 'isDisabled', {
                	get: function()
					{
					    return nlapiGetLineItemDisabled(sublistObj.getName(), fieldInfo.name);
					},
	                set: function(val)
					{
					    nlapiSetLineItemDisabled(sublistObj.getName(), fieldInfo.name, val);
					},
	                configurable: true,
	                enumerable: true
                });
                Object.defineProperty(returnMe, 'isMandatory', {
                	get: function()
					{
						return nlapiGetLineItemMandatory(sublistObj.getName(), fieldInfo.name);
					},
	                set: function (val)
					{
						var internalBefore = nsapiIsInternal();
						try {
							nsapiSetIsInternal(true);
							nlapiSetLineItemMandatory(sublistObj.getName(), fieldInfo.name, val);
						}
						finally {
							nsapiSetIsInternal(internalBefore);
						}
					},
	                configurable: true,
	                enumerable: true
                });
                columnBase.call(returnMe, record);
            }

            return returnMe;
        };

        // Functions for debugger
        this.toJSON = function ()
        {
            return {
                id: this.getName(),
                type: this.getType(),
                isChanged: this.isChanged(),
                isDisplay: this.isDisplay()
            };
        };

        this.toString = function ()
        {
            return "currentRecordSublist";
        };

        sublistBase.call(this, record);
    }
    CurrentRecordSublist.prototype = nsobject.getNewInstance();
    Object.freeze(CurrentRecordSublist);

    return Object.freeze({
        /**
         * return a new instance of sublist object
         * @param {Object} sublistObj
         * @returns {CurrentRecordSublist}
         */
        create: function(sublistObj, record) { return new CurrentRecordSublist(sublistObj, record); },
        /**
         * @enum
         */
        Type: SUBLIST_TYPE
    });
});
/**
 * SuiteScript currentSubrecord module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/currentRecord/currentSubrecord
 * @NApiVersion 2.x
 *
 */
define(
	'N/currentRecord/currentSubrecord',['N/record/recordDefinitionBase',
	 'N/utilityFunctions', 'N/error', 'N/util/formatter', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist', 'N/record/recordUtilityFunctions',
	 'N/record/recordConstants', 'N/util/validator', 'N/fieldTypeConstants', 'N/recordMessage'],
	function (recordDefinitionBase,
	          utilityFunctions, error, formatter, field, sublist, recordUtil,
			  constants, validator, fieldTypeConstants, recordMessage)
	{
		var currentSubrecords = {};

		/**
		 * Current Subrecord interface
		 * @return {CurrentSubrecord}
		 * @constructor
		 * @since 2015.2
		 */
		function CurrentSubrecord(subrecordObj)
		{
			var that = this;
			var parentSublistId = subrecordObj.machinename;
			var parentFieldId = subrecordObj.name;
			var recordObj = subrecordObj.recordmanager;
			var instanceId = subrecordObj.subrecordinstance;
			var isWritable = !!instanceId;

			recordDefinitionBase.call(this, {
				recordOptions: {
					isSubrecord: true,
					isCurrentRecord: true
				}
			});

			this.type = null;
			this.id = null;
			this.isNew = recordUtil.emptyIfNullOrUndefined(subrecordObj.getFieldValue('id')) === '';
			this.isDynamic = isWritable;
			this.isReadOnly = !isWritable;

			function checkTextApiSupported(fieldObj, where)
			{
				if (fieldObj.type === fieldTypeConstants.Type.SELECT || fieldObj.type === fieldTypeConstants.Type.MULTISELECT)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, where);
				}
			}

			function convertV2ValueToV1(fieldObj, value, isText)
			{
				if (util.isArray(value))
				{
					value = value.join(String.fromCharCode(5));
				}
				else if (isText)
				{
					value = formatter.parse(value, fieldObj.type, fieldObj.isCurrency, fieldObj.isNumeric, fieldObj.validationType);
				}

				validator.validateField(fieldObj.name, fieldObj.type, value, fieldObj.isCurrency, fieldObj.isNumeric,
					fieldObj.validationType, undefined, undefined, fieldObj.maxleng, fieldObj.required, undefined, isText);

				value = formatter.format(value, fieldObj.type, fieldObj.isCurrency, fieldObj.isNumeric);

				return value;
			}

			function convertV1ValueToV2(fieldObj, value, isText)
			{
				if (fieldObj.type === fieldTypeConstants.Type.MULTISELECT)
				{
					value = value.split(String.fromCharCode(5));
				}
				else if (isText)
				{
					value = formatter.format(value, fieldObj.type, fieldObj.isCurrency, fieldObj.isNumeric);
				}
				else if (fieldObj.type === fieldTypeConstants.Type.CHECKBOX && utilityFunctions.isValEmpty(value))
				{
					value = false;
				}
				else
				{
					value = formatter.parse(value, fieldObj.type, fieldObj.isCurrency, fieldObj.isNumeric, fieldObj.validationType, undefined, true);
				}

				return value;
			}

			function handleParentActiveRowChange()
			{
				if (parentSublistId)
				{
					recordObj.handleParentActiveRowChange(subrecordObj.sysId);
				}
			}

			function updateChildRecordManagerCurrentLine(sublistId)
			{
				subrecordObj.childRecordManagerCurrentLine[sublistId] = subrecordObj.getChildMachineRecordManager(sublistId).getActiveRowIdx() + 1;
			}

			/**
			 * JSON.stringify() implementation.
			 * @returns {Object}
			 */
			this.toJSON = function ()
			{
				var result = {};

				result.type = this.type;
				result.id = this.id;
				result.isDynamic = true;

				handleParentActiveRowChange();
				result.fields = recordObj.getFieldNames().reduce(function (p, c)
				{
					p[c] = recordObj.getFieldValue(c);
					return p;
				}, {});

				return result;
			};
			/**
			 * Returns the object type name for the implementation.
			 * @returns {string}
			 */
			function toString()
			{
				return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_SUBRECORD;
			}

			this.toString = toString;

			/**
			 * remove body field data
			 * @param {string|{fieldId:string}} options fieldId
			 * @return {CurrentSubrecord}
			 */
			this.removeField = function removeField(options)
			{
				recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', 'CurrentSubrecord.removeField');
				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeField');
			};

			/**
			 * return array of names of all body fields, including machine header field and matrix header fields
			 * @return {array}
			 */
			this.getFields = function getFields()
			{
				return recordObj.getFieldNames();
			};

			/**
			 * return array of names of all sublists
			 * @return {array}
			 */
			this.getSublists = function getSublists()
			{
				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.getSublists');
			};

			/**
			 * return array of names of all fields in a sublist
			 * @param {string|{sublistId:string}} options sublistId
			 * @return {array}
			 */
			this.getSublistFields = function getSublistFields(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.getSublistFields');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					return sublistObj.getFieldNames();
				}

				return null;
			};

			/**
			 * return value of the field
			 *
			 * @param {string|{fieldId:string}} options fieldId
			 * @return {number|date|string|array}
			 *
			 */
			this.getValue = function getValue(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', 'CurrentSubrecord.getValue');

				var fieldObj = recordObj.getField(fieldId);
				if (fieldObj)
				{
					handleParentActiveRowChange();
					return convertV1ValueToV2(fieldObj, subrecordObj.getFieldValue(fieldId), false);
				}
			};

			//
			/**
			 * set value of the field
			 *
			 * @param {string|{fieldId:string, value:(number|date|string|array)}} options fieldId or options-object
			 * @param {number|date|string|array} value
			 * @return {CurrentSubrecord}
			 *
			 */
			this.setValue = function setValue(options, value)
			{
				var undef = undefined,
					fieldId;

				if (value !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.setValue');
				utilityFunctions.checkArgsDefined([value], ['value'], 'CurrentSubrecord.setValue');

				var fieldObj = recordObj.getField(fieldId);
				if (fieldObj)
				{
					handleParentActiveRowChange();
					subrecordObj.setFieldValue(fieldId, convertV2ValueToV1(fieldObj, value, false));
				}

				return that;
			};

			/**
			 * get value of the field in text representation
			 * @param {string|{fieldId:string}} options fieldId
			 * @return {string}
			 */
			this.getText = function getText(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', 'CurrentSubrecord.getText');

				var fieldObj = recordObj.getField(fieldId);
				if (fieldObj)
				{
					checkTextApiSupported(fieldObj, 'CurrentSubrecord.getText');
					handleParentActiveRowChange();
					return convertV1ValueToV2(fieldObj, subrecordObj.getFieldValue(fieldId), true);
				}
			};

			/**
			 * set value of the field by text representation
			 *
			 * @param {string|{fieldId:string, text:string}} options fieldId
			 * @param {string} text
			 * @return {CurrentSubrecord}
			 */
			this.setText = function setText(options, text)
			{
				var undef = undefined,
					fieldId;

				if (text !== undef)
				{
					fieldId = options;
				}
				else if (options !== undef && options !== null)
				{
					fieldId = options.fieldId;
					text = options.text;
				}

				utilityFunctions.checkArgs([fieldId], ['fieldId'], 'CurrentSubrecord.setText');
				utilityFunctions.checkArgsDefined([text], ['text'], 'CurrentSubrecord.setText');

				var fieldObj = recordObj.getField(fieldId);
				if (fieldObj)
				{
					checkTextApiSupported(fieldObj, 'CurrentSubrecord.setText');
					handleParentActiveRowChange();
					subrecordObj.setFieldValue(fieldId, convertV2ValueToV1(fieldObj, text, true));
				}

				return that;
			};

			/**
			 * return field object from record
			 * @param {string|{fieldId:string}} options fieldId
			 * @return {Field}
			 */
			this.getField = function getField(options)
			{
				var fieldId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'fieldId', 'CurrentSubrecord.getField');

				var fieldObj = recordObj.getField(fieldId);
				if (fieldObj)
				{
					return field.create(fieldObj, that);
				}
			};

			/**
			 * return field object from record
			 * return field object from record's sublist
			 * @param {string|{sublistId:string, fieldId:string, line: number}} options sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @return {Field}
			 */
			this.getSublistField = function getSublistField(options, fieldId, line)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentSubrecord.getSublistField');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						return field.create(fieldObj, that);
					}
				}
			};

			/**
			 * return line count of sublist
			 * @param {Object|string} options
			 * @param {string} options.sublistId
			 * @return {number}
			 */
			this.getLineCount = function getLineCount(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.getLineCount');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					return subrecordObj.getLineItemCount(sublistId);
				}

				return -1;
			};

			/**
			 * insert a sublist line
			 * @param {string} options sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.insertLine = function insertLine(options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentSubrecord.insertLine');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentSubrecord.insertLine", subrecordObj.getLineItemCount(sublistId) + 1);

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.insertLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					handleParentActiveRowChange();
					sublistObj.addLine(line);
					updateChildRecordManagerCurrentLine(sublistId);
				}

				return that;
			};

			/**
			 * remove a sublist line
			 * @param {string} sublistId
			 * @param {number} line
			 * @param {boolean} [ignoreRecalc=false] ignore recalc scripting
			 * @return {CurrentSubrecord}
			 */
			this.removeLine = function removeLine(options, line)
			{
				var undef = undefined,
					sublistId,
					ignoreRecalc = false;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
					ignoreRecalc = !!options.ignoreRecalc;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentSubrecord.removeLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeLine');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentSubrecord.removeLine", subrecordObj.getLineItemCount(sublistId) + 1);

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.removeLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					handleParentActiveRowChange();
					sublistObj.removeLine(line);
					updateChildRecordManagerCurrentLine(sublistId);
				}

				return that;
			};

			/**
			 * return the line number for the first occurrence of a field value in a sublist
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @return {number}
			 */
			this.findSublistLineWithValue = function findSublistLineWithValue(options, fieldId, value)
			{
				var undef = undefined,
					result = -1,
					sublistId,
					i, v;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, value], ['sublistId', 'fieldId', 'value'], 'CurrentSubrecord.findSublistLineWithValue');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						handleParentActiveRowChange();
						for (i = 0; i < sublistObj.rows.length; i++)
						{
							v = formatter.parse(sublistObj.rows[i][sublistObj.fldIdx[fieldId]], fieldObj.type, fieldObj.isNumeric, fieldObj.isCurrency, fieldObj.validationType);
							if (v === value)
							{
								result = i;
								break;
							}
						}
					}
				}

				return result;
			};

			/**
			 * cancel the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.cancelLine = function cancelLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.cancelLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.cancelLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					handleParentActiveRowChange();
					sublistObj.cancelLineChanges();
					updateChildRecordManagerCurrentLine(sublistId);
				}

				return that;
			};

			/**
			 * commit the current selected line
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.commitLine = function commitLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.commitLine');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.commitLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					handleParentActiveRowChange();
					sublistObj.addRow();
					updateChildRecordManagerCurrentLine(sublistId);
				}

				return that;
			};

			/**
			 * select line
			 * @param {string} sublistId
			 * @param {number} line
			 * @return {CurrentSubrecord}
			 */
			this.selectLine = function selectLine(options, line)
			{
				var undef = undefined,
					sublistId;

				if (line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], 'CurrentSubrecord.selectLine');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentSubrecord.selectLine", subrecordObj.getLineItemCount(sublistId));

				subrecordObj.selectLineItem(sublistId, line);

				return that;
			};

			/**
			 * select a new line at the end of sublist
			 * @param {string} sublistId
			 * @return {CurrentSubrecord}
			 */
			this.selectNewLine = function selectNewLine(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.selectNewLine');
				var line = recordUtil.getOneBasedIndex(subrecordObj.getLineItemCount(sublistId));

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.selectNewLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					handleParentActiveRowChange();
					sublistObj.setActiveLine(line, true);
					updateChildRecordManagerCurrentLine(sublistId);
				}

				return that;
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @return {number|date|string|array}
			 */
			this.getCurrentSublistValue = function getCurrentSublistValue(options, fieldId)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.getCurrentSublistValue');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						handleParentActiveRowChange();
						return convertV1ValueToV2(fieldObj, sublistObj.getFieldValue(fieldId), false);
					}
				}
			};

			/**
			 * return value of a sublist field on the current selected sublist line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {string} line
			 * @return {number|date|string|array}
			 */
			this.getSublistValue = function getSublistValue(options, fieldId, line)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentSubrecord.getSublistValue');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentSubrecord.getSublistValue", subrecordObj.getLineItemCount(sublistId));

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (sublistObj)
					{
						handleParentActiveRowChange();
						return convertV1ValueToV2(fieldObj, sublistObj.getFieldValue(fieldId, line - 1), false);
					}
				}
			};

			/**
			 * set the value for field in the current selected line
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistValue = function setCurrentSublistValue(options, fieldId, value)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && value !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					value = options.value;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.setCurrentSublistValue');
				utilityFunctions.checkArgsDefined([value], ['value'], 'CurrentSubrecord.setCurrentSublistValue');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistValue');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						handleParentActiveRowChange();
						sublistObj.setFieldValue(fieldId, convertV2ValueToV1(fieldObj, value, false));
					}
				}

				return that;
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @returns {string}
			 */
			this.getCurrentSublistText = function getCurrentSublistText(options, fieldId)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.getCurrentSublistText');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						checkTextApiSupported(fieldObj, 'CurrentSubrecord.getCurrentSublistText');
						handleParentActiveRowChange();
						return convertV1ValueToV2(fieldObj, sublistObj.getFieldValue(fieldId), true);
					}
				}
			};

			/**
			 * return the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number} line
			 * @returns {string}
			 */
			this.getSublistText = function getSublistText(options, fieldId, line)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && line !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					line = options.line;
				}

				utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], 'CurrentSubrecord.getSublistText');
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentSubrecord.getSublistText", subrecordObj.getLineItemCount(sublistId));

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						checkTextApiSupported(fieldObj, 'CurrentSubrecord.getSublistText');
						handleParentActiveRowChange();
						return convertV1ValueToV2(fieldObj, sublistObj.getFieldValue(fieldId, line - 1), true);
					}
				}
			};

			/**
			 * set the value for field in the current selected line by text representation
			 * @param {string} sublistId
			 * @param {string} fieldId
			 * @param {number|date|string|array} value
			 * @returns {CurrentSubrecord}
			 */
			this.setCurrentSublistText = function setCurrentSublistText(options, fieldId, text)
			{
				var undef = undefined,
					sublistId;

				if (fieldId !== undef && text !== undef)
				{
					sublistId = options;
				}
				else if (options !== undef && options !== null)
				{
					sublistId = options.sublistId;
					fieldId = options.fieldId;
					text = options.text;
				}

				utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], 'CurrentSubrecord.setCurrentSublistText');
				utilityFunctions.checkArgsDefined([text], ['text'], 'CurrentSubrecord.setCurrentSublistText');

				utilityFunctions.throwSuiteScriptError(error.Type.NOT_SUPPORTED_ON_CURRENT_SUBRECORD, 'CurrentSubrecord.setCurrentSublistText');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					var fieldObj = sublistObj.getField(fieldId);
					if (fieldObj)
					{
						checkTextApiSupported(fieldObj, 'CurrentSubrecord.setCurrentSublistText');
						handleParentActiveRowChange();
						sublistObj.setFieldValue(fieldId, convertV2ValueToV1(fieldObj, text, true));
					}
				}

				return that;
			};

			/**
			 * return the line number of current selected line
			 * @param {string} options.sublistId
			 * @return {number}
			 */
			this.getCurrentSublistIndex = function getCurrentSublistIndex(options)
			{
				var sublistId = recordUtil.handleOverloadingMethodsForSingleArgument(options, 'sublistId', 'CurrentSubrecord.selectNewLine');

				var sublistObj = subrecordObj.getChildMachineRecordManager(sublistId);
				if (sublistObj)
				{
					return recordUtil.getZeroBasedIndex(subrecordObj.linenum);
				}

				return -1;
			};

			this.isAbandoned = function isAbandoned()
			{
				if (!that.isReadOnly && (!subrecordObj || !subrecordObj.subrecordinstance))
				{
					delete currentSubrecords[instanceId];
					subrecordObj = parentSublistId == null ? nlapiEditSubrecord(parentFieldId) : nlapiEditCurrentLineItemSubrecord(parentSublistId, parentFieldId);
					recordObj = undefined;
					instanceId = undefined;
					if (subrecordObj)
					{
						recordObj = subrecordObj.recordmanager;
						instanceId = subrecordObj.subrecordinstance;
						currentSubrecords[instanceId] = that;
						return false;
					}
					return true;
				}
				return false;
			};

			/**
			 * commit the subrecord
			 * @returns {CurrentSubrecord}
			 */
			this.commit = function commit()
			{
				handleParentActiveRowChange();
				subrecordObj.commit();
				NS.form.setChanged(true);
				return this;
			};

			/**
			 * cancel the subrecord
			 * @returns {CurrentSubrecord}
			 */
			this.cancel = function cancel()
			{
				handleParentActiveRowChange();
				subrecordObj.cancel();
				return this;
			};

			var _recordMessage = recordMessage.createWithListener({listenerType: recordMessage.Type.LEGACY});

			this.getRecordMessage = function ()
			{
				return _recordMessage;
			};

			return that;
		}

		/**
		 * return a new instance of field object
		 * @param {Object} subrecordObj
		 * @returns {CurrentSubrecord}
		 */
		function get(subrecordObj)
		{
			if (subrecordObj)
			{
				var instanceId = subrecordObj.subrecordinstance;
				if (instanceId && currentSubrecords[instanceId])
				{
					return currentSubrecords[instanceId];
				}
				else
				{
					var subrecord = new CurrentSubrecord(subrecordObj);
					if (instanceId)
					{
						currentSubrecords[instanceId] = subrecord;
					}
					return subrecord;
				}
			}
		}

		return Object.freeze({get: get});
	});

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * @private
 * @module N/currentRecord/currentRecordScriptingScope
 * @NApiVersion 2.x
 */
define('N/currentRecord/currentRecordScriptingScope',['N/contextSwitch', 'N/internal/reflet', 'N/scriptLoader', 'N/util/callRecordScript'], function (contextSwitch, refletModule, v2ScriptLoader, callRecMod) {
	var global = (function () { return this; })();

	function CurrentScope(options) {
		var coreRecord = options.record;

		var stillLoadingScripts = undefined;
		var runClientScript = undefined;
		var runRecordScript = undefined;
		var fetchClientScripts = undefined;
		var _localeContext;
		(function initScripting() {

			var callRecordScript;
			var moduleKeeper;

			stillLoadingScripts = function stillLoadingScripts() {
				return !callRecordScript || (hasV2clientScripts() && (!moduleKeeper || moduleKeeper.isLoadingModules()));
			};

			fetchClientScripts = (function ()
			{
				function doFetching() {

					callRecMod.create.promise({
						context: null, //coreRecord.getSystemId(),
						handlerModules: coreRecord.getEventHandlerModules(),
						scriptingContext: coreRecord.getScriptingContext(),
						statefulStoreProvider: function (handler, proxyOptions) {
							return coreRecord.getStatefulStoreProxyProvider(proxyOptions).proxy(handler);
						},
						isNSE: coreRecord.isNSE,
					}).then(function (result) {
						callRecordScript = result;
					});

					_localeContext = coreRecord.getLocaleContext();

					if (hasV2clientScripts()) {
						moduleKeeper = v2ScriptLoader.createModuleKeeper({
							scriptList: _clientScriptContext.superScriptList,
							localizationScriptLimit: _localeContext.localizedScriptLimit()
						});
						moduleKeeper.loadModules();
						moduleKeeper.loadModulesWithLocale(_localeContext.getTargetLocale());

						_localeContext.setupCallbacks({
							loadScriptsForLocale: loadScriptsForLocale,
							localizationContextEnter: localizationContextEnter,
							localizationContextExit: localizationContextExit
						});
					}
				}
				return doFetching;
			})();

			runClientScript = (function () {
				function isRecordInitialized() {
					return window.loadcomplete && NS.form.isInited();
				}

				function doRunClientScript(trigger, _args, options)
				{
					var args = _args || [];
					options = options || {};
					var locale = options.locale;
					var callback = isFunction(options.callback) ? options.callback : function noop() {};
					var isValid = true;

					if ((trigger === triggerInfo.localizationContextEnter.name || trigger === triggerInfo.localizationContextExit.name)
						&& (!moduleKeeper || !_localeContext || !isRecordInitialized() || locale !== _localeContext.getTargetLocale()))
					{
						callback({executed:false, trigger: trigger, locale: locale});
						return isValid;
					}

					if ((trigger === triggerInfo.localizationContextEnter.name || trigger === triggerInfo.localizationContextExit.name) && stillLoadingScripts())
					{
						if (typeof setTimeout !== "undefined")
							setTimeout(runClientScript, 0, trigger, args, options);
						else
							throw new Error("Failed to load record customizations");
						return;
					}

					var isInternal = nsapiIsInternal();
					try
					{
						nsapiSetIsInternal(false);
						var returnMatters = triggerInfo[trigger].needsReturn;
						var moduleInfos = moduleKeeper.getOrderedModuleInfos();
						for (var i = 0; i < moduleInfos.length; i++) {
							var module = moduleInfos[i];

							if (module.script.isLibraryModule || module.script.excludeFromClientScriptExecution)
								continue;

							var thisId = module.script.scriptId;
							var thisVersion = module.script.version || "1.0";
							var realTrigger = ((thisVersion !== "1.0") && (trigger === triggerInfo.recalc.name)) ? "sublistChanged" : trigger;
							var functionTrigger = module.getTrigger(realTrigger);
							var validCall = (thisVersion === "1.0" && realTrigger === triggerInfo.fieldChanged.name && document.forms['main_form'].elements.nlapiFC != null) ? (document.forms['main_form'].elements.nlapiFC.value !== '') : true;

							var shouldRun = module.shouldExecuteTrigger(locale, realTrigger);

							if (trigger === 'validateDelete' && thisVersion === '1.0' && args[1] != null) {
								shouldRun = false;
							}

							if (shouldRun && trigger === triggerInfo.localizationContextEnter.name) {
								module.activate();
							}

							if (shouldRun && !!functionTrigger && !!validCall)
							{
								var currentRecord = coreRecord.proxy({scriptId: module.script.scriptId, bundleId: module.script.bundleId});
								var currentClientScriptFunction;
								if (typeof(functionTrigger) === "function")
									currentClientScriptFunction = functionTrigger;
								else if (typeof(functionTrigger) === "string") {
									var namespacePaths = functionTrigger.split(".");
									currentClientScriptFunction = global[namespacePaths[0]];
									namespacePaths = namespacePaths.splice(1);
									for (var j in namespacePaths) {
										if (namespacePaths.hasOwnProperty(j))
											currentClientScriptFunction = currentClientScriptFunction[namespacePaths[j]];
									}
								}
								var currentArguments = (thisVersion !== "1.0") ?
									organizeArgs(trigger, currentRecord, args) :
									(function (args) {
										var result = [];
										for (var i = 0; i < args.length; i++) {
											result.push(typeof args[i] === 'undefined' ? null : args[i]);
										}
										return result;
									})(args);

								if (typeof(currentClientScriptFunction) === "function")
								{
									var context = {
										record: coreRecord,
										scriptInfo: module.script,
										nlrumArgs: [realTrigger, thisId, args, thisVersion, nlapiGetRecordType()]
									};

									if (nlapiGetContext().usage)
										nlapiGetContext().usage[thisId] = 0;

									refletModule.setupScript(module.script);

									if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.prepareForAsync({info: module.script, version: thisVersion, record: currentRecord, trigger: realTrigger, args: args});
									try
									{
										if (typeof(NLRUM) !== 'undefined')
											NLRUM.clientScriptBegin(realTrigger, thisId, args);

										var result = contextSwitch.execute(context, function (currentClientScriptFunction, currentArguments) {
											return currentClientScriptFunction.apply(null, currentArguments);
										}.bind(global, currentClientScriptFunction, currentArguments));

										if (typeof(NLRUM) !== 'undefined')
											NLRUM.clientScriptEnd(realTrigger, thisId, args, nlapiGetRecordType(), thisVersion);
									}
									finally
									{
										if (typeof(nlapi) !== 'undefined' && nlapi && nlapi.async) nlapi.async.unloadAsync();
									}

									isValid = thisVersion === '1.0' ? result : alignValidationResult(result);

									if (returnMatters && !validationResultToBoolean(isValid))
										break;
								}
							}
							if (shouldRun && trigger === triggerInfo.localizationContextExit.name) {
								module.deactivate();
							}
						}
					}
					catch(e)
					{
						var fn = thisId;
						var id = e.getId != null && typeof(e.getId) == "function" ? e.getId() : e.id ? e.id : null;
						var code = e.getCode != null && typeof(e.getCode) == "function" ? e.getCode() : typeof(e) == "string" ? new String(e) : typeof(e) == "object" && e.name && e.message ? "JS_EXCEPTION" : "UNEXPECTED_ERROR";
						if (code == "UNEXPECTED_ERROR" && id != null)
							code += " (id="+id+")";
						var msg = e.getDetails != null && typeof(e.getDetails) == "function" ? emptyIfNull(e.getDetails()) : typeof(e) == "string" ? "" : typeof(e) == "object" && e.name && e.message ? e.name+' '+e.message : e.toString()
						var suppressnotification = e.getCode != null && typeof(e.getCode) == "function" && e.suppressnotification === true;
						var supportsLogging = thisId != "customform";
						alert(window.nsScriptErrorMsg+'\n\n'+fn+' ('+trigger+')\n'+''+(isValEmpty(nlapiGetContext().getBundleId()) ? '' : ' ('+ nlapiGetContext().getBundleId() +')')+'\n\n'+""+code+'\n'+msg)
						if (supportsLogging)
							nsServerCall(nsJSONProxyURL, "logError", [code, msg, id, fn, thisId, suppressnotification, nlapiGetRecordType(), nlapiGetRecordId()]);
						throw e;
					}
					finally
					{
						nsapiUpdateMachines();
						nsapiSetIsInternal(isInternal);
					}

					if (trigger === triggerInfo.pageInit.name) {
						_localeContext && _localeContext.triggerLocalizationContextChange();
					} else if (trigger == triggerInfo.fieldChanged.name) {
						_localeContext && _localeContext.checkLocaleAndTriggerContextChange({sublistId:args[0], fieldId:args[1], valueGetter: coreRecord.getValue, lineCountGetter: coreRecord.getLineCount, lineValueGetter: coreRecord.getSublistValue});
					}

					callback({executed:true, trigger: trigger, locale: locale});
					return isValid;

				}

				return doRunClientScript;
			})();

			runRecordScript = function doRunRecordScript(trigger) {
				if (callRecordScript) {
					return callRecordScript.call(this, trigger);
				}
			};

			function localizationContextEnter(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					runRecordScript.call(coreRecord, getV2RecordScriptOptions(triggerInfo.localizationContextEnter.name, null, null, args));
					runClientScript(triggerInfo.localizationContextEnter.name, args, {locale: locale, callback: resolve});
				});
			}

			function localizationContextExit(locale)
			{
				return new Promise(function (resolve, reject) {
					var args = [locale];
					runRecordScript.call(coreRecord, getV2RecordScriptOptions(triggerInfo.localizationContextExit.name, null, null, args));
					runClientScript(triggerInfo.localizationContextExit.name, args, {locale: locale, callback: resolve});
				});
			}

			function loadScriptsForLocale(locale)
			{
				return moduleKeeper.loadModulesWithLocale.promise(locale);
			}

			function getV2RecordScriptOptions(eventName, fieldId, sublistId, callerArgs) {
				return {'eventName':eventName, 'fieldId': fieldId, 'sublistId': sublistId, 'arguments': callerArgs};
			}

			function organizeArgs(trigger, currRec, args)
			{
				function getZeroBasedIndex(idx)
				{
					if (isNaN(idx))
					{
						return idx;
					}
					else
					{
						idx = parseInt(idx, 10);
						return (idx < 0) ? idx : idx - 1;
					}
				}
				var returnMe;
				switch(trigger)
				{
					case triggerInfo.pageInit.name:
						returnMe = [{currentRecord: currRec, mode: args[0]}];
						break;

					case triggerInfo.saveRecord.name:
						returnMe = [{currentRecord: currRec}];
						break;
					case triggerInfo.validateDelete.name:
						returnMe = [{currentRecord: currRec, sublistId: args[0], lineCount: args[1]}];
						break;

					case triggerInfo.lineInit.name:
					case triggerInfo.validateInsert.name:
					case triggerInfo.validateLine.name:
						returnMe = [{currentRecord: currRec, sublistId: args[0]}];
						break;

					case triggerInfo.recalc.name:
						returnMe = [{currentRecord: currRec, sublistId: args[0], operation: args[1]}];
						break;

					case triggerInfo.postSourcing.name:
						returnMe = [{currentRecord: currRec, sublistId: args[0], fieldId: args[1], line: getZeroBasedIndex(args[2])}];
						break;

					case triggerInfo.validateField.name:
					case triggerInfo.fieldChanged.name:
						returnMe = [{currentRecord: currRec, sublistId: args[0], fieldId: args[1], line: getZeroBasedIndex(args[2]), column: getZeroBasedIndex(args[3])}];
						break;
					case triggerInfo.localizationContextEnter.name:
					case triggerInfo.localizationContextExit.name:
						returnMe = [{currentRecord: currRec, locale: args[0]}];
						break;

					default:
						returnMe = [];
				}
				return returnMe;
			}
		})();

		this.stillLoadingScripts = stillLoadingScripts;
		this.runClientScript = runClientScript;
		this.runRecordScript = runRecordScript;
		this.fetchClientScripts = fetchClientScripts;
	}

	function create(options) {
		return new CurrentScope(options);
	}

	return Object.freeze({
		create: create
	});
});

/*
 * Copyright Â© 2025, Oracle and/or its affiliates.
 */
/**
 * @ownership {@link ProductTeam.RECORD_ARCHITECTURE_RECORD_SERVICE}
 */
/**
 * SuiteScript module
 *
 * This is the V1/V2 implementation for all record methods, executed against the legacy DOM current record
 *
 * @private
 * @module N/domCurrentRecord
 * @NApiVersion 2.x
 */
define(
	'N/domCurrentRecord',['N/record/clientRecordDefinitionBase',
	'N/error', 'N/utilityFunctions', 'N/record/recordUtilityFunctions',
	'N/record/recordConstants',
	'N/util/formatter', 'N/util/validator', 'N/currentRecord/currentField', 'N/currentRecord/currentSublist',
	'N/currentRecord/currentSubrecord',
	'N/fieldTypeConstants', 'N/record/subrecordUtilityFunctions',
	'N/currentRecordService', 'N/currentRecord/currentRecordScriptingScope',
	'N/recordMessage'
	],
	function (clientRecordDefinitionBase,
	          error, utilityFunctions, recordUtil,
			  constants,
			  formatter, validator, field, sublist,
			  domSubrecord,
			  fieldTypeConstants, subrecordUtilityFunctions,
			  currentRecordService, currentRecordScriptingScope,
			  recordMessage) {

	/**
	 * Current record interface for legacy UI
	 * @return {CurrentRecord}
	 * @constructor
	 */
	function CurrentRecord() {
		var that = this;
		var isWritable = document && document.forms['main_form'] && document.forms['main_form'].onsubmit;
		var id = nlapiGetRecordId();
		var _statefulStores = {};

		clientRecordDefinitionBase.call(this, {
			recordOptions: {
				type: nlapiGetRecordType(),
				id: id,
				isDynamic: isWritable,
				isReadOnly: !isWritable,
				isSubrecord: false,
				isCurrentRecord: true
			},
			defaultLocale: typeof _defaultLocale !== 'undefined' ? _defaultLocale : null,
			dynamicData: typeof _dynamicRecordSpecificData !== 'undefined' ? _dynamicRecordSpecificData : null
		});
		if (this.id == null)
		{
			this.id = id;
		}

		var sysId = subrecordUtilityFunctions.getNextSysId(this.isNew);

		/**
		 * Returns the object type name for the implementation.
		 * @returns {string}
		 */
		function toString()
		{
			return constants.RECORD_UNDERLYING_IMPL_NAME.DOM_CURRENT_RECORD;
		}

		this.toString = toString;

		this.getScriptingContext = getScriptingContext;

		function getScriptingContext() {
			return typeof _scriptingContext !== 'undefined' && _scriptingContext || {};
		}

		this.getEventHandlerModules = getEventHandlerModules;

		function getEventHandlerModules() {
			return typeof _eventHandlerModules !== 'undefined' && _eventHandlerModules || [];
		}

		function getMacroMetadata()
		{
			return typeof _macro !== 'undefined' && _macro.macroMetadata || [];
		}
		this.getMacroMetadata = getMacroMetadata;

		function getMissingArgumentErrorMessageFillerValue(methodName)
		{
			return 'CurrentRecord.' + methodName;
		}
		this.getMissingArgumentErrorMessageFillerValue = getMissingArgumentErrorMessageFillerValue;

		function validateAndFormat(id, type, value, allowPercentage)
		{
			var undef = undefined;
			validator.validateField(id, type, value, undef, undef, undef, undef, undef, undef, undef, undef, allowPercentage);
			if (!fieldTypeConstants.isNumeric(type) && !fieldTypeConstants.isCurrency(type))
				value = formatter.format(value, type);
			return value;
		}

		function checkAndFormatForSetText(text, fldType, fieldId)
		{
			var value = formatter.parse(text, fldType);
			return validateAndFormat(fieldId, fldType, value, true);
		}

		// ==== set/get fieldValue
		function setValue(options, value)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (value !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setValue'));
			if (forceSyncSourcing) {
				doSetValue(fieldId, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setValue = setValue;

		function doSetValue(fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = nlapiGetField(fieldId);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
			else if (isInlineHtml(fieldId))
			{
				setInlineHtmlContent(fieldId, value);
			}
		}

		function getValue(options)
		{
			var fieldId;

			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('getValue'));
			nsapiAssertTrue(!isSubrecordField(null, fieldId), 'SSS_INVALID_OPERATION_USING_SUBRECORD_FIELD');

			return doGetValue(fieldId);
		}

		this.getValue = getValue;

		function doGetValue(fieldId)
		{
			var fieldObj = nlapiGetField(fieldId);
			var value;
			if (fieldObj == null)
			{
				if (isInlineHtml(fieldId))
				{
					value = getInlineHtmlContent(fieldId);
				}
			}
			else if (fieldObj.type === "multiselect")
			{
				if (fieldObj.isHidden)
					value = nlapiGetFieldValue(fieldId).split(String.fromCharCode(5));
				else
					value = nlapiGetFieldValues(fieldId);
			}
			else
			{
				value = (fieldObj !== null) ? handlePossiblyAlreadyParsedValue(nlapiGetFieldValue(fieldId), fieldObj.type, null, fieldId, null) : undefined;
			}
			return value == null ? undefined : value;
		}

		function handlePossiblyAlreadyParsedValue(fieldValue, fieldType, sublistId, fieldId, line) {
			var returnMe;
			if (isValEmpty(fieldValue))
			{
				returnMe = (fieldType === fieldTypeConstants.Type.CHECKBOX) ? false : fieldValue;
			}
			else if (fieldTypeConstants.isNumeric(fieldType) || fieldTypeConstants.isCurrency(fieldType))
			{
				if (!isNaN(fieldValue))
				{
					returnMe = parseFloat(fieldValue);
				}
				else
				{
					returnMe = formatter.parse(fieldValue, fieldType, undefined, undefined, undefined, undefined, true, true);
				}
			}
			else if (!isNaN(fieldValue) && getFieldFromDocument(sublistId, fieldId, line, "_formattedValue") !== null)
			{
				returnMe = parseFloat(fieldValue);
			}
			else
			{
				returnMe = formatter.parse(fieldValue, fieldType, undefined, undefined, undefined, undefined, true, true);
			}
			return returnMe;
		}

		function getFieldFromDocument(sublistId, fieldName, line, suffix) {
			var field = null;
			if (typeof document !== "undefined") {
				if (sublistId) {
					field = document.getElementById(fieldName + line + suffix);
				}
				if (!field) {
					field = document.getElementById(fieldName + suffix);
				}
			}
			return field || null;
		}

		// ==== set/get matrixValue
		function setMatrixHeaderValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;

				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setMatrixHeaderValue'));
			if (forceSyncSourcing) {
				doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setMatrixHeaderValue = setMatrixHeaderValue;

		function doSetMatrixHeaderValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixHeaderValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = nlapiGetMatrixField(sublistId, fieldId, column);
			if (fieldObj !== null)
			{
				value = validateAndFormat(fieldId, fieldObj.type, value);
				nlapiSetMatrixValue.v2(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getMatrixHeaderValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('getMatrixHeaderValue'));
			return doGetMatrixHeaderValue(sublistId, fieldId, column)
		}

		this.getMatrixHeaderValue = getMatrixHeaderValue;

		function doGetMatrixHeaderValue(sublistId, fieldId, column)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = nlapiGetMatrixField(sublistId, fieldId, column);
			var value;

			if (fieldObj == null)
				return undefined;

			value = formatter.parse(nlapiGetMatrixValue(sublistId, fieldId, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// ==== set/get fieldText
		function setText(options, text)
		{
			var fieldId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (text !== undef)
			{
				fieldId = options;
			}
			else if (options !== undef && options !== null)
			{
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('setText'));
			utilityFunctions.checkArgsDefined([text], ['text'], getMissingArgumentErrorMessageFillerValue('setText'));
			if (forceSyncSourcing) {
				doSetText(fieldId, text, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetText(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setText = setText;

		function doSetText(fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fldObj = nlapiGetField(fieldId);
			if (fldObj == null)
			{
				if (isInlineHtml(fieldId))
				{
					setInlineHtmlContent(fieldId, text, true);
				}
			}
			else if (fldObj.type === "multiselect")
			{
				text = (!Array.isArray(text)) ? text.split(String.fromCharCode(5)) : text;
				nlapiSetFieldTexts.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else if (fldObj.type.indexOf("select") !== -1)
			{
				nlapiSetFieldText.v2(fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, fldObj.type, fieldId);
				nlapiSetFieldValue.v2(fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getText(options)
		{
			var fieldId;
			fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('getText'));

			return doGetText(fieldId);
		}

		this.getText = getText;

		function doGetText(fieldId)
		{
			var fieldObj = nlapiGetField(fieldId);
			if (fieldObj == null)
			{
				return isInlineHtml(fieldId) ? getInlineHtmlContent(fieldId, true) : undefined;
			}
			var text;
			if (fieldObj.type === "multiselect")
			{
				text = nlapiGetFieldTexts(fieldId);
			}
			else if (fieldObj.type.indexOf("select") !== -1)
			{
				text = nlapiGetFieldText(fieldId);
			}
			else
			{
				var includePercentSign;
				if ((fieldObj.type === fieldTypeConstants.Type.RATE) || (fieldObj.type === fieldTypeConstants.Type.RATEHIGHPRECISION)) {
					includePercentSign = isNaN(nlapiGetFieldValue(fieldId));
				}
				text = formatter.format(doGetValue(fieldId), fieldObj.type, undefined, undefined, undefined, includePercentSign);
			}
			return text == null ? undefined : text;
		}

		// ==== helper functions for INLINEHTML field
		function isInlineHtml(fieldId)
		{
			return typeof ftypes === 'object' && ftypes[fieldId] === 'inlinehtml';
		}

		function getInlineHtmlContent(fieldId, useText)
		{
			var result, node;
			if (typeof document === 'object' && (node = document.getElementById(fieldId + "_val"))) {
				if (isBackend) {
					result = node.value;
				} else {
					result = useText ? node.innerText : node.innerHTML;
				}
			}
			return result;
		}

		function setInlineHtmlContent(fieldId, value, useText)
		{
			var node;
			if (typeof document === 'object' && (node = document.getElementById(fieldId + "_val"))) {
				if (isBackend) {
					node.value = value;
				}
				if (useText) {
					node.innerText = value;
				} else {
					node.innerHTML = value;
				}
			}
		}

		// ==== get sublist information
		function getSublistValue(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistValue'));
			return doGetSublistValue(sublistId, fieldId, line)
		}

		this.getSublistValue = getSublistValue;

		function doGetSublistValue(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistValue", nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			var value = fieldType ? handlePossiblyAlreadyParsedValue(nlapiGetLineItemValue(sublistId, fieldId, line), fieldType, sublistId, fieldId, line) : null;

			return value == null ? undefined : value;
		}

		function getSublistText(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistText'));
			return doGetSublistText(sublistId, fieldId, line)
		}

		this.getSublistText = getSublistText;

		function getDropdownTextFromGlobalArray(sublistId, fieldId, line)
		{
			// nlapiGetLineItemText returns nothing when new line is selected -> we have to use this instead
			var text = '';
			if (nlapiGetCurrentLineItemIndex(sublistId) - 1 === nlapiGetLineItemCount(sublistId)) {
				var sel = getFormElement(document.forms[sublistId.toLowerCase() + '_form'], fieldId.toLowerCase());
				if (isNLDropDown(sel) && Array.isArray(window[fieldId + 'Text'])) {
					text = window[fieldId + 'Text'][nlapiGetLineItemValue(sublistId, fieldId, line)] || '';
				}
			}
			return text;
		}

		function doGetSublistText(sublistId, fieldId, line)
		{
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistText", nlapiGetLineItemCount(sublistId));

			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			if (fieldType === null)
				return undefined;
			var text;
			if (fieldType === "multiselect")
				text = nlapiGetLineItemTexts(sublistId, fieldId, line);
			else if (fieldType.indexOf("select") !== -1) {
				text = nlapiGetLineItemText(sublistId, fieldId, line) || getDropdownTextFromGlobalArray(sublistId, fieldId, line);
			}
			else
			{
				var includePercentSign;
				if ((fieldType === fieldTypeConstants.Type.RATE) || (fieldType === fieldTypeConstants.Type.RATEHIGHPRECISION)) {
					includePercentSign = isNaN(nlapiGetLineItemValue(sublistId, fieldId, line));
				}
				text = formatter.format(doGetSublistValue(sublistId, fieldId, recordUtil.getZeroBasedIndex(line)), fieldType, undefined, undefined, undefined, includePercentSign);
			}

			return text == null ? undefined : text;
		}

		function adjustValue(thisValue, sublistId, fieldId)
		{
			var fieldType = getEncodedFieldType(sublistId, fieldId, true);
			if (Array.isArray(thisValue)) {
				thisValue = thisValue.join(String.fromCharCode(5));
			}
			else if (!!fieldType && fieldType.indexOf("select") === -1) {
				thisValue = validateAndFormat(fieldId, fieldType, thisValue);
			}
			return thisValue;
		}

		function setSublistValue(options)
		{
			var funcName = getMissingArgumentErrorMessageFillerValue("setSublistValue");
			utilityFunctions.checkArgs([options], ["options"], funcName);
			var sublistId = options.sublistId;
			var fieldId = options.fieldId;
			var lineInstanceId = options.lineInstanceId;
			var line = options.line;
			var value = options.value;

			utilityFunctions.checkArgs([sublistId, fieldId], ["sublistId", "fieldId"], funcName);
			utilityFunctions.checkMutuallyExclusiveArguments(lineInstanceId, line, "lineInstanceId", "line");
			utilityFunctions.checkArgsDefined([value], ["value"], funcName);

			if (lineInstanceId) {
				line = _getLineIndexForInstanceId(sublistId, lineInstanceId);
			}

			line = recordUtil.validateAndGetOneBasedIndex(line, funcName, nlapiGetLineItemCount(sublistId));

			var fieldObj = nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : line);

			value = adjustValue(value, sublistId, fieldId);
			if (fieldObj == null) {
				var sublistObj = getSublist(sublistId);
				if (!!sublistObj && sublistObj.type === "list") {
					nlapiSetLineItemValue(sublistId, fieldId, line, value);
				}
				return undefined;
			}
			else {
				nlapiSetLineItemValue(sublistId, fieldId, line, value);
				if (nlapiGetCurrentLineItemIndex(sublistId) == line) {
					nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, false);
				}
			}
			return that;
		}

		this.setSublistValue = setSublistValue;

		function getLineInstanceIds(options)
		{
			var sublistId = util.isString(options) ? options : options && options.sublistId;
			utilityFunctions.checkArgs([sublistId], ["sublistId"], getMissingArgumentErrorMessageFillerValue("getLineInstanceIds"));
			return _getLineInstanceIds(sublistId);
		}
		this.getLineInstanceIds = getLineInstanceIds;

		function setMatrixSublistValue(options, fieldId, line, column, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
				value = options.value;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setMatrixSublistValue'));
			doSetMatrixSublistValue(sublistId, fieldId, line, column, value);
			return that;
		}

		this.setMatrixSublistValue = setMatrixSublistValue;

		function doSetMatrixSublistValue(sublistId, fieldId, line, column, value)
		{
			validateMatrixField(sublistId, fieldId);
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.setMatrixSublistValue", nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				nlapiSetLineItemMatrixValue(sublistId, fieldId, line, column, value);
			}
		}

		function getMatrixSublistValue(options, fieldId, line, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line, column], ['sublistId', 'fieldId', 'line', 'column'], getMissingArgumentErrorMessageFillerValue('getMatrixSublistValue'));
			return doGetMatrixSublistValue(sublistId, fieldId, line, column);
		}

		this.getMatrixSublistValue = getMatrixSublistValue;

		function doGetMatrixSublistValue(sublistId, fieldId, line, column)
		{
			validateMatrixField(sublistId, fieldId);
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistValue", nlapiGetLineItemCount(sublistId));
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			if (fieldObj == null)
				return undefined;
			var value = formatter.parse(nlapiGetLineItemMatrixValue(sublistId, fieldId, line, column), fieldObj.type);

			return value == null ? undefined : value;
		}

		// === set/get currentLineItemValue
		function setCurrentSublistValue(options, fieldId, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('setCurrentSublistValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setCurrentSublistValue'));
			if (forceSyncSourcing) {
				doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setCurrentSublistValue = setCurrentSublistValue;

		function doSetCurrentSublistValue(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : nlapiGetCurrentLineItemIndex(sublistId));

			value = adjustValue(value, sublistId, fieldId);
			if (fieldObj == null)
			{
				var sublistObj = getSublist(sublistId);
				if (!!sublistObj && sublistObj.type === "list")
				{
					var oneBasedlineIndex = nlapiGetCurrentLineItemIndex(sublistId);
					nlapiSetLineItemValue(sublistId, fieldId, oneBasedlineIndex, value);
				}
				return undefined;
			}
			else
			{
				nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentSublistValue(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistValue'));
			return doGetCurrentSublistValue(sublistId, fieldId);
		}

		this.getCurrentSublistValue = getCurrentSublistValue;

		function doGetCurrentSublistValue(sublistId, fieldId)
		{
			var line = nlapiGetCurrentLineItemIndex(sublistId);
			var fieldObj = nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : line);
			var fieldType = getEncodedFieldType(sublistId, fieldId, true) === fieldTypeConstants.Type.CHECKBOX ? fieldTypeConstants.Type.CHECKBOX : (fieldObj ? fieldObj.type : null);
			var value = fieldType ? handlePossiblyAlreadyParsedValue(nlapiGetCurrentLineItemValue(sublistId, fieldId), fieldType, sublistId, fieldId, line) : null;
			return value == null ? undefined : value;
		}

		// === set/get currentLineItemMatrixValue
		function setCurrentMatrixSublistValue(options, fieldId, column, value)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && column !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				value = options.value;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('setCurrentMatrixSublistValue'));
			if (forceSyncSourcing) {
				doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setCurrentMatrixSublistValue = setCurrentMatrixSublistValue;

		function doSetCurrentMatrixSublistValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync)
		{
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.setCurrentMatrixSublistValue", getMatrixHeaderCount(sublistId, fieldId));
			var fieldObj = nlapiGetLineItemMatrixField(sublistId, fieldId, column, nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj !== null)
			{
				validator.validateField(fieldId, fieldObj.type, value);
				nlapiSetCurrentLineItemMatrixValue(sublistId, fieldId, column, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentMatrixSublistValue(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('getCurrentMatrixSublistValue'));
			var currLine = nlapiGetCurrentLineItemIndex(sublistId);
			if (currLine > 0)
				currLine = currLine - 1;

			return doGetMatrixSublistValue(sublistId, fieldId, currLine, column);
		}

		this.getCurrentMatrixSublistValue = getCurrentMatrixSublistValue;

		// === set/get currentLineItemText
		function setCurrentSublistText(options, fieldId, text)
		{
			var sublistId,
				fireFieldChanged = true,
				fireSlavingSync = false,
				forceSyncSourcing = false,
				undef = undefined;

			if (fieldId !== undef && text !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				text = options.text;
				fireFieldChanged = util.isBoolean(options.ignoreFieldChange) ? !options.ignoreFieldChange : fireFieldChanged;
				fireSlavingSync = util.isBoolean(options.fireSlavingSync) ? options.fireSlavingSync : fireSlavingSync;
				forceSyncSourcing = util.isBoolean(options.forceSyncSourcing) ? options.forceSyncSourcing : forceSyncSourcing;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('setCurrentSublistText'));
			utilityFunctions.checkArgsDefined([text], ['text'], getMissingArgumentErrorMessageFillerValue('setCurrentSublistText'));
			if (forceSyncSourcing) {
				doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, forceSyncSourcing);
			} else {
				doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			return that;
		}

		this.setCurrentSublistText = setCurrentSublistText;

		function doSetCurrentSublistText(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync)
		{
			var fieldObj = nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : nlapiGetCurrentLineItemIndex(sublistId));
			if (fieldObj === null)
				return;

			if (fieldObj.type.indexOf("select") !== -1)
			{
				nlapiSetCurrentLineItemText.v2(sublistId, fieldId, text, fireFieldChanged, fireSlavingSync);
			}
			else
			{
				var value = checkAndFormatForSetText(text, getEncodedFieldType(sublistId, fieldId, true) || fieldObj.type, fieldId);
				nlapiSetCurrentLineItemValue.v2(sublistId, fieldId, value, fireFieldChanged, fireSlavingSync);
			}
		}

		function getCurrentSublistText(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistText'));
			return doGetCurrentSublistText(sublistId, fieldId);
		}

		this.getCurrentSublistText = getCurrentSublistText;

		function doGetCurrentSublistText(sublistId, fieldId)
		{
			var fldObj = nlapiGetLineItemField(sublistId, fieldId, isEditMachine(sublistId) ? null : nlapiGetCurrentLineItemIndex(sublistId));
			if (fldObj === null)
				return undefined;

			var text;
			if (fldObj.type.indexOf("select") !== -1)
			{
				text = nlapiGetCurrentLineItemText(sublistId, fieldId);
			}
			else
			{
				var includePercentSign;
				if ((fldObj.type === fieldTypeConstants.Type.RATE) || (fldObj.type === fieldTypeConstants.Type.RATEHIGHPRECISION)) {
					includePercentSign = isNaN(nlapiGetCurrentLineItemValue(sublistId, fieldId));
				}
				text = formatter.format(doGetCurrentSublistValue(sublistId, fieldId), fldObj.type, undefined, undefined, undefined, includePercentSign);
			}
			return text == null ? undefined : text;
		}

		function fixMissingProperties(obj)
		{
			if (obj != null)
			{
				obj.visible = true;
				obj.display = true;
			}
			return obj;
		}

		// === Get Fields
		function getField(options)
		{
			var fieldId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.fieldId : options;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('getField'));

			var fldObj = nlapiGetField(fieldId);

			//nlapiGetField and nlapiGetLineItemField (and their matrix counterparts do not properly initialize
			//isDisplay and isVisible. We should make sure they get the proper values for them.
			var fieldElement = getFieldFromDocument(null, fieldId, null, "_fs");
			if (fldObj !== null && fieldElement !== null && fieldElement.style !== null)
			{
				fldObj.visible = fieldElement.style.visibility !== "hidden";
				fldObj.display = fieldElement.style.display !== "none";
			}

			return fldObj ? field.create(fldObj, that) : null;
		}

		this.getField = getField;

		function getSublist(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getSublist'));

			var sublistObj = nlapiGetSubList(sublistId, true);
			return sublistObj ? sublist.create(sublistObj, that) : null;
		}

		this.getSublist = getSublist;

		function isMultilineEditable(sublistId)
		{
			return false;
		}
		this.isMultilineEditable = isMultilineEditable;

		function getMatrixHeaderField(options, fieldId, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('getMatrixHeaderField'));
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixHeaderField", getMatrixHeaderCount(sublistId, fieldId));

			var fldObj = nlapiGetMatrixField(sublistId, fieldId, column);
			fldObj = fixMissingProperties(fldObj);
			return fldObj ? field.create(fldObj, that) : null;
		}

		this.getMatrixHeaderField = getMatrixHeaderField;

		function getSublistField(options, fieldId, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistField'));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getSublistField", nlapiGetLineItemCount(sublistId) + 1);

			var fldObj = nlapiGetLineItemField(sublistId, fieldId, line);
			if (fldObj && fldObj.type === fieldTypeConstants.Type.TEXT && getEncodedFieldType(sublistId, fieldId, true) === fieldTypeConstants.Type.CHECKBOX)
				fldObj.type = fieldTypeConstants.Type.CHECKBOX;
			fldObj = fixMissingProperties(fldObj);
			return fldObj ? field.create(fldObj, that) : null;
		}

		this.getSublistField = getSublistField;

		function getCurrentSublistField(options, fieldId) {
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistField'));
			return getSublistField(sublistId, fieldId, getCurrentSublistIndex(sublistId));
		}

		this.getCurrentSublistField = getCurrentSublistField;


		function getMatrixSublistField(options, fieldId, column, line)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && column !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				column = options.column;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, fieldId, column, line], ['sublistId', 'fieldId', 'column', 'line'], getMissingArgumentErrorMessageFillerValue('getMatrixSublistField'));
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.getMatrixSublistField", getMatrixHeaderCount(sublistId, fieldId));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.getMatrixSublistField", nlapiGetLineItemCount(sublistId));

			var fldObj = nlapiGetLineItemMatrixField(sublistId, fieldId, column, line);
			fldObj = fixMissingProperties(fldObj);
			return fldObj ? field.create(fldObj, that) : null;
		}

		this.getMatrixSublistField = getMatrixSublistField;

		function getCurrentSublistIndex(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistIndex'));

			var currIndex = nlapiGetCurrentLineItemIndex(sublistId);
			return recordUtil.getZeroBasedIndex(currIndex);
		}

		this.getCurrentSublistIndex = getCurrentSublistIndex;

		// === Find Values
		function findSublistLineWithValue(options, fieldId, value)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('findSublistLineWithValue'));
			return recordUtil.getZeroBasedIndex(nlapiFindLineItemValue(sublistId, fieldId, value));
		}

		this.findSublistLineWithValue = findSublistLineWithValue;

		function findMatrixSublistLineWithValue(options, fieldId, value, column)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef && value !== undef && column !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				value = options.value;
				column = options.column;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, column], ['sublistId', 'fieldId', 'column'], getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			utilityFunctions.checkArgsDefined([value], ['value'], getMissingArgumentErrorMessageFillerValue('findMatrixSublistLineWithValue'));
			validateMatrixField(sublistId, fieldId);
			column = recordUtil.validateAndGetOneBasedIndex(column, "CurrentRecord.findMatrixSublistLineWithValue", getMatrixHeaderCount(sublistId, fieldId));
			return recordUtil.getZeroBasedIndex(nlapiFindLineItemMatrixValue(sublistId, fieldId, value, column));
		}

		this.findMatrixSublistLineWithValue = findMatrixSublistLineWithValue;

		function selectLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('selectLine'));

			if (recordUtil.getZeroBasedIndex(nlapiGetCurrentLineItemIndex(sublistId)) !== line)
			{
				line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.selectLine", nlapiGetLineItemCount(sublistId));
				nlapiSelectLineItem(sublistId, line);
			}
			return that;
		}

		this.selectLine = selectLine;

		function commitLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('commitLine'));
			nlapiCommitLineItem(sublistId);
			return that;
		}

		this.commitLine = commitLine;

		function insertLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('insertLine'));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.insertLine", nlapiGetLineItemCount(sublistId) + 1); //+1 because you can insert on the newest line

			nlapiInsertLineItem(sublistId, line);
			return that;
		}

		this.insertLine = insertLine;

		function removeLine(options, line)
		{
			var sublistId,
				undef = undefined;

			if (line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				line = options.line;
			}
			utilityFunctions.checkArgs([sublistId, line], ['sublistId', 'line'], getMissingArgumentErrorMessageFillerValue('removeLine'));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.removeLine", nlapiGetLineItemCount(sublistId));
			if (typeof NLGetBusinessObject !== 'undefined' && line > 0)
			{
				var recordObj = NLGetBusinessObject().getRecordManager(sublistId);
				if (recordObj)
				{
					var fieldIds = recordObj.getFieldNames();
					for (var i = 0; i < fieldIds.length; i++)
					{
						var fieldId = fieldIds[i];
						if (isSubrecordField(sublistId, fieldId))
						{
							doRemoveSubrecord(sublistId, fieldId, line);
						}
					}
				}
			}
			nlapiRemoveLineItem(sublistId, line);
			return that;
		}

		this.removeLine = removeLine;

		/**
		 * Move one line to desired location.
		 * Order of all other lines is preserved.
		 * @param {Object|string} options (sublistId)
		 * @param {string} options.sublistId
		 * @param {number} options.from Which line index to move (0-based)
		 * @param {number} options.to New position (0-based)
		 * @param {number} from (0-based index)
		 * @param {number} to (0-based index)
		 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if sublistId, from or to is missing
		 * @throws {SuiteScriptError} SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES if machine doesn't support line moving
		 * @throws {SuiteScriptError} SSS_INVALID_SUBLIST_OPERATION if sublistId or indexes are invalid
		 * @throws {SuiteScriptError} SSS_NOT_YET_SUPPORTED if moving other than current line
		 */
		function moveLine(options, from, to) {
			var sublistId;
			if (util.isString(options)) {
				sublistId = options;
			} else if (options !== undefined) {
				sublistId = options.sublistId;
				from = options.from;
				to = options.to;
			}
			utilityFunctions.checkArgs([sublistId, from, to], ['sublistId', 'from', 'to'],
				getMissingArgumentErrorMessageFillerValue('moveLine'));
			var lineCount = nlapiGetLineItemCount(sublistId);
			if (lineCount == -1 || isNaN(from) || isNaN(to))
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
			var mach = machines[sublistId];
			if (!mach || !isEditMachine(sublistId) || !mach.allowMoveLines || typeof mach.movelineto !== 'function')
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_SUBLIST_DOESNT_SUPPORT_MOVING_LINES, sublistId);
			// 1-based line indexes are used in Suite Script 1.0 API.
			var fromIndex1 = recordUtil.validateAndGetOneBasedIndex(from, "CurrentRecord.moveLine", lineCount);
			var toIndex1 = recordUtil.validateAndGetOneBasedIndex(to, "CurrentRecord.moveLine", lineCount);
			if (fromIndex1 == undefined || toIndex1 == undefined)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SUBLIST_OPERATION);
			if (nlapiGetCurrentLineItemIndex(sublistId) != fromIndex1)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_NOT_YET_SUPPORTED, "You can move only currently selected line.");
			mach.movelineto(toIndex1, false);
			return that;
		}
		this.moveLine = moveLine;

		function cancelLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('cancelLine'));
			var line = nlapiGetCurrentLineItemIndex(sublistId);
			if (typeof NLGetBusinessObject !== 'undefined' && line > 0)
			{
				var recordObj = NLGetBusinessObject().getRecordManager(sublistId);
				if (recordObj)
				{
					var fieldIds = recordObj.getFieldNames();
					for (var i = 0; i < fieldIds.length; i++)
					{
						var fieldId = fieldIds[i];
						var subrecordObj = getSubRecordFromCache(sublistId, fieldId, line);
						if (subrecordObj)
						{
							// isNew?
							if (recordUtil.emptyIfNullOrUndefined(subrecordObj.getFieldValue('id')) === '')
							{
								subrecordObj.remove();
							}
							else
							{
								subrecordObj.cancel();
							}
						}
					}
				}
			}
			nlapiCancelLineItem(sublistId);
			return that;
		}

		this.cancelLine = cancelLine;

		function selectNewLine(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('selectNewLine'));
			nlapiSelectNewLineItem(sublistId);
			return that;
		}

		this.selectNewLine = selectNewLine;

		function getLineCount(options)
		{
			var sublistId = ((options !== undefined) && (options !== null) && !util.isString(options)) ? options.sublistId : options;
			utilityFunctions.checkArgs([sublistId], ['sublistId'], getMissingArgumentErrorMessageFillerValue('getLineCount'));
			return nlapiGetLineItemCount(sublistId);
		}

		this.getLineCount = getLineCount;

		function getMatrixHeaderCount(options, fieldId)
		{
			var sublistId,
				undef = undefined;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}
			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getMatrixHeaderCount'));
			return nlapiGetMatrixCount(sublistId, fieldId);
		}

		this.getMatrixHeaderCount = getMatrixHeaderCount;

		function validateMatrixField(sublistId, fieldName)
		{
			if (!getMatrixHeaderCount(sublistId, fieldName) || getMatrixHeaderCount(sublistId, fieldName) < 0)
				utilityFunctions.throwSuiteScriptError(error.Type.METHOD_IS_ONLY_ALLOWED_FOR_MATRIX_FIELD);
		}

		function getSystemId() { return sysId; }

		this.getSystemId = getSystemId;

		function doHasSubrecord(sublistId, fieldId, line)
		{
			if (!isSubrecordField(sublistId, fieldId))
			{
				return false;
			}
			if (!sublistId)
			{
				line = 1;
			}
			var parentRecordObj = sublistId ? NLGetBusinessObject().getRecordManager(sublistId) : NLGetUIForm().recordManager;
			var recordObj = NLGetBusinessObject().getRecordManager(parentRecordObj.getField(fieldId).target);
			if (recordObj.isDataSetLoaded(line - 1))
			{
				return !!(sublistId ? nlapiViewLineItemSubrecord(sublistId, fieldId, line) : nlapiViewSubrecord(fieldId));
			}
			else
			{
				return parentRecordObj.getFieldValue(fieldId, line - 1) * 1 > 0;
			}
		}

		function doGetSubrecord(sublistId, fieldId, line)
		{
			function getAlert(message)
			{
				message = message.toJSON();
				if (message && message.source === 'window.alert' && message.data && message.data.args)
				{
					return String(message.data.args[0]);
				}
			}

			if (!isSubrecordField(sublistId, fieldId))
			{
				utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
			}

			var isReadOnly = that.isReadOnly;
			var subrecordObj;

			if (isReadOnly)
			{
				subrecordObj = sublistId ? nlapiViewLineItemSubrecord(sublistId, fieldId, line) : nlapiViewSubrecord(fieldId);
			}
			else
			{
				subrecordObj = sublistId ? nlapiEditCurrentLineItemSubrecord(sublistId, fieldId) : nlapiEditSubrecord(fieldId);
			}

			if (!subrecordObj && !isReadOnly)
			{
				var messageIndex = that.getMessageService().getMessages().length;

				subrecordObj = sublistId ? nlapiCreateCurrentLineItemSubrecord(sublistId, fieldId) : nlapiCreateSubrecord(fieldId);
				if (subrecordObj && !subrecordObj.subrecordinstance)
				{
					subrecordObj = null;

					// get error, if any (adapted from checkWarningMessageInSession)
					var alerts = that.getMessageService().getMessages().slice(messageIndex).map(getAlert).filter(util.isString);
					if (alerts.length > 1)
					{
						utilityFunctions.throwSuiteScriptError('USER_ERROR', ["Multiple Error Detected"].concat(alerts).join("\n") + "\n");
					}
					else if (alerts.length > 0)
					{
						utilityFunctions.throwSuiteScriptError('USER_ERROR', alerts[0]);
					}
				}
				else if (subrecordObj)
				{
					// initialize with default values
					NLGetUncommittedSubRecord(subrecordObj.subrecordinstance, subrecordObj.recordmanager);
					if (subrecordObj.recordmanager.children)
					{
						for (var i = 0; i < subrecordObj.recordmanager.children.length; i++)
						{
							if (!subrecordObj.recordmanager.children[i].rows)
							{
								subrecordObj.recordmanager.children[i].rows = subrecordObj.recordmanager.children[i].createData();
							}
						}
					}
					subrecordObj.recordmanager.handleParentActiveRowChange(subrecordObj.sysId, true);

					// mark as modified
					subrecordObj.isOnServer = true;
				}
			}

			return domSubrecord.get(subrecordObj);
		}

		function doRemoveSubrecord(sublistId, fieldId, line)
		{
			if (!isSubrecordField(sublistId, fieldId))
			{
				utilityFunctions.throwSuiteScriptError(error.Type.FIELD_1_IS_NOT_A_SUBRECORD_FIELD, fieldId);
			}
			if (doHasSubrecord(sublistId, fieldId, line))
			{
				if (sublistId)
				{
					// the following would be nlapiRemoveLineItemSubrecord if it existed
					var subrecordObj = nlapiViewLineItemSubrecord(sublistId, fieldId, line);
					if (subrecordObj)
					{
						subrecordObj.remove();
					}
				}
				else
				{
					nlapiRemoveSubrecord(fieldId);
				}
			}
		}

		function hasSubrecord(options)
		{
			var undef = undefined, fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('hasSubrecord'));

			return doHasSubrecord(null, fieldId);
		}

		this.hasSubrecord = hasSubrecord;

		function oldGetSubrecord(options)
		{
			var undef = undefined,
				fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('getSubrecord'));

			return doGetSubrecord(null, fieldId);
		}

		this.getSubrecord = oldGetSubrecord;

		function oldRemoveSubrecord(options)
		{
			var undef = undefined,
				fieldId;

			fieldId = options !== undef && options !== null && !util.isString(options) ? options.fieldId : options;

			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue('removeSubrecord'));

			doRemoveSubrecord(null, fieldId);

			return that;
		}

		this.removeSubrecord = oldRemoveSubrecord;

		function hasSublistSubrecord(options, fieldId, line)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}

			utilityFunctions.checkArgs([sublistId, fieldId, line], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('hasSublistSubrecord'));
			line = recordUtil.validateAndGetOneBasedIndex(line, "CurrentRecord.hasSublistSubrecord", nlapiGetLineItemCount(sublistId));

			return doHasSubrecord(sublistId, fieldId, line);
		}

		this.hasSublistSubrecord = hasSublistSubrecord;

		function getSublistSubrecord(options, fieldId, line)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef && line !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
				line = options.line;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId', 'line'], getMissingArgumentErrorMessageFillerValue('getSublistSubrecord'));

			return doGetSubrecord(sublistId, fieldId, line);
		}

		this.getSublistSubrecord = getSublistSubrecord;

		function hasCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('hasCurrentSublistSubrecord'));
			var line = nlapiGetCurrentLineItemIndex(sublistId);

			return doHasSubrecord(sublistId, fieldId, line);
		}

		this.hasCurrentSublistSubrecord = hasCurrentSublistSubrecord;

		function oldGetCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('getCurrentSublistSubrecord'));

			return doGetSubrecord(sublistId, fieldId);
		}

		this.getCurrentSublistSubrecord = oldGetCurrentSublistSubrecord;

		function oldRemoveCurrentSublistSubrecord(options, fieldId)
		{
			var undef = undefined,
				sublistId;

			if (fieldId !== undef)
			{
				sublistId = options;
			}
			else if (options !== undef && options !== null)
			{
				sublistId = options.sublistId;
				fieldId = options.fieldId;
			}

			utilityFunctions.checkArgs([sublistId, fieldId], ['sublistId', 'fieldId'], getMissingArgumentErrorMessageFillerValue('removeCurrentSublistSubrecord'));
			var line = nlapiGetCurrentLineItemIndex(sublistId);

			doRemoveSubrecord(sublistId, fieldId, line);

			return that;
		}

		this.removeCurrentSublistSubrecord = oldRemoveCurrentSublistSubrecord;

		function sourcingAndOnChangeHandler(name, executor, options, proxyOptions)
		{
			var scriptId = (proxyOptions || that).scriptId;
			if (scriptId != null)
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_UNSUPPORTED_METHOD);

			var fieldId = (options || {}).fieldId;
			utilityFunctions.checkArgs([fieldId], ['fieldId'], getMissingArgumentErrorMessageFillerValue(name));
			var sublistId = options.sublistId || null;
			var line = options.line != null ? options.line : -1;
			var fieldSpec = options.fieldSpec;

			executor(sublistId, fieldId, recordUtil.getOneBasedIndex(line), fieldSpec);
		}

		this.sourceField = util.extend(function sourceField(options, proxyOptions)
		{
			return sourcingAndOnChangeHandler('sourceField', function(sublistId, fieldId, line_1, fieldSpec)
			{
				sublistId ? nlapiSourceLineItemField(sublistId, fieldId, fieldSpec, line_1) : nlapiSourceField(fieldId, fieldSpec)
			}, options, proxyOptions);
		}, {
			proxyOptionsArgIndex: 1
		});

		this.fireOnChange = util.extend(function fireOnChange(options, proxyOptions)
		{
			return sourcingAndOnChangeHandler('fireOnChange', function(sublistId, fieldId, line_1)
			{
				sublistId ? nlapiFireLineItemOnChange(sublistId, fieldId, line_1) : nlapiFireOnChange(fieldId)
			}, options, proxyOptions);
		}, {
			proxyOptionsArgIndex: 1
		});

		var scriptingScope = currentRecordScriptingScope.create({record: this});

		this.stillLoadingScripts = scriptingScope.stillLoadingScripts;
		this.runClientScript = scriptingScope.runClientScript;
		this.runRecordScript = scriptingScope.runRecordScript;
		this.fetchClientScripts = scriptingScope.fetchClientScripts;

		var _recordMessage = recordMessage.createWithListener({listenerType: recordMessage.Type.LEGACY});

		this.getRecordMessage = function ()
		{
			return _recordMessage;
		};

		var getStatefulStoreProxyProvider = function getStatefulStoreProxyProvider(proxyOptions) {
			return recordUtil.getStatefulStoreProxyProvider(_statefulStores, proxyOptions);
		}
		this.getStatefulStoreProxyProvider = getStatefulStoreProxyProvider;
	}

	if (typeof nlapiGetField !== 'undefined')
	{
		var currentRecord = new CurrentRecord();
		currentRecordService.set(currentRecord);
	}

	function get()
	{
		return currentRecord;
	}

	return {
		get: get
	}
});
/**
 * SuiteScript module
 *
 * @private
 * @module N/currentRecord
 * @NApiVersion 2.x
 */
define('N/currentRecord',['N/currentRecordService', 'N/domCurrentRecord'], function (currentRecordService, domCurrentRecord) {
	// domCurrentRecord is required only to make sure it's initialized
	void domCurrentRecord;

	function get() {
		var rawCurrentRecord = currentRecordService.get();
		return rawCurrentRecord ? rawCurrentRecord.proxy() : undefined;
	}

	get.promise = function get_promise() {
		return Promise.resolve(get());
	};

	return Object.freeze({
		get: get
	});
});

/**
 * @private
 */
define('N/restricted/scriptArguments',[], function (){ return {}; });
/**
 * @private
 */
define('N/restricted/fileApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript file module
 *
 * @module N/file
 * @NApiVersion 2.x
 *
 */
define('N/file',['N/restricted/fileApi', 'N/error', 'N/nsobject', 'N/utilityFunctions', 'N/internal/invoker','N/creationFunctionWrapper', 'N/common/pattern/iterator'],
	function (fileApi, error, nsobject, utilityFunctions, invoker, funcWrapper, iteratorFactory)
	{
		//enums
		var FILE_TYPES = Object.freeze({
			APPCACHE: 'APPCACHE',
			AUTOCAD: 'AUTOCAD',
			BMPIMAGE: 'BMPIMAGE',
			CERTIFICATE : 'CERTIFICATE',
			CONFIG : 'CONFIG',
			CSV: 'CSV',
			EXCEL: 'EXCEL',
			FLASH: 'FLASH',
			FREEMARKER: 'FREEMARKER',
			GIFIMAGE: 'GIFIMAGE',
			GZIP: 'GZIP',
			HTMLDOC: 'HTMLDOC',
			ICON: 'ICON',
			JAVASCRIPT: 'JAVASCRIPT',
			JPGIMAGE: 'JPGIMAGE',
			JSON: 'JSON',
			MESSAGERFC: 'MESSAGERFC',
			MP3: 'MP3',
			MPEGMOVIE: 'MPEGMOVIE',
			MSPROJECT: 'MSPROJECT',
			PDF: 'PDF',
			PJPGIMAGE: 'PJPGIMAGE',
			PLAINTEXT: 'PLAINTEXT',
			PNGIMAGE: 'PNGIMAGE',
			POSTSCRIPT: 'POSTSCRIPT',
			POWERPOINT: 'POWERPOINT',
			QUICKTIME: 'QUICKTIME',
			RTF: 'RTF',
			SCSS: 'SCSS',
			SMS: 'SMS',
			STYLESHEET: 'STYLESHEET',
			SVG : 'SVG',
			TAR: 'TAR',
			TIFFIMAGE: 'TIFFIMAGE',
			VISIO: 'VISIO',
			WEBAPPPAGE: 'WEBAPPPAGE',
			WEBAPPSCRIPT: 'WEBAPPSCRIPT',
			WORD: 'WORD',
			XMLDOC: 'XMLDOC',
			XSD : 'XSD',
			ZIP: 'ZIP'
		});
		var ENCODINGS = Object.freeze({
			UTF_8: 'UTF-8',
			WINDOWS_1252: 'windows-1252',
			ISO_8859_1: 'ISO-8859-1',
			GB18030: 'GB18030',
			SHIFT_JIS: 'SHIFT_JIS',
			MAC_ROMAN: 'MacRoman',
			GB2312: 'GB2312',
			BIG5: 'Big5'
		});
		var NAME_CONFLICT_RESOLUTION = Object.freeze({
			FAIL: 'FAIL',
			OVERWRITE: 'OVERWRITE',
			OVERWRITE_CONTENT_AND_ATTRIBUTES: 'OVERWRITE_CONTENT_AND_ATTRIBUTES',
			RENAME_TO_UNIQUE: 'RENAME_TO_UNIQUE'
		});

		var fileLinesObjectsCreated = [];
		var fileSegmentsObjectsCreated = [];
		var fileReaderObjectsCreated = [];

		/**
		 * Return a new instance of file.File used for accessing and manipulating files in the file cabinet.
		 *
		 * @protected
		 * @class File
		 * @classdesc Encapsulation of files (media items) in the file cabinet.
		 * @alias file.File
		 *
		 * @since 2015.2
		 */
		function File(delegate, folder)
		{
			var TYPE = 'file.File';
			/**
			 The id of the file (if stored in the FC).
			 * @name File#id
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 */
			Object.defineProperty(this, 'id', {
				get: function ()
				{
					return invoker(delegate, "getId", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'id');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The size of the file in bytes.
			 * @name File#size
			 * @type {number}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'size', {
				get: function ()
				{
					return invoker(delegate, "getSize", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'size');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 Return the URL of the file (if stored in the FC).
			 * @name File#url
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'url', {
				get: function ()
				{
					return invoker(delegate, "getURL", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'url');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The path to the file in the file cabinet.
			 * @name File#path
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'path', {
				get: function ()
				{
					return invoker(delegate, "getPath", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'path');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 The type of the file.
			 * @name File#fileType
			 * @type {string}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'fileType', {
				get: function ()
				{
					return invoker(delegate, "getType", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'fileType');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * Indicates whether or not the file is text-based or binary.
			 * @name File#isText
			 * @type {boolean}
			 * @readonly
			 * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'isText', {
				get: function ()
				{
					return invoker(delegate, "isText", []);
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'isText');
				},
				enumerable: true,
				configurable: false,
				writeable: false
			});
			/**
			 * The character encoding for the file.
			 * @name File#encoding
			 * @type {string}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'encoding', {
				get: function ()
				{
					return invoker(delegate, "getEncoding", []);
				},
				set: function (val)
				{
					invoker(delegate, "setEncoding", [val]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The name of the file.
			 * @name File#name
			 * @type {string}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'name', {
				get: function ()
				{
					return invoker(delegate, "getName", []);
				},
				set: function (val)
				{
					invoker(delegate, "setName", [val]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The internal ID of the folder that this file is in.
			 * @name File#folder
			 * @type {number}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'folder', {
				get: function ()
				{
					return invoker(delegate, "getFolder", []);
				},
				set: function (val)
				{
					var folder = util.isString(val) ? parseInt(val, 10) : val;
					invoker(delegate, "setFolder", [folder]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file description.
			 * @name File#description
			 * @type {string}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'description', {
				get: function ()
				{
					return invoker(delegate, "getDescription", []);
				},
				set: function (val)
				{
					invoker(delegate, "setDescription", [val]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's inactive status.
			 * @name File#isInactive
			 * @type {boolean}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'isInactive', {
				get: function ()
				{
					return invoker(delegate, "isInactive", []);
				},
				set: function (val)
				{
					invoker(delegate, "setIsInactive", [val]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});
			/**
			 * The file's "Available without Login" status.
			 * @name File#isOnline
			 * @type {boolean}
			 *
			 * @since 2015.2
			 */
			Object.defineProperty(this, 'isOnline', {
				get: function ()
				{
					return invoker(delegate, "isOnline", []);
				},
				set: function (val)
				{
					invoker(delegate, "setIsOnline", [val]);
				},
				enumerable: true,
				configurable: false,
				writeable: true
			});

			/**
			 * @name File#lines
			 * @type {Iterator} iterator - Iterator which provides the next line of text from the text file to the iterator function.
			 *      <pre> file.lines.iterator().each(function(lineContext){...}); </pre>
			 *
			 * @throws {SuiteScriptError} YOU_CANNOT_READ_FROM_A_FILE_AFTER_YOU_BEGAN_WRITING_TO_IT if you call after having called appendLine
			 * @readonly
			 *
			 * @since 2017.1
			 */
			Object.defineProperty(this, 'lines', {
				get: function ()
				{
					return Object.freeze({
						iterator: function iterator()
						{
							var fileContents = invoker(delegate, 'createStreamingFileContents', []);
							var fileLines = new FileLines(fileContents);
							fileLinesObjectsCreated.push(fileLines);
							return iteratorFactory.create(fileLines);
						}
					});
				},
				set: function (val)
				{
					utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'output');
				},
				enumerable: true,
				configurable: false
			});


			/*
			 * Helper function for http.writeFile()
			 */
			Object.defineProperty(this, '_writeTo', {
				set: function (val)
				{
					invoker(val.delegate, 'writeFile', [delegate, val.isInline ? true : false]);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});
			/*
			 * Helper function for task.CsvImportTask
			 */
			Object.defineProperty(this, '_sd', {
				set: function (val)
				{
					if (val.toString() === 'task.CsvImportTask')
						val._fd = delegate;
					else if (val.toString() === 'FileDelegateContainer')
						val.set(delegate);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for sftp.upload
			 */
			Object.defineProperty(this, '_upload', {
				set: function (val)
				{
					invoker(val.delegate, 'upload', [delegate, val.filename, val.directory, val.timeout, val.replace])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * Helper function for bank connectivity
			 */
			Object.defineProperty(this, '_saveBankStatementFile', {
				set: function (val)
				{
					invoker(val.delegate, 'saveBankStatementFile', [delegate, val.bankStatementFormat])
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/**
			 * Returns iterator of segments delimited by separator
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.separator
			 * @return {Iterator}
			 *
			 * @since 2019.1
			 */
			this.getSegments = function getContents(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.getSegments');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject)]);
				var separator = options.separator;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(separator, 'options.separator', util.isString)]);
				if (separator === "")
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_SEGMENT_SEPARATOR);
				return Object.freeze({
					iterator: function iterator()
					{
						var fileContents = invoker(delegate, 'createStreamingFileContents', []);
						var fileSegments = new FileSegments(fileContents, separator);
						fileSegmentsObjectsCreated.push(fileSegments);
						return iteratorFactory.create(fileSegments);
					}
				});
			};

			/**
			 * Returns reader object for performing special read operations
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {Reader}
			 *
			 * @since 2019.1
			 */
			this.getReader = function getReader()
			{
				var fileContents = invoker(delegate, 'createStreamingFileContents', []);
				var reader = new Reader(fileContents);
				fileReaderObjectsCreated.push(reader);
				return reader;
			};

			/**
			 * Return the value (Base64 encoded for binary types) of the file.
			 * Note: Contents are lazy loaded and must be less than 10MB in size in order to access.
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @throws {SuiteScriptError} SSS_FILE_CONTENT_SIZE_EXCEEDED when trying to get contents of a file larger than 10MB
			 * @return {string}
			 *
			 * @since 2015.2
			 */
			this.getContents = function getContents()
			{
				return invoker(delegate, 'getValue', []);
			};

			/**
			 * Add/update a file in the file cabinet based on the properties of this object.
			 * @restriction Server SuiteScript only
			 * @governance 20 units
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when the folder property is not set
			 * @throws {SuiteScriptError} INVALID_KEY_OR_REF if trying to save to a non-existing folder
			 * @return {number} return internal ID of file in the file cabinet
			 *
			 * @since 2015.2
			 */
			this.save = function save()
			{
				if (invoker(delegate, "getFolder", []) == -1)
					utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT,'file.File.save', 'folder');

				return invoker(fileApi, 'nlapiSubmitFile', [delegate]);
			};

			/**
			 * Append a chunk of text to the file.
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {File} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.append = function append(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.append');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.append');
				invoker(delegate, 'append', [String(options.value)]);
				return this;
			};

			/**
			 * Append a line of text to the file.
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.value text to append
			 * @return {File} Returns this file
			 * @throws {SuiteScriptError} YOU_CANNOT_WRITE_TO_A_FILE_AFTER_YOU_BEGAN_READING_FROM_IT If you call it after having called FileLines#each
			 * @since 2017.1
			 */
			this.appendLine = function appendLine(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'file.appendLine');
				utilityFunctions.checkArgs([options.value], ['options.value'], 'file.appendLine');
				invoker(delegate, 'appendLine', [String(options.value)]);
				return this;
			};

			/**
			 * Reset the reading and writing streams that may have been opened by appendLine or FileLines#each
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {void}
			 * @since 2017.1
			 */
			this.resetStream = function resetStream()
			{
				invoker(delegate, 'resetStream', []);
				for(var i = 0; i < fileLinesObjectsCreated.length; i++)
					fileLinesObjectsCreated[i].reset();

				for(var i = 0; i < fileSegmentsObjectsCreated.length; i++)
					fileSegmentsObjectsCreated[i].reset();

				for(var i = 0; i < fileReaderObjectsCreated.length; i++)
					fileReaderObjectsCreated[i].reset();
			};

			/**
			 * Returns the object type name (file.File)
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2015.2
			 */
			this.toString = function toString()
			{
				return TYPE;
			};

			/**
			 * JSON.stringify() implementation.
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @returns {{type: string, id: *, name: *, description: *, path: *, url: *, folder: *, fileType: *, isText: *,
			 *     size: *, encoding: *, isInactive: *, isOnline: *, contents: *}}
			 *
			 * @since 2015.2
			 */
			this.toJSON = function toJSON()
			{
				return {
					type: TYPE,
					id: this.id,
					name: this.name,
					description: this.description,
					path: this.path,
					url: this.url,
					folder: this.folder,
					fileType: this.fileType,
					isText: this.isText,
					size: this.size,
					encoding: this.encoding,
					isInactive: this.isInactive,
					isOnline: this.isOnline
				};
			};

			Object.defineProperty(this, '_attachToEmail', {
				set: function (email)
				{
					email._attach = delegate;
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			if (folder != null)
				this.folder = folder;
		}
		File.prototype = nsobject.getNewInstance();

		/**
		 * @class FileLines
		 * @classdesc Object for iterating over file lines
		 * @protected
		 * @constructor
		 */
		function FileLines(delegate)
		{

			var nextLine = invoker(delegate, 'nextLine', []);

			/**
			 * Returns true if there are still any line which can be read from the file
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {boolean}
			 *
			 * @since 2017.1
			 */
			this.hasNext = function hasNext()
			{
				return nextLine !== null;
			};

			/**
			 * Returns the current line and moves the iterator to the next line
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2017.1
			 */
			this.next = function next()
			{
				var _nextLine = nextLine;
				nextLine = invoker(delegate, 'nextLine', []);
				return _nextLine;
			};

			/**
			 * Sets the current line to the first line of the file
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {void}
			 *
			 * @since 2017.1
			 */
			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
				nextLine = invoker(delegate, 'nextLine', []);
			}

		}

		/**
		 * @class FileSegments
		 * @classdesc Object for iterating over file segments
		 * @protected
		 * @constructor
		 */
		function FileSegments(delegate, separator)
		{

			var nextSegment = invoker(delegate, 'nextSegment', [separator]);

			/**
			 * Returns true if there are still any segments which can be read from the file
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {boolean}
			 *
			 * @since 2019.1
			 */
			this.hasNext = function hasNext()
			{
				return nextSegment !== null;
			};

			/**
			 * Returns the current segment and moves the iterator to the next segment
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.next = function next()
			{
				var _nextSegment = nextSegment;
				nextSegment = invoker(delegate, 'nextSegment', [separator]);
				return _nextSegment;
			};

			/**
			 * Sets the current segment to the first segment of the file
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {void}
			 *
			 * @since 2017.1
			 */
			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
				nextSegment = invoker(delegate, 'nextSegment', [separator]);
			}
		}

		/**
		 * @class Reader
		 * @classdesc object for reading arbitrary amount of data from a file
		 * @protected
		 * @constructor
		 */
		function Reader(delegate)
		{
			/**
			 * Returns string from current position to the next occurrence of options.tag
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @param {Object} options
			 * @param {string} options.tag
			 * @throws {SuiteScriptError} SSS_TAG_CANNOT_BE_EMPTY if tag to read until is empty
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.readUntil = function(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'readUntil');
				var tag = util.isObject(options) && options.hasOwnProperty('tag') ? options.tag : options;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(tag, 'tag', util.isString)]);
				if (tag === "")
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_TAG_CANNOT_BE_EMPTY);
				return invoker(delegate, 'readUntil', [tag]);
			};

			/**
			 * Returns the next options.number characters from the current position
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @param {Object} options
			 * @param {number} options.number
			 * @throws {SuiteScriptError} SSS_INVALID_READ_SIZE if number of characters to read is not greater than zero
			 * @return {string}
			 *
			 * @since 2019.1
			 */
			this.readChars = function(options)
			{
				utilityFunctions.checkArgs([options], ['options'], 'readChars');
				var number = util.isObject(options) && options.hasOwnProperty('number') ? options.number : options;
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(number, 'number', util.isNumber)]);
				if (number <= 0)
					utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_READ_SIZE);
				return invoker(delegate, 'readChars', [number]);
			};

			/**
			 * Resets the stream, so the next read starts from the beginning of the file
			 * @restriction Server SuiteScript only
			 * @governance none
			 * @return {void}
			 *
			 * @since 2017.1
			 */
			this.reset = function reset(){
				invoker(delegate, 'resetStream', []);
			}
		}

		function create(options)
		{
			utilityFunctions.checkArgs([options], ['options object'], 'file.create');
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
			utilityFunctions.checkArgs([options.name, options.fileType], ['name', 'fileType'], 'file.create');
			var name = options.name;
			var fileType = options.fileType;
			var contents = options.contents || "";
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(name, 'name', util.isString)]);
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(fileType, 'fileType', util.isString)]);
			if (utilityFunctions.isSignedXml(contents))
				contents = contents.asString();
			utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(contents, 'contents', util.isString)]);

			return new File(invoker(fileApi, 'nlapiCreateFile', [name, fileType, contents]), options.folder);
		}

		/** @alias N/file */
		return Object.freeze({
			/**
			 * Instantiate a file object (specifying the name, type, and contents which are base-64 encoded for binary types.)
			 * @restriction Server SuiteScript only
			 * @governance none
			 *
			 * @param {Object} options
			 * @param {string} options.name file name
			 * @param {string} options.fileType file type i.e. PLAINTEXT, HTMLDOC, PDF, WORD, see file.Type enum
			 * @param {string} options.contents string containing file contents (must be base-64 encoded for binary types)
			 * @param {number} [options.folder] (optional) the internal ID of the folder to be used when the file is saved
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if options is missing or one of mandatory options
			 *     properties not set
			 * @throws {SuiteScriptError} SSS_INVALID_TYPE_ARG if options.fileType is an invalid type
			 * @throws {SuiteScriptError} BINARY_DATA_EXPECTED_FOR_SUCH_FILE if `fileType` implies a binary type
			 *      yet `contents` is not a valid base-64 encoded string.
			 *
			 * @since 2015.2
			 */
			create: funcWrapper.wrap( create ),
			/**
			 * Load a file from the file cabinet (via its internal ID or path).
			 *
			 * @governance 10 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID or path to file in the file cabinet (i.e. /SuiteScript/foo.js)
			 * @return {File}
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if idOrPath parameter is missing
			 * @throws {SuiteScriptError} RCRD_DSNT_EXIST attempt to load a file from non-existing path
			 * @throws {SuiteScriptError} INSUFFICIENT_PERMISSION attempt to load a file with non-existing ID
			 *
			 * @since 2015.2
			 */
			load: function load(options)
			{
				var idOrPath = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([idOrPath], ['id'], 'file.load');
				var stack = Error().stack;
				return new File(invoker(fileApi, 'nlapiLoadRelativeFile', [idOrPath, util.isString(stack) ? stack : ""]));
			},
			/**
			 * Delete a file from the file cabinet.
			 *
			 * @governance 20 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID of file to be deleted
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id parameter is missing
			 *
			 * @since 2015.2
			 */
			'delete': function (options)
			{
				var id = (options && options.hasOwnProperty('id')) ? options.id : options;

				utilityFunctions.checkArgs([id], ['id'], 'file.delete');

				invoker(fileApi, 'nlapiDeleteFile', [id]);
			},
			/**
			 * Copies file to a different folder.
			 *
			 * @governance 20 units
			 * @restriction Server SuiteScript only
			 *
			 * @param {Object} options
			 * @param {number|string} options.id internal ID of file to be copied
			 * @param {number|string} options.folder internal ID of target folder
			 * @param {string} [options.conflictResolution] NameConflictResolution enum, way to handle conflict name resolution in the folder, the default value is 'FAIL'
			 *
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if id or folder parameter is missing
			 * @throws {SuiteScriptError} INVALID_CONFLICT_RESOLUTION_1 if conflictResolution paramater has wrong value
			 * @since 2021.1
			 */
			'copy': function (options)
			{
				utilityFunctions.checkArgs([options], ['options object'], 'file.copy');
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(options, 'options', util.isObject)]);
				utilityFunctions.checkArgs([options.id, options.folder], ['id', 'folder'], 'file.copy');
				var id = options.id;
				var folder = options.folder;
				var conflictResolution = options.conflictResolution || 'FAIL';
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(id, 'id', util.isNumber)]);
				utilityFunctions.checkArgTypes([utilityFunctions.checkArgObject(folder, 'folder', util.isNumber)]);
				if (!NAME_CONFLICT_RESOLUTION[conflictResolution])
					throw utilityFunctions.throwSuiteScriptError(error.Type.INVALID_CONFLICT_RESOLUTION_1, conflictResolution);
				return new File(invoker(fileApi, 'nlapiCopyFile', [id, folder, conflictResolution]), folder);
			},
			//Undocumented helper function, takes a nlobjFile and wraps it into file.File
			wrap: function wrap(nlobj)
			{
				return new File(nlobj);
			},
			/**
			 * Enum for file types.
			 * @enum {string}
			 * @readonly
			 */
			Type: FILE_TYPES,
			/**
			 * Enum for file encodings.
			 * @enum {string}
			 * @readonly
			 */
			Encoding: ENCODINGS,
			/**
			 * Enum for name conflict resolution.
			 * @enum {string}
			 * @readonly
			 */
			NameConflictResolution :NAME_CONFLICT_RESOLUTION
		});
	});

/**
 * @private
 */
define('N/restricted/httpApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * @private
 */
define('N/restricted/marshalUtil',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript module - common functionality between http and https modules
 *
 * @private
 * @module N/http/httpUtil
 * @suiteScriptVersion 2.x
 *
 */
define('N/http/httpUtil',['N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/restricted/httpApi', 'N/restricted/marshalUtil', 'N/resultObject'],
       function (scriptArguments, error, file, nsobject, invoker, utilityFunctions, httpApi, marshalUtil, resultObject)
       {
           //enums
           var METHODS = Object.freeze({
                                             GET: 'GET',
                                             POST: 'POST',
                                             PUT: 'PUT',
                                             DELETE: 'DELETE',
                                             HEAD: 'HEAD'
                                         });

           var CACHE_DURATIONS = Object.freeze({
                                                     UNIQUE: 'UNIQUE',
                                                     SHORT: 'SHORT',
                                                     MEDIUM: 'MEDIUM',
                                                     LONG: 'LONG'
                                                 });

           var REDIRECT_TYPES = Object.freeze({
               RECORD: 'RECORD',
               SUITELET: 'SUITELET',
               RESTLET: 'RESTLET',
               MEDIA_ITEM: 'MEDIAITEM',
               TASK_LINK: 'TASKLINK'
           });

           /**
            * Encapsulates the response of an HTTP client request (i.e., the return type for http.delete(options), http.get(options), http.post(options), http.put(options), http.request(options), and corresponding promise methods).
            *
            * @protected
            * @classDescription Encapsulation of the response returned by a web server as a response to our HTTP request.
            * @return {http.ClientResponse}
            * @constructor
            *
            * @since 2015.2
            */
           function ClientResponse(delegate)
           {
               var TYPE = 'http.ClientResponse';
               /**
                * The client response code.
                * @name ClientResponse#code
                * @type {number}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'code', {
                   get: function ()
                   {
                       return delegate.getCode ? invoker(delegate, 'getCode', []) : delegate.code;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'code' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * The response headers.
                * @name ClientResponse#headers
                * @type {Object}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'headers', {
                   get: function ()
                   {
                       var headers = {};
                       if (delegate.getAllHeaders)
                       {
                           var headerNames = invoker(delegate, 'getAllHeaders', []);
                           var headers = {};
                           // server-side getHeader() has an undocumented behaviour - it returns only a single occurrence of a
                           // header in case the same header (case-insensitive!) is received multiple times (the rest is ignored).
                           // Standard says that multiple occurrences of one header should be concatenated into a single
                           // comma-separated string - Which is what browser XMLHttpRequest.* functionality does. The only
                           // exception (as per standard) is a Set-Cookie header, which should not be concatenated (it may contain
                           // commas). However Set-Cookie headers can not be retried via browser's XMLHttpRequest.* functionality,
                           // so browsers do not have to consider this edge-case for XMLHttpRequest.getResponseHeader().

                           // It also  seems that the this retrieval is quite ineffective, given that whait is being obtained is
                           // just string[], nothing more complex.

                           for (var i = 0; i < headerNames.length; i++)
                               headers[headerNames[i]] = invoker(delegate, 'getHeader', [headerNames[i]]);
                       }
                       else
                       {
                           headers = delegate.headers;
                       }
                       // To maintain compatibility with older scripts which might work case-sensitively with the header name and
                       // expect a Title-Cased version, we unify the the headers array so that all headers are aliased under:

                       // 1) original case (should be lower-case or Title-Case for most web servers)
                       // 2) lower-case
                       // 3) Title-Case
                       var headersMultiCased = {};
                       for (var originalCased in headers) {
                           if (headers.hasOwnProperty(originalCased)) {
                               var headerValue = headers[originalCased];
                               var lowerCased = originalCased.toLowerCase();
                               var pascalCased = "";
                               var nameParts = lowerCased.split("-");
                               for (var namePartIdx = 0; namePartIdx < nameParts.length; ++namePartIdx) {
                                   if (namePartIdx !== 0) {
                                       pascalCased += "-";
                                   }
                                   var namePart = nameParts[namePartIdx];
                                   for (var charIdx = 0; charIdx < namePart.length; ++charIdx) {
                                       if (charIdx === 0) {
                                           pascalCased += namePart.charAt(0).toUpperCase();
                                       } else {
                                           pascalCased += namePart.charAt(charIdx);
                                       }
                                   }
                               }
                               headersMultiCased[originalCased] = headerValue;
                               headersMultiCased[lowerCased] = headerValue;
                               headersMultiCased[pascalCased] = headerValue;
                           }
                       }
                       return headersMultiCased;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'headers' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });
               /**
                * The client response body.
                * @name ClientResponse#body
                * @type {string}
                * @readonly
                * @throws {SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
                */
               Object.defineProperty(this, 'body', {
                   get: function ()
                   {
                       return delegate.getBody ? invoker(delegate, 'getBody', []) : delegate.body;
                   },
                   set: function (val)
                   {
                       utilityFunctions.throwSuiteScriptError(error.Type.READ_ONLY_PROPERTY, 'body' );
                   },
                   enumerable: true,
                   configurable: false,
                   writeable: false
               });

               /**
                * Returns the object type name (http.ClientResponse)
                * @governance none
                * @returns {string}
                *
                * @since 2015.2
                */
               this.toString = function toString()
               {
                   return TYPE;
               };

               /**
                * get JSON format of the object
                * @governance none
                * @returns {{type: string, code: *, headers: *, body: *}}
                *
                * @since 2015.2
                */
               this.toJSON = function toJSON()
               {
                   return {
                       type: TYPE,
                       code: this.code,
                       headers: this.headers,
                       body: this.body
                   };
               }
           }

           ClientResponse.prototype = nsobject.getNewInstance();

           function checkParams(config, required, optional)
           {
               checkConfig(config);
               for (var i = 0; i < required.length; i++)
               {
                   if (!config[required[i]] && config[required[i]] !== 0)
                       utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "checkParams", "options." + required[i] );

               }
           }

           function checkConfig(config)
           {
               if (!config)
                   utilityFunctions.throwSuiteScriptError(error.Type.MISSING_REQD_ARGUMENT, "checkConfig", 'options object' );
           }

           function runRequest(options, callback)
           {
               var hasBody = options.method === this.Method.POST || options.method === this.Method.PUT;
               this.checkParams(options, hasBody ? ['method', 'url', 'body'] : ['method', 'url'], ['headers']);
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("https:") !== 0), error.Type.SSS_INVALID_URL, "HTTP");
               var headers = options.headers || null;
               var isClient = typeof document != 'undefined';
               if (url[0] == '/')
               {
                   utilityFunctions.assertTrue(isClient, error.Type.SSS_INVALID_URL, "HTTP");
                   url = 'http://' + document.location.host + url;
               }
               if (isClient)
               {
                   if (!headers)
                       headers = {};
               }
	           detectBodyIsUnexpectedlyObject(options.body, headers);
               headers = invoker(marshalUtil, "nsObjectToMap", [headers]);
               return invoker(httpApi, "nlapiRequestURL", [url, hasBody ? options.body : null, headers, options.method], callback);
           }

	       var delegates = {};

	       function storeDelegate(delegate){
		       delegates[invoker(delegate, 'getID', [])] = delegate;
	       }

	       function getDelegate(id){
				return delegates[id];
	       }

	       function makeHeaders(options){
	            var headers = {};
		        if (options.headers && (util.isObject(options.headers) || util.isArray(options.headers)))
		        {
			        for (var key in options.headers)
			        {
				        if (utilityFunctions.checkObjectType(options.headers[key], 'https.SecureString'))
					        headers[key] = delegates[options.headers[key]._id];
				        else if (util.isString(options.headers[key]))
					        headers[key] = options.headers[key];
			        }
		        }
		        return headers;
	       }

	       function processBody(options)
	       {
		       if (utilityFunctions.checkObjectType(options.body, 'https.SecureString'))
			       options.body = delegates[options.body._id];
		       else if (options.body && util.isObject(options.body))
		       {
			       Object.getOwnPropertyNames(options.body).forEach(function(elem){
				       if (utilityFunctions.checkObjectType(options.body[elem], 'https.SecureString'))
					       options.body[elem] = delegates[options.body[elem]._id];
			       });
		       }
		       return options.body;
	       }

	       var requestSuitelet = utilityFunctions.thenableFunction(function requestSuitelet(options, doRequest, isAsync)
	       {
		       var opts = utilityFunctions.processOptions(
			       "https.requestSuitelet",
			       arguments,
			       {
				       scriptId: {verify: util.isString},
				       deploymentId: {verify: util.isString},
				       external: {verify: util.isBoolean, defaultValue: false},
				       urlParams: {verify: utilityFunctions.isObject, defaultValue: null},
				       method: {verify: util.isString, defaultValue: null},
				       body: {verify: utilityFunctions.isOneOf(util.isString, utilityFunctions.isObject), defaultValue: null},
				       headers: {verify: utilityFunctions.isObject, defaultValue: null},
			       }
		       );
		       return resultObject.create(function ()
		       {
			       return (isAsync ? invoker.promise : invoker)(
				       httpApi, 'nlapiRequestSuitelet', [
					       opts.scriptId, opts.deploymentId, opts.external,
					       opts.urlParams, opts.body, opts.headers, opts.method
				       ]
			       );
		       }).then(function (response)
		       {
			       return new ClientResponse(response);
		       });

	       }, {
		       isAsyncArgIndex: 2
	       });

		   function detectBodyIsUnexpectedlyObject(body, headers)
		   {
			   if (
				   body && util.isObject(body) &&
				   headers && util.isObject(headers) &&
				   util.isString(headers["Content-Type"]) &&
				   headers["Content-Type"].toLowerCase() === "application/json"
			   ) {
				   log.error("Wrong request body!", error.create({
					   name: "REQUEST_BODY_MUST_BE_STRING_WHEN_CONTENT_TYPE_IS_APPLICATION_JSON",
					   message: "You (most likely) forgot to `JSON.stringify()` the request body.  " +
						   "You passed `Content-Type: application/json` header, but the body parameter is an object!  " +
						   "As per documentation, the body will be encoded to the URL and the header will be changed to " +
						   "`application/x-www-form-urlencoded; charset=UTF-8`."
				   }));
			   }
		   }

           /** @alias N/http */
           return Object.freeze(
                   {
                       /**
                        * Enum for HTTP methods.
                        * @enum {string}
                        * @readonly
                        */
                       Method: METHODS,
                       /**
                        * Enum for caching durations.
                        * @enum {string}
                        * @readonly
                        */
                       CacheDuration: CACHE_DURATIONS,
                       /**
                        * Enum for redirect types.
                        * Holds the string values for supported NetSuite resources that you can redirect to. This enum is used to set the value of the type argument for ServerResponse.sendRedirect.
                        * @enum {string}
                        * @readonly
                        */
                       RedirectType: REDIRECT_TYPES,
                       /**
                        * Send a HTTP GET request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       get: function get(config, headers, httpClient)
                       {
                           checkConfig(config);
                           if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.GET;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP POST request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       post: function post(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.POST;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP PUT request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body PUT data
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       put: function put(config, httpClient)
                       {
                           checkConfig(config);
                           config.method = this.Method.PUT;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP DELETE request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.url the HTTP URL being requested
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       'delete': function (config, headers, httpClient)
                       {
                           checkConfig(config);
                            if (!utilityFunctions.isObject(config))
                           {
                               var url = config;
                               config = {url: url, headers: headers || null};
                           }
                           config.method = this.Method.DELETE;
                           return this.request(config, httpClient);
                       },
                       /**
                        * Send a HTTP request and return server response.
                        *
                        * @governance 10 units
                        *
                        * @param {Object} options
                        * @param {string} options.method HTTP method of the request
                        * @param {string} options.url the HTTP URL being requested
                        * @param {string|Object} options.body POST data; must be present if and only if method is POST
                        * @param {Object} options.headers (optional) request HTTP headers
                        * @return {ClientResponse}
                        *
                        * @throws {SuiteScriptError} REQUIRED_PARAM_MISSING if a required parameter is missing
                        * @throws {SuiteScriptError} UNKNOWN_PARAM if an unknown parameter is present in options
                        * @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
                        *
                        * @since 2015.2
                        */
                       request: function request(options, httpClient)
                       {
                           return httpClient.doRequest(options);
                       },
                       setRequester: function setRequester(val)
                       {
                           requester = val;
                       },
                       createClientResponse: function createClientResponse(val)
                       {
                           return new ClientResponse(val);
                       },
                       checkConfig: checkConfig,
                       checkParams: checkParams,
	                   storeDelegate: storeDelegate,
	                   getDelegate: getDelegate,
	                   makeHeaders: makeHeaders,
	                   processBody: processBody,
	                   requestSuitelet: requestSuitelet,
	                   detectBodyIsUnexpectedlyObject: detectBodyIsUnexpectedlyObject,
                       runRequest: runRequest
                   });
       });

/**
 * SuiteScript module - defines the Suitelet response and request objects
 *
 * @module N/suiteletContext
 * @NApiVersion 2.x
 *
 */

define('N/suiteletContext',['N/restricted/scriptArguments', 'N/error', 'N/file', 'N/nsobject', 'N/internal/invoker', 'N/utilityFunctions', 'N/util'],
        function (scriptArguments, error, file, nsobject, invoker, utilityFunctions, util)
        {
			/**
			 * Return a new instance of ServerRequest object that carries incoming HTTP request info.
			 *
			 * @class ServerRequest
			 * @classDescription Encapsulation of the HTTP request incoming to the suitelet.
			 * @protected
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerRequest(delegate)
			{
				var TYPE = 'http.ServerRequest';
				/**
				 * Server request headers.
				 * @name ServerRequest#headers
				 * @type {Object}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						return invoker(delegate, 'getAllHeaders', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request clientIpAddress.
				 * @name ServerRequest#clientIpAddress
				 * @type {Object}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2018.1
				 */
				Object.defineProperty(this, 'clientIpAddress', {
					get: function ()
					{
						return invoker(delegate, 'getClientIpAddress', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'clientIpAddress'});
					},
					enumerable: true,
					configurable: false
				});

				/**
				 * Server request client public port.
				 * @name ServerRequest#clientPublicPort
				 * @type {number}
				 * @readonly
				 *
				 * @since 2021.2
				 */
				Object.defineProperty(this, 'clientPublicPort', {
					get: function ()
					{
						return invoker(delegate, 'getClientPublicPort', []);
					},
					enumerable: false,
					configurable: false
				});

				/**
				 * Server request vendor public ip.
				 * @name ServerRequest#vendorPublicIp
				 * @type {string}
				 * @readonly
				 *
				 * @since 2021.2
				 */
				Object.defineProperty(this, 'vendorPublicIp', {
					get: function ()
					{
						return invoker(delegate, 'getVendorPublicIp', []);
					},
					enumerable: false,
					configurable: false
				});

				/**
				 * Server request forwarded vendor.
				 * @name ServerRequest#forwardedVendor
				 * @type {string}
				 * @readonly
				 *
				 * @since 2021.2
				 */
				Object.defineProperty(this, 'forwardedVendor', {
					get: function ()
					{
						return invoker(delegate, 'getForwardedVendor', []);
					},
					enumerable: false,
					configurable: false
				});
				/**
				 * Server request parameters.
				 * @name ServerRequest#parameters
				 * @type {Object}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'parameters', {
					get: function ()
					{
						return invoker(delegate, 'getAllParameters', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'parameters'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request files.
				 * @name ServerRequest#files
				 * @type {Object}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'files', {
					get: function ()
					{
						var fileMap = invoker(delegate, 'getAllFiles', []);
						var files = {};
						util.each(fileMap, function(val, key){
							files[key] = file.wrap(val);
						});
						return files;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'files'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request body.
				 * @name ServerRequest#body
				 * @type {string}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'body', {
					get: function ()
					{
						return invoker(delegate, 'getBody', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'body'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request HTTP method.
				 * @name ServerRequest#method
				 * @type {string}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 * 
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'method', {
					get: function ()
					{
						return invoker(delegate, 'getMethod', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'method'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Server request URL.
				 * @name ServerRequest#url
				 * @type {string}
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 * 
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'url', {
					get: function ()
					{
						return invoker(delegate, 'getURL', []);
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'url'});
					},
					enumerable: true,
					configurable: false
				});
				/**
				 * Returns the number of lines in a sublist.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @return {integer} the integer value of the number of line items in the sublist
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * 
				 * @since 2015.2
				 */
				this.getLineCount = function getLineCount(options)
				{
					var group = (options && options.hasOwnProperty('group')) ? options.group : options;
					utilityFunctions.checkArgs([group], ['group'], 'ServerRequest.getLineCount');
					return invoker(delegate, 'getLineItemCount', [group]);
				};
				/**
				 * Returns the value of a sublist line item.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.group sublist internal ID
				 * @param {string} options.name the name of the field whose value is returned
				 * @param {string} options.line the line number for this field (1-based)
				 * @return {string} the string value of the line item
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 *
				 * @since 2015.2
				 */
				this.getSublistValue = function getSublistValue(options)
				{
					var group = null, name = null, line = null;

					if (options && (options.hasOwnProperty('group') || options.hasOwnProperty('name') || options.hasOwnProperty('line')))
					{
						group = options.group;
						name = options.name;
						line = options.line;
					}
					else
					{
						group = options;
						name = arguments[1];
						line = arguments[2];
					}

					utilityFunctions.checkArgs([group, name, line], ['group', 'name', 'line'], 'ServerRequest.getSublistValue');
					return invoker(delegate, 'getLineItemValue', [group, name, line + 1]);
				};
				/**
				 * Returns the object type name (http.ServerRequest)
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @return {string}
				 *
				 * @since 2015.2
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * get JSON format of the object
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @return {Object}
				 *
				 * @since 2015.2
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						method: this.method,
						url: this.url,
						parameters: this.parameters,
						headers: this.headers,
						clientIpAddress: this.clientIpAddress,
						files: this.files,
						body: this.body
					};
				}
			}

			ServerRequest.prototype = nsobject.getNewInstance();

			/**
			 * Return a new instance of ServerResponse object that carries the response to an incoming HTTP request.
			 *
			 * @class ServerResponse
			 * @classDescription Encapsulation of the HTTP response that will be returned to the browser.
			 * @protected
			 * @constructor
			 *
			 * @since 2015.2
			 */
			function ServerResponse(delegate)
			{
				var TYPE = 'http.ServerResponse';
				/**
				 * Server response headers.
				 * @name ServerResponse#headers
				 * @type {Object} key/value pairs with all the headers; if multiple values are assigned to one header name, they are returned as an array
				 * @readonly
				 * @throws {error.SuiteScriptError} READ_ONLY_PROPERTY when setting the property is attempted
				 *
				 * @since 2015.2
				 */
				Object.defineProperty(this, 'headers', {
					get: function ()
					{
						var headerNames = invoker(delegate, 'getAllHeaders', []);
						var headers = {};
						for (var i = 0; i < headerNames.length; i++)
						{
							var values = invoker(delegate, "getHeaders", [headerNames[i]]);
							headers[headerNames[i]] = values.length == 1 ? values[0] : values;
						}
						return headers;
					},
					set: function (val)
					{
						throw error.create({name: error.Type.READ_ONLY_PROPERTY, message: 'headers'});
					},
					enumerable: true,
					configurable: false
				});
				/*
				 * Helper function for ui.Assistant.sendRedirect()
				 */
				Object.defineProperty(this, '_assistantSendRedirect', {
					set: function (val)
					{
						invoker(val.delegate, 'sendRedirect', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/*
				 * Helper function for render.TemplateRenderer.renderToResponse()
				 */
				Object.defineProperty(this, '_renderToResponse', {
					set: function (val)
					{
						return invoker(val, 'renderToResponse', [delegate]);
					},
					enumerable: false,
					configurable: false
				});

				/**
				 * Sets the value of a response header.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 *
				 * @since 2015.2
				 */
				this.setHeader = function setHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.setHeader');
					invoker(delegate, 'setHeader', [name, value]);
				};
				/**
				 * Adds a header to the response. If this header has already been set, this will add another line for that header.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.name the name of the header
				 * @param {string} options.value the value used to set the header
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_HEADER if the header name or value is invalid
				 *
				 * @since 2015.2
				 */
				this.addHeader = function addHeader(options)
				{
					var name = null, value = null;
					if (options && (options.hasOwnProperty('name') || options.hasOwnProperty('value')))
					{
						name = options.name;
						value = options.value;
					}
					else
					{
						name = options;
						value = arguments[1];
					}
					utilityFunctions.checkArgs([name, value], ['name', 'value'], 'ServerResponse.addHeader');
					invoker(delegate, 'addHeader', [name, value]);
				};
				/**
				 * Sets the redirect URL by resolving to a NetSuite resource. Note that all parameters must be prefixed with custparam.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.type the base type for this resource - one of RECORD, TASKLINK or SUITELET
				 * @param {string} options.identifier the primary id for this resource
				 * @param {string} options.id (optional) the secondary id for this resource
				 * @param {boolean} options.editMode (optional) for RECORD calls, this determines whether to return a URL for the record in edit mode or view mode
				 * @param {Object} options.parameters (optional) additional URL parameters as name/value pairs
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} SSS_INVALID_URL_CATEGORY if type is none of RECORD, TASKLINK or SUITELET
				 * @throws {error.SuiteScriptError} SSS_INVALID_TASK_ID if type is TASKLINK and an invalid task identifier is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_RECORD_TYPE if type is RECORD and an invalid record type is passed in the options.identifier parameter
				 * @throws {error.SuiteScriptError} SSS_INVALID_SCRIPT_ID_1 if type is SUITELET and an invalid script ID and deployment ID are passed in the options.identifier and options.id parameters
				 *
				 * @since 2015.2
				 */
				this.sendRedirect = function sendRedirect(options)
				{
					var type = null, identifier = null, id = null, editMode = false, parameters = null;
					if (options && (options.hasOwnProperty('type') || options.hasOwnProperty('identifier')))
					{
						type = options.type;
						identifier = options.identifier;
						id = options.id ? options.id : null;
						editMode = util.isBoolean(options.editMode) ? options.editMode : false;
						parameters = typeof(options.parameters) === 'object' ? options.parameters : null;
					}
					else
					{
						type = options;
						identifier = arguments[1];
						id = arguments[2] ? arguments[2] : null;
						editMode = util.isBoolean(arguments[3]) ? arguments[3] : false;
						parameters = typeof(arguments[4]) === 'object' ? arguments[4] : null;
					}
					utilityFunctions.checkArgs([type, identifier], ['type', 'identifier'], 'ServerResponse.sendRedirect');
					invoker(delegate, 'sendRedirect', [type, identifier, id, editMode, parameters]);
				};
				/**
				 * Write information (text/xml/html) to the response.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.output string or file being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 *
				 * @since 2015.2
				 */
				this.write = function write(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.write');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'write', [output]);
				};
				/**
				 * Write line information (text/xml/html) to the response.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.output string being written
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a string
				 *
				 * @since 2015.2
				 */
				this.writeLine = function writeLine(options)
				{
					var output = (options && options.hasOwnProperty('output')) ? options.output : options;
					utilityFunctions.checkArgs([output], ['output'], 'ServerResponse.writeLine');
					utilityFunctions.assertTrue(util.isString(output), error.Type.WRONG_PARAMETER_TYPE, 'output');
					invoker(delegate, 'writeLine', [output]);
				};
				/**
				 * Generates a page using a page element object.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {serverWidget.Assistant|serverWidget.Form|serverWidget.List} options.pageObject standalone page object: assistant, form or list
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 *
				 * @since 2015.2
				 */
				this.writePage = function writePage(options)
				{
					var pageObject = (options && options.hasOwnProperty('pageObject')) ? options.pageObject : options;
					utilityFunctions.checkArgs([pageObject], ['pageObject'], 'ServerResponse.writePage');
					pageObject._writeTo = {'delegate': delegate}
				};
				/**
				 * Write a file to the response.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {file.File} options.file the file to be written
				 * @param {boolean} options.isInline (optional) true if the file is inline
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 * @throws {error.SuiteScriptError} WRONG_PARAMETER_TYPE if the file parameter is not a file.File object
				 *
				 * @since 2015.2
				 */
				this.writeFile = function writeFile(options)
				{
					var fileObj = options && options['file'] !== undefined ? options['file'] : options;
					var isInline = options && options['isInline'] !== undefined ? options['isInline'] : arguments[1];
					utilityFunctions.checkArgs([fileObj], ['file'], 'ServerResponse.writeFile');
					if (fileObj.toString() != 'file.File')
					{
						throw error.create({name: error.Type.WRONG_PARAMETER_TYPE, message: 'file'});
					}
					fileObj._writeTo = {'delegate': delegate, 'isInline': isInline};
				};
				/**
				 * Returns the value for a header returned in the response.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.name the header name
				 * @return {string|Array} the value of the header; if multiple values are assigned to the header name, they are returned as an array
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 *
				 * @since 2015.2
				 */
				this.getHeader = function getHeader(options)
				{
					var name = (options && options.hasOwnProperty('name')) ? options.name : options;
					utilityFunctions.checkArgs([name], ['name'], 'ServerResponse.getHeader');
					var values = invoker(delegate, 'getHeaders', [name]);
					return values != null ? (values.length == 1 ? values[0] : values) : null;
				};
				/**
				 * Generates and renders a PDF directly to the response.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.xmlString content of your PDF
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 *
				 * @since 2015.2
				 */
				this.renderPdf = function renderPdf(options)
				{
					var xmlString = (options && options.hasOwnProperty('xmlString')) ? options.xmlString : options;
					utilityFunctions.checkArgs([xmlString], ['xmlString'], 'ServerResponse.renderPdf');
					invoker(delegate, 'renderPDF', [xmlString]);
				};
				/**
				 * Sets CDN caching for a period of time.
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @param {Object} options
				 * @param {string} options.type constant value to represent the caching duration, see http.CacheDuration enum
				 * @throws {error.SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required parameter is missing
				 *
				 * @since 2015.2
				 */
				this.setCdnCacheable = function setCdnCacheable(options)
				{
					var type = (options && options.hasOwnProperty('type')) ? options.type : options;
					utilityFunctions.checkArgs([type], ['type'], 'ServerResponse.setCdnCacheable');
					invoker(delegate, 'setCDNCacheable', [type]);
				};
				/**
				 * Returns the object type name (http.ServerResponse)
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @return {string}
				 *
				 * @since 2020.2
				 */
				this.toString = function toString()
				{
					return TYPE;
				};
				/**
				 * get JSON format of the object
				 * @restriction Server SuiteScript only
				 * @governance none
				 * @return {Object}
				 *
				 * @since 2015.2
				 */
				this.toJSON = function toJSON()
				{
					return {
						type: TYPE,
						headers: this.headers
					};
				}
			}

			ServerResponse.prototype = nsobject.getNewInstance();

            return Object.freeze(
                    {
                        createServerRequest: function createServerRequest(delegate)
                        {
                            return new ServerRequest(delegate);
                        },
                        createServerResponse: function createServerResponse(delegate)
                        {
                            return new ServerResponse(delegate);
                        },
	                    getServerRequest: function getServerRequest()
                        {
                            return new ServerRequest(scriptArguments.request);
                        },
                        getServerResponse: function getServerResponse()
                        {
                            return new ServerResponse(scriptArguments.response);
                        },
                        _ServerRequest: Object.freeze(ServerRequest)
                    }
            );
        }
);
/**
 * SuiteScript module
 *
 * @module N/http
 * @suiteScriptVersion 2.x
 *
 */
define('N/http',['N/http/httpUtil', 'N/suiteletContext'],
       function (httpUtil, suiteletContext)
       {

           function requestProcess(options)
           {
               var requestResponse = httpUtil.runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           }

           function requestProcessPromise(options)
           {
               var myPromise = new Promise(function (resolve, reject)
               {
                   try
                   {
                       httpUtil.runRequest(options, callback)
                   }
                   catch (e)
                   {
                       reject(e);
                   }

                   function callback(result, exception)
                   {
                       if (exception)
                       {
                           reject(exception)
                       }
                       else
                       {
                           try
                           {
                               resolve(httpUtil.createClientResponse(result));
                           }
                           catch (e)
                           {
                               reject(e);
                           }
                       }
                   }
               });
               return myPromise
           };

           var httpClient = Object.freeze({doRequest: requestProcess});
           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise});

           function doGet(options, headers) { return httpUtil.get(options, headers, httpClient)}
           doGet.promise = function doGetPromise(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};

           function doPost(options) { return httpUtil.post(options, httpClient)}
           doPost.promise = function doPostPromise(options) { return httpUtil.post(options, httpClientPromise)};

           function doPut(options) { return httpUtil.put(options, httpClient)}
           doPut.promise = function doPutPromise(options) { return httpUtil.put(options, httpClientPromise)};

           function doDelete(options, headers) { return httpUtil['delete'](options, headers, httpClient)}
           doDelete.promise = function doDeletePromise(options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};

           function doRequest(options) { return httpUtil.request(options, httpClient)}
           doRequest.promise = function doRequestPromise(options) { return httpUtil.request(options, httpClientPromise)};

           return Object.freeze(
                   {
					   /**
						* Enum describing available HTTP methods. Holds the string value for supported HTTP requests. This enum is used to set the value of http.request and ServerRequest.method.
						* @enum {string}
					    * @readonly
						*/
                       Method: httpUtil.Method,
					   /**
						* Enum describing available Commerce API Cache Durations. Holds the string value for supported cache durations. This enum is used to set the value of the ServerResponse.setCdnCacheable property.
						* @enum {string}
					    * @readonly
						*/
                       CacheDuration: httpUtil.CacheDuration,
					   /**
						* Send a HTTP GET request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {Object} options.headers (optional) The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   get: doGet,
					   /**
						* Send a HTTP POST request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The POST data
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   post: doPost,
					   /**
						* Send a HTTP PUT request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The PUT data
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   put: doPut,
					   /**
						* Send a HTTP DELETE request and return a reponse from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.url the HTTP URL being requested
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   'delete': doDelete,
					   /**
						* Send a HTTP request and return a response from a server.
						*
						* @governance 10 units
						* @restriction Server SuiteScript only
						*
						* @param {Object} options
						* @param {string} options.method The HTTP request method. Set using the http.Method enum.
						* @param {string} options.url the HTTP URL being requested
						* @param {string|Object} options.body The POST data; must be present if and only if method is POST
						* @param {Object} [options.headers] The HTTP headers
						* @return {ClientResponse}
						*
					    * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if a required argument is missing
						* @throws {SuiteScriptError} SSS_INVALID_URL if an incorrect protocol is used (ex: http in the HTTPS module)
						*
						* @since 2015.2
						*/
					   request: doRequest,
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse,
                       /**
                        * @enum {string}
                        * @readonly
                        */
                       RedirectType : httpUtil.RedirectType
                   });

       });

/**
 * SuiteScript portlet module
 *
 * @module N/portlet
 * @NApiVersion 2.x
 *
 */
define('N/portlet',['N/error', 'N/utilityFunctions'],
	function (error, utilityFunctions)
	{
		var SUPPORTED_PORTLET_TYPE = 'form';

		function refresh()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.refreshfn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		function resize()
		{
			if (typeof window.nlportlet === 'object' && window.nlportlet.type === SUPPORTED_PORTLET_TYPE)
				window.nlportlet.resizefn();
			else
				utilityFunctions.throwSuiteScriptError(error.Type.SSS_INVALID_UI_OBJECT_TYPE, window.nlportlet.type, SUPPORTED_PORTLET_TYPE);
		}

		return Object.freeze({
			/**
			 * Causes a FORM type portlet to immediately refresh.
			 * @restriction Client SuiteScript only
			 * @governance none
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			refresh: refresh,
			/**
			 * Causes a FORM type portlet to be immediately resized.
			 * @restriction Client SuiteScript only
			 * @governance none
			 * @throws {SuiteScriptError} SSS_INVALID_UI_OBJECT_TYPE if portlet is not FORM type
			 *
			 * @since 2016.1
			 */
			resize: resize
		})
	}
);
/**
 * SuiteScript module
 *
 * @private
 * @module N/xmlHelpers
 * @NApiVersion 2.x
 */
define('N/internal/xmlHelpers',['N/internal/bridge'],
	function(apiBridge)
	{
		function selectValues(node, expr)
		{
			var selectedValues = [];
			var selections = apiBridge.nlapiSelectNodes(node, expr);
			if (selections != null)
			{
				selectedValues = [];
				for (var i = 0; i < selections.length; i++)
					selectedValues[i] = getXMLValue(selections[i]);
			}
			return selectedValues;
		}

		function selectValue(node, expr)
		{
			var selections = selectValues(node, expr);
			var selection = selections != null ? selections[0] : null;
			return selection;
		}

		function getXMLValue(node)
		{
			if (node.nodeType == 3 || node.nodeType == 4)	/* Text or CDATA Nodes */
				return node.nodeValue;
			if (node.nodeType == 2)
				return node.value;    /* Attr node will deprecate child nodes */
			if (node.nodeType == 9)	/* Document Node (Use root Element instead) */
				node = node.documentElement;

			var value = null;
			var elems = node.childNodes;
			for (var i = 0; i < elems.length; i++)
			{
				var elem = elems[i];
				if (elem.nodeType == 3 || elem.nodeType == 4)	/* Text or CDATA Nodes */
				{
					if (value == null)
						value = elem.nodeValue;
					else
						value += elem.nodeValue;
				}
			}
			return value;
		}

		return Object.freeze({
			nlapiSelectValue: selectValue
		});
	}
);
/**
 * SuiteScript module
 *
 * @private
 * @module N/ajaxHelpers
 * @NApiVersion 2.x
 */
define('N/internal/ajaxHelpers',['N/internal/bridge', 'N/internal/xmlHelpers'],
	function(apiBridge, xmlHelpers)
	{
		var trim = String.prototype.trim || function(){
				return this.replace(/^\s+|\s+$/gm,'');
			};

		function isJson(body)
		{
			if(!body)
				return false;
			body = trim.call(body);
			return body && body.indexOf('{') === 0 && body.lastIndexOf('}') === body.length - 1;
		}

		function throwServerCallError(details, code, id)
		{
			var error = Error(details);
			error.name = code;
			error.id = id;
			error.userFacing = false;
			throw error;
		}

		function handleServerCallError(responseCode, responseBody, handleJson)
		{
			if (responseBody && responseBody.toLowerCase().indexOf('error')>=0)
			{
				if (isJson(responseBody))
				{
					if (handleJson && responseBody.indexOf('{"error"') >= 0)
					{
						var errorBody = JSON.parse(responseBody);
						throwServerCallError(errorBody.error.message, errorBody.error.code);
					}
				}
				else if (responseBody.indexOf('<onlineError>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/detail'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/code'), xmlHelpers.nlapiSelectValue(errorBody, '/onlineError/id'));
				}
				else if (responseBody.indexOf('<error>') >= 0)
				{
					var errorBody = apiBridge.nlapiStringToXML(responseBody);
					throwServerCallError(xmlHelpers.nlapiSelectValue(errorBody, '/error/message'), xmlHelpers.nlapiSelectValue(errorBody, '/error/code'));
				}
				else if (responseBody.indexOf('error code:') >= 0 && responseBody.indexOf('error message:') >= 0 && responseCode != 200)
				{
					var errorBody = responseBody.split("\n");
					throwServerCallError(errorBody[1].substring("error message: ".length), errorBody[0].substring("error code: ".length));
				}
			}
			else if (responseCode != 200 && responseCode != 206 && responseCode != 500)
				throwServerCallError(responseBody, 'SERVER_RESPONSE_ERROR');
		}

		return Object.freeze({
			isJson: isJson,
			handleServerCallError: handleServerCallError
		});
	}
);
/**
 * SuiteScript https module (Client Side)
 * @private Ignore for JSDoc stub generation
 * @module N/clientHttps
 * @suiteScriptVersion 2.x
 *
 */
define('N/https',['N/http/httpUtil','N/internal/bridge', 'N/internal/invoker', 'N/utilityFunctions', 'N/error', 'N/suiteletContext', 'N/restricted/httpApi', 'N/internal/ajaxHelpers'],
       function (httpUtil, apiBridge, invoker, utilityFunctions, error, suiteletContext, httpApi, ajaxHelpers)
       {
	       function getHost()
	       {
		       return document.location.protocol + '//' + document.location.host;
	       }

           function extractResponse(xhr, async)
           {
	           try
	           {
		           ajaxHelpers.handleServerCallError(xhr.status, xhr.responseText, true);
	           }
	           catch (e)
	           {
		           if (async)
		           	    return e;
		           else
		           	    throw error.create(e);
	           }
               apiBridge.chargeUsage('nlapiRequestURL');
               var responseHeaders = xhr.getAllResponseHeaders();
               var headers = {};
               if (responseHeaders != null)
               {
                   var headerLines = responseHeaders.split("\r\n");
                   var arrayLength = headerLines.length;
                   for (var i = 0; i < arrayLength; i++)
                   {
                       var header = headerLines[i].split(":")[0];
                       if (!!header)
                           headers[header] = xhr.getResponseHeader(header);
                   }
               }
               else
                   headers = null;

               return {code: xhr.status, body: xhr.responseText, headers: headers};
           }

           function runRequest(options, callback)
           {
               utilityFunctions.checkArgs([ options ], ["options"], "request");
               utilityFunctions.checkArgs([ options.url ], ["options.url"], "request");
               var url = '' + options.url;
               utilityFunctions.assertTrue((url.indexOf("http:") !== 0), error.Type.SSS_INVALID_URL, "HTTPS");
               var body = (options.method === httpUtil.Method.POST || options.method === httpUtil.Method.PUT) ? options.body : null;
               var headers = options.headers || {};

	           if (typeof nsDefaultContextObj !== 'undefined' && nsDefaultContextObj !== null)
	           {
		           url += url.indexOf("?") > 0 ? "&" : "?";
		           url += "c=" + nsDefaultContextObj.company;
		           url += "&isExternal=T";
	           }

               if (url[0] == '/' || url.indexOf(getHost()) === 0)
               {
                   var async = typeof(callback) === "function";
                   var xhr = new XMLHttpRequest();
                   xhr.open(options.method, url, async);
                   if (async)
                   {
                       xhr.onload = function ()
                       {
                           if (this.readyState === 4)
                           {
                           	   var resp;
                           	   try {
	                               resp = extractResponse(xhr, true);
                               } catch (e) {
	                               callback(null, e);
                               }
	                           if (resp instanceof Error)
		                           callback(null, resp);
	                           else
		                           callback(resp);
                           }
                       }
                   }

                   if (url.toLowerCase().indexOf("restlet.nl") >= 0)
                   {
                       if (util.isObject(body))
                       {
                           xhr.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
                           body = JSON.stringify(body);
                       }
                       else
                       {
                       	   if (util.isObject(headers) && util.isString(headers["Content-Type"]))
                       	   	    xhr.setRequestHeader("Content-Type", headers["Content-Type"])
	                       else
	                       	    xhr.setRequestHeader("Content-Type", "text/plain; charset=UTF-8");
                       }
                   }
                   else
                   {
	                   xhr.setRequestHeader("NSXMLHttpRequest", "NSXMLHttpRequest");
                       if (util.isObject(body))
                       {
	                       httpUtil.detectBodyIsUnexpectedlyObject(body, headers);
                           body = Object.keys(body).map(function (v) {return encodeURIComponent(v) + '=' + encodeURIComponent(body[v]);}).join('&');
                           xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
                       }
                       else
                       {
	                       if (util.isObject(headers) && util.isString(headers["Content-Type"]))
		                       xhr.setRequestHeader("Content-Type", headers["Content-Type"])
	                       else
		                       xhr.setRequestHeader("Content-Type", "text/xml; charset=UTF-8");
                       }
                   }
                   if (util.isObject(headers))
                   {
                   	    delete headers["Content-Type"];
	                    delete headers["NSXMLHttpRequest"];
                   	    Object.getOwnPropertyNames(headers).forEach(function(header){
                   	    	xhr.setRequestHeader(header, headers[header]);
                        });
                   }
                   xhr.send(body);
                   if (!async)
                       return extractResponse(xhr, false);
               }
               else {
	               httpUtil.detectBodyIsUnexpectedlyObject(body, headers);
	               return invoker(httpApi, "nlapiRequestURLWithCredentials", [null, url, body, headers, options.method], callback);
               }
           }

           var requestProcess = function(options)
           {
               var requestResponse = runRequest(options);
               return httpUtil.createClientResponse(requestResponse);
           };

           var requestProcessPromise = function (options)
           {
               var myPromise = new Promise( function(resolve, reject)
                                            {
                                                try
                                                {
                                                    runRequest(options, callback)
                                                }
                                                catch(e)
                                                {
                                                    reject(e);
                                                }

                                                function callback(result, exception)
                                                {
                                                    if (exception)
                                                    {
                                                        reject(exception)
                                                    }
                                                    else
                                                    {
                                                        try
                                                        {
                                                            resolve(httpUtil.createClientResponse(result));
                                                        }
                                                        catch(e)
                                                        {
                                                            reject(e);
                                                        }
                                                    }
                                                }
                                            });
               return myPromise
           };
           var httpClient = Object.freeze({doRequest: requestProcess});
           var httpClientPromise = Object.freeze({doRequest: requestProcessPromise } );

           var doGet = function (options, headers) { return httpUtil.get(options, headers, httpClient)};
           doGet.promise = function(options, headers) { return httpUtil.get(options, headers, httpClientPromise)};

           var doPost = function (options) { return httpUtil.post(options, httpClient)};
           doPost.promise = function (options) { return httpUtil.post(options, httpClientPromise)};

           var doPut = function (options) { return httpUtil.put(options, httpClient)};
           doPut.promise = function (options) { return httpUtil.put(options, httpClientPromise)};

           var doDelete = function (options, headers) { return httpUtil['delete'](options, headers, httpClient)};
           doDelete.promise = function (options, headers) { return httpUtil['delete'](options, headers, httpClientPromise)};

           var doRequest = function (options) { return httpUtil.request(options, httpClient)};
           doRequest.promise = function (options) { return httpUtil.request(options, httpClientPromise)};

	       var requestSuitelet = utilityFunctions.thenableFunction(function requestSuitelet(options, isAsync)
	       {
		       var func = isAsync ? httpUtil.requestSuitelet.promise : httpUtil.requestSuitelet.thenable;
		       return func(options, doRequest);
	       }, {
		       isAsyncArgIndex: 1
	       });

           return Object.freeze(
                   {
                       Method: httpUtil.Method,
                       CacheDuration: httpUtil.CacheDuration,
                       get: doGet,
                       post: doPost,
                       put: doPut,
                       'delete': doDelete,
                       request: doRequest,
	                   requestSuitelet: requestSuitelet,
                       getServerRequest: suiteletContext.getServerRequest,
                       getServerResponse: suiteletContext.getServerResponse
                   });

       });
/**
 * SuiteScript transaction util module
 *
 * @private
 * @module N/transaction/transactionUtil
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction/transactionUtil',['N/utilityFunctions'],
       function(utilityFunctions)
       {
            function getVoidTransactionArgs(options,id)
            {
                var type = options;
                if ( utilityFunctions.isObject(options))
                {
                    type = options.type;
                    id = options.id;
                }

                utilityFunctions.checkArgs([type, id], ['type', 'id'], 'void');
                return [type, id];
            }

            function doVoidTransaction(voidedId)
            {
                return parseInt(voidedId, 10);
            }

            return {
                getVoidTransactionArgs: getVoidTransactionArgs,
                doVoidTransaction: doVoidTransaction
            }
       });
/**
 * @private
 */
define('N/restricted/transactionApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript transaction common module
 *
 * @module N/transaction
 * @suiteScriptVersion 2.x
 *
 */

define('N/transaction',['N/transaction/transactionUtil', 'N/restricted/transactionApi', 'N/internal/invoker', 'N/dynamicEnums'],
       function(transactionUtil, transactionApi, invoker, dynamicEnums)
       {
            function voidTransaction(options, id)
            {
                var voidArgs = transactionUtil.getVoidTransactionArgs(options, id);
                var voidResult = invoker(transactionApi, "nlapiVoidTransaction", voidArgs);

                return transactionUtil.doVoidTransaction(voidResult);
            }

            voidTransaction.promise = function voidTransactionPromise(options, id) {
                return new Promise(
                    function(resolve, reject)
                    {
                        try
                        {
                            var args = transactionUtil.getVoidTransactionArgs(options, id);
                            invoker(transactionApi, "nlapiVoidTransaction", args, callback);
                        }
                        catch(e)
                        {
                            reject(e);
                        }

                        function callback(result, exception) {
                            if (exception)
                            {
                                reject(exception);
                                return;
                            }
                            try
                            {
                                resolve(transactionUtil.doVoidTransaction(result));
                            }
                            catch(e)
                            {
                                reject(e);
                            }
                        }
                    }
                );
            };

            return Object.freeze({
                /**
                 * Void a transaction record object based on provided type, id
                 * @governance 10 units
                 * @param {Object} options
                 * @param {string} options.type record type to be voided
                 * @param {number|string} options.id record id to be voided
                 * @return {number} the id is the voided record or new reverse journal entry based on preference
                 *
                 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT if type or id is missing
                 * @throws {SuiteScriptError} INVALID_RCRD_TYPE if type is not voidable
                 * @throws {SuiteScriptError} RCRD_DSNT_EXIST if record does not exist
                 *
                 * @since 2015.2
                 */
                "void": voidTransaction,
                /*
                 * module enums
                 */
                get Type()
                {
                    if(!transactionUtil.transactionTypes)
                        transactionUtil.transactionTypes = dynamicEnums.transactionTypes;
                    return transactionUtil.transactionTypes;
                }
            });
       });

/**
 * @private
 */
define('N/restricted/emailApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript email common module
 *
 * @module N/email
 * @suiteScriptVersion 2.x
 *
 */

define('N/email',['N/restricted/emailApi', 'N/internal/invoker', 'N/utilityFunctions', 'N/error'],
	function (emailApi, invoker, utilityFunctions, error)
	{
		/*
		 * Object for sending emails
		 * @class EmailObject
		 * @classdesc Special object for sending emails is needed, so delegates from attachments can be accessed
		 * @protected
		 * @constructor
		 *
		 * @since 2015.2
		 */
		function EmailObject()
		{
			var files = [];
			this.doSendEmail = function doSendEmail(options, notifySenderOnBounce)
			{
				var relatedRecords = new Object();
				var undef = undefined;
				utilityFunctions.checkArgs([options], ['options'], 'email.send');
				if (!utilityFunctions.isObject(options))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options', 'object' );
				}
				// check required parameters
				var author = options !== undef && options !== null && options.author !== undef ?
					options.author : undef;
				var recipients = options !== undef && options !== null && options.recipients !== undef ?
					options.recipients : undef;
				var body = options !== undef && options !== null && options.body !== undef ?
					options.body : undef;
				var subject = options !== undef && options !== null && options.subject !== undef ?
					options.subject : undef;

				utilityFunctions.checkArgs([author, recipients, body, subject], ['options.author', 'options.recipients', 'options.body', 'options.subject'], 'email.send');

				if (Array.isArray(recipients))
				{
					recipients = recipients.join();
				}

				// check optional parameters
				if (options.cc && !Array.isArray(options.cc))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.cc', 'Array' );
				}
				if (options.bcc && !Array.isArray(options.bcc))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.bcc', 'Array' );
				}
				if (options.isInternalOnly && !util.isBoolean(options.isInternalOnly))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.isInternalOnly', 'boolean' );
				}

				if (options.replyTo && !util.isString(options.replyTo))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.replyTo', 'string' );
				}

				if (options.attachments && !(util.isArray(options.attachments)))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'Array' );
				}
				if (options.attachments)
				{
					for (var index in options.attachments)
					{
						var file = options.attachments[index];
						if (!file.hasOwnProperty('toString') || file.toString() !== 'file.File')
						{
							utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.attachments', 'file.File[]' );
						}
						file._attachToEmail = this;
					}
				}

				if (options.relatedRecords && !utilityFunctions.isObject(options.relatedRecords))
				{
					utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.relatedRecords', 'object' );
				}

				if (options.relatedRecords)
				{

					if (options.relatedRecords.hasOwnProperty('transactionId'))
					{
						relatedRecords['transaction'] = options.relatedRecords.transactionId;
					}

					if (options.relatedRecords.hasOwnProperty('activityId'))
					{
						relatedRecords['activity'] = options.relatedRecords.activityId;
					}

					if (options.relatedRecords.hasOwnProperty('entityId'))
					{
						relatedRecords['entity'] = options.relatedRecords.entityId;
					}

					if (options.relatedRecords.hasOwnProperty('customRecord') && options.relatedRecords.customRecord)
					{
						if (options.relatedRecords.customRecord.hasOwnProperty('id') && options.relatedRecords.customRecord.hasOwnProperty('recordType'))
						{
							relatedRecords['record'] = options.relatedRecords.customRecord.id;
							relatedRecords['recordtype'] = options.relatedRecords.customRecord.recordType;
						}
					}
				}

				return invoker(emailApi, 'nlapiSendEmail', [author, recipients, subject, body, options.cc || null, options.bcc || null, relatedRecords, files || null, notifySenderOnBounce, options.isInternalOnly || false, options.replyTo || null]);

			};

			this._attach = function (f)
			{
				files.push(f);
			};

			Object.defineProperty(this, '_attach', {
				set: function (f)
				{
					files.push(f);
				},
				enumerable: false,
				configurable: false,
				writeable: true
			});

			/*
			 * get JSON format of the object
			 * @governance none
			 * @return {Object}
			 *
			 * @since 2015.2
			 */
			this.toJSON = function toJSON(){
				return {};
			};

			/*
			 * Returns the object type name
			 * @governance none
			 * @return {string}
			 *
			 * @since 2015.2
			 */
			this.toString = function toString(){
				return "email.EmailObject";
			};
		}

		function doSendEmail(options, isNotBulk)
		{
			var emailObject = new EmailObject();
			return emailObject.doSendEmail(options, isNotBulk);
		}

		function doSendCampaignEventEmail(options, recipientId)
		{
			var campaign = options;
			var recipient = recipientId;
			if (util.isObject(options))
			{
				campaign = options.campaignEventId;
				recipient = options.recipientId;
			}
			utilityFunctions.checkArgs([campaign, recipient], ['campaignEventId', 'recipientId'], 'email.sendCampaignEvent');
			return invoker(emailApi, 'nlapiSendCampaignEmail', [campaign, recipient]);
		}

		function craftPromise(resolveThis)
		{
			return new Promise(function (resolve, reject)
			{
				try
				{
					resolve(resolveThis());
				}
				catch (e)
				{
					reject(e);
				}
			});
		}

		function sendEmail(options)
		{
			return doSendEmail(options, true);
		}

		sendEmail.promise = function sendEmailPromise(options)
		{
			var resolveThis = function callback() { return sendEmail(options); };
			return craftPromise(resolveThis);
		};

		function sendBulkEmail(options)
		{
			return doSendEmail(options, false);
		}

		sendBulkEmail.promise = function sendBulkEmailPromise(options)
		{
			var resolveThis = function callback() { return sendBulkEmail(options) };
			return craftPromise(resolveThis);
		};

		function sendCampaignEventEmail(options, recipientId)
		{
			return doSendCampaignEventEmail(options, recipientId);
		}

		sendCampaignEventEmail.promise = function sendCampaignEventEmailPromise(options, recipientId)
		{
			var resolveThis = function callback() { return sendCampaignEventEmail(options, recipientId); };
			return craftPromise(resolveThis);
		};

		/**
		 * RelatedRecords represents the NetSuite records to which an Email Message record should be attached.
		 * @typedef {Object} RelatedRecords
		 * @property {number} transactionId - Transaction record to attach Message record to.
		 * @property {number} activityId - Activity record to attach Message record to.
		 * @property {number} entityId - Entity record to attach Message record to.
		 * @property {Object} customRecord - Custom record to attach Message record to.
		 * @property {number} customRecord.id - The instance ID for the custom record to attach the Message record to.
		 * @property {string} customRecord.recordType - The integer ID for the custom record type to attach the Message record to.
		 */
		//this is a public @typedef and needs a code to be attached to to be stubbed
		function RelatedRecordsTypedef(){}

		return Object.freeze({
			/**
			 * Sends email to an individual or group of recipients and receives bounceback notifications.
			 *
			 * @governance 20 units
			 * @restriction The maximum number of total recipients (recipient + cc + bcc) allowed is 10
			 *
			 * @param {Object} options Email options
			 * @param {number} options.author Sender of the email.
			 * @param {number|string|Array<number|string>} options.recipients Recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number|string|Array<number|string>=} options.cc CC recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number|string|Array<number|string>=} options.bcc BCC recipients of the email as an EmailEntity, Internal ID or Email Address.
			 * @param {string} options.subject Subject of the outgoing message.
			 * @param {string} options.body Contents of the outgoing message.
			 * @param {string} [options.replyTo] The email address that appears in the reply-to header.
			 * @param {Array<file.File>} [options.attachments] Email file attachments. Not supported in client side.
			 * @param {RelatedRecords} [options.relatedRecords] Object that contains key/value pairs to associate (attach) the Message record with related records (i.e., transaction, activity, entity, and custom records)
			 * @param {boolean} [options.isInternalOnly] If true, the Message record is not visible to an external Entity (for example, a customer or contact). The default value is false.
			 * @return {void}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			send: sendEmail,
			/**
			 * Sends bulk email (for use when bounceback notification is not required).
			 *
			 * @governance 10 units
			 * @restriction The maximum number of total recipients (recipient + cc + bcc) allowed is 10
			 *
			 * @param {Object} options Email options
			 * @param {number} options.author Internal ID of the email sender.
			 * @param {number|string|Array<number|string>} options.recipients Recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number|string|Array<number|string>=} options.cc CC recipients of the email, Internal ID or array of Email Addresses.
			 * @param {number|string|Array<number|string>=} options.bcc BCC recipients of the email as an EmailEntity, Internal ID or Email Address.
			 * @param {string} options.subject Subject of the outgoing message.
			 * @param {string} options.body Contents of the outgoing message.
			 * @param {string} [options.replyTo] The email address that appears in the reply-to header.
			 * @param {Array<file.File>} [options.attachments] Email file attachments.  Not supported in client side.
			 * @param {RelatedRecords} [options.relatedRecords] Object that contains key/value pairs to associate (attach) the Message record with related records (i.e., transaction, activity, entity, and custom records)
			 * @param {boolean} [options.isInternalOnly] If true, the Message record is not visible to an external Entity (for example, a customer or contact). The default value is false.
			 * @return {void}
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			sendBulk: sendBulkEmail,
			/**
			 * Send a single "on-demand" campaign email to a specified recipient and return a campaign response ID to track the email
			 * @governance 10 units
			 *
			 * @param {number} campaignEventId  The internal ID of the campaign event.
			 * @param {number} recipientId The internal ID of the recipient. Note that the recipient must have an email.
			 * @return {number} A campaign response ID (tracking code) as an integer. If the email fails to send, the value returned is -1.
			 * @throws {SuiteScriptError} SSS_MISSING_REQD_ARGUMENT when some required argument is missing
			 * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE when some argument's type is incorrect
			 *
			 * @since 2015.2
			 *
			 */
			sendCampaignEvent: sendCampaignEventEmail
		});
	});
/**
 * SuiteScript Message Module (Client Side)
 * Load the message module to display a message at the top of the screen under the menu bar.
 *
 * @module N/ui/message
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui/message',['N/utilityFunctions', 'N/nsobject', 'N/error', 'N/msgRouter'], function (utilityFunctions, nsobject, error, msgRouter)
{
	var MESSAGE_TYPE = Object.freeze({
		CONFIRMATION: 0,
		INFORMATION: 1,
		WARNING: 2,
		ERROR: 3
	});

    /**
     * Return a new instance of Message, used to show/hide messages
     * @class
     * @classdesc Encapsulates the Message object that gets created when calling the create method.
     * @constructor
     * @protected
     *
     * @since 2016.1
     */
    function Message(initOptions)
    {
        var THIS_TYPE = 'message.Message';
        var msgOptions = initOptions;
        var msgObject = null;
        var messageQueue = msgRouter.getActiveQueue();
        var initialDuration = msgOptions.duration;

        /**
         * Shows the message.
         * @restriction Client SuiteScript only
         * @governance none
         * @param {Object} [options] The options object.
         * @param {number} [options.duration] The amount of time, in milliseconds, to show the message. The default is 0, which shows the message until Message.hide() is called.
         * @return {void}
         * @throws {SuiteScriptError} WRONG_PARAMETER_TYPE If options.duration is specified with a non-numerical value.
         *
         * @since 2016.1
         */
        this.show = function(options)
        {
            var msecsToShow = initialDuration;
            if (options != null && options.hasOwnProperty('duration'))
                msecsToShow = options.duration;
            else if (util.isNumber(options))
                msecsToShow = options;

            msecsToShow = parseInt(msecsToShow);
            if (isNaN(msecsToShow))
                utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE);

            msgOptions.duration = msecsToShow;

            messageQueue.storeMessage({source: THIS_TYPE, data: msgOptions, reply: null, forClient: options && options.sendToClient});

            // NS.UI.Messaging is available only in client
	        var NS = msgRouter.getNSUIObject();
            if (typeof(NS) !== 'undefined' &&
                typeof(NS.UI) !== 'undefined' &&
                typeof(NS.UI.Messaging) !== 'undefined' &&
                typeof(NS.UI.Messaging.Message) === 'function')
            {
                msgObject = new NS.UI.Messaging.Message(msgOptions);
                msgObject.show();
            }
        };

        /**
         * Hides the message
         * @restriction Client SuiteScript only
         * @governance none
         * @return {void}
         *
         * @since 2016.1
         */
        this.hide = function()
        {
            if (msgObject !== null)
                msgObject.hide();
        };

        /**
         * Returns the object type name (message.Message)
         * @restriction Client SuiteScript only
         * @governance none
         * @return {string}
         *
         * @since 2016.1
         */
        this.toString = function()
        {
            return THIS_TYPE;
        };

	    /**
	     * get JSON format of the object
	     * @restriction Client SuiteScript only
	     * @governance none
	     * @return {Object}
	     *
	     * @since 2016.1
	     */
        this.toJSON = function()
        {
            return msgOptions;
        };
    }
    Message.prototype = nsobject.getNewInstance();
    Object.freeze(Message);

    function create(options)
    {
        var type, title, message, duration;

        if (options != null)
        {
            type = options.type;
            title = options.title || "";
            message = options.message || "";
            duration = options.hasOwnProperty('duration') ? options.duration : 0;
        }

        utilityFunctions.checkArgs([type], ['type'], 'Message.create');

        var messageOptions = {
            title: title,
            message: message,
            type: type,
            duration: duration
        };

        return new Message(messageOptions);
    }

    return Object.freeze({
                             /**
                              * Creates a message that can be displayed or hidden near the top of the page.
                              *
                              * @restriction Client SuiteScript only
                              * @governance none
                              * @param {Object} options The options object.
                              * @param {string} options.type The type of message, see message.Type
                              * @param {string} [options.title] The title of the message. Defaults to empty string.
                              * @param {string} [options.message] The content of the message. Defaults to empty string.
                              * @param {number} [options.duration] The amount of time, in milliseconds, to show the message. The default is 0, which shows the message until Message.hide() is called.
                              *
                              * @return {Message} A message object which can be shown or hidden.
                              * @throws {SuiteScriptError} MISSING_REQD_ARGUMENT If options or type are undefined
                              *
                              * @since 2016.1
                              */
                             create: create,

                             /**
                              * Enum for message types
                              * @enum {string}
                              * @readonly
                              */
                             Type: MESSAGE_TYPE
                             //Type: NS.UI.Messaging ? NS.UI.Messaging.Type : null
                         });
});
/**
 * SuiteScript UI Module (Client Side)
 *
 * @module N/ui
 * @suiteScriptVersion 2.x
 *
 */
define('N/ui',['N/ui/message', 'N/ui/dialog'], function (message, dialog)
{
    return Object.freeze({
        message: message,
        dialog: dialog
    })
});
/**
 * @private
 */
define('N/restricted/urlApi',['N/internal/reflet'], function(reflet){ return reflet; });
/**
 * SuiteScript module
 *
 * @module N/url
 * @NApiVersion 2.x
 *
 */
define('N/url',['N/internal/invoker', 'N/restricted/urlApi'],
	function (invoker, urlApi)
        {

	        var HOST_TYPES = Object.freeze({
		        APPLICATION: 'APPLICATION',
		        CUSTOMER_CENTER: 'CUSTOMERCENTER',
		        RESTLET: 'RESTLETS',
		        SUITETALK: 'SUITETALK',
		        FORM: 'FORMS'
	        });

            function traverseParams(prefix, obj, add)
            {

                var rbracket = /\[\]$/;
                if (util.isArray(obj))
                {
                    // Serialize array item.
                    util.each(obj, function (i, v)
                    {
                        if (rbracket.test(prefix))
                        {
                            // Treat each array item as a scalar.
                            add(prefix, v);

                        }
                        else
                        {
                            // Item is non-scalar (array or object), encode its numeric index.
                            traverseParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, add);
                        }
                    });

                }
                else
                {
                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            /*
             Inspired by jQuery.param()
             */
            function format(options, params)
            {
                var domain = options;
                if (util.isObject(options))
                {
                    domain = options.domain;
                    params = options.params;
                }
                var prefix;
                var s = [];
                var r20 = /%20/g;
                format = format || '';

                function add(key, value)
                {
                    // If value is a function, invoke it and return its value
                    value = util.isFunction(value) ? value() : (value == null ? "" : value);
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
                };

                // If an array was passed in, assume that it is an array of form elements.
                if (util.isArray(params))
                {
                    for (var i = 0; i < params.length; i++)
                        add(i, params[i]);
                }
                else
                {
                    // encode params recursively.
                    for (prefix in params)
                    {
                        traverseParams(prefix, params[prefix], add);
                    }
                }

                // Return the resulting serialization
                var queryString = s.join("&").replace(r20, "+");
                var separator = (domain.indexOf('?') === -1) ? '?' : '&';

                return domain + separator + queryString;
            }


            /** @alias N/url */
            return Object.freeze({
                /**
                 * @restriction Server SuiteScript only
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.recordType
                 * @param {string} [options.recordId]
                 * @param {boolean} [options.isEditMode]
                 * @param {Object} [options.params] url parameters
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveRecord: function resolveRecord(options)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['RECORD', options.recordType, options.recordId || null, options.isEditMode === true ? 'EDIT' : null]);
                    if (options.params)
                        url = format(url, options.params);
                    return url;
                },
                /**
                 * @restriction Server SuiteScript only
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.id
                 * @param {Object} [options.params] url parameters
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveTaskLink: function resolveTaskLink(options, params)
                {
                    var taskId = options;
                    if (util.isObject(options))
                    {
                        taskId = options.id;
                        params = options.params;
                    }
                    var url = invoker(urlApi, 'nlapiResolveURL', ['TASKLINK', taskId, null, null]);
                    if (params)
                        url = format(url, params);
                    return url;
                },
                /**
                 * @restriction Server SuiteScript only
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.scriptId
                 * @param {string} options.deploymentId
                 * @param {boolean} [options.returnExternalUrl]
                 * @param {Object} [options.params] url parameters
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                resolveScript: function resolveScript(options)
                {
                    var url = invoker(urlApi, 'nlapiResolveURL', ['WEB_SCRIPT', options.scriptId, options.deploymentId, options.returnExternalUrl === true ? 'EXTERNAL' : null]);
                    if (options.params)
                        url = format(url, options.params);
                    return url;
                },
                /**
                 * @restriction Server SuiteScript only
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.hostType
                 * @param {string} [options.accountId]
                 * @return {String} domain
                 *
                 * @since 2017.1
                 */
                resolveDomain: function resolveDomain(options)
                {
                    return invoker(urlApi, 'nlapiResolveDomain', [options.hostType, options.accountId || null]);
                },
                /**
                 * @restriction Server SuiteScript only
                 * @governance none
                 * @param {Object} options
                 * @param {string} options.domain
                 * @param {Object} options.params query string data parameters as an object
                 * @return {String} url
                 *
                 * @since 2015.1
                 */
                format: format,
	            /**
	             * @enum {string}
	             * @readonly
	             */
                HostType: HOST_TYPES
            });
        });
/**
 * @private
 */
define(
	'N/restricted/suiteAppInfoBridge',['N/internal/reflet'],
	function (reflet)
	{
		return util.extend({bridge: 'suiteAppInfoBridge'}, reflet);
	}
);

/**
 * SuiteScript suiteAppInfo module
 *
 * A module exposing a set of handy functions
 * to read information about bundles and suite apps.
 *
 * @module N/suiteAppInfo
 * @NApiVersion 2.x
 */
define(
	'N/suiteAppInfo',[
		'N/restricted/suiteAppInfoBridge',
		'N/internal/invoker',
		'N/utilityFunctions',
		'N/error'
	],
	function (
		api,
		invoker,
		utilityFunctions,
		error
	) {
		/**
		 * Tells whether the given bundle is installed.
		 *
		 * @param {Object} options
		 * @param {int} options.bundleId
		 * @return {boolean}
		 * @governance 5
		 * @since 2021.1
		 */
		function isBundleInstalled(options)
		{
			utilityFunctions.checkArgs(
				[options],
				['options'],
				'suiteAppInfo.isBundleInstalled'
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
			]);

			var bundleId = options.bundleId;
			var accountId = options.accountId || null;  // intentionally undocumented

			// throws when undefined or null
			utilityFunctions.checkArgsPresent(
				[bundleId],
				["options.bundleId"],
				"suiteAppInfo.isBundleInstalled"
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(bundleId, 'options.bundleId', util.isNumber),
				utilityFunctions.checkArgObject(accountId, 'options.accountId', util.isString)
			]);

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'isBundleInstalled',
				[ bundleId, accountId ],
				isPromise ? this : undefined
			);
			if (!isPromise)
				return out;
		}

		isBundleInstalled.promise = function()
		{
			return utilityFunctions.promiseTo(isBundleInstalled, arguments);
		};

		// --------------------------------------------------------------------

		/**
		 * @typedef {Object} Installer
		 * @property {int} id
		 * @property {string} name
		 */

		/**
		 * @typedef {Object} Publisher
		 * @property {string} id
		 * @property {string} name
		 */

		/**
		 * @typedef {Object} Bundle
		 * @property {int} id
		 * @property {string} name
		 * @property {string} version
		 * @property {string} description
		 * @property {string} installedFrom
		 * @property {boolean} isManaged
		 * @property {Date} dateInstalled
		 * @property {Date} dateLastUpdated
		 * @property {Publisher} publisher
		 * @property {Installer} installedBy
		 */

		/**
		 * Returns a list of installed bundles.
		 *
		 * Unlike at `/app/bundler/bundlelist.nl`, this function
		 * returns only bundles that were successfuly installed.
		 *
		 * @param {Object} [options]
		 * @return {Array<Bundle>}
		 * @governance 10
		 * @since 2021.1
		 */
		function listInstalledBundles(options)
		{
			if (arguments.length === 0)
				options = {};
			else {
				utilityFunctions.checkArgTypes([
					utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
				]);
			}

			var accountId = options.accountId || null;  // intentionally undocumented

			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(accountId, 'options.accountId', util.isString)
			]);

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'listInstalledBundles', [ accountId ],
				utilityFunctions.isPromiseCallback(this) ? this : undefined
			);
			if (!isPromise)
				return listInstalledBundles_postprocess({ result: out });
		}

		function listInstalledBundles_postprocess(obj)
		{
			var out = obj.result;
			utilityFunctions.timestampToDate(["dateInstalled", "dateLastUpdated"], out);
			return out;
		}

		listInstalledBundles.promise = function()
		{
			return utilityFunctions.promiseTo(listInstalledBundles, arguments, listInstalledBundles_postprocess);
		};

		// --------------------------------------------------------------------

		/**
		 * Lists ID-s of bundles that contain a script,
		 * for each given script individually.
		 *
		 * @param {Object} options
		 * @param {Array<string>} options.scriptIds
		 * @return {Object<string,Array<int>>} A `{ scriptId: arrayOfBundleIds }` mapping.
		 * @governance 10
		 * @since 2021.1
		 */
		function listBundlesContainingScripts(options)
		{
			utilityFunctions.checkArgs(
				[options],
				['options'],
				'suiteAppInfo.listBundlesContainingScripts'
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
			]);
			var scriptIds = options.scriptIds;

			// throws when undefined or null
			utilityFunctions.checkArgsPresent(
				[scriptIds],
				["options.scriptIds"],
				"suiteAppInfo.listBundlesContainingScripts"
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(scriptIds, 'options.scriptIds', util.isArray),
			]);
			if (!utilityFunctions.checkArrayType(scriptIds, util.isString))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.scriptIds', 'String[]');

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'listBundlesContainingScripts', [ JSON.stringify(scriptIds) ],
				utilityFunctions.isPromiseCallback(this) ? this : undefined
			);
			if (!isPromise)
				return out;
		}

		listBundlesContainingScripts.promise = function()
		{
			return utilityFunctions.promiseTo(listBundlesContainingScripts, arguments);
		};

		// --------------------------------------------------------------------

		/**
		 * Tells whether the given suite app is installed.
		 *
		 * @param {Object} options
		 * @param {string} options.suiteAppId
		 * @return {boolean}
		 * @governance 5
		 * @since 2021.1
		 */
		function isSuiteAppInstalled(options)
		{
			utilityFunctions.checkArgs(
				[options],
				['options'],
				'suiteAppInfo.isSuiteAppInstalled'
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
			]);
			var suiteAppId = options.suiteAppId;  // ...
			var accountId = options.accountId || null;  // intentionally undocumented

			// throws when undefined or null
			utilityFunctions.checkArgsPresent(
				[suiteAppId],
				["options.suiteAppId"],
				"suiteAppInfo.isSuiteAppInstalled"
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(suiteAppId, 'options.suiteAppId', util.isString),
				utilityFunctions.checkArgObject(accountId, 'options.accountId', util.isString)
			]);

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'isSuiteAppInstalled',
				[ suiteAppId, accountId ],
				isPromise ? this : undefined
			);
			if (!isPromise)
				return out;
		}

		isSuiteAppInstalled.promise = function()
		{
			return utilityFunctions.promiseTo(isSuiteAppInstalled, arguments);
		};

		// --------------------------------------------------------------------

		/**
		 * @typedef {Object} Installer
		 * @property {int} id
		 * @property {string} name
		 */

		/**
		 * @typedef {Object} SuiteApp
		 * @property {string} appId
		 * @property {string} publisherId
		 * @property {string} name
		 * @property {string} version
		 * @property {string} description
		 * @property {Date} dateInstalled
		 * @property {Date} dateLastUpdated
		 * @property {Installer} installedBy
		 */

		/**
		 * Returns a list of installed suite apps.
		 *
		 * Unlike at `/app/suiteapp/devframework/appinstalllist.nl`, this function
		 * returns only suite apps that were successfuly installed.
		 *
		 * @param {Object} [options]
		 * @return {Array<SuiteApp>}
		 * @governance 10
		 * @since 2021.1
		 */
		function listInstalledSuiteApps(options)
		{
			if (arguments.length === 0)
				options = {};
			else {
				utilityFunctions.checkArgTypes([
					utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
				]);
			}

			var accountId = options.accountId || null;  // intentionally undocumented

			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(accountId, 'options.accountId', util.isString)
			]);

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'listInstalledSuiteApps', [ accountId ],
				utilityFunctions.isPromiseCallback(this) ? this : undefined
			);
			if (!isPromise)
				return listInstalledSuiteApps_postprocess({ result: out });
		}

		function listInstalledSuiteApps_postprocess(obj)
		{
			var out = obj.result;
			utilityFunctions.timestampToDate(["dateInstalled", "dateLastUpdated"], out);
			return out;
		}

		listInstalledSuiteApps.promise = function()
		{
			return utilityFunctions.promiseTo(listInstalledSuiteApps, arguments, listInstalledSuiteApps_postprocess);
		};

		// --------------------------------------------------------------------

		/**
		 * Lists ID-s of suite apps that contain a script,
		 * for each given script individually.
		 *
		 * @param {Object} options
		 * @param {Array<string>} options.scriptIds
		 * @return {Object.<String,null|String>} A `{ scriptId: suiteAppId|null }` mapping.
		 * @governance 10
		 * @since 2021.1
		 */
		function listSuiteAppsContainingScripts(options)
		{
			utilityFunctions.checkArgs(
				[options],
				['options'],
				'suiteAppInfo.listSuiteAppsContainingScripts'
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(options, 'options', utilityFunctions.isObject),
			]);
			var scriptIds = options.scriptIds;

			// throws when undefined or null
			utilityFunctions.checkArgsPresent(
				[scriptIds],
				["options.scriptIds"],
				"suiteAppInfo.listSuiteAppsContainingScripts"
			);
			utilityFunctions.checkArgTypes([
				utilityFunctions.checkArgObject(scriptIds, 'options.scriptIds', util.isArray),
			]);
			if (!utilityFunctions.checkArrayType(scriptIds, util.isString))
				utilityFunctions.throwSuiteScriptError(error.Type.WRONG_PARAMETER_TYPE, 'options.scriptIds', 'String[]');

			var isPromise = utilityFunctions.isPromiseCallback(this);
			var out = invoker(
				api,
				'listSuiteAppsContainingScripts', [ JSON.stringify(scriptIds) ],
				utilityFunctions.isPromiseCallback(this) ? this : undefined
			);
			if (!isPromise)
				return out;
		}

		listSuiteAppsContainingScripts.promise = function()
		{
			return utilityFunctions.promiseTo(listSuiteAppsContainingScripts, arguments);
		};

		// --------------------------------------------------------------------

		return Object.freeze({
			isBundleInstalled: isBundleInstalled,
			listInstalledBundles: listInstalledBundles,
			listBundlesContainingScripts: listBundlesContainingScripts,
			isSuiteAppInstalled: isSuiteAppInstalled,
			listInstalledSuiteApps: listInstalledSuiteApps,
			listSuiteAppsContainingScripts: listSuiteAppsContainingScripts,
		});
	}
);

define('N',['N/nsobject', 'N/error','N/util','N/log','N/xml','N/format','N/currency','N/runtime','N/action','N/query','N/translation','N/recordContext','N/dynamicData','N/dataset','N/workbook','N/datasetLink','N/record','N/currentRecord','N/http','N/portlet','N/https','N/search','N/transaction','N/email','N/ui','N/url','N/suiteAppInfo'],
	function (nsobject, error,util,log,xml,format,currency,runtime,action,query,translation,recordContext,dynamicData,dataset,workbook,datasetLink,record,currentRecord,http,portlet,https,search,transaction,email,ui,url,suiteAppInfo){
		function ModuleConfiguration(){
			this.create = function(module){
				return {
					value: module,
					enumerable: true,
					configurable: false,
					writable: false
				};
			};
		}
		var moduleConfiguration = new ModuleConfiguration();

		return Object.create(nsobject.getNewInstance(), {
    			error: moduleConfiguration.create(error),
    			util: moduleConfiguration.create(util),
    			log: moduleConfiguration.create(log),
    			xml: moduleConfiguration.create(xml),
    			format: moduleConfiguration.create(format),
    			currency: moduleConfiguration.create(currency),
    			runtime: moduleConfiguration.create(runtime),
    			action: moduleConfiguration.create(action),
    			query: moduleConfiguration.create(query),
    			translation: moduleConfiguration.create(translation),
    			recordContext: moduleConfiguration.create(recordContext),
    			dynamicData: moduleConfiguration.create(dynamicData),
    			dataset: moduleConfiguration.create(dataset),
    			workbook: moduleConfiguration.create(workbook),
    			datasetLink: moduleConfiguration.create(datasetLink),
    			record: moduleConfiguration.create(record),
    			currentRecord: moduleConfiguration.create(currentRecord),
    			http: moduleConfiguration.create(http),
    			portlet: moduleConfiguration.create(portlet),
    			https: moduleConfiguration.create(https),
    			search: moduleConfiguration.create(search),
    			transaction: moduleConfiguration.create(transaction),
    			email: moduleConfiguration.create(email),
    			ui: moduleConfiguration.create(ui),
    			url: moduleConfiguration.create(url),
    			suiteAppInfo: moduleConfiguration.create(suiteAppInfo)
		});
	},
	{internal: ['nsobject','utilityFunctions','fieldUtil','util/platformResponse','util/currencyUtility','util/date','util/callRecordScript','util/recordScripting','util/slaving','util/sqlInjectionFilter','util/formatter','fieldTypeConstants','util/validator','util/uuid','field','msgRouter','creationFunctionWrapper','formatI18nCommon','dateTimeZone','metadata/fieldDefinition','metadata/fieldPermissions','metadata/sublistDefinition','metadata/sublistPermissions','http/httpUtil','record/clientRecordDefinitionBase','record/recordImpl','record/recordUtil','search/searchUtil','search/searchObject','search/pagingUtil','suiteletContext','transaction/transactionUtil','common/pattern/iterator','common/record/recordActualWork','common/record/recordDefinition','common/record/recordDefinitionEvent','common/record/recordDefinitionEventCompressor','common/record/line/lineDefinition','emptyModule','pagination/paginationObject','util/serverWidgetUtility','searchDefinition','scope','eventEmitter','macro','queryInternal','notification','saveResult','exampleCommon','contextSwitch','localization','scriptLoader','localeContext','erp/item/unitsOfMeasure','erp/item/catchWeightCommon','recordContextSignificantFields','recordMessage','resultObject','internal/reflet','idConverterService','expression','analyticsListing','argumentProcessor','record/recordDataEncoding','record/parameterMarshaler','record/parameterValidator','record/expressionBuilder','record/proxy','record/proxy/dynamicRecord','record/proxy/deferredDynamicRecord','record/proxy/readOnlyRecord','record/proxy/dynamicSubrecord','record/proxy/deferredDynamicSubrecord','record/proxy/readOnlySubrecord','record/recordDefinitionBase','record/recordConstants','record/sublistBase','record/sublist','record/columnBase','record/fieldBase','record/recordField','record/recordFieldEvent','record/matrix','record/recordEvent','record/relatedRecord','record/actionInternal','record/recordUtilityFunctions','record/subrecordUtilityFunctions','record/line/deferredDynamicLine','record/line/dynamicLine','record/line/readOnlyLine','record/line/sublistLineImpl','record/line/sublistLineBufferImpl','record/line/sublistLineImplementation','currentRecordService','record/recordService','record/modelController','record/sublistLine','record/sublistLineEvent','record/recordCache','record/recordCacheController','record/model','record/modelEvent','record/metadata','record/metadataEvent','record/fieldLevelMetadata','record/fieldLevelMetadataEvent','record/sublistLevelMetadata','record/sublistLevelMetadataEvent','record/recordStateController','record/recordStateControllerEvent','record/fieldState','record/fieldStateEvent','record/sublistState','record/sublistStateEvent','record/sublistLineState','record/sublistLineStateEvent','record/recordImplementation','record/dynamicRecordImpl','record/deferredDynamicRecordImpl','record/recordScriptingScope','record/recordImplV1','record/legacyNLObjects','record/selectFieldOptionTextCache','domCurrentRecord','currentRecord/currentSublist','currentRecord/currentField','currentRecord/currentSubrecord','currentRecord/currentRecordScriptingScope','search/searchPaging','environment','FieldValidationHelper','dynamicEnums','file','internal/invoker','utilityFunctionsImpl','internal/serverCommunicationProxy','restricted/scriptArguments','internalRecordService','restricted/exampleBridge','restricted/recordContextSignificantFieldsApiBridge','restricted/environmentApiBridge','restricted/fieldValidationHelperApi','restricted/dynamicEnumsApi','restricted/queryApiBridge','restricted/datasetApi','restricted/workbookApi','restricted/actionApi','restricted/translationBridge','restricted/formatApi','restricted/localizationApiBridge','restricted/catchWeightApiBridge','libphonenumber','restricted/recordContextApiBridge','restricted/suiteAppInfoBridge','internal/bridge','restricted/scriptSessionContext','restricted/scriptWorkQueueContext','restricted/remoteApiBridge','restricted/scriptDeploymentContext','restricted/scriptSessionObjectService','restricted/clientScriptHandler','internal/recordRemoteApiBridge','internal/fieldClientScriptHandler','internal/scopeRemoteApiBridge','restricted/urlApi','restricted/xmlApi','restricted/fileApi','restricted/errorApi','restricted/httpApi','restricted/csvApi','restricted/scheduledScriptApi','restricted/mapReduceApi','restricted/compressApi','restricted/sassCompilerApi','restricted/recordDraftBridge','restricted/ssoApi','restricted/authApi','restricted/sftpApi','restricted/supplyAllocationApiBridge','restricted/scpBridge','restricted/certificateBridge','restricted/kpiApi','restricted/piremovalBridge','restricted/taxRateDataApiBridge','restricted/assetInfoBridge','restricted/serviceTierBridge','restricted/adminEmailNotifierBridge','restricted/cacheApi','restricted/pluginApi','restricted/currencyApi','restricted/searchApi','restricted/searchTaskApi','restricted/queryTaskApi','restricted/entityDedupTaskApi','restricted/workflowTriggerTaskApi','restricted/emailApi','restricted/transactionApi','restricted/dateTimeZoneApi','restricted/marshalUtil','restricted/recordApi','internal/commerceOrderApi','scriptPerformanceMarker','restricted/commercePromisingApiBridge'], devonly: ['N/errorHandlerTestApi','N/exampleApi','N/javaExampleApi','N/manufacturing/capacityPlanning']}
);

window._N_define = define;

// Issue 547060 UI team will manage when to remove define from global scope
;
